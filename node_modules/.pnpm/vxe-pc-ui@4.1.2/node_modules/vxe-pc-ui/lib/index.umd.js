(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("xe-utils"));
	else if(typeof define === 'function' && define.amd)
		define([, "xe-utils"], factory);
	else if(typeof exports === 'object')
		exports["VxeUI"] = factory(require("vue"), require("xe-utils"));
	else
		root["VxeUI"] = factory(root["Vue"], root["XEUtils"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__9274__, __WEBPACK_EXTERNAL_MODULE__8871__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9274:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9274__;

/***/ }),

/***/ 8871:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8871__;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 6955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(2140);
var isCallable = __webpack_require__(4901);
var classofRaw = __webpack_require__(4576);
var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2106:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var makeBuiltIn = __webpack_require__(283);
var defineProperty = __webpack_require__(4913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 9392:
/***/ (function(module) {


module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ 7388:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var userAgent = __webpack_require__(9392);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 8727:
/***/ (function(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = global[TARGET] && global[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 4475:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(4576);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(8622);
var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(4576);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6395:
/***/ (function(module) {


module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4475);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.37.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(7388);
var fails = __webpack_require__(9039);
var global = __webpack_require__(4475);

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 655:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(6955);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 6823:
/***/ (function(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 2812:
/***/ (function(module) {


var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 4603:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var append = uncurryThis(URLSearchParamsPrototype.append);
var $delete = uncurryThis(URLSearchParamsPrototype['delete']);
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
var push = uncurryThis([].push);
var params = new $URLSearchParams('a=1&a=2&b=3');

params['delete']('a', 1);
// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
params['delete']('b', undefined);

if (params + '' !== 'a=2') {
  defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $delete(this, name);
    var entries = [];
    forEach(this, function (v, k) { // also validates `this`
      push(entries, { key: k, value: v });
    });
    validateArgumentsLength(length, 1);
    var key = toString(name);
    var value = toString($value);
    var index = 0;
    var dindex = 0;
    var found = false;
    var entriesLength = entries.length;
    var entry;
    while (index < entriesLength) {
      entry = entries[index++];
      if (found || entry.key === key) {
        found = true;
        $delete(this, entry.key);
      } else dindex++;
    }
    while (dindex < entriesLength) {
      entry = entries[dindex++];
      if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
    }
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 7566:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
var $has = uncurryThis(URLSearchParamsPrototype.has);
var params = new $URLSearchParams('a=1');

// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
if (params.has('a', 2) || !params.has('a', undefined)) {
  defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $has(this, name);
    var values = getAll(this, name); // also validates `this`
    validateArgumentsLength(length, 1);
    var value = toString($value);
    var index = 0;
    while (index < values.length) {
      if (values[index++] === value) return true;
    } return false;
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 8721:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var uncurryThis = __webpack_require__(9504);
var defineBuiltInAccessor = __webpack_require__(2106);

var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
    get: function size() {
      var count = 0;
      forEach(this, function () { count++; });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Alert: function() { return /* reexport */ Alert; },
  Anchor: function() { return /* reexport */ Anchor; },
  AnchorLink: function() { return /* reexport */ AnchorLink; },
  Breadcrumb: function() { return /* reexport */ Breadcrumb; },
  BreadcrumbItem: function() { return /* reexport */ BreadcrumbItem; },
  Button: function() { return /* reexport */ Button; },
  ButtonGroup: function() { return /* reexport */ ButtonGroup; },
  Calendar: function() { return /* reexport */ Calendar; },
  Card: function() { return /* reexport */ Card; },
  Carousel: function() { return /* reexport */ Carousel; },
  CarouselItem: function() { return /* reexport */ CarouselItem; },
  Checkbox: function() { return /* reexport */ Checkbox; },
  CheckboxGroup: function() { return /* reexport */ CheckboxGroup; },
  Col: function() { return /* reexport */ Col; },
  Collapse: function() { return /* reexport */ Collapse; },
  CollapsePane: function() { return /* reexport */ CollapsePane; },
  DatePicker: function() { return /* reexport */ DatePicker; },
  Drawer: function() { return /* reexport */ Drawer; },
  DrawerController: function() { return /* reexport */ DrawerController; },
  Form: function() { return /* reexport */ Form; },
  FormDesign: function() { return /* reexport */ FormDesign; },
  FormGather: function() { return /* reexport */ FormGather; },
  FormItem: function() { return /* reexport */ FormItem; },
  FormView: function() { return /* reexport */ FormView; },
  GLOBAL_EVENT_KEYS: function() { return /* reexport */ GLOBAL_EVENT_KEYS; },
  Icon: function() { return /* reexport */ Icon; },
  IconPicker: function() { return /* reexport */ IconPicker; },
  Image: function() { return /* reexport */ Image; },
  ImageGroup: function() { return /* reexport */ ImageGroup; },
  ImagePreview: function() { return /* reexport */ ImagePreview; },
  Input: function() { return /* reexport */ Input; },
  LayoutAside: function() { return /* reexport */ LayoutAside; },
  LayoutBody: function() { return /* reexport */ LayoutBody; },
  LayoutContainer: function() { return /* reexport */ LayoutContainer; },
  LayoutFooter: function() { return /* reexport */ LayoutFooter; },
  LayoutHeader: function() { return /* reexport */ LayoutHeader; },
  Link: function() { return /* reexport */ Link; },
  List: function() { return /* reexport */ List; },
  ListDesign: function() { return /* reexport */ ListDesign; },
  ListView: function() { return /* reexport */ ListView; },
  Loading: function() { return /* reexport */ Loading; },
  LoadingController: function() { return /* reexport */ LoadingController; },
  Menu: function() { return /* reexport */ Menu; },
  Modal: function() { return /* reexport */ Modal; },
  ModalController: function() { return /* reexport */ ModalController; },
  NumberInput: function() { return /* reexport */ NumberInput; },
  Optgroup: function() { return /* reexport */ Optgroup; },
  Option: function() { return /* reexport */ Option; },
  Pager: function() { return /* reexport */ Pager; },
  PasswordInput: function() { return /* reexport */ PasswordInput; },
  Print: function() { return /* reexport */ Print; },
  PrintPageBreak: function() { return /* reexport */ PrintPageBreak; },
  Pulldown: function() { return /* reexport */ Pulldown; },
  Radio: function() { return /* reexport */ Radio; },
  RadioButton: function() { return /* reexport */ RadioButton; },
  RadioGroup: function() { return /* reexport */ RadioGroup; },
  Row: function() { return /* reexport */ Row; },
  Select: function() { return /* reexport */ Select; },
  Switch: function() { return /* reexport */ Switch; },
  TabPane: function() { return /* reexport */ TabPane; },
  Tabs: function() { return /* reexport */ Tabs; },
  Tag: function() { return /* reexport */ Tag; },
  Text: function() { return /* reexport */ Text; },
  Textarea: function() { return /* reexport */ Textarea; },
  Tip: function() { return /* reexport */ Tip; },
  Tips: function() { return /* reexport */ Tips; },
  Tooltip: function() { return /* reexport */ Tooltip; },
  Tree: function() { return /* reexport */ Tree; },
  TreeSelect: function() { return /* reexport */ TreeSelect; },
  Upload: function() { return /* reexport */ Upload; },
  VxeAlert: function() { return /* reexport */ VxeAlert; },
  VxeAnchor: function() { return /* reexport */ VxeAnchor; },
  VxeAnchorLink: function() { return /* reexport */ VxeAnchorLink; },
  VxeBreadcrumb: function() { return /* reexport */ VxeBreadcrumb; },
  VxeBreadcrumbItem: function() { return /* reexport */ VxeBreadcrumbItem; },
  VxeButton: function() { return /* reexport */ VxeButton; },
  VxeButtonGroup: function() { return /* reexport */ VxeButtonGroup; },
  VxeCalendar: function() { return /* reexport */ VxeCalendar; },
  VxeCard: function() { return /* reexport */ VxeCard; },
  VxeCarousel: function() { return /* reexport */ VxeCarousel; },
  VxeCarouselItem: function() { return /* reexport */ VxeCarouselItem; },
  VxeCheckbox: function() { return /* reexport */ VxeCheckbox; },
  VxeCheckboxGroup: function() { return /* reexport */ VxeCheckboxGroup; },
  VxeCol: function() { return /* reexport */ VxeCol; },
  VxeCollapse: function() { return /* reexport */ VxeCollapse; },
  VxeCollapsePane: function() { return /* reexport */ VxeCollapsePane; },
  VxeDatePicker: function() { return /* reexport */ VxeDatePicker; },
  VxeDrawer: function() { return /* reexport */ VxeDrawer; },
  VxeForm: function() { return /* reexport */ VxeForm; },
  VxeFormDesign: function() { return /* reexport */ VxeFormDesign; },
  VxeFormGather: function() { return /* reexport */ VxeFormGather; },
  VxeFormItem: function() { return /* reexport */ VxeFormItem; },
  VxeFormView: function() { return /* reexport */ VxeFormView; },
  VxeIcon: function() { return /* reexport */ VxeIcon; },
  VxeIconPicker: function() { return /* reexport */ VxeIconPicker; },
  VxeImage: function() { return /* reexport */ VxeImage; },
  VxeImageGroup: function() { return /* reexport */ VxeImageGroup; },
  VxeImagePreview: function() { return /* reexport */ VxeImagePreview; },
  VxeInput: function() { return /* reexport */ VxeInput; },
  VxeLayoutAside: function() { return /* reexport */ VxeLayoutAside; },
  VxeLayoutBody: function() { return /* reexport */ VxeLayoutBody; },
  VxeLayoutContainer: function() { return /* reexport */ VxeLayoutContainer; },
  VxeLayoutFooter: function() { return /* reexport */ VxeLayoutFooter; },
  VxeLayoutHeader: function() { return /* reexport */ VxeLayoutHeader; },
  VxeLink: function() { return /* reexport */ VxeLink; },
  VxeList: function() { return /* reexport */ VxeList; },
  VxeListDesign: function() { return /* reexport */ VxeListDesign; },
  VxeListView: function() { return /* reexport */ VxeListView; },
  VxeLoading: function() { return /* reexport */ VxeLoading; },
  VxeMenu: function() { return /* reexport */ VxeMenu; },
  VxeModal: function() { return /* reexport */ VxeModal; },
  VxeNumberInput: function() { return /* reexport */ VxeNumberInput; },
  VxeOptgroup: function() { return /* reexport */ VxeOptgroup; },
  VxeOption: function() { return /* reexport */ VxeOption; },
  VxePager: function() { return /* reexport */ VxePager; },
  VxePasswordInput: function() { return /* reexport */ VxePasswordInput; },
  VxePrint: function() { return /* reexport */ VxePrint; },
  VxePrintPageBreak: function() { return /* reexport */ VxePrintPageBreak; },
  VxePulldown: function() { return /* reexport */ VxePulldown; },
  VxeRadio: function() { return /* reexport */ VxeRadio; },
  VxeRadioButton: function() { return /* reexport */ VxeRadioButton; },
  VxeRadioGroup: function() { return /* reexport */ VxeRadioGroup; },
  VxeRow: function() { return /* reexport */ VxeRow; },
  VxeSelect: function() { return /* reexport */ VxeSelect; },
  VxeSwitch: function() { return /* reexport */ VxeSwitch; },
  VxeTabPane: function() { return /* reexport */ VxeTabPane; },
  VxeTabs: function() { return /* reexport */ VxeTabs; },
  VxeTag: function() { return /* reexport */ VxeTag; },
  VxeText: function() { return /* reexport */ VxeText; },
  VxeTextarea: function() { return /* reexport */ VxeTextarea; },
  VxeTip: function() { return /* reexport */ VxeTip; },
  VxeTooltip: function() { return /* reexport */ VxeTooltip; },
  VxeTree: function() { return /* reexport */ VxeTree; },
  VxeTreeSelect: function() { return /* reexport */ VxeTreeSelect; },
  VxeUI: function() { return /* reexport */ core_VxeUI; },
  VxeUpload: function() { return /* reexport */ VxeUpload; },
  clipboard: function() { return /* reexport */ clipboard; },
  commands: function() { return /* reexport */ commands; },
  component: function() { return /* reexport */ component; },
  config: function() { return /* reexport */ config; },
  coreVersion: function() { return /* reexport */ coreVersion; },
  createEvent: function() { return /* reexport */ createEvent; },
  "default": function() { return /* binding */ entry_lib; },
  drawer: function() { return /* reexport */ components_drawer; },
  formats: function() { return /* reexport */ formats; },
  getComponent: function() { return /* reexport */ getComponent; },
  getConfig: function() { return /* reexport */ getConfig; },
  getI18n: function() { return /* reexport */ i18n_getI18n; },
  getIcon: function() { return /* reexport */ getIcon; },
  getLanguage: function() { return /* reexport */ getLanguage; },
  getTheme: function() { return /* reexport */ getTheme; },
  globalEvents: function() { return /* reexport */ globalEvents; },
  globalResize: function() { return /* reexport */ globalResize; },
  globalStore: function() { return /* reexport */ globalStore; },
  handleCheckInfo: function() { return /* reexport */ handleCheckInfo; },
  hasLanguage: function() { return /* reexport */ hasLanguage; },
  hooks: function() { return /* reexport */ hooks; },
  install: function() { return /* reexport */ install; },
  interceptor: function() { return /* reexport */ interceptor; },
  loading: function() { return /* reexport */ loading; },
  log: function() { return /* reexport */ log; },
  menus: function() { return /* reexport */ menus; },
  modal: function() { return /* reexport */ components_modal; },
  permission: function() { return /* reexport */ permission; },
  print: function() { return /* reexport */ components_print; },
  readFile: function() { return /* reexport */ readFile; },
  renderer: function() { return /* reexport */ renderer; },
  saveFile: function() { return /* reexport */ saveFile; },
  setConfig: function() { return /* reexport */ setConfig; },
  setI18n: function() { return /* reexport */ setI18n; },
  setIcon: function() { return /* reexport */ setIcon; },
  setLanguage: function() { return /* reexport */ setLanguage; },
  setTheme: function() { return /* reexport */ setTheme; },
  setup: function() { return /* reexport */ setup; },
  use: function() { return /* reexport */ use; },
  useFns: function() { return /* reexport */ useFns; },
  usePermission: function() { return /* reexport */ usePermission; },
  useSize: function() { return /* reexport */ useSize; },
  validators: function() { return /* reexport */ validators; },
  version: function() { return /* reexport */ ui_version; }
});

// NAMESPACE OBJECT: ./packages/components.ts
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, {
  Alert: function() { return Alert; },
  Anchor: function() { return Anchor; },
  AnchorLink: function() { return AnchorLink; },
  Breadcrumb: function() { return Breadcrumb; },
  BreadcrumbItem: function() { return BreadcrumbItem; },
  Button: function() { return Button; },
  ButtonGroup: function() { return ButtonGroup; },
  Calendar: function() { return Calendar; },
  Card: function() { return Card; },
  Carousel: function() { return Carousel; },
  CarouselItem: function() { return CarouselItem; },
  Checkbox: function() { return Checkbox; },
  CheckboxGroup: function() { return CheckboxGroup; },
  Col: function() { return Col; },
  Collapse: function() { return Collapse; },
  CollapsePane: function() { return CollapsePane; },
  DatePicker: function() { return DatePicker; },
  Drawer: function() { return Drawer; },
  DrawerController: function() { return DrawerController; },
  Form: function() { return Form; },
  FormDesign: function() { return FormDesign; },
  FormGather: function() { return FormGather; },
  FormItem: function() { return FormItem; },
  FormView: function() { return FormView; },
  GLOBAL_EVENT_KEYS: function() { return GLOBAL_EVENT_KEYS; },
  Icon: function() { return Icon; },
  IconPicker: function() { return IconPicker; },
  Image: function() { return Image; },
  ImageGroup: function() { return ImageGroup; },
  ImagePreview: function() { return ImagePreview; },
  Input: function() { return Input; },
  LayoutAside: function() { return LayoutAside; },
  LayoutBody: function() { return LayoutBody; },
  LayoutContainer: function() { return LayoutContainer; },
  LayoutFooter: function() { return LayoutFooter; },
  LayoutHeader: function() { return LayoutHeader; },
  Link: function() { return Link; },
  List: function() { return List; },
  ListDesign: function() { return ListDesign; },
  ListView: function() { return ListView; },
  Loading: function() { return Loading; },
  LoadingController: function() { return LoadingController; },
  Menu: function() { return Menu; },
  Modal: function() { return Modal; },
  ModalController: function() { return ModalController; },
  NumberInput: function() { return NumberInput; },
  Optgroup: function() { return Optgroup; },
  Option: function() { return Option; },
  Pager: function() { return Pager; },
  PasswordInput: function() { return PasswordInput; },
  Print: function() { return Print; },
  PrintPageBreak: function() { return PrintPageBreak; },
  Pulldown: function() { return Pulldown; },
  Radio: function() { return Radio; },
  RadioButton: function() { return RadioButton; },
  RadioGroup: function() { return RadioGroup; },
  Row: function() { return Row; },
  Select: function() { return Select; },
  Switch: function() { return Switch; },
  TabPane: function() { return TabPane; },
  Tabs: function() { return Tabs; },
  Tag: function() { return Tag; },
  Text: function() { return Text; },
  Textarea: function() { return Textarea; },
  Tip: function() { return Tip; },
  Tips: function() { return Tips; },
  Tooltip: function() { return Tooltip; },
  Tree: function() { return Tree; },
  TreeSelect: function() { return TreeSelect; },
  Upload: function() { return Upload; },
  VxeAlert: function() { return VxeAlert; },
  VxeAnchor: function() { return VxeAnchor; },
  VxeAnchorLink: function() { return VxeAnchorLink; },
  VxeBreadcrumb: function() { return VxeBreadcrumb; },
  VxeBreadcrumbItem: function() { return VxeBreadcrumbItem; },
  VxeButton: function() { return VxeButton; },
  VxeButtonGroup: function() { return VxeButtonGroup; },
  VxeCalendar: function() { return VxeCalendar; },
  VxeCard: function() { return VxeCard; },
  VxeCarousel: function() { return VxeCarousel; },
  VxeCarouselItem: function() { return VxeCarouselItem; },
  VxeCheckbox: function() { return VxeCheckbox; },
  VxeCheckboxGroup: function() { return VxeCheckboxGroup; },
  VxeCol: function() { return VxeCol; },
  VxeCollapse: function() { return VxeCollapse; },
  VxeCollapsePane: function() { return VxeCollapsePane; },
  VxeDatePicker: function() { return VxeDatePicker; },
  VxeDrawer: function() { return VxeDrawer; },
  VxeForm: function() { return VxeForm; },
  VxeFormDesign: function() { return VxeFormDesign; },
  VxeFormGather: function() { return VxeFormGather; },
  VxeFormItem: function() { return VxeFormItem; },
  VxeFormView: function() { return VxeFormView; },
  VxeIcon: function() { return VxeIcon; },
  VxeIconPicker: function() { return VxeIconPicker; },
  VxeImage: function() { return VxeImage; },
  VxeImageGroup: function() { return VxeImageGroup; },
  VxeImagePreview: function() { return VxeImagePreview; },
  VxeInput: function() { return VxeInput; },
  VxeLayoutAside: function() { return VxeLayoutAside; },
  VxeLayoutBody: function() { return VxeLayoutBody; },
  VxeLayoutContainer: function() { return VxeLayoutContainer; },
  VxeLayoutFooter: function() { return VxeLayoutFooter; },
  VxeLayoutHeader: function() { return VxeLayoutHeader; },
  VxeLink: function() { return VxeLink; },
  VxeList: function() { return VxeList; },
  VxeListDesign: function() { return VxeListDesign; },
  VxeListView: function() { return VxeListView; },
  VxeLoading: function() { return VxeLoading; },
  VxeMenu: function() { return VxeMenu; },
  VxeModal: function() { return VxeModal; },
  VxeNumberInput: function() { return VxeNumberInput; },
  VxeOptgroup: function() { return VxeOptgroup; },
  VxeOption: function() { return VxeOption; },
  VxePager: function() { return VxePager; },
  VxePasswordInput: function() { return VxePasswordInput; },
  VxePrint: function() { return VxePrint; },
  VxePrintPageBreak: function() { return VxePrintPageBreak; },
  VxePulldown: function() { return VxePulldown; },
  VxeRadio: function() { return VxeRadio; },
  VxeRadioButton: function() { return VxeRadioButton; },
  VxeRadioGroup: function() { return VxeRadioGroup; },
  VxeRow: function() { return VxeRow; },
  VxeSelect: function() { return VxeSelect; },
  VxeSwitch: function() { return VxeSwitch; },
  VxeTabPane: function() { return VxeTabPane; },
  VxeTabs: function() { return VxeTabs; },
  VxeTag: function() { return VxeTag; },
  VxeText: function() { return VxeText; },
  VxeTextarea: function() { return VxeTextarea; },
  VxeTip: function() { return VxeTip; },
  VxeTooltip: function() { return VxeTooltip; },
  VxeTree: function() { return VxeTree; },
  VxeTreeSelect: function() { return VxeTreeSelect; },
  VxeUI: function() { return core_VxeUI; },
  VxeUpload: function() { return VxeUpload; },
  clipboard: function() { return clipboard; },
  commands: function() { return commands; },
  component: function() { return component; },
  config: function() { return config; },
  coreVersion: function() { return coreVersion; },
  createEvent: function() { return createEvent; },
  drawer: function() { return components_drawer; },
  formats: function() { return formats; },
  getComponent: function() { return getComponent; },
  getConfig: function() { return getConfig; },
  getI18n: function() { return i18n_getI18n; },
  getIcon: function() { return getIcon; },
  getLanguage: function() { return getLanguage; },
  getTheme: function() { return getTheme; },
  globalEvents: function() { return globalEvents; },
  globalResize: function() { return globalResize; },
  globalStore: function() { return globalStore; },
  handleCheckInfo: function() { return handleCheckInfo; },
  hasLanguage: function() { return hasLanguage; },
  hooks: function() { return hooks; },
  install: function() { return install; },
  interceptor: function() { return interceptor; },
  loading: function() { return loading; },
  log: function() { return log; },
  menus: function() { return menus; },
  modal: function() { return components_modal; },
  permission: function() { return permission; },
  print: function() { return components_print; },
  readFile: function() { return readFile; },
  renderer: function() { return renderer; },
  saveFile: function() { return saveFile; },
  setConfig: function() { return setConfig; },
  setI18n: function() { return setI18n; },
  setIcon: function() { return setIcon; },
  setLanguage: function() { return setLanguage; },
  setTheme: function() { return setTheme; },
  setup: function() { return setup; },
  use: function() { return use; },
  useFns: function() { return useFns; },
  usePermission: function() { return usePermission; },
  useSize: function() { return useSize; },
  validators: function() { return validators; },
  version: function() { return ui_version; }
});

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
// EXTERNAL MODULE: external {"root":"XEUtils","commonjs":"xe-utils","commonjs2":"xe-utils","amd":"xe-utils"}
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_ = __webpack_require__(8871);
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default = /*#__PURE__*/__webpack_require__.n(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_);
;// CONCATENATED MODULE: ./node_modules/dom-zindex/es/index.esm.js
var storeEl = null;
var storeId = 'z-index-manage';
var storeMainKey = 'm';
var storeSubKey = 's';
var storeData = {
  m: 1000,
  s: 1000
};
function isDocument() {
  return typeof document !== 'undefined';
}
function getDomMaxZIndex() {
  var max = 0;
  if (isDocument()) {
    var allElem = document.body.getElementsByTagName('*');
    for (var i = 0; i < allElem.length; i++) {
      var elem = allElem[i];
      if (elem && elem.style && elem.nodeType === 1) {
        var zIndex = elem.style.zIndex;
        if (zIndex && /^\d+$/.test(zIndex)) {
          max = Math.max(max, Number(zIndex));
        }
      }
    }
  }
  return max;
}
function getDom() {
  if (!storeEl) {
    if (isDocument()) {
      storeEl = document.getElementById(storeId);
      if (!storeEl) {
        storeEl = document.createElement('div');
        storeEl.id = storeId;
        storeEl.style.display = 'none';
        document.body.appendChild(storeEl);
        setCurrent(storeData.m);
        setSubCurrent(storeData.s);
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function (value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var doc = getDom();
      if (doc) {
        if (doc.dataset) {
          doc.dataset[key] = value + '';
        } else {
          doc.setAttribute('data-' + key, value + '');
        }
      }
    }
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent(currZindex) {
    var zIndex;
    var doc = getDom();
    if (doc) {
      var domVal = doc.dataset ? doc.dataset[key] : doc.getAttribute('data-' + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
/**
 * Web common z-index style management
 */
var DomZIndex = {
  setCurrent: setCurrent,
  getCurrent: getCurrent,
  getNext: getNext,
  setSubCurrent: setSubCurrent,
  getSubCurrent: getSubCurrent,
  getSubNext: getSubNext,
  getMax: getDomMaxZIndex
};
/* harmony default export */ var index_esm = (DomZIndex);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/globalStore.js
const globalConfigStore = {
  size: '',
  version: 1,
  zIndex: 999,
  resizeInterval: 500
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/iconStore.js
const iconConfigStore = {};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/themeStore.js
const themeConfigStore = {
  theme: ''
};
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(9274);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/i18nStore.js

const i18nConfigStore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  language: '',
  langMaps: {}
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/event.js


const GLOBAL_EVENT_KEYS = {
  F2: 'F2',
  ESCAPE: 'Escape',
  ENTER: 'Enter',
  TAB: 'Tab',
  DELETE: 'Delete',
  BACKSPACE: 'Backspace',
  SPACEBAR: ' ',
  CONTEXT_MENU: 'ContextMenu',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  PAGE_UP: 'PageUp',
  PAGE_DOWN: 'PageDown',
  R: 'R',
  P: 'P',
  Z: 'Z',
  X: 'X',
  C: 'C',
  V: 'V',
  M: 'M'
};
const browse = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
const convertEventKeys = {
  ' ': 'Spacebar',
  Apps: GLOBAL_EVENT_KEYS.CONTEXT_MENU,
  Del: GLOBAL_EVENT_KEYS.DELETE,
  Up: GLOBAL_EVENT_KEYS.ARROW_UP,
  Down: GLOBAL_EVENT_KEYS.ARROW_DOWN,
  Left: GLOBAL_EVENT_KEYS.ARROW_LEFT,
  Right: GLOBAL_EVENT_KEYS.ARROW_RIGHT
};
// 监听全局事件
const wheelName = browse.firefox ? 'DOMMouseScroll' : 'mousewheel';
const eventStore = [];
function triggerEvent(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({
    type,
    cb
  }) => {
    // 如果被取消冒泡，不再执行
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === 'mousewheel') {
        cb(evnt);
      }
    }
  });
}
class VxeComponentEvent {
  constructor(evnt, params1, params2) {
    Object.defineProperty(this, "$event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.$event = evnt;
    Object.assign(this, params1, params2);
  }
  stopPropagation() {
    const evnt = this.$event;
    if (evnt) {
      evnt.stopPropagation();
    }
  }
  preventDefault() {
    const evnt = this.$event;
    if (evnt) {
      evnt.preventDefault();
    }
  }
}
const createEvent = (evnt, params1, params2) => {
  return new VxeComponentEvent(evnt, params1, params2);
};
const globalEvents = {
  on(comp, type, cb) {
    eventStore.push({
      comp,
      type,
      cb
    });
  },
  off(comp, type) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eventStore, item => item.comp === comp && item.type === type);
  },
  hasKey(evnt, targetKey) {
    const {
      key
    } = evnt;
    targetKey = targetKey.toLowerCase();
    return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener('copy', triggerEvent, false);
    window.addEventListener('cut', triggerEvent, false);
    window.addEventListener('paste', triggerEvent, false);
  }
  document.addEventListener('keydown', triggerEvent, false);
  document.addEventListener('contextmenu', triggerEvent, false);
  window.addEventListener('mousedown', triggerEvent, false);
  window.addEventListener('blur', triggerEvent, false);
  window.addEventListener('resize', triggerEvent, false);
  window.addEventListener(wheelName, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(triggerEvent, 100, {
    leading: true,
    trailing: false
  }), {
    passive: true,
    capture: false
  });
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/resize.js



/**
 * 监听 resize 事件
 * 如果项目中已使用了 resize-observer-polyfill，那么只需要将方法定义全局，该组件就会自动使用
 */
let resizeTimeout;
/* eslint-disable no-use-before-define */
const resize_eventStore = [];
const defaultInterval = 500;
function eventHandle() {
  if (resize_eventStore.length) {
    resize_eventStore.forEach(item => {
      item.tarList.forEach(observer => {
        const {
          target,
          width,
          heighe
        } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    /* eslint-disable @typescript-eslint/no-use-before-define */
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, globalConfigStore.resizeInterval || defaultInterval);
}
class XEResizeObserver {
  constructor(callback) {
    Object.defineProperty(this, "tarList", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "callback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const {
        tarList
      } = this;
      if (!tarList.some(observer => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!resize_eventStore.length) {
        eventListener();
      }
      if (!resize_eventStore.some(item => item === this)) {
        resize_eventStore.push(this);
      }
    }
  }
  unobserve(target) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item.tarList.some(observer => observer.target === target));
  }
  disconnect() {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item === this);
  }
}
const globalResize = {
  create(callback) {
    if (window.ResizeObserver) {
      return new window.ResizeObserver(callback);
    }
    return new XEResizeObserver(callback);
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/i18n.js


function i18n_getI18n(key, args) {
  const {
    langMaps,
    language
  } = i18nConfigStore;
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(langMaps[language], key, key), args);
}
function hasLanguage(language) {
  const {
    langMaps
  } = i18nConfigStore;
  return !!langMaps[language];
}
function getLanguage() {
  const {
    language
  } = i18nConfigStore;
  return language;
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/log.js

function createLog(type, name) {
  return function (key, args) {
    const msg = `[vxe ${name || ''}] ${i18n_getI18n(key, args)}`;
    console[type](msg);
    return msg;
  };
}
const version = "4.0.3";
const log = {
  create: createLog,
  warn: createLog('warn', `v${version}`),
  err: createLog('error', `v${version}`)
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/renderer.js


/**
 * 内置的组件渲染
 */
const renderMap = {};
/**
 * 全局渲染器
 */
const renderer = {
  mixin(opts) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        // 检测是否覆盖
        if (false) {}
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(renderMap, callback);
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/store.js


/**
 * 创建数据仓库
 */
class Store {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    // 检测是否覆盖
    if (false) {}
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
/* harmony default export */ var store = (Store);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/validators.js

const validators = new store();
if (false) {}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/menus.js


class VXEMenusStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      if (false) {}
      render = {
        menuMethod: render
      };
    }
    // 检测是否覆盖
    if (false) {}
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const menus = new VXEMenusStore();
if (false) {}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/formats.js


class VXEFormatsStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      if (false) {}
      render = {
        cellFormatMethod: render
      };
    }
    // 检测是否覆盖
    if (false) {}
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const formats = new VXEFormatsStore();
if (false) {}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/commands.js


class VXECommandsStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      if (false) {}
      render = {
        commandMethod: render
      };
    }
    // 检测是否覆盖
    if (false) {}
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const commands = new VXECommandsStore();
if (false) {}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/interceptor.js



const storeMap = {};
const interceptor = {
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (render, type) => {
      interceptor.add(type, render);
    });
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, render) {
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      // if (process.env.NODE_ENV === 'development') {
      //   log.warn('vxe.error.delProp', ['interceptor -> callback', 'tableInterceptorMethod'])
      // }
      render = {
        tableInterceptorMethod: render
      };
    }
    const callback = render.tableInterceptorMethod;
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      // 检测重复
      if (false) {}
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, render) {
    const eList = storeMap[type];
    if (eList) {
      // 兼容
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
        render = {
          tableInterceptorMethod: render
        };
      }
      const callback = render ? render.tableInterceptorMethod : null;
      if (callback) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eList, fn => fn === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/clipboard.js

let copyElem;
const clipStore = {
  text: '',
  html: ''
};
function handleText(text) {
  if (!copyElem) {
    copyElem = document.createElement('textarea');
    copyElem.id = '$VxeCopy';
    const styles = copyElem.style;
    styles.width = '48px';
    styles.height = '24px';
    styles.position = 'fixed';
    styles.zIndex = '0';
    styles.left = '-500px';
    styles.top = '-500px';
    document.body.appendChild(copyElem);
  }
  copyElem.value = text;
}
const clipboard = {
  getStore() {
    return clipStore;
  },
  setStore(data) {
    Object.assign(clipStore, data || {});
  },
  /**
   * 复制内容到剪贴板
   *
   * @param {String} content Text 内容
   */
  copy(content) {
    let result = false;
    try {
      const text = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content);
      handleText(text);
      copyElem.select();
      copyElem.setSelectionRange(0, copyElem.value.length);
      result = document.execCommand('copy');
      copyElem.blur();
      clipStore.text = text;
      clipStore.html = '';
    } catch (e) {}
    return result;
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/permission.js


function handleCheckInfo(permissionCode, permissionMethod) {
  let checkVisible = true;
  let checkDisabled = false;
  const checkMethod = permissionMethod || globalConfigStore.permissionMethod;
  if (permissionCode && checkMethod) {
    checkVisible = false;
    checkDisabled = true;
    let vDone = false;
    let dDone = false;
    // 或 使用 | 隔开：任意一个为可视，则可视；任意一个禁用，则禁用
    const codeList = String(permissionCode).split('|');
    for (let i = 0; i < codeList.length; i++) {
      const code = codeList[i];
      let visible = true;
      let disabled = false;
      const rest = checkMethod({
        code
      });
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(rest)) {
        visible = rest;
      } else if (rest) {
        visible = !!rest.visible;
        disabled = !!rest.disabled;
      }
      if (!disabled && !dDone) {
        dDone = true;
        checkDisabled = disabled;
      }
      if (visible && !vDone) {
        vDone = true;
        checkVisible = visible;
      }
      if (vDone && dDone) {
        break;
      }
    }
  }
  const info = {
    code: permissionCode,
    visible: checkVisible,
    disabled: checkDisabled
  };
  return info;
}
const permission = {
  getCheckInfo(code) {
    return handleCheckInfo(code);
  },
  checkVisible(code) {
    const permissionInfo = handleCheckInfo(code);
    return permissionInfo.visible;
  },
  checkDisable(code) {
    const permissionInfo = handleCheckInfo(code);
    return permissionInfo.disabled;
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/hooks.js

const hooks = new store();
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/useFns.js


function useSize(props) {
  // 组件尺寸上下文
  const xeSizeInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeSizeInfo', null);
  const computeSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.size || (xeSizeInfo ? xeSizeInfo.value : null);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeSizeInfo', computeSize);
  return {
    computeSize
  };
}
function usePermission(props) {
  const computePermissionInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return handleCheckInfo(props.permissionCode, props.permissionMethod);
  });
  return {
    computePermissionInfo
  };
}
const useFns = {
  useSize,
  usePermission
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/core.js





















function setTheme(name) {
  const theme = !name || name === 'default' ? 'light' : name;
  themeConfigStore.theme = theme;
  if (typeof document !== 'undefined') {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute('data-vxe-ui-theme', theme);
    }
  }
  return core_VxeUI;
}
function getTheme() {
  return themeConfigStore.theme;
}
function setLanguage(locale) {
  i18nConfigStore.language = locale || 'zh-CN';
  return core_VxeUI;
}
function setI18n(locale, data) {
  i18nConfigStore.langMaps[locale] = Object.assign({}, data);
  return core_VxeUI;
}
/**
* 全局参数设置
*/
function setConfig(options) {
  if (options) {
    if (options.zIndex) {
      index_esm.setCurrent(options.zIndex);
    }
    if (options.theme) {
      setTheme(options.theme);
    }
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(globalConfigStore, options);
  }
  return core_VxeUI;
}
/**
* 获取全局参数
*/
function getConfig(key, defaultValue) {
  return arguments.length ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(globalConfigStore, key, defaultValue) : globalConfigStore;
}
function setIcon(options) {
  if (options) {
    Object.assign(iconConfigStore, options);
  }
  return core_VxeUI;
}
function getIcon(key) {
  return arguments.length ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(iconConfigStore, key) : iconConfigStore;
}
const coreVersion = "4.0.3";
const installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(core_VxeUI, options);
      installedPlugins.push(Plugin);
    }
  }
  return core_VxeUI;
}
const components = {};
function getComponent(name) {
  return components[name] || null;
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
  }
}
const core_VxeUI = {
  coreVersion,
  setTheme,
  getTheme,
  setConfig,
  getConfig: getConfig,
  setIcon,
  getIcon: getIcon,
  setLanguage,
  hasLanguage: hasLanguage,
  getLanguage: getLanguage,
  setI18n,
  getI18n: i18n_getI18n,
  globalEvents: globalEvents,
  GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS,
  createEvent: createEvent,
  globalResize: globalResize,
  renderer: renderer,
  validators: validators,
  menus: menus,
  formats: formats,
  commands: commands,
  interceptor: interceptor,
  clipboard: clipboard,
  log: log,
  permission: permission,
  hooks: hooks,
  component,
  getComponent,
  useFns: useFns,
  use
};
setTheme();














/* harmony default export */ var core = ((/* unused pure expression or super */ null && (core_VxeUI)));
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/index.esm.js


/* harmony default export */ var es_index_esm = ((/* unused pure expression or super */ null && (VxeUI)));
;// CONCATENATED MODULE: ./packages/language/zh-CN.ts
/* harmony default export */ var zh_CN = ({
  vxe: {
    base: {
      pleaseInput: '请输入',
      pleaseSelect: '请选择',
      comma: '，',
      fullStop: '。'
    },
    loading: {
      text: '加载中...'
    },
    error: {
      groupFixed: '如果使用分组表头，冻结列必须按组设置',
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: '无法插入到指定位置，请检查参数是否正确',
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: '工具栏无法关联表格',
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: '该浏览器不支持导入/导出功能',
      impFields: '导入失败，请检查字段名和数据格式是否正确',
      treeNotImp: '树表格不支持导入'
    },
    table: {
      emptyText: '暂无数据',
      allTitle: '全选/取消',
      seqTitle: '序号',
      actionTitle: '操作',
      confirmFilter: '筛选',
      resetFilter: '重置',
      allFilter: '全部',
      sortAsc: '升序：最低到最高',
      sortDesc: '降序：最高到最低',
      filter: '对所选的列启用筛选',
      impSuccess: '成功导入 {0} 条记录',
      expLoading: '正在导出中',
      expSuccess: '导出成功',
      expFilename: '导出_{0}',
      expOriginFilename: '导出_源_{0}',
      customTitle: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customCancel: '取消',
      customRestore: '恢复默认',
      maxFixedCol: '最大冻结列的数量不能超过 {0} 个'
    },
    grid: {
      selectOneRecord: '请至少选择一条记录！',
      deleteSelectRecord: '您确定要删除所选记录吗？',
      removeSelectRecord: '您确定要移除所选记录吗？',
      dataUnchanged: '数据未改动！',
      delSuccess: '成功删除所选记录！',
      saveSuccess: '保存成功！',
      operError: '发生错误，操作失败！'
    },
    select: {
      search: '搜索',
      loadingText: '加载中',
      emptyText: '暂无数据'
    },
    pager: {
      goto: '前往',
      gotoTitle: '页数',
      pagesize: '{0}条/页',
      total: '共 {0} 条记录',
      pageClassifier: '页',
      homePage: '首页',
      homePageTitle: '首页',
      prevPage: '上一页',
      prevPageTitle: '上一页',
      nextPage: '下一页',
      nextPageTitle: '下一页',
      prevJump: '向上跳页',
      prevJumpTitle: '向上跳页',
      nextJump: '向下跳页',
      nextJumpTitle: '向下跳页',
      endPage: '末页',
      endPageTitle: '末页'
    },
    alert: {
      title: '系统提示'
    },
    button: {
      confirm: '确认',
      cancel: '取消'
    },
    filter: {
      search: '搜索'
    },
    custom: {
      cstmTitle: '列设置',
      cstmRestore: '恢复默认',
      cstmCancel: '取消',
      cstmConfirm: '确定',
      cstmConfirmRestore: '请确认是否恢复成默认列配置？',
      cstmDragTarget: '移动目标：{0}',
      setting: {
        colSort: '排序',
        sortHelpTip: '点击并拖动图标可以调整列的排序',
        colTitle: '标题',
        colResizable: '列宽（像素）',
        colVisible: '是否显示',
        colFixed: '冻结列',
        colFixedMax: '冻结列（最多 {0} 列）',
        fixedLeft: '左侧',
        fixedUnset: '不设置',
        fixedRight: '右侧'
      }
    },
    import: {
      modes: {
        covering: '覆盖方式（直接覆盖表格数据）',
        insert: '底部追加（在表格的底部追加新数据）',
        insertTop: '顶部追加（在表格的顶部追加新数据）',
        insertBottom: '底部追加（在表格的底部追加新数据）'
      },
      impTitle: '导入数据',
      impFile: '文件名',
      impSelect: '选择文件',
      impType: '文件类型',
      impOpts: '参数设置',
      impMode: '导入模式',
      impConfirm: '导入',
      impCancel: '取消'
    },
    export: {
      types: {
        csv: 'CSV (逗号分隔)(*.csv)',
        html: '网页(*.html)',
        xml: 'XML 数据(*.xml)',
        txt: '文本文件(制表符分隔)(*.txt)',
        xls: 'Excel 97-2003 工作簿(*.xls)',
        xlsx: 'Excel 工作簿(*.xlsx)',
        pdf: 'PDF (*.pdf)'
      },
      modes: {
        current: '当前数据（当前页的数据）',
        selected: '选中数据（当前页选中的数据）',
        all: '全量数据（包括所有分页的数据）'
      },
      printTitle: '打印数据',
      expTitle: '导出数据',
      expName: '文件名',
      expNamePlaceholder: '请输入文件名',
      expSheetName: '标题',
      expSheetNamePlaceholder: '请输入标题',
      expType: '保存类型',
      expMode: '选择数据',
      expCurrentColumn: '全部字段',
      expColumn: '选择字段',
      expOpts: '参数设置',
      expOptHeader: '表头',
      expHeaderTitle: '是否需要表头',
      expOptFooter: '表尾',
      expFooterTitle: '是否需要表尾',
      expOptColgroup: '分组表头',
      expColgroupTitle: '如果存在，则支持带有分组结构的表头',
      expOptMerge: '合并',
      expMergeTitle: '如果存在，则支持带有合并结构的单元格',
      expOptAllExpand: '展开层级',
      expAllExpandTitle: '如果存在，则支持将带有层级结构的数据全部展开',
      expOptUseStyle: '样式',
      expUseStyleTitle: '如果存在，则支持带样式的单元格',
      expOptOriginal: '源数据',
      expOriginalTitle: '如果为源数据，则支持导入到表格中',
      expPrint: '打印',
      expConfirm: '导出',
      expCancel: '取消'
    },
    modal: {
      errTitle: '错误提示',
      zoomMin: '最小化',
      zoomIn: '最大化',
      zoomOut: '还原',
      close: '关闭',
      miniMaxSize: '最小化窗口的数量不能超过 {0} 个'
    },
    drawer: {
      close: '关闭'
    },
    form: {
      folding: '收起',
      unfolding: '展开'
    },
    toolbar: {
      import: '导入',
      export: '导出',
      print: '打印',
      refresh: '刷新',
      zoomIn: '全屏',
      zoomOut: '还原',
      custom: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customRestore: '重置',
      fixedLeft: '冻结在左侧',
      fixedRight: '冻结在右侧',
      cancelFixed: '取消冻结列'
    },
    input: {
      date: {
        m1: '01 月',
        m2: '02 月',
        m3: '03 月',
        m4: '04 月',
        m5: '05 月',
        m6: '06 月',
        m7: '07 月',
        m8: '08 月',
        m9: '09 月',
        m10: '10 月',
        m11: '11 月',
        m12: '12 月',
        quarterLabel: '{0} 年',
        monthLabel: '{0} 年',
        dayLabel: '{0} 年 {1}',
        labelFormat: {
          date: 'yyyy-MM-dd',
          time: 'HH:mm:ss',
          datetime: 'yyyy-MM-dd HH:mm:ss',
          week: 'yyyy 年第 WW 周',
          month: 'yyyy-MM',
          quarter: 'yyyy 年第 q 季度',
          year: 'yyyy'
        },
        weeks: {
          w: '周',
          w0: '周日',
          w1: '周一',
          w2: '周二',
          w3: '周三',
          w4: '周四',
          w5: '周五',
          w6: '周六'
        },
        months: {
          m0: '一月',
          m1: '二月',
          m2: '三月',
          m3: '四月',
          m4: '五月',
          m5: '六月',
          m6: '七月',
          m7: '八月',
          m8: '九月',
          m9: '十月',
          m10: '十一月',
          m11: '十二月'
        },
        quarters: {
          q1: '第一季度',
          q2: '第二季度',
          q3: '第三季度',
          q4: '第四季度'
        }
      }
    },
    imagePreview: {
      popupTitle: '预览',
      operBtn: {
        zoomOut: '缩小',
        zoomIn: '放大',
        pctFull: '等比例缩放',
        pct11: '显示原始尺寸',
        rotateLeft: '向左旋转',
        rotateRight: '向右旋转',
        print: '点击打印图片',
        download: '点击下载图片'
      }
    },
    upload: {
      fileBtnText: '点击或拖拽上传',
      imgBtnText: '点击或拖拽上传',
      dragPlaceholder: '请把文件拖放到这个区域即可上传',
      imgSizeHint: '单张{0}',
      imgCountHint: '最多{0}张',
      fileTypeHint: '支持 {0} 文件类型',
      fileSizeHint: '单个文件大小不超过{0}',
      fileCountHint: '最多可上传{0}个文件',
      overCountErr: '最多只能选择{0}个文件！',
      overCountExtraErr: '已超出最大数量{0}个，超出的{1}个文件将被忽略！',
      overSizeErr: '文件大小最大不能超过{0}！',
      reUpload: '重新上传',
      uploadProgress: '上传中 {0}%',
      uploadErr: '上传失败',
      uploadSuccess: '上传成功',
      moreBtnText: '更多（{0}）',
      viewItemTitle: '点击查看'
    },
    formDesign: {
      formName: '表单名称',
      defFormTitle: '未命名的表单',
      widgetPropTab: '控件属性',
      widgetFormTab: '表单属性',
      error: {
        wdFormUni: '该类型的控件在表单中只允许添加一个',
        wdSubUni: '该类型的控件在子表中只允许添加一个'
      },
      styleSetting: {
        btn: '样式设置',
        title: '表单的样式设置',
        layoutTitle: '控件布局',
        verticalLayout: '上下布局',
        horizontalLayout: '横向布局',
        styleTitle: '标题样式',
        boldTitle: '标题加粗',
        fontBold: '加粗',
        fontNormal: '常规',
        colonTitle: '显示冒号',
        colonVisible: '显示',
        colonHidden: '隐藏',
        alignTitle: '对齐方式',
        widthTitle: '标题宽度',
        alignLeft: '居左',
        alignRight: '居右',
        unitPx: '像素',
        unitPct: '百分比'
      },
      widget: {
        group: {
          base: '基础控件',
          layout: '布局控件',
          system: '系统控件',
          module: '模块控件',
          chart: '图表控件',
          advanced: '高级控件'
        },
        copyTitle: '副本_{0}',
        component: {
          input: '输入框',
          textarea: '文本域',
          select: '下拉选择',
          row: '一行多列',
          title: '标题',
          text: '文本',
          subtable: '子表',
          VxeSwitch: '是/否',
          VxeInput: '输入框',
          VxeNumberInput: '数字',
          VxeDatePicker: '日期',
          VxeTextarea: '文本域',
          VxeSelect: '下拉选择',
          VxeTreeSelect: '树形选择',
          VxeRadioGroup: '单选框',
          VxeCheckboxGroup: '复选框',
          VxeUploadFile: '文件',
          VxeUploadImage: '图片'
        }
      },
      widgetProp: {
        name: '控件名称',
        placeholder: '提示语',
        required: '必填校验',
        multiple: '允许多选',
        displaySetting: {
          name: '显示设置',
          pc: '电脑端',
          mobile: '手机端',
          visible: '显示',
          hidden: '隐藏'
        },
        dataSource: {
          name: '数据源',
          defValue: '选项{0}',
          addOption: '添加选项',
          batchEditOption: '批量编辑',
          batchEditTip: '每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。',
          batchEditSubTip: '每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。',
          buildOption: '生成选项'
        },
        rowProp: {
          colSize: '列数',
          col2: '两列',
          col3: '三列',
          col4: '四列',
          col6: '六列',
          layout: '布局'
        },
        textProp: {
          name: '内容',
          alignTitle: '对齐方式',
          alignLeft: '居左',
          alignCenter: '居中',
          alignRight: '居右',
          colorTitle: '字体颜色',
          sizeTitle: '字体大小',
          boldTitle: '字体加粗',
          fontNormal: '常规',
          fontBold: '加粗'
        },
        subtableProp: {
          seqTitle: '序号',
          showSeq: '显示序号',
          showCheckbox: '允许多选',
          errSubDrag: '子表不支持该控件，请使用其他控件'
        },
        uploadProp: {
          limitFileCount: '文件数量限制',
          limitFileSize: '文件大小限制',
          multiFile: '允许上传多个文件',
          limitImgCount: '图片数量限制',
          limitImgSize: '图片大小限制',
          multiImg: '允许上传多张图片'
        }
      }
    },
    listDesign: {
      fieldSettingTab: '字段设置',
      listSettingTab: '参数设置',
      searchTitle: '查询条件',
      listTitle: '列表字段',
      searchField: '查询字段',
      listField: '列表字段',
      activeBtn: {
        ActionButtonUpdate: '编辑',
        ActionButtonDelete: '删除'
      },
      search: {
        addBtn: '编辑',
        emptyText: '未配置查询条件'
      }
    },
    text: {
      copySuccess: '已复制到剪贴板',
      copyError: '当前环境不支持该操作'
    },
    /**
     * 扩展插件
     */
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: '无法对合并单元格进行该操作',
          multiErr: '无法对多重选择区域进行该操作',
          extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
          pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作',
          cpInvalidErr: '该操作无法进行，您选择的区域中存在被禁止的列（{0}）'
        },
        fnr: {
          title: '查找和替换',
          findLabel: '查找',
          replaceLabel: '替换',
          findTitle: '查找内容：',
          replaceTitle: '替换为：',
          tabs: {
            find: '查找',
            replace: '替换'
          },
          filter: {
            re: '正则表达式',
            whole: '全词匹配',
            sensitive: '区分大小写'
          },
          btns: {
            findNext: '查找下一个',
            findAll: '查找全部',
            replace: '替换',
            replaceAll: '替换全部',
            cancel: '取消'
          },
          header: {
            seq: '#',
            cell: '单元格',
            value: '值'
          },
          empty: '(空值)',
          reError: '无效的正则表达式',
          recordCount: '已找到 {0} 个单元格',
          notCell: '找不到匹配的单元格',
          replaceSuccess: '成功替换 {0} 个单元格'
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧'
        },
        cases: {
          equal: '等于',
          gt: '大于',
          lt: '小于',
          begin: '开头是',
          endin: '结尾是',
          include: '包含',
          isSensitive: '区分大小写'
        }
      },
      filterCombination: {
        menus: {
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        cases: {
          equal: '等于',
          unequal: '不等于',
          gt: '大于',
          ge: '大于或等于',
          lt: '小于',
          le: '小于或等于',
          begin: '开头是',
          notbegin: '开头不是',
          endin: '结尾是',
          notendin: '结尾不是',
          include: '包含',
          exclude: '不包含',
          between: '介于',
          custom: '自定义筛选',
          insensitive: '不区分大小写',
          isSensitive: '区分大小写'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    },
    /**
     * 以下废弃
     * @deprecated
     */
    pro: {
      area: {
        mergeErr: '无法对合并单元格进行该操作',
        multiErr: '无法对多重选择区域进行该操作',
        extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
        pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作'
      },
      fnr: {
        title: '查找和替换',
        findLabel: '查找',
        replaceLabel: '替换',
        findTitle: '查找内容：',
        replaceTitle: '替换为：',
        tabs: {
          find: '查找',
          replace: '替换'
        },
        filter: {
          re: '正则表达式',
          whole: '全词匹配',
          sensitive: '区分大小写'
        },
        btns: {
          findNext: '查找下一个',
          findAll: '查找全部',
          replace: '替换',
          replaceAll: '替换全部',
          cancel: '取消'
        },
        header: {
          seq: '#',
          cell: '单元格',
          value: '值'
        },
        empty: '(空值)',
        reError: '无效的正则表达式',
        recordCount: '已找到 {0} 个单元格',
        notCell: '找不到匹配的单元格',
        replaceSuccess: '成功替换 {0} 个单元格'
      }
    },
    renderer: {
      search: '搜索',
      cases: {
        equal: '等于',
        unequal: '不等于',
        gt: '大于',
        ge: '大于或等于',
        lt: '小于',
        le: '小于或等于',
        begin: '开头是',
        notbegin: '开头不是',
        endin: '结尾是',
        notendin: '结尾不是',
        include: '包含',
        exclude: '不包含',
        between: '介于',
        custom: '自定义筛选',
        insensitive: '不区分大小写',
        isSensitive: '区分大小写'
      },
      combination: {
        menus: {
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '锁定列',
          fixedGroup: '锁定组',
          cancelFixed: '取消锁定',
          fixedLeft: '锁定左侧',
          fixedRight: '锁定右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/dynamics/index.ts

let dynamicContainerElem;
const dynamicStore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  modals: [],
  drawers: [],
  globalLoading: null
});
/**
 * 动态组件
 */
const VxeDynamics = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  setup() {
    return () => {
      const {
        modals,
        drawers,
        globalLoading
      } = dynamicStore;
      return [modals.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-dynamics--modal'
      }, modals.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-modal'), item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), drawers.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-dynamics--drawer'
      }, drawers.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-drawer'), item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), globalLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-loading'), globalLoading) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
    };
  }
});
const dynamicApp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createApp)(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement('div');
    dynamicContainerElem.className = 'vxe-dynamics';
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}
;// CONCATENATED MODULE: ./packages/ui/src/utils.ts



function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function nextZIndex() {
  return index_esm.getNext();
}
function getLastZIndex() {
  return index_esm.getCurrent();
}
function getFuncText(content, args) {
  if (content) {
    const translate = getConfig().translate;
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(translate ? translate('' + content, args) : content);
  }
  return '';
}
/**
 * 判断值为：'' | null | undefined 时都属于空值
 */
function eqEmptyValue(cellValue) {
  return cellValue === null || cellValue === undefined || cellValue === '';
}
function handleBooleanDefaultValue(value) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(value) ? value : null;
}
;// CONCATENATED MODULE: ./packages/ui/src/log.ts

const log_version = `ui v${"4.1.1"}`;
const warnLog = log.create('warn', log_version);
const errLog = log.create('error', log_version);
;// CONCATENATED MODULE: ./packages/ui/index.ts




const ui_version = "4.1.1";
core_VxeUI.version = ui_version;
core_VxeUI.uiVersion = ui_version;
core_VxeUI.tableVersion = '';
core_VxeUI.t = core_VxeUI.getI18n;
core_VxeUI._t = getFuncText;
core_VxeUI.dynamicApp = dynamicApp;
function config(options) {
  warnLog('vxe.error.delFunc', ['config', 'setConfig']);
  return setConfig(options);
}
function setup(options) {
  warnLog('vxe.error.delFunc', ['setup', 'setConfig']);
  return setConfig(options);
}
core_VxeUI.config = config;
core_VxeUI.setup = setup;
/**
 * 已废弃
 * @deprecated
 */
const globalStore = {};
core_VxeUI.globalStore = globalStore;
setConfig({
  alert: {},
  anchor: {},
  anchorLink: {},
  breadcrumb: {
    separator: '/'
  },
  breadcrumbItem: {},
  button: {
    trigger: 'hover'
  },
  buttonGroup: {},
  card: {
    border: true,
    padding: true
  },
  carousel: {
    height: 200,
    loop: true,
    showIndicators: true
  },
  carouselItem: {},
  checkbox: {},
  checkboxGroup: {},
  col: {},
  colgroup: {},
  collapse: {},
  collapsePane: {},
  column: {},
  datePicker: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  drawer: {
    // size: null,
    position: 'right',
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true,
    padding: true
  },
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: true,
      autoPos: true
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true,
    titleOverflow: false,
    padding: true
  },
  formDesign: {
    height: 400,
    showHeader: true,
    showPc: true
  },
  formGather: {},
  formItem: {},
  formView: {},
  grid: {},
  icon: {},
  iconPicker: {
    icons: ['home', 'company', 'comment', 'setting', 'send', 'envelope', 'envelope-open', 'bell', 'search', 'print', 'pc', 'goods', 'chart-line', 'edit', 'delete', 'save', 'folder', 'microphone', 'flag', 'link', 'location', 'sunny', 'rmb', 'usd', 'user', 'add-user', 'add-users', 'star', 'unlock', 'time', 'text', 'feedback', 'calendar', 'association-form', 'cloud-download', 'cloud-upload', 'file', 'subtable', 'chart-bar-x', 'chart-bar-y', 'chart-line', 'chart-pie', 'chart-radar']
  },
  image: {
    showPreview: true
  },
  imageGroup: {
    showPreview: true
  },
  imagePreview: {
    showPrintButton: true,
    showDownloadButton: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  layoutAside: {},
  layoutBody: {},
  layoutContainer: {},
  layoutFooter: {},
  layoutHeader: {},
  link: {
    underline: true
  },
  listDesign: {
    height: 400,
    showPc: true
  },
  listView: {},
  list: {
    // size: null,
    scrollY: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  loading: {},
  modal: {
    // size: null,
    top: 16,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3000,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    padding: true,
    draggable: true,
    showConfirmButton: null,
    zoomConfig: {
      minimizeMaxSize: 10,
      minimizeVerticalOffset: {
        top: -24,
        left: 0
      },
      minimizeHorizontalOffset: {
        top: 0,
        left: 32
      }
    },
    // storage: false,
    storageKey: 'VXE_MODAL_POSITION'
  },
  numberInput: {
    // size: null,
    // transfer: false
    digits: 2,
    controls: true
  },
  optgroup: {},
  option: {},
  pager: {
    pageSizePlacement: 'top'
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  print: {},
  passwordInput: {},
  printPageBreak: {},
  pulldown: {},
  radio: {
    strict: true
  },
  radioButton: {
    strict: true
  },
  radioGroup: {
    strict: true
  },
  row: {},
  select: {
    multiCharOverflow: 8
  },
  switch: {},
  tabPane: {},
  table: {},
  tabs: {},
  tag: {},
  text: {},
  textarea: {},
  toolbar: {},
  tip: {},
  tooltip: {
    // size: null,
    trigger: 'hover',
    theme: 'dark',
    enterDelay: 500,
    leaveDelay: 300
  },
  tree: {
    indent: 20,
    minHeight: 60,
    radioConfig: {
      strict: true
    }
  },
  treeSelect: {
    treeConfig: {
      radioConfig: {},
      checkboxConfig: {}
    }
  },
  upload: {
    mode: 'all',
    imageTypes: ['jpg', 'jpeg', 'png', 'gif'],
    showList: true,
    showButtonText: true,
    showRemoveButton: true,
    showButtonIcon: true,
    showPreview: true,
    imageStyle: {}
  }
});
const iconPrefix = 'vxe-icon-';
setIcon({
  // loading
  LOADING: iconPrefix + 'spinner roll vxe-loading--default-icon',
  // button
  BUTTON_DROPDOWN: iconPrefix + 'arrow-down',
  BUTTON_LOADING: iconPrefix + 'spinner roll',
  // menu
  MENU_ITEM_EXPAND_OPEN: iconPrefix + 'arrow-down rotate180',
  MENU_ITEM_EXPAND_CLOSE: iconPrefix + 'arrow-down',
  // select
  SELECT_LOADED: iconPrefix + 'spinner roll',
  SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  SELECT_CLOSE: iconPrefix + 'caret-down',
  // icon-picker
  ICON_PICKER_OPEN: iconPrefix + 'caret-down rotate180',
  ICON_PICKER_CLOSE: iconPrefix + 'caret-down',
  // pager
  PAGER_HOME: iconPrefix + 'home-page',
  PAGER_END: iconPrefix + 'end-page',
  PAGER_JUMP_PREV: iconPrefix + 'arrow-double-left',
  PAGER_JUMP_NEXT: iconPrefix + 'arrow-double-right',
  PAGER_PREV_PAGE: iconPrefix + 'arrow-left',
  PAGER_NEXT_PAGE: iconPrefix + 'arrow-right',
  PAGER_JUMP_MORE: iconPrefix + 'ellipsis-h',
  // radio
  RADIO_CHECKED: iconPrefix + 'radio-checked-fill',
  RADIO_UNCHECKED: iconPrefix + 'radio-unchecked',
  // checkbox
  CHECKBOX_INDETERMINATE: iconPrefix + 'checkbox-indeterminate-fill',
  CHECKBOX_CHECKED: iconPrefix + 'checkbox-checked-fill',
  CHECKBOX_UNCHECKED: iconPrefix + 'checkbox-unchecked',
  // input
  INPUT_CLEAR: iconPrefix + 'error-circle-fill',
  INPUT_SEARCH: iconPrefix + 'search',
  // number-picker
  NUMBER_INPUT_PREV_NUM: iconPrefix + 'caret-up',
  NUMBER_INPUT_NEXT_NUM: iconPrefix + 'caret-down',
  // date-picker
  DATE_PICKER_DATE: iconPrefix + 'calendar',
  // password-input
  PASSWORD_INPUT_SHOW_PWD: iconPrefix + 'eye-fill-close',
  PASSWORD_INPUT_HIDE_PWD: iconPrefix + 'eye-fill',
  // modal
  MODAL_ZOOM_MIN: iconPrefix + 'minus',
  MODAL_ZOOM_REVERT: iconPrefix + 'recover',
  MODAL_ZOOM_IN: iconPrefix + 'square',
  MODAL_ZOOM_OUT: iconPrefix + 'maximize',
  MODAL_CLOSE: iconPrefix + 'close',
  MODAL_INFO: iconPrefix + 'info-circle-fill',
  MODAL_SUCCESS: iconPrefix + 'success-circle-fill',
  MODAL_WARNING: iconPrefix + 'warning-circle-fill',
  MODAL_ERROR: iconPrefix + 'error-circle-fill',
  MODAL_QUESTION: iconPrefix + 'question-circle-fill',
  MODAL_LOADING: iconPrefix + 'spinner roll',
  // drawer
  DRAWER_CLOSE: iconPrefix + 'close',
  // form
  FORM_PREFIX: iconPrefix + 'question-circle-fill',
  FORM_SUFFIX: iconPrefix + 'question-circle-fill',
  FORM_FOLDING: iconPrefix + 'arrow-up rotate180',
  FORM_UNFOLDING: iconPrefix + 'arrow-up',
  // form-design
  FORM_DESIGN_STYLE_SETTING: iconPrefix + 'layout',
  FORM_DESIGN_PROPS_PC: iconPrefix + 'pc',
  FORM_DESIGN_PROPS_MOBILE: iconPrefix + 'mobile',
  FORM_DESIGN_PROPS_ADD: iconPrefix + 'add',
  FORM_DESIGN_PROPS_EDIT: iconPrefix + 'edit',
  FORM_DESIGN_WIDGET_ADD: iconPrefix + 'square-plus-fill',
  FORM_DESIGN_WIDGET_COPY: iconPrefix + 'copy',
  FORM_DESIGN_WIDGET_DELETE: iconPrefix + 'delete',
  FORM_DESIGN_WIDGET_OPTION_DELETE: iconPrefix + 'delete',
  FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN: iconPrefix + 'square-plus',
  FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE: iconPrefix + 'square-minus',
  // list-design
  LIST_DESIGN_FIELD_SETTING: iconPrefix + 'custom-column',
  LIST_DESIGN_LIST_SETTING: iconPrefix + 'menu',
  LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE: iconPrefix + 'delete',
  // upload
  UPLOAD_FILE_ERROR: iconPrefix + 'warning-circle-fill',
  UPLOAD_FILE_ADD: iconPrefix + 'upload',
  UPLOAD_FILE_REMOVE: iconPrefix + 'delete',
  UPLOAD_FILE_DOWNLOAD: iconPrefix + 'download',
  UPLOAD_IMAGE_RE_UPLOAD: iconPrefix + 'repeat',
  UPLOAD_IMAGE_ADD: iconPrefix + 'add',
  UPLOAD_IMAGE_REMOVE: iconPrefix + 'close',
  UPLOAD_LOADING: iconPrefix + 'spinner roll vxe-loading--default-icon',
  UPLOAD_FILE_TYPE_DEFAULT: iconPrefix + 'file',
  UPLOAD_FILE_TYPE_XLSX: iconPrefix + 'file-excel',
  UPLOAD_FILE_TYPE_XLS: iconPrefix + 'file-excel',
  UPLOAD_FILE_TYPE_PDF: iconPrefix + 'file-pdf',
  UPLOAD_FILE_TYPE_PNG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_GIF: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_JPG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_JPEG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_MD: iconPrefix + 'file-markdown',
  UPLOAD_FILE_TYPE_PPD: iconPrefix + 'file-ppt',
  UPLOAD_FILE_TYPE_DOCX: iconPrefix + 'file-word',
  UPLOAD_FILE_TYPE_DOC: iconPrefix + 'file-word',
  UPLOAD_FILE_TYPE_ZIP: iconPrefix + 'file-zip',
  UPLOAD_FILE_TYPE_TXT: iconPrefix + 'file-txt',
  // image-preview
  IMAGE_PREVIEW_CLOSE: iconPrefix + 'close',
  IMAGE_PREVIEW_PREVIOUS: iconPrefix + 'arrow-left',
  IMAGE_PREVIEW_NEXT: iconPrefix + 'arrow-right',
  IMAGE_PREVIEW_PCT_FULL: iconPrefix + 'pct-full',
  IMAGE_PREVIEW_PCT_1_1: iconPrefix + 'pct-1-1',
  IMAGE_PREVIEW_ZOOM_OUT: iconPrefix + 'search-zoom-out',
  IMAGE_PREVIEW_ZOOM_IN: iconPrefix + 'search-zoom-in',
  IMAGE_PREVIEW_ROTATE_LEFT: iconPrefix + 'rotate-left',
  IMAGE_PREVIEW_ROTATE_RIGHT: iconPrefix + 'rotate-right',
  IMAGE_PREVIEW_PRINT: iconPrefix + 'print',
  IMAGE_PREVIEW_DOWNLOAD: iconPrefix + 'download',
  // alert
  ALERT_CLOSE: iconPrefix + 'close',
  ALERT_INFO: iconPrefix + 'info-circle-fill',
  ALERT_SUCCESS: iconPrefix + 'success-circle-fill',
  ALERT_WARNING: iconPrefix + 'warning-circle-fill',
  ALERT_ERROR: iconPrefix + 'error-circle-fill',
  // tree
  TREE_NODE_OPEN: iconPrefix + 'caret-right rotate90',
  TREE_NODE_CLOSE: iconPrefix + 'caret-right',
  TREE_NODE_LOADED: iconPrefix + 'spinner roll',
  // tree-select
  TREE_SELECT_LOADED: iconPrefix + 'spinner roll',
  TREE_SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  TREE_SELECT_CLOSE: iconPrefix + 'caret-down',
  // tabs
  TABS_TAB_BUTTON_LEFT: iconPrefix + 'arrow-left',
  TABS_TAB_BUTTON_RIGHT: iconPrefix + 'arrow-right',
  TABS_TAB_CLOSE: iconPrefix + 'close',
  // text
  TEXT_COPY: iconPrefix + 'copy',
  // carousel
  CAROUSEL_HORIZONTAL_PREVIOUS: iconPrefix + 'arrow-left',
  CAROUSEL_HORIZONTAL_NEXT: iconPrefix + 'arrow-right',
  CAROUSEL_VERTICAL_PREVIOUS: iconPrefix + 'arrow-up',
  CAROUSEL_VERTICAL_NEXT: iconPrefix + 'arrow-down'
});

/* harmony default export */ var ui = ((/* unused pure expression or super */ null && (VxeUI)));
;// CONCATENATED MODULE: ./packages/ui/src/vn.ts

function getOnName(type) {
  return 'on' + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(name) {
  switch (name) {
    case 'input':
    case 'textarea':
      return 'input';
  }
  return 'update:modelValue';
}
function getChangeEvent(name) {
  switch (name) {
    case 'input':
    case 'textarea':
    case 'VxeInput':
    case 'VxeTextarea':
    case '$input': // 已废弃
    case '$textarea':
      // 已废弃
      return 'input';
  }
  return 'change';
}
function getSlotVNs(vns) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return [vns];
}
;// CONCATENATED MODULE: ./packages/alert/src/alert.ts




/* harmony default export */ var src_alert = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeAlert',
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: ['close'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $alert: $xeAlert
        }, params));
      }
    };
    const closeEvent = evnt => {
      alertMethods.dispatchEvent('close', {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const {
        status,
        content,
        icon,
        title,
        showIcon,
        showClose
      } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-alert', {
          [`theme--${status}`]: status
        }]
      }, [iconSlot || showIcon && status || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--icon'
      }, iconSlot ? getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon()[`ALERT_${status?.toUpperCase()}`]
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--body'
      }, [titleSlot || title ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--title'
      }, titleSlot ? getSlotVNs(titleSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(title)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--content'
      }, defaultSlot ? getSlotVNs(defaultSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))]), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--close-btn',
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().ALERT_CLOSE
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/alert/index.ts



const VxeAlert = Object.assign({}, src_alert, {
  install(app) {
    app.component(src_alert.name, src_alert);
  }
});
dynamicApp.component(src_alert.name, src_alert);
core_VxeUI.component(src_alert);
const Alert = VxeAlert;
/* harmony default export */ var packages_alert = (VxeAlert);
;// CONCATENATED MODULE: ./packages/ui/src/dom.ts

const dom_browse = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
const reClsMap = {};
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, 'g');
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), '');
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function toCssUnit(val) {
  if (/^\d+$/.test(`${val}`)) {
    return `${val}px`;
  }
  return `${val || ''}`;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
/**
 * 检查触发源是否属于目标节点
 */
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return {
        flag: queryCls ? !!targetElem : true,
        container,
        targetElem: targetElem
      };
    }
    target = target.parentNode;
  }
  return {
    flag: false
  };
}
/**
 * 获取元素相对于 document 的位置
 */
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, {
    left: 0,
    top: 0
  });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const {
    scrollTop,
    scrollLeft,
    visibleHeight,
    visibleWidth
  } = getDomNode();
  return {
    boundingTop,
    top: scrollTop + boundingTop,
    boundingLeft,
    left: scrollLeft + boundingLeft,
    visibleHeight,
    visibleWidth
  };
}
const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
const scrollIntoView = 'scrollIntoView';
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function dom_triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
;// CONCATENATED MODULE: ./packages/anchor/src/util.ts

function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticLinks, item => item.id === linkConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}
;// CONCATENATED MODULE: ./packages/anchor/src/anchor-link.ts



/* harmony default export */ var anchor_link = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeAnchorLink',
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const $xeAnchor = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeAnchor', null);
    const $xeParentAnchorLink = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeAnchorLink', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const linkConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        href
      } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = event => {
      const {
        href
      } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.href, val => {
      linkConfig.href = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if ($xeAnchor && refElem.value) {
        assembleAnchorLink($xeAnchor, refElem.value, linkConfig, $xeParentAnchorLink);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const {
        href,
        content,
        title
      } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-anchor-link', {
          'is--active': isActive
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
        class: 'vxe-anchor-link--item',
        href,
        title,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content)), subSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-anchor-link--sub-items'
      }, subSlot({})) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeAnchorLink.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeAnchorLink', $xeAnchorLink);
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/anchor/src/anchor.ts






/* harmony default export */ var src_anchor = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeAnchor',
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: ['update:modelValue', 'change', 'click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMarkerElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeHref: null,
      staticLinks: []
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.staticLinks, item => {
        list.push(item.href || '');
      }, {
        children: 'children'
      });
      return list;
    });
    const computeMaps = {};
    let containerElem = null;
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $anchor: $xeAnchor
        }, params));
      }
    };
    const getContainerElem = () => {
      const {
        container
      } = props;
      if (container) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isElement(container)) {
          return container;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(container)) {
          return document.querySelector(container);
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(container)) {
          return container({
            $anchor: $xeAnchor
          });
        }
      }
      return null;
    };
    const emitEvent = value => {
      reactData.activeHref = value;
      emit('update:modelValue', value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map(href => `${href}`).join(','));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      if (containerElem) {
        containerElem.removeEventListener('scroll', handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      containerElem = getContainerElem();
      if (containerElem) {
        containerElem.addEventListener('scroll', handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          activeHref
        } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const {
                top
              } = getOffsetPos(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace('#', ''));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: 'smooth'
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent('click', {
          href
        }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = options => {
      const itemVNs = [];
      if (options) {
        options.forEach(item => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(anchor_link, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(anchor_link, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const {
        options,
        showMarker
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-anchor', {
          'is--marker': showMarker
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-anchor--list'
      }, defaultSlot ? defaultSlot({}) : renderSubItems(options)), showMarker ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refMarkerElem,
        class: 'vxe-anchor--marker'
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeHref = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        updateContainerElem();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      removeContainerElemScroll();
    });
    $xeAnchor.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeAnchor', $xeAnchor);
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/anchor/index.ts



const VxeAnchor = Object.assign({}, src_anchor, {
  install(app) {
    app.component(src_anchor.name, src_anchor);
  }
});
dynamicApp.component(src_anchor.name, src_anchor);
core_VxeUI.component(src_anchor);
const Anchor = VxeAnchor;
/* harmony default export */ var packages_anchor = (VxeAnchor);
;// CONCATENATED MODULE: ./packages/anchor-link/index.ts



const VxeAnchorLink = Object.assign({}, anchor_link, {
  install(app) {
    app.component(anchor_link.name, anchor_link);
  }
});
dynamicApp.component(anchor_link.name, anchor_link);
core_VxeUI.component(anchor_link);
const AnchorLink = VxeAnchorLink;
/* harmony default export */ var packages_anchor_link = (VxeAnchorLink);
;// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.ts


/* harmony default export */ var breadcrumb_item = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeBreadcrumbItem',
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeBreadcrumb = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeBreadcrumb', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeSeparator = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return '';
    });
    const clickEvent = evnt => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        title,
        routerLink
      } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        class: 'vxe-breadcrumb-item',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--content'
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-breadcrumb-item--content-link',
        title,
        to: routerLink
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-breadcrumb-item--content-text'
          }, defaultSlot ? defaultSlot({}) : `${title || ''}`);
        }
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--content-text'
      }, defaultSlot ? defaultSlot({}) : `${title || ''}`)]), separator ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--separator'
      }, `${separator}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.ts




/* harmony default export */ var breadcrumb = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeBreadcrumb',
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $breadcrumb: $xeBreadcrumb
        }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option) {
        breadcrumbMethods.dispatchEvent('click', {
          option
        }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const {
        options
      } = props;
      if (options && options.length) {
        return options.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(breadcrumb_item, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-breadcrumb'
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    $xeBreadcrumb.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeBreadcrumb', $xeBreadcrumb);
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/breadcrumb/index.ts



const VxeBreadcrumb = Object.assign({}, breadcrumb, {
  install(app) {
    app.component(breadcrumb.name, breadcrumb);
  }
});
dynamicApp.component(breadcrumb.name, breadcrumb);
core_VxeUI.component(breadcrumb);
const Breadcrumb = VxeBreadcrumb;
/* harmony default export */ var packages_breadcrumb = (VxeBreadcrumb);
;// CONCATENATED MODULE: ./packages/breadcrumb-item/index.ts



const VxeBreadcrumbItem = Object.assign({}, breadcrumb_item, {
  install(app) {
    app.component(breadcrumb_item.name, breadcrumb_item);
  }
});
dynamicApp.component(breadcrumb_item.name, breadcrumb_item);
core_VxeUI.component(breadcrumb_item);
const BreadcrumbItem = VxeBreadcrumbItem;
/* harmony default export */ var packages_breadcrumb_item = (VxeBreadcrumbItem);
;// CONCATENATED MODULE: ./packages/button/src/button.ts







/* harmony default export */ var src_button = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeButton',
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: {
      type: String,
      default: () => getConfig().button.size || getConfig().size
    },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的图标
     */
    icon: String,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    trigger: {
      type: String,
      default: () => getConfig().button.trigger
    },
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().button.destroyOnClose
    },
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['click', 'mouseenter', 'mouseleave', 'dropdown-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const $xeButtonGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeButtonGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ''
    });
    const internalData = {
      showTime: null
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBtnPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeButton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let buttonMethods = {};
    const computeTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().button.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeBtnDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      const permissionInfo = computePermissionInfo.value;
      return disabled || permissionInfo.disabled;
    });
    const computeIsFormBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      if (type) {
        return ['submit', 'reset', 'button'].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        mode
      } = props;
      if (mode === 'text' || type === 'text' || $xeButtonGroup && $xeButtonGroup.props.mode === 'text') {
        return 'text';
      }
      return 'button';
    });
    const computeBtnStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        status
      } = props;
      if (status) {
        return status;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.status;
      }
      return '';
    });
    const computeBtnRound = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        round
      } = props;
      if (round) {
        return round;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        circle
      } = props;
      if (circle) {
        return circle;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.circle;
      }
      return false;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const targetElem = refButton.value;
        const panelElem = refBtnPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && targetElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            top,
            left,
            boundingTop,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(targetElem);
          let panelPlacement = 'bottom';
          if (transfer) {
            let btnLeft = left + targetWidth - panelWidth;
            let btnTop = top + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              btnTop = top - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                btnTop = top - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (btnTop < marginSize) {
                panelPlacement = 'bottom';
                btnTop = top + targetHeight;
              }
            }
            // 如果溢出右边
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${btnLeft}px`,
              right: 'auto',
              top: `${btnTop}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const clickEvent = evnt => {
      if ($xeButtonGroup) {
        $xeButtonGroup.handleClick({
          name: props.name
        }, evnt);
      } else {
        buttonMethods.dispatchEvent('click', {
          $event: evnt
        }, evnt);
      }
    };
    const mousedownDropdownEvent = evnt => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = evnt => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const {
        flag,
        targetElem
      } = getEventTargetNode(evnt, dropdownElem, 'vxe-button');
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = 'N';
        }
        reactData.visiblePanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== 'Y') {
            reactData.animatVisible = false;
          }
        }, 350);
        buttonMethods.dispatchEvent('dropdown-click', {
          name: targetElem.getAttribute('name'),
          $event: evnt
        }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        reactData.animatVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            reactData.visiblePanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.visiblePanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = evnt => {
      openPanel();
      mouseenterEvent(evnt);
    };
    const mouseleaveTargetEvent = evnt => {
      closePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = evnt => {
      emit('mouseenter', createEvent(evnt, {}));
    };
    const mouseleaveEvent = evnt => {
      emit('mouseleave', createEvent(evnt, {}));
    };
    const clickTargetEvent = evnt => {
      const {
        trigger
      } = props;
      if (trigger === 'click') {
        if (reactData.visiblePanel) {
          closePanel();
        } else {
          openPanel();
        }
      }
      clickEvent(evnt);
    };
    const openPanel = () => {
      const {
        trigger
      } = props;
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        if (!reactData.inited) {
          reactData.inited = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            mouseenterDropdownEvent();
          } else {
            reactData.animatVisible = false;
          }
        }, trigger === 'click' ? 50 : 250);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = 'N';
        setTimeout(() => {
          if (panelElem.dataset.active !== 'Y') {
            reactData.visiblePanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== 'Y') {
                reactData.animatVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.animatVisible = false;
        reactData.visiblePanel = false;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const mouseleaveDropdownEvent = () => {
      closePanel();
    };
    const renderContent = () => {
      const {
        content,
        icon,
        loading
      } = props;
      const contVNs = [];
      if (loading) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--loading-icon', getIcon().BUTTON_LOADING]
        }));
      } else if (slots.icon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--custom-icon'
        }, slots.icon({})));
      } else if (icon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--icon', icon]
        }));
      }
      if (slots.default) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--content'
        }, slots.default({})));
      } else if (content) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--content'
        }, getFuncText(content)));
      }
      return contVNs;
    };
    buttonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $button: $xeButton
        }, params));
      },
      openPanel,
      closePanel,
      focus() {
        const btnElem = refButton.value;
        btnElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const panelElem = refBtnPanel.value;
      if (reactData.visiblePanel && !getEventTargetNode(evnt, panelElem).flag) {
        closePanel();
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const btnDisabled = computeBtnDisabled.value;
      const {
        visiblePanel
      } = reactData;
      if (!btnDisabled) {
        const el = refElem.value;
        const panelElem = refBtnPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          closePanel();
        }
      }
    };
    Object.assign($xeButton, buttonMethods);
    const renderVN = () => {
      const {
        className,
        popupClassName,
        trigger,
        title,
        routerLink,
        type,
        destroyOnClose,
        name,
        loading
      } = props;
      const {
        inited,
        visiblePanel
      } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnCircle = computeBtnCircle.value;
      const transfer = computeTransfer.value;
      const btnDisabled = computeBtnDisabled.value;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      if (slots.dropdowns) {
        const btnOns = {};
        const panelOns = {};
        if (trigger === 'hover') {
          // hover 触发
          btnOns.onMouseenter = mouseenterTargetEvent;
          btnOns.onMouseleave = mouseleaveTargetEvent;
          panelOns.onMouseenter = mouseenterDropdownEvent;
          panelOns.onMouseleave = mouseleaveDropdownEvent;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-button--dropdown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            'is--active': visiblePanel
          }]
        }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          ref: refButton,
          class: ['vxe-button', 'vxe-button--link', `type--${btnMode}`, className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          to: routerLink,
          onClick: clickTargetEvent,
          ...btnOns
        }, {
          default() {
            return renderContent().concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
            })]);
          }
        }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          ref: refButton,
          class: ['vxe-button', `type--${btnMode}`, className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          onClick: clickTargetEvent,
          ...btnOns
        }, renderContent().concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
        })])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: transfer ? !inited : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refBtnPanel,
          class: ['vxe-button--dropdown-panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
            $button: $xeButton
          }) : popupClassName : '', {
            [`size--${vSize}`]: vSize,
            'animat--leave': reactData.animatVisible,
            'animat--enter': visiblePanel
          }],
          placement: reactData.panelPlacement,
          style: reactData.panelStyle,
          ...panelOns
        }, inited ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-button--dropdown-wrapper',
          onMousedown: mousedownDropdownEvent,
          onClick: clickDropdownEvent
        }, destroyOnClose && !visiblePanel ? [] : slots.dropdowns({}))] : [])])]);
      }
      if (routerLink) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          ref: refButton,
          class: ['vxe-button', 'vxe-button--link', `type--${btnMode}`, className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          to: routerLink,
          onClick: clickEvent,
          onMouseenter: mouseenterEvent,
          onMouseleave: mouseleaveEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: ['vxe-button', `type--${btnMode}`, className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $button: $xeButton
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          'is--round': btnRound,
          'is--circle': btnCircle,
          'is--disabled': btnDisabled || loading,
          'is--loading': loading
        }],
        title,
        name,
        type: isFormBtn ? type : 'button',
        disabled: btnDisabled || loading,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xeButton.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (true) {
        if (props.type === 'text') {
          warnLog('vxe.error.delProp', ['type=text', 'mode=text']);
        }
      }
      globalEvents.on($xeButton, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeButton, 'mousedown', handleGlobalMousedownEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeButton, 'mousewheel');
      globalEvents.off($xeButton, 'mousedown');
    });
    return $xeButton;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/button/index.ts



const VxeButton = Object.assign({}, src_button, {
  install(app) {
    app.component(src_button.name, src_button);
  }
});
dynamicApp.component(src_button.name, src_button);
core_VxeUI.component(src_button);
const Button = VxeButton;
/* harmony default export */ var packages_button = (VxeButton);
;// CONCATENATED MODULE: ./packages/button/src/button-group.ts




/* harmony default export */ var button_group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeButtonGroup',
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().buttonGroup.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $buttonGroup: $xeButtonGroup
        }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const {
          options
        } = props;
        const {
          name
        } = params;
        const option = options ? options.find(item => item.name === name) : null;
        buttonGroupMethods.dispatchEvent('click', {
          ...params,
          option
        }, evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const {
        className,
        options
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-button-group', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $buttonGroup: $xeButtonGroup
        }) : className : '']
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: index,
          ...item
        });
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeButtonGroup', $xeButtonGroup);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/button-group/index.ts



const VxeButtonGroup = Object.assign({}, button_group, {
  install(app) {
    app.component(button_group.name, button_group);
  }
});
dynamicApp.component(button_group.name, button_group);
core_VxeUI.component(button_group);
const ButtonGroup = VxeButtonGroup;
/* harmony default export */ var packages_button_group = (VxeButtonGroup);
;// CONCATENATED MODULE: ./packages/calendar/src/calendar.ts


/* harmony default export */ var calendar = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCalendar',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-calendar']
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCalendar.renderVN = renderVN;
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/calendar/index.ts



const VxeCalendar = Object.assign({}, calendar, {
  install(app) {
    app.component(calendar.name, calendar);
  }
});
dynamicApp.component(calendar.name, calendar);
core_VxeUI.component(calendar);
const Calendar = VxeCalendar;
/* harmony default export */ var packages_calendar = (VxeCalendar);
;// CONCATENATED MODULE: ./packages/loading/src/loading.ts




/* harmony default export */ var src_loading = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLoading',
  props: {
    modelValue: Boolean,
    icon: {
      type: String,
      default: () => getConfig().loading.icon
    },
    text: {
      type: String,
      default: () => getConfig().loading.text
    },
    status: String
  },
  setup(props, {
    slots
  }) {
    const refInitialized = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const computeLoadingIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.icon || getIcon().LOADING;
    });
    const computeLoadingText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        text
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(text) ? text : i18n_getI18n('vxe.loading.text');
    });
    const handleInit = () => {
      if (!refInitialized.value) {
        refInitialized.value = !!props.modelValue;
      }
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      handleInit();
    });
    handleInit();
    return () => {
      const {
        modelValue,
        status
      } = props;
      const defaultSlot = slots.default;
      const textSlot = slots.text;
      const iconSlot = slots.icon;
      const initialized = refInitialized.value;
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      if (!initialized && !modelValue) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-loading', {
          [`theme--${status}`]: status,
          'is--visible': modelValue
        }]
      }, defaultSlot ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--wrapper'
      }, getSlotVNs(defaultSlot({})))] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--chunk'
      }, [iconSlot || loadingIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--icon'
      }, iconSlot ? getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: loadingIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--spinner'
      }), textSlot || loadingText ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--text'
      }, textSlot ? getSlotVNs(textSlot({})) : `${loadingText}`) : null])]);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/card/src/card.ts






/* harmony default export */ var card = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCard',
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        width
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        title,
        border,
        shadow,
        padding,
        loading,
        showTitleOverflow
      } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const cardStyle = computeCardStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-card', {
          'is--border': border,
          'is--shadow': shadow,
          'is--padding': padding
        }],
        style: cardStyle
      }, [title || titleSlot || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--header'
      }, headerSlot ? getSlotVNs(headerSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-card--header-title', {
          'is--ellipsis': showTitleOverflow
        }]
      }, titleSlot ? getSlotVNs(titleSlot({})) : `${title || ''}`), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--header-extra'
      }, getSlotVNs(extraSlot({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-left'
      }, getSlotVNs(leftSlot({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-content'
      }, defaultSlot ? getSlotVNs(defaultSlot({})) : []), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-right'
      }, getSlotVNs(rightSlot({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--footer'
      }, getSlotVNs(footerSlot({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-card--loading',
        modelValue: loading
      })]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/card/index.ts



const VxeCard = Object.assign({}, card, {
  install(app) {
    app.component(card.name, card);
  }
});
dynamicApp.component(card.name, card);
core_VxeUI.component(card);
const Card = VxeCard;
/* harmony default export */ var packages_card = (VxeCard);
;// CONCATENATED MODULE: ./packages/carousel/src/carousel.ts






/* harmony default export */ var carousel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCarousel',
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: {
      type: Boolean,
      default: () => getConfig().carousel.loading
    },
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeName: '',
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const refMaps = {
      refElem
    };
    const computeListStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        vertical,
        options
      } = props;
      const {
        activeName,
        itemWidth,
        itemHeight,
        staticItems
      } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit('update:modelValue', value);
      emit('change', {
        value
      }, evnt);
      updateStyle();
    };
    const initDefaultActive = list => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach(item => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit('update:modelValue', activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $carousel: $xeCarousel
      }, params));
    };
    const handlePrevNext = isNext => {
      const {
        options,
        loop
      } = props;
      const {
        activeName,
        staticItems
      } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index = Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName));
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit('update:modelValue', value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent,
      prev() {
        handlePrevNext(false);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      next() {
        handlePrevNext(true);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const prevEvent = evnt => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit('change', {
          value
        }, evnt);
      }
    };
    const nextEvent = evnt => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit('change', {
          value
        }, evnt);
      }
    };
    const carouselPrivateMethods = {};
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = list => {
      const {
        height
      } = props;
      const {
        activeName
      } = reactData;
      const listStyle = computeListStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--list',
        style: listStyle
      }, list.map(item => {
        const {
          name,
          url,
          slots
        } = item;
        const defaultSlot = slots ? slots.default : null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-carousel--item-inner', {
            'is--active': activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? getSlotVNs(defaultSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-carousel--item-img',
          src: url
        })]);
      }));
    };
    const renderIndicators = list => {
      const {
        activeName
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--indicators'
      }, list.map(item => {
        const {
          name
        } = item;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-carousel--indicators-item', {
            'is--active': activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const {
        loading,
        height,
        width,
        vertical,
        options
      } = props;
      const {
        staticItems
      } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-carousel', `is--${vertical ? 'vertical' : 'horizontal'}`],
        style: width ? {
          width: toCssUnit(width)
        } : null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--slots'
      }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refWrapperElem,
        class: 'vxe-carousel--item-wrapper',
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, renderItemWrapper(list)), renderIndicators(list), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--previous-btn',
        onClick: prevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--next-btn',
        onClick: nextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
      })])]),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-carousel--loading',
        modelValue: loading
      })]);
    };
    $xeCarousel.renderVN = renderVN;
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCarousel', $xeCarousel);
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/carousel/index.ts



const VxeCarousel = Object.assign({}, carousel, {
  install(app) {
    app.component(carousel.name, carousel);
  }
});
dynamicApp.component(carousel.name, carousel);
core_VxeUI.component(carousel);
const Carousel = VxeCarousel;
/* harmony default export */ var packages_carousel = (VxeCarousel);
;// CONCATENATED MODULE: ./packages/carousel/src/util.ts

function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === itemConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/carousel/src/carousel-item.ts



/* harmony default export */ var carousel_item = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCarouselItem',
  props: {
    name: String,
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const $xeCarousel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCarousel', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const itemConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      itemConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.url, val => {
      itemConfig.url = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if ($xeCarousel && refElem.value) {
        assembleCarouselItem($xeCarousel, refElem.value, itemConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/carousel-item/index.ts



const VxeCarouselItem = Object.assign({}, carousel_item, {
  install(app) {
    app.component(carousel_item.name, carousel_item);
  }
});
dynamicApp.component(carousel_item.name, carousel_item);
core_VxeUI.component(carousel_item);
const CarouselItem = VxeCarouselItem;
/* harmony default export */ var packages_carousel_item = (VxeCarouselItem);
;// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.ts




/* harmony default export */ var src_checkbox = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCheckbox',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkbox.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeCheckboxGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCheckboxGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeCheckbox = {
      xID,
      props,
      context
    };
    let checkboxMethods = {};
    const {
      computeSize
    } = useSize(props);
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeCheckboxGroup) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const {
            computeIsDisabled,
            computeIsMaximize
          } = $xeCheckboxGroup.getComputeMaps();
          const isMaximize = computeIsMaximize.value;
          const isChecked = computeIsChecked.value;
          return computeIsDisabled.value || isMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = evnt => {
      const {
        checkedValue,
        uncheckedValue
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = {
          checked,
          value,
          label: props.label
        };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit('update:modelValue', value);
          checkboxMethods.dispatchEvent('change', params, evnt);
          // 自动更新校验状态
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    checkboxMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $checkbox: $xeCheckbox
        }, params));
      }
    };
    Object.assign($xeCheckbox, checkboxMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = props.indeterminate;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        class: ['vxe-checkbox', {
          [`size--${vSize}`]: vSize,
          'is--indeterminate': indeterminate,
          'is--disabled': isDisabled,
          'is--checked': isChecked
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-checkbox--input',
        type: 'checkbox',
        disabled: isDisabled,
        checked: isChecked,
        onChange: changeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeCheckbox.renderVN = renderVN;
    return $xeCheckbox;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox/index.ts



const VxeCheckbox = Object.assign(src_checkbox, {
  install(app) {
    app.component(src_checkbox.name, src_checkbox);
  }
});
const Checkbox = VxeCheckbox;
dynamicApp.component(src_checkbox.name, src_checkbox);
core_VxeUI.component(src_checkbox);
/* harmony default export */ var packages_checkbox = (VxeCheckbox);
;// CONCATENATED MODULE: ./packages/checkbox/src/group.ts





/* harmony default export */ var group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCheckboxGroup',
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxGroup.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        max
      } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const checkboxGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $checkboxGroup: $xeCheckboxGroup
        }, params));
      }
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const {
          checked,
          label
        } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit('update:modelValue', checklist);
        $xeCheckboxGroup.dispatchEvent('change', Object.assign({
          checklist
        }, params), evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const {
        options
      } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-checkbox-group'
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    $xeCheckboxGroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCheckboxGroup', $xeCheckboxGroup);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox-group/index.ts



const VxeCheckboxGroup = Object.assign(group, {
  install(app) {
    app.component(group.name, group);
  }
});
dynamicApp.component(group.name, group);
core_VxeUI.component(group);
const CheckboxGroup = VxeCheckboxGroup;
/* harmony default export */ var checkbox_group = (VxeCheckboxGroup);
;// CONCATENATED MODULE: ./packages/row/src/col.ts



/* harmony default export */ var col = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCol',
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const $xeRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRow', null);
    const computeRowGutter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width
      } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = '';
        }
        if (lrGutter) {
          const padding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        span,
        fill,
        align,
        ellipsis
      } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-col', span ? `span${span}` : '', align ? `align--${align}` : '', {
          'is--span': span,
          'is--fill': fill,
          'is--ellipsis': ellipsis
        }],
        style: colStyle
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/col/index.ts



const VxeCol = Object.assign({}, col, {
  install(app) {
    app.component(col.name, col);
  }
});
dynamicApp.component(col.name, col);
core_VxeUI.component(col);
const Col = VxeCol;
/* harmony default export */ var packages_col = (VxeCol);
;// CONCATENATED MODULE: ./packages/collapse/src/collapse.ts


/* harmony default export */ var collapse = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCollapse',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-collapse']
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/collapse/index.ts



const VxeCollapse = Object.assign({}, collapse, {
  install(app) {
    app.component(collapse.name, collapse);
  }
});
dynamicApp.component(collapse.name, collapse);
core_VxeUI.component(collapse);
const Collapse = VxeCollapse;
/* harmony default export */ var packages_collapse = (VxeCollapse);
;// CONCATENATED MODULE: ./packages/collapse-pane/src/collapse-pane.ts


/* harmony default export */ var collapse_pane = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCollapsePane',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-collapse-pane']
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/collapse-pane/index.ts



const VxeCollapsePane = Object.assign({}, collapse_pane, {
  install(app) {
    app.component(collapse_pane.name, collapse_pane);
  }
});
dynamicApp.component(collapse_pane.name, collapse_pane);
core_VxeUI.component(collapse_pane);
const CollapsePane = VxeCollapsePane;
/* harmony default export */ var packages_collapse_pane = (VxeCollapsePane);
;// CONCATENATED MODULE: ./packages/date-picker/src/date-picker.ts







const yearSize = 12;
const monthSize = 20;
const quarterSize = 8;
function toStringTimeDate(str) {
  if (str) {
    const rest = new Date();
    let h = 0;
    let m = 0;
    let s = 0;
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDate(str)) {
      h = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[1]);
        m = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[3]);
        s = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[5]);
      }
    }
    rest.setHours(h);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return new Date('');
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
/* harmony default export */ var date_picker = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeDatePicker',
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'date'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxlength: [String, Number],
    autocomplete: {
      type: String,
      default: 'off'
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePicker.size || getConfig().size
    },
    multiple: Boolean,
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: null,
      panelPlacement: '',
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTimeBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let datePickerMethods = {};
    const parseDate = (value, format) => {
      const {
        type
      } = props;
      if (type === 'time') {
        return toStringTimeDate(value);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const computeTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.startDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.endDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].includes(props.type);
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return type === 'time' ? 'HH:mm:ss' : type === 'datetime' ? 'yyyy-MM-dd HH:mm:ss' : 'yyyy-MM-dd';
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        datetimePanelValue
      } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(datetimePanelValue, hasTimeSecond ? 'HH:mm:ss' : 'HH:mm');
      }
      return '';
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isDatePickerType) {
        return labelFormat || dateValueFormat || i18n_getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter') {
          return i18n_getI18n('vxe.input.date.quarterLabel', [year]);
        } else if (datePanelType === 'month') {
          return i18n_getI18n('vxe.input.date.monthLabel', [year]);
        } else if (datePanelType === 'year') {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        }
        return i18n_getI18n('vxe.input.date.dayLabel', [year, month ? i18n_getI18n(`vxe.input.date.m${month}`) : '-']);
      }
      return '';
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay,
        startWeek
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(startDay) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: i18n_getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: i18n_getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        editable,
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === 'week' || type === 'quarter';
    });
    const computeDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return 'text';
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return i18n_getI18n('vxe.base.pleaseSelect');
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      datePickerMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      datePickerMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        datePickerMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitDatePickerEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          datePickerMethods.dispatchEvent('input', {
            value
          }, evnt);
        }
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitDatePickerEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        datePickerMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    let hidePanelTimeout;
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      emitModel('', evnt);
      datePickerMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        datePickerMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const dateParseValue = value => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = '';
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
        dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, dateLabelFormat, {
          firstDay: firstDayOfWeek
        });
        // 由于年份和第几周是冲突的行为，所以需要特殊处理，判断是否跨年
        if (dateLabelFormat && type === 'week') {
          const firstWeekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf('yyyy');
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    /**
     * 值变化时处理
     */
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const {
        inputValue
      } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        changeValue();
      }
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = date => {
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = date => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      if (multiple) {
        // 如果为多选
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          // 如果是datetime特殊类型
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(dateListValue, val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(date, val, 'yyyyMMdd'));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach(item => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          emitModel(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
            type: 'update'
          });
        } else {
          // 如果是日期类型
          if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
            emitModel(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
              type: 'update'
            });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(','), {
              type: 'update'
            });
          }
        }
      } else {
        // 如果为单选
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          emitModel(inpVal, {
            type: 'update'
          });
        }
      }
    };
    const afterCheckValue = () => {
      const {
        type
      } = props;
      const {
        inputValue,
        datetimePanelValue
      } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (inputValue) {
          let inpDateVal = parseDate(inputValue, dateLabelFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(inpDateVal)) {
            if (type === 'time') {
              inpDateVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat);
              if (inputValue !== inpDateVal) {
                emitModel(inpDateVal, {
                  type: 'check'
                });
              }
              reactData.inputValue = inpDateVal;
            } else {
              let isChange = false;
              const firstDayOfWeek = computeFirstDayOfWeek.value;
              if (type === 'datetime') {
                const dateValue = computeDateValue.value;
                if (inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dateValue, dateLabelFormat) || inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat)) {
                  isChange = true;
                  datetimePanelValue.setHours(inpDateVal.getHours());
                  datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                  datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                }
              } else {
                isChange = true;
              }
              reactData.inputValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat, {
                firstDay: firstDayOfWeek
              });
              if (isChange) {
                dateChange(inpDateVal);
              }
            }
          } else {
            dateRevert();
          }
        } else {
          emitModel('', {
            type: 'check'
          });
        }
      }
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      datePickerMethods.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    const keydownEvent = evnt => {
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    const wheelEvent = evnt => {
      triggerEvent(evnt);
    };
    // 日期
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, offsetMonth, 'first');
    };
    const dateNowHandle = () => {
      const currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        datePickerMethods.dispatchEvent('date-prev', {
          type
        }, evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      datePickerMethods.dispatchEvent('date-today', {
        type: props.type
      }, evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        datePickerMethods.dispatchEvent('date-next', {
          type
        }, evnt);
      }
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      return disabledMethod && disabledMethod({
        type: datePanelType,
        viewType: datePanelType,
        date: item.date,
        $datePicker: $xeDatePicker
      });
    };
    const dateSelectItem = date => {
      const {
        type,
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === 'year') {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === 'datetime') {
            // 日期带时间
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = item => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!isDateDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!isDateDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!isDateDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!isDateDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!isDateDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = liElem => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = evnt => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const {
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          // 如果为多选
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            // 如果是datetime特殊类型
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach(item => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            emitModel(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
              type: 'update'
            });
          } else {
            // 如果是日期类型
            emitModel(dateMultipleValue.join(','), {
              type: 'update'
            });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = evnt => {
      const {
        isActivated,
        datePanelValue,
        datePanelType
      } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === 'year') {
          let offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === 'quarter') {
          let offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === 'month') {
          let offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = evnt => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const {
        type
      } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const timeBodyElem = refInputTimeBody.value;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(timeBodyElem.querySelectorAll('li.is--selected'), updateTimePos);
        });
      }
    };
    // 日期
    // 弹出面板
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const transfer = computeTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(targetElem);
          let panelPlacement = 'bottom';
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.top = '';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const datePickerOpenEvent = evnt => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // 弹出面板
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          // 如果是日期类型
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated,
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $datePicker: $xeDatePicker
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        const labels = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-date-picker--date-label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-date-picker--date-label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : label)];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // 默认最多支持3个节日重叠
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labels.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-date-picker--date-festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-date-picker--date-festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-date-picker--date-festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-date-picker--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-date-picker--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', weekHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--hover': isHover
            },
            // event
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-date-picker--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, i18n_getI18n(`vxe.input.date.months.m${item.month}`)));
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-date-picker--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, i18n_getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-date-picker--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.year));
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--date-picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--date-picker-type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-picker--date-picker-label'
      }, selectDatePanelLabel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-picker--date-picker-btn',
        onClick: dateToggleTypeEvent
      }, selectDatePanelLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--date-picker-btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-prev-btn', {
          'is--disabled': isDisabledPrevDateBtn
        }],
        onClick: datePrevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-left'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-current-btn',
        onClick: dateTodayMonthEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-dot'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-next-btn', {
          'is--disabled': isDisabledNextDateBtn
        }],
        onClick: dateNextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-right'
      })]), multiple && computeSupportMultiples.value ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-confirm-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-date-picker--date-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, i18n_getI18n('vxe.button.confirm'))]) : null])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--date-picker-body'
      }, renderDateTable())];
    };
    const renderTimePanel = () => {
      const {
        datetimePanelValue
      } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--time-picker-header'
      }, [hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--time-picker-title'
      }, dateTimeLabel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--time-picker-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-date-picker--time-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, i18n_getI18n('vxe.button.confirm'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputTimeBody,
        class: 'vxe-date-picker--time-picker-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-picker--time-picker-hour-list'
      }, hourList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getHours() === item.value
          },
          onClick: evnt => dateHourEvent(evnt, item)
        }, item.label);
      })), hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-picker--time-picker-minute-list'
      }, minuteList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getMinutes() === item.value
          },
          onClick: evnt => dateMinuteEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), hasTimeMinute && hasTimeSecond ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-picker--time-picker-second-list'
      }, secondList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getSeconds() === item.value
          },
          onClick: evnt => dateSecondEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])];
    };
    const renderPanel = () => {
      const {
        type
      } = props;
      const {
        inited,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle
      } = reactData;
      const vSize = computeSize.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const transfer = computeTransfer.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === 'datetime') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-date-picker--panel-layout-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-picker--panel-left-wrapper'
          }, renderDatePanel()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-picker--panel-right-wrapper'
          }, renderTimePanel())]));
        } else if (type === 'time') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-date-picker--panel-wrapper'
          }, renderTimePanel()));
        } else {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type || 'default',
            ref: refPanelWrapper,
            class: 'vxe-date-picker--panel-wrapper'
          }, renderDatePanel()));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: transfer ? !inited : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refInputPanel,
          class: ['vxe-table--ignore-clear vxe-date-picker--panel', `type--${type}`, {
            [`size--${vSize}`]: vSize,
            'is--transfer': transfer,
            'ani--leave': isAniVisible,
            'ani--enter': visiblePanel
          }],
          placement: panelPlacement,
          style: panelStyle
        }, renders)]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--prefix-icon'
      }, prefixSlot ? getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-picker--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), renderExtraSuffixIcon(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    const renderExtraSuffixIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--control-icon',
        onClick: datePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-date-picker--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    datePickerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $input: $xeDatePicker
        }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeDatePicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDatePicker, 'mousewheel');
      globalEvents.off($xeDatePicker, 'mousedown');
      globalEvents.off($xeDatePicker, 'keydown');
      globalEvents.off($xeDatePicker, 'blur');
    });
    initValue();
    const renderVN = () => {
      const {
        className,
        type,
        align,
        name,
        autocomplete
      } = props;
      const {
        inputValue,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-date-picker--readonly', `type--${type}`, className]
        }, inputValue);
      }
      const inputReadonly = computeInputReadonly.value;
      const inputType = computeDatePickerType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-date-picker', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-date-picker--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onDatePicker: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      // 下拉面板
      renderPanel()]);
    };
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/date-picker/index.ts



const VxeDatePicker = Object.assign({}, date_picker, {
  install(app) {
    app.component(date_picker.name, date_picker);
    app.component('VxeDateInput', date_picker);
  }
});
dynamicApp.component(date_picker.name, date_picker);
core_VxeUI.component(date_picker);
const DatePicker = VxeDatePicker;
/* harmony default export */ var packages_date_picker = (VxeDatePicker);
;// CONCATENATED MODULE: ./packages/loading/index.ts



const VxeLoading = Object.assign({}, src_loading, {
  install(app) {
    app.component(src_loading.name, src_loading);
  }
});
const LoadingController = {
  open(options) {
    const opts = Object.assign({}, options);
    dynamicStore.globalLoading = {
      modelValue: true,
      text: opts.text,
      icon: opts.icon
    };
    checkDynamic();
  },
  close() {
    dynamicStore.globalLoading = null;
  }
};
dynamicApp.component(src_loading.name, src_loading);
core_VxeUI.component(src_loading);
core_VxeUI.loading = LoadingController;
const Loading = VxeLoading;
/* harmony default export */ var packages_loading = (VxeLoading);
;// CONCATENATED MODULE: ./packages/drawer/src/drawer.ts








const allActiveDrawers = [];
/* harmony default export */ var drawer = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeDrawer',
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().drawer.escClosable
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => getConfig().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => getConfig().drawer.padding
    },
    size: {
      type: String,
      default: () => getConfig().drawer.size || getConfig().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => getConfig().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDrawerBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      firstOpen: true
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ''}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ''}`;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        drawerZIndex
      } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {});
    };
    const closeDrawer = type => {
      const {
        beforeHideMethod
      } = props;
      const {
        visible
      } = reactData;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            reactData.contentVisible = false;
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveDrawers, item => item === $xeDrawer);
            drawerMethods.dispatchEvent('before-hide', params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit('update:modelValue', false);
              drawerMethods.dispatchEvent('hide', params, null);
            }, 200);
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      drawerMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const confirmEvent = evnt => {
      const type = 'confirm';
      drawerMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const cancelEvent = evnt => {
      const type = 'cancel';
      drawerMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const openDrawer = () => {
      const {
        showFooter
      } = props;
      const {
        initialized,
        visible
      } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        recalculate();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emit('update:modelValue', true);
            drawerMethods.dispatchEvent('show', params, null);
          });
        }, 10);
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const {
            firstOpen
          } = reactData;
          if (firstOpen) {
            updatePosition().then(() => {
              setTimeout(() => updatePosition(), 20);
            });
          }
          if (firstOpen) {
            reactData.firstOpen = false;
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const drawerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $drawer: $xeDrawer
        }, params));
      },
      open: openDrawer,
      close() {
        return closeDrawer('close');
      },
      getBox
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeDrawer(type);
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveDrawers, item => item.reactData.drawerZIndex);
        // 多个时，只关掉最上层的窗口
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              closeDrawer('exit');
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const {
        drawerZIndex
      } = reactData;
      if (allActiveDrawers.some(comp => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        title
      } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-title'
      }, titleSlot ? getSlotVNs(titleSlot({
        $drawer: $xeDrawer
      })) : title ? getFuncText(title) : i18n_getI18n('vxe.alert.title')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-right'
      }, [cornerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--corner-wrapper'
      }, getSlotVNs(cornerSlot({
        $drawer: $xeDrawer
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-drawer--close-btn', 'trigger--btn'],
        title: i18n_getI18n('vxe.drawer.close'),
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().DRAWER_CLOSE
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])];
    };
    const renderHeader = () => {
      const {
        slots: propSlots = {},
        showTitleOverflow
      } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-drawer--header', {
            'is--ellipsis': showTitleOverflow
          }]
        }, headerSlot ? getSlotVNs(headerSlot({
          $drawer: $xeDrawer
        })) : renderTitles());
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderBody = () => {
      const {
        slots: propSlots = {},
        content
      } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-left'
      }, getSlotVNs(leftSlot({
        $drawer: $xeDrawer
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-default'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--content'
      }, defaultSlot ? getSlotVNs(defaultSlot({
        $drawer: $xeDrawer
      })) : getFuncText(content))]), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-right'
      }, getSlotVNs(rightSlot({
        $drawer: $xeDrawer
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
        class: 'vxe-drawer--loading',
        modelValue: props.loading
      })]);
    };
    const renderDefaultFooter = () => {
      const {
        slots: propSlots = {},
        showCancelButton,
        showConfirmButton
      } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || i18n_getI18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          status: 'primary',
          content: props.confirmButtonText || i18n_getI18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-left'
      }, lfSlot ? getSlotVNs(lfSlot({
        $drawer: $xeDrawer
      })) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-right'
      }, rfSlot ? getSlotVNs(rfSlot({
        $drawer: $xeDrawer
      })) : btnVNs)]);
    };
    const renderFooter = () => {
      const {
        slots: propSlots = {}
      } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-drawer--footer'
        }, footerSlot ? getSlotVNs(footerSlot({
          $drawer: $xeDrawer
        })) : [renderDefaultFooter()]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderVN = () => {
      const {
        slots: propSlots = {},
        className,
        position,
        loading,
        lockScroll,
        padding,
        lockView,
        mask,
        destroyOnClose
      } = props;
      const {
        initialized,
        contentVisible,
        visible
      } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: props.transfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-drawer--wrapper', `pos--${position}`, className || '', {
          [`size--${vSize}`]: vSize,
          'is--padding': padding,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--mask': mask,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.drawerZIndex
        },
        onClick: selfClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDrawerBox,
        class: 'vxe-drawer--box',
        onMousedown: boxMousedownEvent
      }, [asideSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--aside'
      }, getSlotVNs(asideSlot({
        $drawer: $xeDrawer
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--container'
      }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [renderHeader(), renderBody(), renderFooter()])])])]);
    };
    $xeDrawer.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openDrawer();
      } else {
        closeDrawer('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.modelValue) {
          openDrawer();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDrawer, 'keydown');
    });
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/drawer/index.ts





function openDrawer(options) {
  // 使用动态组件渲染动态弹框
  checkDynamic();
  return new Promise(resolve => {
    if (options && options.id && allActiveDrawers.some(comp => comp.props.id === options.id)) {
      resolve('exist');
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter(item => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveDrawers, $drawer => $drawer.props.id === id);
}
/**
 * 全局关闭动态的活动窗口（只能用于关闭动态的创建的活动窗口）
 * 如果传 id 则关闭指定的窗口
 * 如果不传则关闭所有窗口
 */
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach($drawer => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
const DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
const VxeDrawer = Object.assign(drawer, {
  install: function (app) {
    app.component(drawer.name, drawer);
  }
});
dynamicApp.component(drawer.name, drawer);
core_VxeUI.component(drawer);
core_VxeUI.drawer = DrawerController;
const Drawer = VxeDrawer;
/* harmony default export */ var packages_drawer = (VxeDrawer);
;// CONCATENATED MODULE: ./packages/form/src/itemInfo.ts

class ItemInfo {
  constructor($xeForm, item) {
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('item_'),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 渲染属性
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/form/src/util.ts





function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const {
    reactData
  } = $xeForm;
  const {
    collapseAll
  } = reactData;
  const {
    folding,
    visible
  } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  let {
    visibleMethod,
    itemRender,
    visible,
    field
  } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const {
    data
  } = $xeForm.props;
  return visibleMethod({
    data,
    field,
    property: field,
    item: formItem,
    $form: $xeForm,
    $grid: $xeForm.xegrid
  });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el, formItem, formGather) {
  const {
    reactData
  } = $xeForm;
  const {
    staticItems
  } = reactData;
  const parentElem = el.parentNode;
  const parentItem = formGather ? formGather.formItem : null;
  const parentItems = parentItem ? parentItem.children : staticItems;
  if (parentElem) {
    parentItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, formItem);
    reactData.staticItems = staticItems.slice(0);
  }
}
function destroyItem($xeForm, formItem) {
  const {
    reactData
  } = $xeForm;
  const {
    staticItems
  } = reactData;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/tooltip/src/tooltip.ts






/* harmony default export */ var tooltip = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTooltip',
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => getConfig().tooltip.size || getConfig().size
    },
    trigger: {
      type: String,
      default: () => getConfig().tooltip.trigger || 'hover'
    },
    theme: {
      type: String,
      default: () => getConfig().tooltip.theme || 'dark'
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: {
      type: Boolean,
      default: true
    },
    enterable: Boolean,
    enterDelay: {
      type: Number,
      default: () => getConfig().tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => getConfig().tooltip.leaveDelay
    }
  },
  emits: ['update:modelValue'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: '',
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: '',
        arrowStyle: {}
      }
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeTooltip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const {
        tipTarget,
        tipStore
      } = reactData;
      if (tipTarget) {
        const {
          scrollTop,
          scrollLeft,
          visibleWidth
        } = getDomNode();
        const {
          top,
          left
        } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = 'bottom';
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = value => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit('update:modelValue', value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        tooltipMethods.open();
      }
    };
    const targetMouseenterEvent = () => {
      tooltipMethods.open();
    };
    const targetMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const {
        tipStore
      } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = 'top';
      tipStore.style = {
        width: 'auto',
        left: 0,
        top: 0,
        zIndex: props.zIndex || reactData.tipZindex
      };
      tipStore.arrowStyle = {
        left: '50%'
      };
      return tooltipMethods.updatePlacement();
    };
    const showDelayTip = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(() => {
      if (reactData.tipActive) {
        showTip();
      }
    }, props.enterDelay, {
      leading: false,
      trailing: true
    });
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $tooltip: $xeTooltip
        }, params));
      },
      open(target, content) {
        return tooltipMethods.toVisible(target || reactData.target, content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: '',
          arrowStyle: null
        });
        updateValue(false);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      toVisible(target, content) {
        if (target) {
          const {
            trigger,
            enterDelay
          } = props;
          reactData.tipActive = true;
          reactData.tipTarget = target;
          if (content) {
            reactData.tipContent = content;
          }
          if (enterDelay && trigger === 'hover') {
            showDelayTip();
          } else {
            return showTip();
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      updatePlacement() {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          const {
            tipTarget
          } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(updateTipStyle);
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(actived) {
        reactData.tipActive = !!actived;
      }
    };
    Object.assign($xeTooltip, tooltipMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, () => {
      reactData.tipContent = props.content;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      if (!reactData.isUpdate) {
        if (props.modelValue) {
          tooltipMethods.open();
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          trigger,
          content,
          modelValue
        } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const {
              target
            } = reactData;
            if (target) {
              if (trigger === 'hover') {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === 'click') {
                target.onclick = clickEvent;
              }
            }
            if (modelValue) {
              tooltipMethods.open();
            }
          }
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const {
        trigger
      } = props;
      const {
        target
      } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        if (trigger === 'hover') {
          target.onmouseenter = null;
          target.onmouseleave = null;
        } else if (trigger === 'click') {
          target.onclick = null;
        }
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    const renderContent = () => {
      const {
        useHTML
      } = props;
      const {
        tipContent
      } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 1,
          class: 'vxe-table--tooltip-content'
        }, getSlotVNs(contentSlot({})));
      }
      if (useHTML) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 2,
          class: 'vxe-table--tooltip-content',
          innerHTML: tipContent
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 3,
        class: 'vxe-table--tooltip-content'
      }, `${tipContent}`);
    };
    const renderVN = () => {
      const {
        popupClassName,
        theme,
        isArrow,
        enterable
      } = props;
      const {
        tipActive,
        visible,
        tipStore
      } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--tooltip-wrapper', `theme--${theme}`, popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $tooltip: $xeTooltip
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          [`placement--${tipStore.placement}`]: tipStore.placement,
          'is--enterable': enterable,
          'is--visible': visible,
          'is--arrow': isArrow,
          'is--active': tipActive
        }],
        style: tipStore.style,
        ...ons
      }, [renderContent(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--tooltip-arrow',
        style: tipStore.arrowStyle
      }), ...(defaultSlot ? getSlotVNs(defaultSlot({})) : [])]);
    };
    $xeTooltip.renderVN = renderVN;
    return $xeTooltip;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/icon/src/icon.ts


/* harmony default export */ var icon = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeIcon',
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: {
      type: String,
      default: () => getConfig().icon.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, {
    emit
  }) {
    const {
      computeSize
    } = useSize(props);
    const clickEvent = evnt => {
      emit('click', createEvent(evnt, {}));
    };
    return () => {
      const {
        name,
        roll,
        status,
        className
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-icon', `vxe-icon-${name}`, `${className || ''}`, {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          roll: roll
        }],
        onClick: clickEvent
      });
    };
  }
}));
;// CONCATENATED MODULE: ./packages/form/src/render.ts







function renderPrefixIcon(titlePrefix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-prefix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(icon, {
    class: titlePrefix.icon || getIcon().FORM_PREFIX,
    status: titlePrefix.iconStatus
  })]);
}
function renderSuffixIcon(titleSuffix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-suffix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(icon, {
    class: titleSuffix.icon || getIcon().FORM_SUFFIX,
    status: titleSuffix.iconStatus
  })]);
}
function renderTitle($xeForm, item) {
  const {
    data,
    readonly,
    disabled
  } = $xeForm.props;
  const {
    computeTooltipOpts
  } = $xeForm.getComputeMaps();
  const {
    slots,
    field,
    itemRender,
    titlePrefix,
    titleSuffix
  } = item;
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const params = {
    data,
    readonly,
    disabled,
    field,
    property: field,
    item,
    $form: $xeForm,
    $grid: $xeForm.xegrid
  };
  const titleSlot = slots ? slots.title : null;
  const extraSlot = slots ? slots.extra : null;
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
      ...tooltipOpts,
      ...titlePrefix,
      content: getFuncText(titlePrefix.content || titlePrefix.message)
    }, {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-label'
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? getSlotVNs(rftTitle(itemRender, params)) : getFuncText(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
      ...tooltipOpts,
      ...titleSuffix,
      content: getFuncText(titleSuffix.content || titleSuffix.message)
    }, {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-content'
  }, titVNs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-postfix'
  }, fixVNs), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-extra'
  }, $xeForm.callSlot(extraSlot, params)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
}
;// CONCATENATED MODULE: ./packages/form/src/form-config-item.ts








const VxeFormConfigItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormConfigItem',
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const xeformiteminfo = {
      itemConfig: props.itemConfig
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', xeformiteminfo);
    const renderVN = () => {
      const {
        reactData
      } = $xeForm;
      const {
        data,
        rules,
        readonly,
        disabled,
        span: allSpan,
        align: allAlign,
        titleBold: allTitleBold,
        titleAlign: allTitleAlign,
        titleWidth: allTitleWidth,
        titleColon: allTitleColon,
        titleAsterisk: allTitleAsterisk,
        titleOverflow: allTitleOverflow,
        vertical: allVertical,
        padding: allPadding
      } = $xeForm.props;
      const {
        computeValidOpts
      } = $xeForm.getComputeMaps();
      const item = props.itemConfig;
      const {
        collapseAll
      } = reactData;
      const validOpts = computeValidOpts.value;
      const {
        slots,
        title,
        visible,
        folding,
        field,
        collapseNode,
        itemRender,
        showError,
        errRule,
        className,
        titleOverflow,
        vertical,
        padding,
        children,
        showTitle,
        contentClassName,
        contentStyle,
        titleClassName,
        titleStyle
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : '';
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : '';
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : '';
      const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const titleSlot = slots ? slots.title : null;
      const span = item.span || allSpan;
      const align = item.align || allAlign;
      const itemPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(padding) ? allPadding : padding;
      const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
      const titleBold = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleBold) ? allTitleBold : item.titleBold;
      const titleAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = itemVertical ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const ovEllipsis = itemOverflow === 'ellipsis';
      const ovTitle = itemOverflow === 'title';
      const ovTooltip = itemOverflow === true || itemOverflow === 'tooltip';
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeForm.xegrid
      };
      if (visible === false) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      let isRequired = false;
      let isValid = false;
      if (!readonly && rules) {
        const itemRules = rules[field];
        if (itemRules && itemRules.length) {
          isValid = true;
          isRequired = itemRules.some(rule => rule.required);
        }
      }
      // 如果为项集合
      const isGather = children && children.length > 0;
      if (isGather) {
        const childVNs = children.map((childItem, index) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeFormConfigItem, {
            key: index,
            itemConfig: childItem
          });
        });
        return childVNs.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-form--gather vxe-form--item-row', item.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '']
        }, childVNs) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      let contentVNs = [];
      const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
      if (defaultSlot) {
        contentVNs = $xeForm.callSlot(defaultSlot, params);
      } else if (rftContent) {
        contentVNs = getSlotVNs(rftContent(itemRender, params));
      } else if (field) {
        contentVNs = [external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field))];
      }
      if (collapseNode) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-trigger-node',
          onClick: $xeForm.toggleCollapseEvent
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-form--item-trigger-text'
        }, collapseAll ? i18n_getI18n('vxe.form.unfolding') : i18n_getI18n('vxe.form.folding')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-form--item-trigger-icon', collapseAll ? getIcon().FORM_FOLDING : getIcon().FORM_UNFOLDING]
        })]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-valid',
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.content));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeForm.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeForm.handleTitleTipLeaveEvent
      } : {};
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item', item.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '', itemClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemClassName) ? itemClassName(params) : itemClassName : '', {
          'is--title': title,
          'is--colon': titleColon,
          'is--bold': titleBold,
          'is--padding': itemPadding,
          'is--vertical': itemVertical,
          'is--asterisk': titleAsterisk,
          'is--valid': isValid,
          'is--required': isRequired,
          'is--hidden': folding && collapseAll,
          'is--active': isActiveItem($xeForm, item),
          'is--error': showError
        }],
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--item-inner'
      }, [showTitle !== false && (title || titleSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-title', titleAlign ? `align--${titleAlign}` : '', hasEllipsis ? 'is--ellipsis' : '', itemTitleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : '', titleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleClassName) ? titleClassName(params) : titleClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
          width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
        } : null),
        title: ovTitle ? getFuncText(title) : null,
        ...ons
      }, renderTitle($xeForm, item)) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-content', align ? `align--${align}` : '', itemContentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : '', contentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentClassName) ? contentClassName(params) : contentClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, contentVNs)])]);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGather', null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
/* harmony default export */ var form_config_item = (VxeFormConfigItem);
;// CONCATENATED MODULE: ./packages/form/src/form.ts












class Rule {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
const validErrorRuleValue = (rule, val) => {
  const {
    type,
    min,
    max,
    pattern
  } = rule;
  const isNumType = type === 'number';
  const numVal = isNumType ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(val);
  // 判断数值
  if (isNumType && isNaN(val)) {
    return true;
  }
  // 如果存在 min，判断最小值
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && numVal < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
    return true;
  }
  // 如果存在 max，判断最大值
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && numVal > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
    return true;
  }
  // 如果存在 pattern，正则校验
  if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
function getResetValue(value, resetValue) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(value)) {
    resetValue = [];
  }
  return resetValue;
}
/* harmony default export */ var src_form = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeForm',
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    }
  },
  emits: ['update:collapseStatus', 'collapse', 'toggle-collapse', 'submit', 'submit-invalid', 'reset'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      tooltipTimeout: null,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', null);
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let formMethods = {};
    const computeValidOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      xegrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = list => {
      if (list.length) {
        if (true) {
          list.forEach(item => {
            if (item.slots) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
                if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                  if (!slots[func]) {
                    errLog('vxe.error.notSlot', [func]);
                  }
                }
              });
            }
          });
        }
      }
      reactData.staticItems = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(list, item => createItem($xeForm, item), {
        children: 'children'
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getItems = () => {
      const itemList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.formItems, item => {
        itemList.push(item);
      }, {
        children: 'children'
      });
      return itemList;
    };
    const getItemByField = field => {
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(reactData.formItems, item => item.field === field, {
        children: 'children'
      });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit('update:collapseStatus', status);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const toggleCollapseEvent = evnt => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent('toggle-collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
      formMethods.dispatchEvent('collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
    };
    const clearValidate = fieldOrItem => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach(field => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach(item => {
          item.showError = false;
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const reset = () => {
      const {
        data
      } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach(item => {
          const {
            field,
            resetValue,
            itemRender
          } = item;
          if (isEnableConf(itemRender)) {
            const compConf = renderer.get(itemRender.name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({
                data,
                field,
                property: field,
                item,
                $form: $xeForm,
                $grid: $xeForm.xegrid
              });
            } else if (field) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, resetValue === null ? getResetValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field), undefined) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(resetValue, true));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = evnt => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent('reset', {
        data: props.data
      }, evnt);
    };
    const handleFocus = fields => {
      const el = refElem.value;
      if (el) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf(item.itemRender)) {
            const {
              itemRender
            } = item;
            const compConf = renderer.get(itemRender.name);
            // 定位到第一个
            if (!i) {
              scrollToView(el.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            // 如果指定了聚焦 class
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(autoFocus)) {
              inputElem = autoFocus({
                $form: $xeForm,
                $grid: $xeGrid,
                item,
                data: props.data,
                field
              });
            } else if (autoFocus) {
              inputElem = el.querySelector(`.${item.id} ${autoFocus}`);
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    /**
     * 校验数据
     * 按表格行、列顺序依次校验（同步或异步）
     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
     * 如果校验失败则，触发回调或者 Promise<(ErrMap 校验不通过列的信息)>
     * 如果是传回调方式这返回一个 (ErrMap 校验不通过列的信息)
     *
     * rule 配置：
     *  required=Boolean 是否必填
     *  min=Number 最小长度
     *  max=Number 最大长度
     *  validator=Function({ itemValue, rule, rules, data, property }) 自定义校验，接收一个 Promise
     *  trigger=change 触发方式
     */
    const validItemRules = (validType, fields, val) => {
      const {
        data,
        rules: formRules
      } = props;
      const errorMaps = {};
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map(property => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(formRules, property);
          if (rules) {
            const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property) : val;
            rules.forEach(rule => {
              const {
                type,
                trigger,
                required,
                validator
              } = rule;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog('vxe.error.notValidators', [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog('vxe.error.notValidators', [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger,
                        content: customValid.message,
                        rule: new Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // 如果为异步校验（注：异步校验是并发无序的）
                      syncVailds.push(customValid.catch(e => {
                        errorRules.push(new Rule({
                          type: 'custom',
                          trigger,
                          content: e ? e.message : rule.content || rule.message,
                          rule: new Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === 'array';
                  const isArrVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(itemValue)) {
                    hasEmpty = eqEmptyValue(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map(rule => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    let showErrTime;
    const beginValidate = (itemList, type, callback) => {
      const {
        data,
        rules: formRules
      } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(showErrTime);
      if (data && formRules) {
        itemList.forEach(item => {
          const {
            field
          } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || 'all', field).then(() => {
              item.errRule = null;
            }).catch(errorMaps => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise(resolve => {
            showErrTime = window.setTimeout(() => {
              itemList.forEach(item => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = callback => {
      const {
        readonly
      } = props;
      clearValidate();
      if (readonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      return beginValidate(getItems(), '', callback);
    };
    const validateField = (fieldOrItem, callback) => {
      const {
        readonly
      } = props;
      if (readonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      let fields = [];
      if (fieldOrItem) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map(field => handleFieldOrItem($xeForm, field)), '', callback);
    };
    const submitEvent = evnt => {
      const {
        readonly
      } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent('submit', {
            data: props.data
          }, evnt);
          return;
        }
        beginValidate(getItems()).then(errMap => {
          if (errMap) {
            formMethods.dispatchEvent('submit-invalid', {
              data: props.data,
              errMap
            }, evnt);
          } else {
            formMethods.dispatchEvent('submit', {
              data: props.data
            }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const {
        item
      } = params;
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || '').trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.tooltipTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.tooltipTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ['blur'].includes(evnt.type) ? 'blur' : 'change' : 'all', field, itemValue).then(() => {
          clearValidate(field);
        }).catch(errorMaps => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 更新项状态
     * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一项编辑状态
     * 如果单元格配置了校验规则，则会进行校验
     */
    const updateStatus = (scope, itemValue) => {
      const {
        field
      } = scope;
      return triggerItemEvent(new Event('change'), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $form: $xeForm,
          $grid: $xeGrid
        }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const {
        loading,
        className,
        data,
        customLayout
      } = props;
      const {
        formItems
      } = reactData;
      // const formItems: any[] = []
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('form', {
        ref: refElem,
        class: ['vxe-form', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          items: formItems,
          data,
          $form: $xeForm
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading
        }],
        spellcheck: false,
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--wrapper vxe-form--item-row'
      }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_config_item, {
          key: index,
          itemConfig: item
        });
      })), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-slots',
        ref: 'hideItem'
      }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-form--loading',
        modelValue: loading
      }),
      /**
       * 工具提示
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
        ref: refTooltip,
        ...tooltipOpts
      })]);
    };
    $xeForm.renderVN = renderVN;
    const staticItemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(itemFlag, () => {
      loadItem(props.items || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.collapseStatus, value => {
      reactData.collapseAll = !!value;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.readonly, () => {
      clearValidate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.disabled, () => {
      clearValidate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (true) {
          if (props.customLayout && props.items) {
            errLog('vxe.error.errConflicts', ['custom-layout', 'items']);
          }
        }
      });
    });
    if (props.items) {
      loadItem(props.items);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeForm', $xeForm);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGather', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', null);
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/render/index.ts





const componentDefaultModelProp = 'modelValue';
const defaultCompProps = {
  transfer: true
};
/**
 * 已废弃
 * @deprecated
 */
function getOldComponentName(name) {
  return `vxe-${name.replace('$', '')}`;
}
function getDefaultComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(name);
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(getOldComponentName(name));
}
function getNativeAttrs(renderOpts) {
  let {
    name,
    attrs
  } = renderOpts;
  if (name === 'input') {
    attrs = Object.assign({
      type: 'text'
    }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
/**
 * 原生事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getElementOns(renderOpts, params, modelFunc, changeFunc) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
      ons[getOnName(key)] = function (...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
/**
 * 组件事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
    ons[getOnName(key)] = function (...args) {
      if (true) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
          errLog('vxe.error.errFunc', [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getItemOns(renderOpts, params) {
  const {
    $form,
    data,
    field
  } = params;
  return getComponentOns(renderOpts, params, value => {
    // 处理 model 值双向绑定
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, value);
  }, () => {
    // 处理 change 事件相关逻辑
    $form.updateStatus(params);
  });
}
function getNativeItemOns(renderOpts, params) {
  const {
    $form,
    data,
    field
  } = params;
  return getElementOns(renderOpts, params, evnt => {
    // 处理 model 值双向绑定
    const itemValue = evnt.target.value;
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, itemValue);
  }, () => {
    // 处理 change 事件相关逻辑
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const {
    optionGroups,
    optionGroupProps = {}
  } = renderOpts;
  const groupOptions = optionGroupProps.options || 'options';
  const groupLabel = optionGroupProps.label || 'label';
  return optionGroups.map((group, gIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('optgroup', {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
/**
 * 渲染表单-项
 * 用于渲染原生的标签
 */
function nativeItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(name, {
    class: `vxe-default-${name}`,
    ...attrs,
    value: attrs && name === 'input' && (attrs.type === 'submit' || attrs.type === 'reset') ? null : itemValue,
    ...getNativeItemOns(renderOpts, params)
  })];
}
function defaultItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonItemRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-button'), {
    ...getComponentFormItemProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map(childRenderOpts => oldButtonItemRender(childRenderOpts, params)[0]);
}
/**
 * 渲染原生的 select 标签
 */
function renderNativeFormOptions(options, renderOpts, params) {
  const {
    data,
    field
  } = params;
  const {
    optionProps = {}
  } = renderOpts;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return options.map((item, oIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
/**
 * 渲染表单-项
 */
function defaultFormItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    options,
    optionProps
  } = renderOpts;
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    options,
    optionProps,
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    name,
    options,
    optionProps = {}
  } = renderOpts;
  const {
    data,
    field
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  const compName = getOldComponentName(name);
  // 如果是分组
  if (options) {
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(`${compName}-group`), {
      ...getComponentFormItemProps(renderOpts, params, itemValue),
      ...getItemOns(renderOpts, params)
    }, {
      default: () => {
        return options.map((item, index) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
            key: index,
            label: item[valueProp],
            content: item[labelProp],
            disabled: item[disabledProp]
          });
        });
      }
    })];
  }
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 表单 - 渲染器
 */
renderer.mixin({
  input: {
    renderItemContent: nativeItemRender
  },
  textarea: {
    renderItemContent: nativeItemRender
  },
  select: {
    renderItemContent(renderOpts, params) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
        class: 'vxe-default-select',
        ...getNativeAttrs(renderOpts),
        ...getNativeItemOns(renderOpts, params)
      }, renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))];
    }
  },
  VxeInput: {
    renderItemContent: defaultItemRender
  },
  VxeNumberInput: {
    renderItemContent: defaultItemRender
  },
  VxePasswordInput: {
    renderItemContent: defaultItemRender
  },
  VxeTextarea: {
    renderItemContent: defaultItemRender
  },
  VxeDatePicker: {
    renderItemContent: defaultItemRender
  },
  VxeButton: {
    renderItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderItemContent(renderOpts, params) {
      const {
        options
      } = renderOpts;
      const {
        data,
        field
      } = params;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        options,
        ...getComponentFormItemProps(renderOpts, params, itemValue),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeSelect: {
    renderItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeTreeSelect: {
    renderItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeIconPicker: {
    renderItemContent: defaultFormItemRender
  },
  VxeRadio: {
    renderItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderItemContent: defaultItemRender
  },
  VxeImage: {
    renderItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        props
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        src: itemValue,
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeImageGroup: {
    renderItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        props
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        urlList: itemValue,
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeUpload: {
    renderItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    renderItemContent: oldItemRender
  },
  $textarea: {
    renderItemContent: oldItemRender
  },
  $button: {
    renderItemContent: oldButtonItemRender
  },
  $buttons: {
    renderItemContent: oldButtonsItemRender
  },
  $select: {
    renderItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  $radio: {
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderItemContent: oldItemRender
  }
  // 以上已废弃
});
;// CONCATENATED MODULE: ./packages/form/index.ts




const VxeForm = Object.assign(src_form, {
  install(app) {
    app.component(src_form.name, src_form);
  }
});
dynamicApp.component(src_form.name, src_form);
core_VxeUI.component(src_form);
const Form = VxeForm;
/* harmony default export */ var packages_form = (VxeForm);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
;// CONCATENATED MODULE: ./packages/form-design/src/util.ts


let maxWidgetId = 100000;
function getNewWidgetId(widgetObjList) {
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(widgetObjList, item => {
    if (item) {
      maxWidgetId = Math.max(maxWidgetId, item.id);
    }
  }, {
    children: 'children'
  });
  return ++maxWidgetId;
}
/**
 * 判断是否布局控件
 */
const hasFormDesignLayoutType = widget => {
  return widget && getWidgetConfigGroup(widget.name) === 'layout';
};
;// CONCATENATED MODULE: ./packages/form-design/src/widget-info.ts






// 控件原始配置信息，带响应
const refWidgetReactConfigMaps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
const createHandleGetField = key => {
  return function (name) {
    const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
    const configMaps = widgetReactConfigMaps[name];
    return configMaps ? configMaps[key] : null;
  };
};
function getWidgetConfigTitle(name, $xeFormDesign) {
  const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
  const configMaps = widgetReactConfigMaps[name];
  if (configMaps) {
    const configTitle = configMaps.title;
    const params = {
      name,
      $formDesign: $xeFormDesign
    };
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(configTitle) ? configTitle(params) : configTitle);
  }
  return name;
}
function getWidgetConfigCustomGroup(name, $xeFormDesign) {
  const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
  const configMaps = widgetReactConfigMaps[name];
  if (configMaps) {
    const configCustomGroup = configMaps.customGroup;
    const params = {
      name,
      $formDesign: $xeFormDesign
    };
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(configCustomGroup) ? configCustomGroup(params) : configCustomGroup);
  }
  return name;
}
const getWidgetConfigIcon = createHandleGetField('icon');
const getWidgetConfigGroup = createHandleGetField('group');
const getWidgetConfigUnique = createHandleGetField('unique');
const getWidgetConfigScope = createHandleGetField('scope');
const validWidgetUniqueField = (field, widgetObjList) => {
  return !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item.field === field, {
    children: 'children'
  });
};
class FormDesignWidgetInfo {
  constructor($xeFormDesign, name, widgetObjList) {
    _defineProperty(this, "id", 0);
    _defineProperty(this, "field", '');
    _defineProperty(this, "title", '');
    _defineProperty(this, "name", '');
    _defineProperty(this, "required", false);
    _defineProperty(this, "hidden", false);
    _defineProperty(this, "options", {});
    _defineProperty(this, "children", []);
    _defineProperty(this, "model", {
      update: false,
      value: ''
    });
    let customField = '';
    if (name) {
      const compConf = renderer.get(name) || {};
      if (compConf) {
        const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
        const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
        if (createWidgetFormConfig) {
          const params = {
            name,
            $formDesign: $xeFormDesign
          };
          const widgetConfig = createWidgetFormConfig(params) || {};
          const titleConf = widgetConfig.title;
          const fieldConf = widgetConfig.field;
          this.title = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleConf) ? titleConf(params) : titleConf);
          this.options = widgetConfig.options || {};
          this.children = widgetConfig.children || [];
          if (fieldConf) {
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(fieldConf)) {
              customField = fieldConf({
                name,
                $formDesign: $xeFormDesign
              });
            } else {
              customField = fieldConf;
            }
          }
          if (!widgetReactConfigMaps[name]) {
            widgetReactConfigMaps[name] = {
              title: titleConf || '',
              field: fieldConf || '',
              icon: widgetConfig.icon || '',
              group: widgetConfig.group || '',
              unique: widgetConfig.unique || false,
              scope: widgetConfig.scope || '',
              customGroup: widgetConfig.customGroup || ''
            };
            refWidgetReactConfigMaps.value = Object.assign({}, widgetReactConfigMaps);
          }
        }
      }
    }
    const widgetId = getNewWidgetId(widgetObjList);
    if (customField) {
      // 如果使用了自定义字段，验证字段名是否唯一
      if (!validWidgetUniqueField(customField, widgetObjList)) {
        errLog('vxe.error.uniField', [customField]);
      }
    }
    this.id = widgetId;
    this.field = customField || `${name}${widgetId}`;
    this.name = name;
  }
}
function configToWidget(conf) {
  const widget = new FormDesignWidgetInfo(null, conf.name, []);
  widget.id = conf.id;
  widget.title = conf.title || '';
  widget.field = conf.field || '';
  widget.required = conf.required || false;
  widget.hidden = conf.hidden || false;
  widget.options = Object.assign({}, widget.options, conf.options);
  widget.children = conf.children ? conf.children.map(item => configToWidget(item)) : [];
  return widget;
}
;// CONCATENATED MODULE: ./packages/form-design/src/layout-widget.ts






/* harmony default export */ var layout_widget = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      reactData: formDesignReactData
    } = $xeFormDesign;
    const dragstartEvent = evnt => {
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetName = divEl.getAttribute('data-widget-name') || '';
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        if (dataTransfer) {
          dataTransfer.setData('text/plain', widgetName);
        }
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = dragWidget;
      } else {
        evnt.preventDefault();
      }
    };
    const dragendEvent = evnt => {
      if (formDesignReactData.dragWidget) {
        const newWidget = formDesignReactData.dragWidget;
        formDesignReactData.activeWidget = newWidget;
        $xeFormDesign.dispatchEvent('add-widget', {
          newWidget
        }, evnt);
      }
      formDesignReactData.dragWidget = null;
      formDesignReactData.sortWidget = null;
    };
    const cancelDragoverItem = (evnt, group) => {
      const {
        widgetObjList,
        dragWidget
      } = formDesignReactData;
      if (dragWidget) {
        if (group.children.some(widget => widget.name === dragWidget.name)) {
          const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item && item.id === dragWidget.id, {
            children: 'children'
          });
          if (rest) {
            rest.items.splice(rest.index, 1);
          }
        }
      }
    };
    const addNewWidget = (evnt, widgetName) => {
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const {
          widgetObjList
        } = formDesignReactData;
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        widgetObjList.push(dragWidget);
        formDesignReactData.activeWidget = dragWidget;
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = null;
        $xeFormDesign.dispatchEvent('add-widget', {
          newWidget: dragWidget
        }, evnt);
      }
    };
    const renderWidgetList = group => {
      const widgetVNs = [];
      if (group.children) {
        group.children.forEach((widget, index) => {
          const {
            name
          } = widget;
          const configTitle = getWidgetConfigTitle(name, $xeFormDesign);
          const compConf = renderer.get(name) || {};
          const renderWidgetItem = compConf.renderFormDesignWidgetItem;
          widgetVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: index,
            class: 'vxe-form-design--widget-item'
          }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-box',
            'data-widget-name': name,
            title: configTitle,
            draggable: true,
            onDragstart: dragstartEvent,
            onDragend: dragendEvent
          }, renderWidgetItem ? getSlotVNs(renderWidgetItem({}, {
            $formDesign: $xeFormDesign
          })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: ['vxe-form-design--widget-item-icon', getWidgetConfigIcon(name)]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-form-design--widget-item-name'
          }, configTitle), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-form-design--widget-item-add',
            onClick(evnt) {
              addNewWidget(evnt, name);
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: getIcon().FORM_DESIGN_WIDGET_ADD
          })])])));
        });
      }
      return widgetVNs;
    };
    const renderWidgetGroups = () => {
      const {
        widgetConfigs
      } = formDesignReactData;
      return widgetConfigs.map((config, gIndex) => {
        const {
          title,
          group
        } = config;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: gIndex,
          class: 'vxe-form-design--widget-group'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form-design--widget-title'
        }, group ? i18n_getI18n(`vxe.formDesign.widget.group.${group}`) : `${title || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form-design--widget-list',
          onDragover(evnt) {
            cancelDragoverItem(evnt, config);
          }
        }, renderWidgetList(config))]);
      });
    };
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--widget'
      }, renderWidgetGroups());
    };
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/layout-view-item.ts




const ViewItemComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'FormDesignLayoutViewItem',
  props: {
    item: {
      type: Object,
      default: () => ({})
    },
    itemIndex: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      default: () => []
    }
  },
  emits: [],
  setup(props, {
    slots
  }) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      reactData: formDesignReactData
    } = $xeFormDesign;
    const sortDragstartEvent = evnt => {
      const {
        widgetObjList,
        sortSubWidget
      } = formDesignReactData;
      if (sortSubWidget) {
        evnt.preventDefault();
        return;
      }
      const divEl = evnt.currentTarget;
      const widgetId = Number(divEl.getAttribute('data-widget-id'));
      const currRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item && item.id === widgetId, {
        children: 'children'
      });
      if (currRest) {
        formDesignReactData.dragWidget = null;
        formDesignReactData.sortWidget = currRest.item;
        formDesignReactData.sortSubWidget = null;
      }
    };
    const sortDragendEvent = () => {
      formDesignReactData.activeWidget = formDesignReactData.sortWidget;
      formDesignReactData.sortWidget = null;
    };
    let isDragAnimate = false;
    const sortDragenterEvent = evnt => {
      const {
        widgetObjList,
        sortWidget,
        sortSubWidget
      } = formDesignReactData;
      if (isDragAnimate || sortSubWidget) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        const divEl = evnt.currentTarget;
        evnt.preventDefault();
        const widgetId = Number(divEl.getAttribute('data-widget-id'));
        if (widgetId !== sortWidget.id) {
          const targetRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item && item.id === widgetId, {
            children: 'children'
          });
          if (targetRest) {
            const currRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item && item.id === sortWidget.id, {
              children: 'children'
            });
            if (currRest) {
              // 控件换位置
              currRest.items.splice(currRest.index, 1);
              targetRest.items.splice(targetRest.index, 0, currRest.item);
              $xeFormDesign.dispatchEvent('drag-widget', {
                widget: currRest.item
              }, evnt);
              isDragAnimate = true;
              setTimeout(() => {
                isDragAnimate = false;
              }, 150);
            }
          }
        }
      }
    };
    const dragoverItemEvent = evnt => {
      const {
        sortWidget,
        dragWidget,
        sortSubWidget
      } = formDesignReactData;
      if (sortWidget || dragWidget || sortSubWidget) {
        evnt.preventDefault();
      }
    };
    const handleClickEvent = (evnt, item) => {
      $xeFormDesign.handleClickWidget(evnt, item);
      formDesignReactData.sortSubWidget = null;
    };
    return () => {
      const {
        dragWidget,
        activeWidget,
        sortWidget
      } = formDesignReactData;
      const {
        item
      } = props;
      const {
        name
      } = item;
      const isActive = activeWidget && activeWidget.id === item.id;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: item.id,
        'data-widget-id': item.id,
        draggable: true,
        class: ['vxe-form-design--preview-item', `widget-${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().kebabCase(name)}`, {
          'is--active': isActive,
          'is--sort': sortWidget && sortWidget.id === item.id,
          'is--drag': dragWidget && dragWidget.id === item.id
        }],
        onDragstart: sortDragstartEvent,
        onDragend: sortDragendEvent,
        onDragenter: sortDragenterEvent,
        onDragover: dragoverItemEvent,
        onClick(evnt) {
          handleClickEvent(evnt, item);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--preview-item-view vxe-form--item-row'
      }, defaultSlot ? defaultSlot({}) : []), isActive ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--preview-item-operate'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        icon: getIcon().FORM_DESIGN_WIDGET_COPY,
        status: 'primary',
        size: 'mini',
        circle: true,
        onClick(params) {
          $xeFormDesign.handleCopyWidget(params.$event, item);
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
        status: 'danger',
        size: 'mini',
        circle: true,
        onClick(params) {
          $xeFormDesign.handleRemoveWidget(params.$event, item);
        }
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/src/layout-preview.ts







/* harmony default export */ var layout_preview = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'FormDesignLayoutPreview',
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      reactData: formDesignReactData
    } = $xeFormDesign;
    const dragoverEvent = evnt => {
      const {
        widgetObjList,
        dragWidget
      } = formDesignReactData;
      if (dragWidget) {
        evnt.preventDefault();
        const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item && item.id === dragWidget.id, {
          children: 'children'
        });
        if (!rest) {
          formDesignReactData.sortWidget = dragWidget;
          widgetObjList.push(dragWidget);
          $xeFormDesign.dispatchEvent('drag-widget', {
            widget: dragWidget
          }, evnt);
        }
      }
    };
    return () => {
      const {
        widgetObjList
      } = formDesignReactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--preview',
        onDragover: dragoverEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--preview-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        customLayout: true,
        span: 24,
        vertical: true
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
            class: 'vxe-form-design--preview-list',
            tag: 'div',
            name: 'vxe-form-design--preview-list'
          }, {
            default: () => {
              return widgetObjList.map((widget, widgetIndex) => {
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(ViewItemComponent, {
                  key: widget.id,
                  item: widget,
                  itemIndex: widgetIndex,
                  items: widgetObjList
                }, {
                  default() {
                    const {
                      name
                    } = widget;
                    const compConf = renderer.get(name) || {};
                    const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
                    const renderOpts = widget;
                    const isEditMode = true;
                    const params = {
                      widget,
                      readonly: false,
                      disabled: false,
                      isEditMode,
                      isViewMode: !isEditMode,
                      $formDesign: $xeFormDesign,
                      $formView: null
                    };
                    return renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : [];
                  }
                });
              });
            }
          });
        }
      })])]);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/tabs/src/tabs.ts







/* harmony default export */ var tabs = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTabs',
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    beforeCloseMethod: Function
  },
  emits: ['update:modelValue', 'change', 'tab-change-fail', 'tab-close', 'tab-close-fail', 'tab-click', 'tab-load'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeParentTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeadWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: false,
      resizeFlag: 1
    });
    const refMaps = {
      refElem
    };
    const handleFilterTab = item => {
      const {
        permissionCode
      } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const computeTabOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        options
      } = props;
      return (options || []).filter(handleFilterTab);
    });
    const computeTabStaticOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        staticTabs
      } = reactData;
      return staticTabs.filter(handleFilterTab);
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const updateTabStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          type
        } = props;
        const {
          activeName
        } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        let lintWidth = 0;
        let lintLeft = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === activeName);
          const {
            children,
            scrollWidth,
            clientWidth
          } = headerWrapperEl;
          isOver = scrollWidth !== clientWidth;
          if (index > -1) {
            const tabEl = children[index];
            const tabWidth = tabEl.clientWidth;
            if (type) {
              if (type === 'card') {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft;
              } else if (type === 'border-card') {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft - 1;
              }
            } else {
              lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
              lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
            }
          }
        }
        reactData.lintLeft = lintLeft;
        reactData.lintWidth = lintWidth;
        reactData.isTabOver = isOver;
      });
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tabs: $xeTabs
      }, params));
    };
    const addInitName = (name, evnt) => {
      const {
        initNames
      } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent('tab-load', {
          name
        }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = list => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach(item => {
          if (activeName === item.name) {
            validVal = true;
          }
          if (item && item.preload) {
            addInitName(item.name, null);
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emit('update:modelValue', activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const clickEvent = (evnt, item) => {
      const {
        trigger
      } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const {
        activeName
      } = reactData;
      const {
        name
      } = item;
      if (trigger === 'manual') {
        dispatchEvent('tab-click', {
          name
        }, evnt);
        return;
      }
      const value = name;
      reactData.activeName = name;
      emit('update:modelValue', value);
      dispatchEvent('tab-click', {
        name
      }, evnt);
      addInitName(name, evnt);
      if (name !== activeName) {
        if (!beforeMethod || beforeMethod({
          $tabs: $xeTabs,
          name,
          oldName: activeName,
          newName: name
        })) {
          dispatchEvent('change', {
            value,
            name,
            oldName: activeName,
            newName: name
          }, evnt);
        } else {
          dispatchEvent('tab-change-fail', {
            value,
            name,
            oldName: activeName,
            newName: name
          }, evnt);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index, list) => {
      evnt.stopPropagation();
      const {
        activeName
      } = reactData;
      const beforeMethod = props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const {
        name
      } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      if (!beforeMethod || beforeMethod({
        $tabs: $xeTabs,
        value,
        name,
        nextName
      })) {
        dispatchEvent('tab-close', {
          value,
          name,
          nextName
        }, evnt);
      } else {
        dispatchEvent('tab-close-fail', {
          value,
          name,
          nextName
        }, evnt);
      }
    };
    let scrollTimeout = null;
    const startScrollAnimation = (offsetPos, offsetSize) => {
      let offsetLeft = offsetSize;
      let scrollCount = 6;
      let delayNum = 35;
      clearTimeout(scrollTimeout);
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const {
              clientWidth,
              scrollWidth,
              scrollLeft
            } = headerWrapperEl;
            offsetLeft = Math.floor(offsetLeft / 2);
            if (offsetPos > 0) {
              if (clientWidth + scrollLeft < scrollWidth) {
                headerWrapperEl.scrollLeft += offsetLeft;
                delayNum -= 4;
                scrollTimeout = setTimeout(scrollAnimate, delayNum);
              }
            } else {
              if (scrollLeft > 0) {
                headerWrapperEl.scrollLeft -= offsetLeft;
                delayNum -= 4;
                scrollTimeout = setTimeout(scrollAnimate, delayNum);
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = offsetPos => {
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const offsetSize = Math.floor(headerWrapperEl.clientWidth * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = name => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === name);
          if (index > -1) {
            const {
              scrollLeft,
              clientWidth,
              children
            } = headerWrapperEl;
            const tabEl = children[index];
            if (tabEl) {
              const tabOffsetLeft = tabEl.offsetLeft;
              const tabClientWidth = tabEl.clientWidth;
              // 如果右侧被挡
              const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
              if (overSize > 0) {
                headerWrapperEl.scrollLeft += overSize;
              }
              // 如果左侧被挡，优先
              if (tabOffsetLeft < scrollLeft) {
                headerWrapperEl.scrollLeft = tabOffsetLeft;
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const createHandlePrevNext = isNext => {
      return () => {
        const {
          activeName
        } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
        const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName);
        if (index > -1) {
          let item = null;
          if (isNext) {
            if (index < list.length - 1) {
              item = list[index + 1];
            }
          } else {
            if (index > 0) {
              item = list[index - 1];
            }
          }
          if (item) {
            const name = item.name;
            const value = name;
            reactData.activeName = name;
            emit('update:modelValue', value);
            addInitName(name, null);
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      };
    };
    const tabsMethods = {
      dispatchEvent,
      scrollToTab,
      prev: createHandlePrevNext(false),
      next: createHandlePrevNext(true),
      prevTab() {
        warnLog('vxe.error.delFunc', ['prevTab', 'prev']);
        return tabsMethods.prev();
      },
      nextTab() {
        warnLog('vxe.error.delFunc', ['nextTab', 'next']);
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = tabList => {
      const {
        type,
        titleWidth: allTitleWidth,
        titleAlign: allTitleAlign,
        showClose
      } = props;
      const {
        activeName,
        lintLeft,
        lintWidth,
        isTabOver
      } = reactData;
      const extraSlot = slots.extra;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-header'
      }, [isTabOver ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-header--bar vxe-tabs-header--left-bar',
        onClick: scrollLeftEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: getIcon().TABS_TAB_BUTTON_LEFT
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-header--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeadWrapperElem,
        class: 'vxe-tabs-header--item-wrapper'
      }, tabList.map((item, index) => {
        const {
          title,
          titleWidth,
          titleAlign,
          icon,
          name,
          slots
        } = item;
        const tabSlot = slots ? slots.tab : null;
        const itemWidth = titleWidth || allTitleWidth;
        const itemAlign = titleAlign || allTitleAlign;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-tabs-header--item', itemAlign ? `align--${itemAlign}` : '', {
            'is--active': activeName === name
          }],
          style: itemWidth ? {
            width: toCssUnit(itemWidth)
          } : null,
          onClick(evnt) {
            clickEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tabs-header--item-inner'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tabs-header--item-content'
        }, [icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: icon
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-name'
        }, tabSlot ? callSlot(tabSlot, {
          name,
          title
        }) : `${title}`)]), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tabs-header--close-btn',
          onClick(evnt) {
            handleCloseTabEvent(evnt, item, index, tabList);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().TABS_TAB_CLOSE
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
      }).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        key: 'line',
        class: `vxe-tabs-header--active-line type--${type || 'default'}`,
        style: {
          left: `${lintLeft}px`,
          width: `${lintWidth}px`
        }
      })]))]), isTabOver ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-header--bar vxe-tabs-header--right-bar',
        onClick: scrollRightEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: getIcon().TABS_TAB_BUTTON_RIGHT
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-header--extra'
      }, getSlotVNs(extraSlot({}))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    const renderTabPane = item => {
      const {
        initNames,
        activeName
      } = reactData;
      const {
        name,
        slots
      } = item;
      const defaultSlot = slots ? slots.default : null;
      return name && initNames.includes(name) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: name,
        class: ['vxe-tabs-pane--item', {
          'is--visible': activeName === name,
          'has--content': !!defaultSlot
        }]
      }, defaultSlot ? callSlot(defaultSlot, {
        name
      }) : []) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderTabContent = tabList => {
      const {
        destroyOnClose
      } = props;
      const {
        activeName
      } = reactData;
      const activeDefaultTab = tabList.find(item => item.name === activeName);
      if (destroyOnClose) {
        return activeDefaultTab ? [renderTabPane(activeDefaultTab)] : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      return tabList.map(renderTabPane);
    };
    const renderVN = () => {
      const {
        type,
        height,
        padding,
        trigger
      } = props;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const defaultSlot = slots.default;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tabs', `vxe-tabs--${type || 'default'}`, `trigger--${trigger === 'manual' ? 'trigger' : 'default'}`, {
          'is--padding': padding,
          'is--height': height
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-slots'
      }, defaultSlot ? defaultSlot({}) : []), renderTabHeader(tabList), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-pane'
      }, renderTabContent(tabList))]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeName, val => {
      scrollToTab(val);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        reactData.resizeFlag++;
      });
    });
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultName(props.options);
      updateTabStyle();
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      updateTabStyle();
    });
    if ($xeParentTabs) {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null, () => {
        reactData.resizeFlag++;
      });
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.resizeFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(updateTabStyle);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeTabs, 'resize', updateTabStyle);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateTabStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTabs, 'resize');
    });
    $xeTabs.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTabs', $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tabs/src/util.ts

function assembleAnchorTab($xeTabs, elem, tabConfig) {
  const staticLinks = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticLinks.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticLinks.slice(0);
  }
}
function destroyAnchorTab($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticTabs, item => item.id === tabConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}
;// CONCATENATED MODULE: ./packages/tabs/src/tab-pane.ts



/* harmony default export */ var tab_pane = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTabPane',
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const tabConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots: {
        default: slots.default
      }
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.title, val => {
      tabConfig.title = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      tabConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.icon, val => {
      tabConfig.icon = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.permissionCode, val => {
      tabConfig.permissionCode = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if ($xeTabs && refElem.value) {
        assembleAnchorTab($xeTabs, refElem.value, tabConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeTabs) {
        destroyAnchorTab($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/src/form-item.ts








const formItemProps = {
  title: String,
  field: String,
  span: [String, Number],
  align: String,
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: {
    default: null
  },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
/* harmony default export */ var form_item = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormItem',
  props: formItemProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const formGather = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormGather', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = {
      itemConfig: formItem
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', formItemInfo);
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assembleItem($xeForm, refElem.value, formItem, formGather);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeForm, formItem);
    });
    const renderItem = ($xeForm, item) => {
      const {
        props,
        reactData
      } = $xeForm;
      const {
        data,
        rules,
        readonly,
        disabled,
        titleBold: allTitleBold,
        titleAlign: allTitleAlign,
        titleWidth: allTitleWidth,
        titleColon: allTitleColon,
        titleAsterisk: allTitleAsterisk,
        titleOverflow: allTitleOverflow,
        vertical: allVertical,
        padding: allPadding
      } = props;
      const {
        collapseAll
      } = reactData;
      const {
        computeValidOpts
      } = $xeForm.getComputeMaps();
      const validOpts = computeValidOpts.value;
      const {
        slots,
        title,
        visible,
        folding,
        field,
        collapseNode,
        itemRender,
        showError,
        errRule,
        className,
        titleOverflow,
        vertical,
        padding,
        showTitle,
        contentClassName,
        contentStyle,
        titleClassName,
        titleStyle
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : '';
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : '';
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : '';
      const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const titleSlot = slots ? slots.title : null;
      const span = item.span || props.span;
      const align = item.align || props.align;
      const itemPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(padding) ? allPadding : padding;
      const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
      const titleBold = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleBold) ? allTitleBold : item.titleBold;
      const titleAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = itemVertical ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const ovEllipsis = itemOverflow === 'ellipsis';
      const ovTitle = itemOverflow === 'title';
      const ovTooltip = itemOverflow === true || itemOverflow === 'tooltip';
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeForm.xegrid
      };
      let isRequired = false;
      let isValid = false;
      if (visible === false) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      if (!readonly && rules) {
        const itemRules = rules[field];
        if (itemRules && itemRules.length) {
          isValid = true;
          isRequired = itemRules.some(rule => rule.required);
        }
      }
      let contentVNs = [];
      const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
      if (defaultSlot) {
        contentVNs = $xeForm.callSlot(defaultSlot, params);
      } else if (rftContent) {
        contentVNs = getSlotVNs(rftContent(itemRender, params));
      } else if (field) {
        contentVNs = [`${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field)}`];
      }
      if (collapseNode) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-trigger-node',
          onClick: $xeForm.toggleCollapseEvent
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-form--item-trigger-text'
        }, collapseAll ? i18n_getI18n('vxe.form.unfolding') : i18n_getI18n('vxe.form.folding')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-form--item-trigger-icon', collapseAll ? getIcon().FORM_FOLDING : getIcon().FORM_UNFOLDING]
        })]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-valid',
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.message));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeForm.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeForm.handleTitleTipLeaveEvent
      } : {};
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-form--item', item.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '', itemClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemClassName) ? itemClassName(params) : itemClassName : '', {
          'is--title': title,
          'is--colon': titleColon,
          'is--bold': titleBold,
          'is--padding': itemPadding,
          'is--vertical': itemVertical,
          'is--asterisk': titleAsterisk,
          'is--valid': isValid,
          'is--required': isRequired,
          'is--hidden': folding && collapseAll,
          'is--active': isActiveItem($xeForm, item),
          'is--error': showError
        }],
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--item-inner'
      }, [showTitle !== false && (title || titleSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-title', titleAlign ? `align--${titleAlign}` : '', hasEllipsis ? 'is--ellipsis' : '', itemTitleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : '', titleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleClassName) ? titleClassName(params) : titleClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
          width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
        } : null),
        title: ovTitle ? getFuncText(title) : null,
        ...ons
      }, renderTitle($xeForm, item)) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-content', align ? `align--${align}` : '', itemContentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : '', contentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentClassName) ? contentClassName(params) : contentClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, contentVNs)])]);
    };
    const renderVN = () => {
      const formProps = $xeForm ? $xeForm.props : null;
      return formProps && formProps.customLayout ? renderItem($xeForm, formItem) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    const $xeFormitem = {
      formItem,
      renderVN
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', $xeFormitem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGather', null);
    return $xeFormitem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/switch/src/switch.ts




/* harmony default export */ var src_switch = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeSwitch',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().switch.size || getConfig().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: ['update:modelValue', 'change', 'focus', 'blur'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData
    };
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let switchMethods = {};
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeOnShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.modelValue === props.openValue;
    });
    let _atimeout;
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isChecked = computeIsChecked.value;
        clearTimeout(_atimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emit('update:modelValue', value);
        switchMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        _atimeout = setTimeout(() => {
          reactData.hasAnimat = false;
        }, 400);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent('focus', {
        value: props.modelValue
      }, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent('blur', {
        value: props.modelValue
      }, evnt);
    };
    switchMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $switch: $xeSwitch
        }, params));
      },
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        btnElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const {
        openIcon,
        closeIcon,
        openActiveIcon,
        closeActiveIcon
      } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-switch', isChecked ? 'is--on' : 'is--off', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled,
          'is--animat': reactData.hasAnimat
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: 'vxe-switch--button',
        type: 'button',
        disabled: isDisabled,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-on'
      }, [openIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', openIcon]
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), onShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-off'
      }, [closeIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', closeIcon]
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), offShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-switch--icon']
      }, openActiveIcon || closeActiveIcon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isChecked ? openActiveIcon : closeActiveIcon
      })] : [])])]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/text/src/text.ts




/* harmony default export */ var src_text = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeText',
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    clickToCopy: Boolean,
    size: {
      type: String,
      default: () => getConfig().text.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refContentElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const clickIconEvent = () => {
      const {
        content,
        clickToCopy
      } = props;
      if (clickToCopy) {
        const contentEl = refContentElem.value;
        const copyVal = (contentEl ? contentEl.textContent : '') || content;
        if (copyVal) {
          if (core_VxeUI.clipboard.copy(copyVal)) {
            if (core_VxeUI.modal) {
              core_VxeUI.modal.message({
                content: i18n_getI18n('vxe.text.copySuccess'),
                status: 'success'
              });
            }
          } else {
            if (core_VxeUI.modal) {
              core_VxeUI.modal.message({
                content: i18n_getI18n('vxe.text.copyError'),
                status: 'error'
              });
            }
          }
        }
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderContent = () => {
      const {
        icon,
        content,
        clickToCopy
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [iconSlot || icon || clickToCopy ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-text--icon',
        onClick: clickIconEvent
      }, iconSlot ? getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon().TEXT_COPY
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refContentElem,
        class: 'vxe-text--content'
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))];
    };
    const renderVN = () => {
      const {
        status,
        title,
        clickToCopy
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        title,
        class: ['vxe-text', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--copy': clickToCopy
        }]
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/default-setting-form.ts






const DefaultSettingFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'DefaultSettingForm',
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      props: formDesignProps
    } = $xeFormDesign;
    return () => {
      const {
        formData
      } = props;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          const {
            showPc,
            showMobile
          } = formDesignProps;
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.formName'),
            field: 'title',
            itemRender: {
              name: 'VxeInput',
              props: {
                placeholder: i18n_getI18n('vxe.formDesign.defFormTitle')
              }
            }
          }), showPc && showMobile ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.name')
          }, {
            default() {
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-devices'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-pc'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
                icon: getIcon().FORM_DESIGN_PROPS_PC,
                content: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.pc')
              }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: formData.pcVisible,
                openLabel: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.visible'),
                closeLabel: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.hidden'),
                'onUpdate:modelValue'(val) {
                  formData.pcVisible = val;
                }
              })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-mobile'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
                icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                content: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.mobile')
              }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: formData.mobileVisible,
                openLabel: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.visible'),
                closeLabel: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.hidden'),
                'onUpdate:modelValue'(val) {
                  formData.mobileVisible = val;
                }
              })])])];
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/src/layout-setting.ts






/* harmony default export */ var layout_setting = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'FormDesignLayoutSetting',
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      props: formDesignProps,
      reactData: formDesignReactData
    } = $xeFormDesign;
    const activeTab = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(1);
    const renderSettingWidgetForm = () => {
      const {
        activeWidget
      } = formDesignReactData;
      if (activeWidget) {
        const compConf = renderer.get(activeWidget.name);
        const renderWidgetFormView = compConf ? compConf.renderFormDesignWidgetFormView : null;
        if (renderWidgetFormView) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--custom-widget-form-view'
          }, getSlotVNs(renderWidgetFormView(activeWidget, {
            widget: activeWidget,
            $formDesign: $xeFormDesign
          })));
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderSettingConfigForm = () => {
      const {
        formRender
      } = formDesignProps;
      const {
        formData
      } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingView = compConf ? compConf.renderFormDesignSettingFormView : null;
        if (renderSettingView) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--custom-setting-form-view'
          }, getSlotVNs(renderSettingView({}, {
            $formDesign: $xeFormDesign
          })));
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(DefaultSettingFormComponent, {
        formData
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => formDesignReactData.activeWidget, () => {
      activeTab.value = 1;
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--setting'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--setting-form'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tabs, {
        modelValue: activeTab.value,
        titleWidth: '50%',
        titleAlign: 'center',
        padding: true,
        class: 'vxe-form-design--setting-form-tabs',
        'onUpdate:modelValue'(val) {
          activeTab.value = val;
        }
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tab_pane, {
            title: i18n_getI18n('vxe.formDesign.widgetPropTab'),
            name: 1
          }, {
            default() {
              return renderSettingWidgetForm();
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tab_pane, {
            title: i18n_getI18n('vxe.formDesign.widgetFormTab'),
            name: 2
          }, {
            default() {
              return renderSettingConfigForm();
            }
          })];
        }
      })])]);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/modal/src/modal.ts










const allActiveModals = [];
const msgQueue = [];
const notifyQueue = [];
/* harmony default export */ var modal = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeModal',
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: 'modal'
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => getConfig().modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => getConfig().modal.duration
    },
    message: [Number, String],
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().modal.escClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => getConfig().modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().modal.showFooter
    },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMinimize)
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => getConfig().modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => getConfig().modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => getConfig().modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => getConfig().modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => getConfig().modal.draggable
    },
    remember: {
      type: Boolean,
      default: () => getConfig().modal.remember
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => getConfig().modal.storage
    },
    storageKey: {
      type: String,
      default: () => getConfig().modal.storageKey
    },
    padding: {
      type: Boolean,
      default: () => getConfig().modal.padding
    },
    size: {
      type: String,
      default: () => getConfig().modal.size || getConfig().size
    },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * 已废弃
     */
    animat: {
      type: Boolean,
      default: () => getConfig().modal.animat
    }
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel', 'zoom', 'resize', 'move'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: '',
      zoomStatus: '',
      revertLocat: null,
      prevLocat: null,
      firstOpen: true
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refModalBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const computeIsMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'message' || props.type === 'notification';
    });
    const computeIsMinimizeStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.zoomStatus === 'minimize';
    });
    const computeIsMaximizeStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.zoomStatus === 'maximize';
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().modal.zoomConfig, props.zoomConfig);
    });
    const computeMaps = {
      computeSize,
      computeZoomOpts
    };
    const $xeModal = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let modalMethods = {};
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ''}`;
        boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ''}`;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        modalZindex
      } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else if (modalZindex < getLastZIndex()) {
        reactData.modalZindex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          position
        } = props;
        const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === 'center';
        const {
          top,
          left
        } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(position) ? {
          top: position,
          left: position
        } : Object.assign({}, position);
        const topCenter = isPosCenter || top === 'center';
        const leftCenter = isPosCenter || left === 'center';
        let posTop = '';
        let posLeft = '';
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          type
        } = props;
        const queueList = type === 'notification' ? notifyQueue : msgQueue;
        let offsetTop = 0;
        queueList.forEach(comp => {
          const boxElem = comp.getBox();
          if (boxElem) {
            offsetTop += external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(comp.props.top);
            comp.reactData.modalTop = offsetTop;
            offsetTop += boxElem.clientHeight;
          }
        });
      });
    };
    const removeMsgQueue = () => {
      const {
        type
      } = props;
      const queueList = type === 'notification' ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) > -1) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(queueList, comp => comp === $xeModal);
      }
      updateStyle();
    };
    const closeModal = type => {
      const {
        remember
      } = props;
      const {
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      const beforeHideFn = props.beforeHideMethod || getConfig().modal.beforeHideMethod;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideFn ? beforeHideFn(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              handleRevert();
            }
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveModals, item => item === $xeModal);
            modalMethods.dispatchEvent('before-hide', params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit('update:modelValue', false);
              modalMethods.dispatchEvent('hide', params, null);
            }, 200);
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      modalMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const confirmEvent = evnt => {
      const type = 'confirm';
      modalMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const cancelEvent = evnt => {
      const type = 'cancel';
      modalMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const getStorageMap = key => {
      const version = getConfig().version;
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(key) || '');
      return rest && rest._v === version ? rest : {
        _v: version
      };
    };
    const hasPosStorage = () => {
      const {
        id,
        remember,
        storage,
        storageKey
      } = props;
      return !!(id && remember && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const {
        id,
        remember,
        storage,
        storageKey
      } = props;
      if (id && remember && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(',');
          if (boxElem) {
            if (left) {
              boxElem.style.left = `${left}px`;
            }
            if (top) {
              boxElem.style.top = `${top}px`;
            }
            if (width) {
              boxElem.style.width = `${width}px`;
            }
            if (height) {
              boxElem.style.height = `${height}px`;
            }
          }
          if (zoomLeft && zoomTop) {
            reactData.revertLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      const {
        type
      } = props;
      const queueList = type === 'notification' ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) === -1) {
        queueList.push($xeModal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const {
        id,
        remember,
        storage,
        storageKey
      } = props;
      const {
        revertLocat
      } = reactData;
      if (id && remember && storage) {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [boxElem.style.left, boxElem.style.top, boxElem.style.width, boxElem.style.height].concat(revertLocat ? [revertLocat.left, revertLocat.top, revertLocat.width, revertLocat.height] : []).map(val => val ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : '').join(',');
        localStorage.setItem(storageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(posStorageMap));
      }
    };
    const handleMinimize = () => {
      const zoomOpts = computeZoomOpts.value;
      const {
        minimizeLayout,
        minimizeMaxSize,
        minimizeHorizontalOffset,
        minimizeVerticalOffset,
        minimizeOffsetMethod
      } = zoomOpts;
      const isHorizontalLayout = minimizeLayout === 'horizontal';
      const prevZoomStatus = reactData.zoomStatus;
      const hlMList = [];
      const vlMList = [];
      allActiveModals.forEach(item => {
        if (item.xID !== $xeModal.xID && item.props.type === 'modal' && item.reactData.zoomStatus === 'minimize') {
          const itemZoomOpts = item.getComputeMaps().computeZoomOpts.value;
          if (itemZoomOpts.minimizeLayout === 'horizontal') {
            hlMList.push(item);
          } else {
            vlMList.push(item);
          }
        }
      });
      const mList = isHorizontalLayout ? hlMList : vlMList;
      // 如果配置最小化最大数量
      if (minimizeMaxSize && mList.length >= minimizeMaxSize) {
        if (core_VxeUI.modal) {
          core_VxeUI.modal.message({
            status: 'error',
            content: i18n_getI18n('vxe.modal.miniMaxSize', [minimizeMaxSize])
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = 'minimize';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const headerEl = refHeaderElem.value;
        if (!headerEl) {
          return;
        }
        const {
          visibleHeight
        } = getDomNode();
        // 如果当前处于复原状态
        if (!prevZoomStatus) {
          reactData.revertLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
        }
        const targetModal = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[isHorizontalLayout ? 'max' : 'min'](mList, $modal => {
          const boxElem = $modal.getBox();
          return boxElem ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(boxElem.style[isHorizontalLayout ? 'left' : 'top']) : 0;
        });
        let targetTop = visibleHeight - headerEl.offsetHeight - 16;
        let targetLeft = 16;
        if (targetModal) {
          const minBoxElem = targetModal.getBox();
          if (minBoxElem) {
            const boxLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(minBoxElem.style.left);
            const boxTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(minBoxElem.style.top);
            let offsetObj = {};
            if (isHorizontalLayout) {
              offsetObj = Object.assign({}, minimizeHorizontalOffset);
            } else {
              offsetObj = Object.assign({}, minimizeVerticalOffset);
            }
            targetLeft = boxLeft + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.left);
            targetTop = boxTop + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.top);
            if (minimizeOffsetMethod) {
              offsetObj = minimizeOffsetMethod({
                $modal: $xeModal,
                left: targetLeft,
                top: targetTop
              });
              targetLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.left);
              targetTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.top);
            }
          }
        }
        Object.assign(boxElem.style, {
          top: `${targetTop}px`,
          left: `${targetLeft}px`,
          width: '200px',
          height: `${headerEl.offsetHeight}px`
        });
        savePosStorage();
      });
    };
    const handleMaximize = () => {
      const prevZoomStatus = reactData.zoomStatus;
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = 'maximize';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const boxElem = getBox();
        if (boxElem) {
          // 如果当前处于复原状态
          if (!prevZoomStatus) {
            reactData.revertLocat = {
              top: boxElem.offsetTop,
              left: boxElem.offsetLeft,
              width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
              height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
            };
          }
          Object.assign(boxElem.style, {
            top: '0',
            left: '0',
            width: '100%',
            height: '100%'
          });
        }
        savePosStorage();
      });
    };
    let msgTimeout = null;
    const handleMsgAutoClose = () => {
      const {
        duration
      } = props;
      if (duration !== -1) {
        msgTimeout = setTimeout(() => closeModal('close'), external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(duration));
      }
    };
    const openModal = () => {
      const {
        remember,
        showFooter
      } = props;
      const {
        initialized,
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        if (!remember) {
          recalculate();
        }
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xeModal);
        setTimeout(() => {
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emit('update:modelValue', true);
            modalMethods.dispatchEvent('show', params, null);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          handleMsgAutoClose();
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const {
              fullscreen
            } = props;
            const {
              firstOpen
            } = reactData;
            if (!remember || firstOpen) {
              updatePosition().then(() => {
                setTimeout(() => updatePosition(), 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => handleMaximize());
              }
            } else {
              if (fullscreen) {
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => handleMaximize());
              }
            }
          });
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeModal(type);
      }
    };
    const selfMouseoverEvent = () => {
      if (msgTimeout === null) {
        return;
      }
      const isMsg = computeIsMsg.value;
      if (isMsg) {
        clearTimeout(msgTimeout);
        msgTimeout = null;
      }
    };
    const selfMouseoutEvent = () => {
      if (msgTimeout === null) {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          handleMsgAutoClose();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveModals, item => item.reactData.modalZindex);
        // 多个时，只关掉最上层的窗口
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xeModal && lastModal.props.escClosable) {
              closeModal('exit');
            }
          }, 10);
        }
      }
    };
    const isMinimized = () => {
      return reactData.zoomStatus === 'minimize';
    };
    const isMaximized = () => {
      return reactData.zoomStatus === 'maximize';
    };
    const handleRevert = () => {
      reactData.prevZoomStatus = reactData.zoomStatus;
      reactData.zoomStatus = '';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          revertLocat
        } = reactData;
        if (revertLocat) {
          const boxElem = getBox();
          reactData.revertLocat = null;
          if (boxElem) {
            Object.assign(boxElem.style, {
              top: `${revertLocat.top}px`,
              left: `${revertLocat.left}px`,
              width: `${revertLocat.width}px`,
              height: `${revertLocat.height}px`
            });
          }
          savePosStorage();
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const handleZoom = type => {
      const {
        zoomStatus
      } = reactData;
      return new Promise(resolve => {
        if (type) {
          if (type === 'maximize') {
            resolve(handleMaximize());
            return;
          }
          if (type === 'minimize') {
            resolve(handleMinimize());
            return;
          }
          resolve(handleRevert());
          return;
        }
        resolve(zoomStatus ? handleRevert() : handleMaximize());
      }).then(() => {
        return reactData.zoomStatus || 'revert';
      });
    };
    const toggleZoomMinEvent = evnt => {
      const {
        zoomStatus,
        prevZoomStatus
      } = reactData;
      return handleZoom(zoomStatus === 'minimize' ? prevZoomStatus || 'revert' : 'minimize').then(type => {
        const params = {
          type
        };
        modalMethods.dispatchEvent('zoom', params, evnt);
      });
    };
    const toggleZoomMaxEvent = evnt => {
      return handleZoom().then(type => {
        const params = {
          type
        };
        modalMethods.dispatchEvent('zoom', params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(top)) {
            boxElem.style.top = `${top}px`;
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(left)) {
            boxElem.style.left = `${left}px`;
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const boxMousedownEvent = () => {
      const {
        modalZindex
      } = reactData;
      if (allActiveModals.some(comp => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = evnt => {
      const {
        remember,
        storage
      } = props;
      const {
        zoomStatus
      } = reactData;
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const boxElem = getBox();
      if (!boxElem) {
        return;
      }
      if (zoomStatus !== 'maximize' && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, 'trigger--btn').flag) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const {
          visibleHeight,
          visibleWidth
        } = getDomNode();
        document.onmousemove = evnt => {
          evnt.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt.clientX - disX;
          let top = evnt.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
          emit('move', createEvent(evnt, {
            type: 'move'
          }));
        };
        document.onmouseup = () => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          if (remember && storage) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              savePosStorage();
            });
          }
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
          }, 50);
        };
      }
    };
    const dragEvent = evnt => {
      evnt.preventDefault();
      const {
        remember,
        storage
      } = props;
      const {
        visibleHeight,
        visibleWidth
      } = getDomNode();
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute('type');
      const minWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minWidth);
      const minHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = {
        type: 'resize'
      };
      document.onmousemove = evnt => {
        evnt.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case 'wl':
            dragLeft = disX - evnt.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case 'swst':
            dragLeft = disX - evnt.clientX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'swlb':
            dragLeft = disX - evnt.clientX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'st':
            dragTop = disY - evnt.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'wr':
            dragLeft = evnt.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'sest':
            dragLeft = evnt.clientX - disX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'selb':
            dragLeft = evnt.clientX - disX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'sb':
            dragTop = evnt.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
        if (remember && storage) {
          savePosStorage();
        }
        modalMethods.dispatchEvent('resize', params, evnt);
      };
      document.onmouseup = () => {
        reactData.revertLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
        }, 50);
      };
    };
    modalMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $modal: $xeModal
        }, params));
      },
      open: openModal,
      close() {
        return closeModal('close');
      },
      getBox,
      getPosition,
      setPosition,
      isMinimized,
      isMaximized,
      zoom: handleZoom,
      minimize: handleMinimize,
      maximize: handleMaximize,
      revert: handleRevert
    };
    Object.assign($xeModal, modalMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        showZoom,
        showMaximize,
        showMinimize,
        title
      } = props;
      const {
        zoomStatus
      } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const isMaximizeStatus = computeIsMaximizeStatus.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-title'
      }, titleSlot ? getSlotVNs(titleSlot({
        $modal: $xeModal,
        minimized: isMinimizeStatus,
        maximized: isMaximizeStatus
      })) : title ? getFuncText(title) : i18n_getI18n('vxe.alert.title')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-right'
      }, [cornerSlot && !isMinimizeStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--corner-wrapper'
      }, getSlotVNs(cornerSlot({
        $modal: $xeModal
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMinimize) ? showMinimize : showZoom) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--zoom-btn', 'trigger--btn'],
        title: i18n_getI18n(`vxe.modal.zoom${zoomStatus === 'minimize' ? 'Out' : 'Min'}`),
        onClick: toggleZoomMinEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: zoomStatus === 'minimize' ? getIcon().MODAL_ZOOM_REVERT : getIcon().MODAL_ZOOM_MIN
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMaximize) ? showMaximize : showZoom) && zoomStatus !== 'minimize' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--zoom-btn', 'trigger--btn'],
        title: i18n_getI18n(`vxe.modal.zoom${zoomStatus === 'maximize' ? 'Out' : 'In'}`),
        onClick: toggleZoomMaxEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: zoomStatus === 'maximize' ? getIcon().MODAL_ZOOM_OUT : getIcon().MODAL_ZOOM_IN
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--close-btn', 'trigger--btn'],
        title: i18n_getI18n('vxe.modal.close'),
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().MODAL_CLOSE
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])];
    };
    const renderHeader = () => {
      const {
        slots: propSlots = {},
        showZoom,
        showMaximize,
        draggable
      } = props;
      const isMsg = computeIsMsg.value;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if ((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMaximize) ? showMaximize : showZoom) && props.dblclickZoom && props.type === 'modal') {
          headerOns.onDblclick = toggleZoomMaxEvent;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refHeaderElem,
          class: ['vxe-modal--header', {
            'is--ellipsis': !isMsg && props.showTitleOverflow
          }],
          ...headerOns
        }, headerSlot ? getSlotVNs(headerSlot({
          $modal: $xeModal
        })) : renderTitles());
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderBody = () => {
      const {
        slots: propSlots = {},
        status,
        message,
        iconStatus
      } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      const contVNs = [];
      if (!isMsg && (status || iconStatus)) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--status-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-modal--status-icon', iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
        })]));
      }
      contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--content'
      }, defaultSlot ? getSlotVNs(defaultSlot({
        $modal: $xeModal
      })) : getFuncText(content)));
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-left'
      }, getSlotVNs(leftSlot({
        $modal: $xeModal
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-default'
      }, contVNs), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-right'
      }, getSlotVNs(rightSlot({
        $modal: $xeModal
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), isMsg ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
        class: 'vxe-modal--loading',
        modelValue: props.loading
      })]);
    };
    const renderDefaultFooter = () => {
      const {
        slots: propSlots = {},
        showCancelButton,
        showConfirmButton,
        type
      } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showCancelButton) ? showCancelButton : type === 'confirm') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || i18n_getI18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showConfirmButton) ? showConfirmButton : type === 'confirm' || type === 'alert') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          status: 'primary',
          content: props.confirmButtonText || i18n_getI18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-left'
      }, lfSlot ? getSlotVNs(lfSlot({
        $modal: $xeModal
      })) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-right'
      }, rfSlot ? getSlotVNs(rfSlot({
        $modal: $xeModal
      })) : btnVNs)]);
    };
    const renderFooter = () => {
      const {
        slots: propSlots = {}
      } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--footer'
        }, footerSlot ? getSlotVNs(footerSlot({
          $modal: $xeModal
        })) : [renderDefaultFooter()]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderVN = () => {
      const {
        slots: propSlots = {},
        className,
        type,
        animat,
        draggable,
        iconStatus,
        position,
        loading,
        destroyOnClose,
        status,
        lockScroll,
        padding,
        lockView,
        mask,
        resize
      } = props;
      const {
        initialized,
        modalTop,
        contentVisible,
        visible,
        zoomStatus
      } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const isMsg = computeIsMsg.value;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const ons = {};
      if (isMsg) {
        ons.onMouseover = selfMouseoverEvent;
        ons.onMouseout = selfMouseoutEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: props.transfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-modal--wrapper', `type--${type}`, `zoom--${zoomStatus || 'revert'}`, className || '', position ? `pos--${position}` : '', {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          'is--padding': padding,
          'is--animat': animat,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--draggable': draggable,
          'is--resize': resize,
          'is--mask': mask,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        },
        onClick: selfClickEvent,
        ...ons
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refModalBox,
        class: 'vxe-modal--box',
        onMousedown: boxMousedownEvent
      }, [(isMsg || asideSlot) && !isMinimizeStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--aside'
      }, asideSlot ? getSlotVNs(asideSlot({
        $modal: $xeModal
      })) : [status || iconStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--status-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-modal--status-icon', iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--container'
      }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [renderHeader(), renderBody(), renderFooter(), !isMsg && resize ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-modal--resize'
      }, ['wl', 'wr', 'swst', 'sest', 'st', 'swlb', 'selb', 'sb'].map(type => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: `${type}-resize`,
          type: type,
          onMousedown: dragEvent
        });
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])])]);
    };
    $xeModal.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openModal();
      } else {
        closeModal('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.storage && !props.id) {
          errLog('vxe.error.reqProp', ['modal.id']);
        }
        if (props.modelValue) {
          openModal();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeModal, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeModal, 'keydown');
      removeMsgQueue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeModal', $xeModal);
    return $xeModal;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/default-setting-data.ts
const getDefaultSettingFormData = defOpts => {
  return {
    title: '',
    pcVisible: defOpts ? !!defOpts.pcVisible : true,
    pcVertical: true,
    pcTitleBold: true,
    pcTitleColon: false,
    pcTitleAlign: '',
    pcTitleWidth: '',
    pcTitleWidthUnit: '',
    mobileVisible: defOpts ? !!defOpts.mobileVisible : true,
    mobileVertical: true,
    mobileTitleBold: true,
    mobileTitleColon: false,
    mobileTitleAlign: '',
    mobileTitleWidth: '',
    mobileTitleWidthUnit: ''
  };
};
const createDefaultFormViewPCFormConfig = params => {
  const {
    formConfig
  } = params;
  return {
    vertical: formConfig.pcVertical,
    titleBold: formConfig.pcTitleBold,
    titleColon: formConfig.pcTitleColon,
    titleAlign: formConfig.pcTitleAlign,
    titleWidth: formConfig.pcTitleWidth
  };
};
const createDefaultFormViewMobileFormConfig = params => {
  const {
    formConfig
  } = params;
  return {
    vertical: formConfig.mobileVertical,
    titleBold: formConfig.mobileTitleBold,
    titleColon: formConfig.mobileTitleColon,
    titleAlign: formConfig.mobileTitleAlign,
    titleWidth: formConfig.mobileTitleWidth
  };
};
;// CONCATENATED MODULE: ./packages/form/src/form-gather.ts




/* harmony default export */ var form_gather = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormGather',
  props: formItemProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const parentFormGather = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormGather', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeForm, props));
    formItem.children = [];
    const formItemInfo = {
      itemConfig: formItem
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', formItemInfo);
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assembleItem($xeForm, refElem.value, formItem, parentFormGather);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeForm, formItem);
    });
    const renderVN = () => {
      const {
        className,
        field
      } = props;
      const span = props.span || ($xeForm ? $xeForm.props.span : null);
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-form--gather vxe-form--item-row', formItem.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $form: $xeForm,
          data: $xeForm ? $xeForm.props.data : {},
          item: formItem,
          field: field,
          property: field
        }) : className : '']
      }, defaultSlot ? defaultSlot({}) : []);
    };
    const $xeFormGather = {
      formItem,
      renderVN
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGather', $xeFormGather);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', null);
    return $xeFormGather;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/form-view.ts










/* harmony default export */ var form_view = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormView',
  props: {
    modelValue: Object,
    config: Object,
    readonly: Boolean,
    disabled: Boolean,
    viewRender: Object,
    createFormConfig: Function
  },
  emits: ['update:modelValue', 'submit', 'reset'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const formRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeFormDesignLayoutStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesignLayoutStyle', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      formConfig: {},
      formRules: {},
      widgetObjList: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeFormView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clearConfig = () => {
      return loadConfig({
        formConfig: {},
        widgetData: []
      });
    };
    const loadConfig = config => {
      if (config) {
        const {
          formConfig,
          widgetData
        } = config;
        loadFormConfig(formConfig || {});
        loadWidgetData(widgetData || []);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const parseConfig = config => {
      const {
        formConfig,
        widgetData
      } = config || {};
      const widgetObjList = parseWidgetData(widgetData || []);
      return {
        ...parseForm(widgetObjList),
        formConfig: parseFormConfig(formConfig || {}),
        widgetData: widgetObjList
      };
    };
    const parseFormConfig = formConfig => {
      const {
        viewRender,
        createFormConfig
      } = props;
      const params = {
        viewRender,
        formConfig
      };
      if (createFormConfig) {
        return createFormConfig(params);
      }
      const {
        name
      } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      return Object.assign({}, createPCFormConfig ? createPCFormConfig(params) : createDefaultFormViewPCFormConfig(params));
    };
    const loadFormConfig = formConfig => {
      reactData.formConfig = parseFormConfig(formConfig);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const parseForm = widgetObjList => {
      const formData = {};
      const formRules = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(widgetObjList, widget => {
        const {
          name,
          field,
          required
        } = widget;
        const compConf = renderer.get(name) || {};
        const createWidgetFieldValue = compConf.createFormDesignWidgetFieldValue;
        const createWidgetFieldRules = compConf.createFormDesignWidgetFieldRules;
        formData[field] = createWidgetFieldValue ? createWidgetFieldValue({
          widget,
          $formView: $xeFormView
        }) : getWidgetDefaultValue(widget);
        if (createWidgetFieldRules) {
          const rules = createWidgetFieldRules({
            widget,
            $formView: $xeFormView
          });
          if (rules && rules.length) {
            formRules[field] = rules;
          }
        } else if (required) {
          formRules[field] = getWidgetDefaultRule();
        }
      }, {
        children: 'children'
      });
      return {
        formData,
        formRules
      };
    };
    const parseWidgetData = widgetData => {
      return (widgetData || []).map(item => configToWidget(item));
    };
    const loadWidgetData = widgetData => {
      const widgetObjList = parseWidgetData(widgetData);
      reactData.widgetObjList = widgetObjList;
      const {
        formData,
        formRules
      } = parseForm(widgetObjList);
      reactData.formRules = formRules;
      emit('update:modelValue', Object.assign(formData, props.modelValue));
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getWidgetDefaultValue = widget => {
      switch (widget.name) {
        case 'subtable':
          return [];
      }
      return null;
    };
    const getWidgetDefaultRule = () => {
      return [{
        required: true,
        content: '该填写该字段！'
      }];
    };
    const updateWidgetStatus = (widget, value) => {
      const {
        field
      } = widget;
      const $form = formRef.value;
      if ($form) {
        $form.updateStatus({
          field
        }, value);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const setItemValue = (widget, value) => {
      const {
        modelValue
      } = props;
      const {
        field
      } = widget;
      const $form = formRef.value;
      if (modelValue) {
        modelValue[field] = value;
      }
      if ($form) {
        $form.updateStatus({
          field
        }, value);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getItemValue = widget => {
      const {
        modelValue
      } = props;
      if (modelValue) {
        return modelValue[widget.field];
      }
      return null;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $formView: $xeFormView
      }, params));
    };
    const toWidgetFields = widget => {
      if (widget) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(widget)) {
          return widget.map(item => item.name);
        } else {
          return [widget.name];
        }
      }
      return null;
    };
    const formViewMethods = {
      dispatchEvent,
      clearConfig,
      loadConfig,
      parseConfig,
      loadFormConfig,
      loadWidgetData,
      updateWidgetStatus,
      setItemValue,
      getItemValue,
      validate() {
        const $form = formRef.value;
        if ($form) {
          return $form.validate();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      validateWidget(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.validateField(toWidgetFields(widget));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearValidate(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.clearValidate(toWidgetFields(widget));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      reset() {
        const $form = formRef.value;
        if ($form) {
          return $form.reset();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 已废弃
       * @deprecated
       */
      updateItemStatus(widget, value) {
        warnLog('vxe.error.delFunc', ['updateItemStatus', 'updateWidgetStatus']);
        return updateWidgetStatus(widget, value);
      }
    };
    const handleSubmit = params => {
      dispatchEvent('submit', params, params.$event);
    };
    const handleReset = params => {
      dispatchEvent('reset', params, params.$event);
    };
    const formViewPrivateMethods = {};
    Object.assign($xeFormView, formViewMethods, formViewPrivateMethods);
    const renderVN = () => {
      const {
        readonly,
        disabled,
        modelValue
      } = props;
      const {
        formConfig,
        formRules,
        widgetObjList
      } = reactData;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-form-view'
      }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-view--top'
      }, getSlotVNs(topSlot({
        $formView: $xeFormView
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        ref: formRef,
        data: modelValue,
        customLayout: true,
        readonly,
        disabled,
        span: 24,
        vertical: formConfig.vertical,
        titleBold: formConfig.titleBold,
        titleColon: formConfig.titleColon,
        titleAlign: formConfig.titleAlign,
        titleWidth: formConfig.titleWidth,
        rules: formRules,
        onSubmit: handleSubmit,
        onReset: handleReset
      }, {
        default() {
          const {
            readonly,
            disabled
          } = props;
          return [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {}, {
            default() {
              return headerSlot({});
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), ...widgetObjList.map(widget => {
            const {
              name
            } = widget;
            const compConf = renderer.get(name) || {};
            const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
            const renderWidgetDesignPreview = compConf.renderFormDesignWidgetPreview;
            const renderWidgetDesignMobilePreview = compConf.renderFormDesignWidgetMobilePreview;
            const isEditMode = !!$xeFormDesignLayoutStyle;
            const renderOpts = widget;
            const params = {
              widget,
              readonly: !!readonly,
              disabled: !!disabled,
              isEditMode,
              isViewMode: !isEditMode,
              $formDesign: null,
              $formView: $xeFormView
            };
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_gather, {
              key: widget.id
            }, {
              default() {
                // 如果处于表单设计器-样式设置-预览模式下
                if ($xeFormDesignLayoutStyle) {
                  if ($xeFormDesignLayoutStyle.reactData.activeTab === 2) {
                    if (renderWidgetDesignMobilePreview) {
                      return getSlotVNs(renderWidgetDesignMobilePreview(renderOpts, params));
                    }
                  } else {
                    if (renderWidgetDesignPreview) {
                      return getSlotVNs(renderWidgetDesignPreview(renderOpts, params));
                    }
                  }
                }
                return renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : [];
              }
            });
          }), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_gather, {
            span: 24
          }, {
            default() {
              return footerSlot({});
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
        }
      }), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-view--bottom'
      }, getSlotVNs(bottomSlot({
        $formView: $xeFormView
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeFormView.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.config, value => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormView', $xeFormView);
    return $xeFormView;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/input/src/date.ts

function date_toStringTimeDate(str) {
  if (str) {
    const rest = new Date();
    let h = 0;
    let m = 0;
    let s = 0;
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDate(str)) {
      h = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[1]);
        m = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[3]);
        s = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[5]);
      }
    }
    rest.setHours(h);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return new Date('');
}
function date_getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
;// CONCATENATED MODULE: ./packages/input/src/number.ts

function handleNumber(val) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val) ? val.replace(/,/g, '') : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test('' + inputValue)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(inputValue, digitsValue), digitsValue);
  }
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(inputValue, digitsValue), digitsValue);
}
;// CONCATENATED MODULE: ./packages/input/src/input.ts









const input_yearSize = 12;
const input_monthSize = 20;
const input_quarterSize = 8;
/* harmony default export */ var input = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeInput',
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'text'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().input.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: 'off'
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().input.size || getConfig().size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().input.exponential
    },
    // number、integer、float、password
    controls: {
      type: Boolean,
      default: () => getConfig().input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => getConfig().input.digits
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => getConfig().input.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'search-click', 'toggle-visible', 'prev-number', 'next-number', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: null,
      panelPlacement: '',
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTimeBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate = (value, format) => {
      const {
        type
      } = props;
      if (type === 'time') {
        return date_toStringTimeDate(value);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const computeTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().input.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeForm) {
        return $xeForm.props.readonly;
      }
      return false;
    });
    const computeIsReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      const maxLen = maxLength || maxlength;
      const isNumType = computeIsNumType.value;
      // 数值最大长度限制 16 位，包含小数
      if (isNumType) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxLen)) {
          return 16;
        }
      }
      return maxLen;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsNumType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['number', 'integer', 'float'].indexOf(props.type) > -1;
    });
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpMaxLength);
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsPawdType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'password';
    });
    const computeIsSearchType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'search';
    });
    const computeDigitsValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(props.digits) || 1;
    });
    const computeStepValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === 'integer') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(step) || 1;
      } else if (type === 'float') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === 'text' || type === 'search');
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.startDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.endDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].includes(props.type);
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return type === 'time' ? 'HH:mm:ss' : type === 'datetime' ? 'yyyy-MM-dd HH:mm:ss' : 'yyyy-MM-dd';
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        datetimePanelValue
      } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(datetimePanelValue, hasTimeSecond ? 'HH:mm:ss' : 'HH:mm');
      }
      return '';
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isDatePickerType) {
        return labelFormat || dateValueFormat || i18n_getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % input_yearSize, 0, 1);
        for (let index = -4; index < input_yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= input_yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter') {
          return i18n_getI18n('vxe.input.date.quarterLabel', [year]);
        } else if (datePanelType === 'month') {
          return i18n_getI18n('vxe.input.date.monthLabel', [year]);
        } else if (datePanelType === 'year') {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        }
        return i18n_getI18n('vxe.input.date.dayLabel', [year, month ? i18n_getI18n(`vxe.input.date.m${month}`) : '-']);
      }
      return '';
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay,
        startWeek
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(startDay) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: i18n_getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: i18n_getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = date_getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < input_quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = date_getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < input_monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        editable,
        multiple
      } = props;
      const isReadonly = computeIsReadonly.value;
      return isReadonly || multiple || !editable || type === 'week' || type === 'quarter';
    });
    const computeInputType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        showPwd
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === 'number') {
        return 'text';
      }
      return type;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().input.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return i18n_getI18n('vxe.base.pleaseInput');
    });
    const computeInpMaxlength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isNumType = computeIsNumType.value;
      const inpMaxLength = computeInpMaxLength.value;
      // 数值最大长度限制 16 位，包含小数
      return isNumType && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpMaxLength) ? 16 : inpMaxLength;
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        immediate
      } = props;
      return immediate || !(type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    });
    const computeNumValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        min
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        max
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const getNumberValue = val => {
      const {
        type,
        exponential
      } = props;
      const inpMaxlength = computeInpMaxlength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === 'float' ? toFloatValueFixed(val, digitsValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val);
      if (exponential && (val === restVal || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val).toLowerCase() === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxlength);
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      inputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      inputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          inputMethods.dispatchEvent('input', {
            value
          }, evnt);
        }
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        inputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    let hidePanelTimeout;
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const {
        type
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ['text', 'search', 'password'].indexOf(type) > -1) {
        focus();
      }
      emitModel('', evnt);
      inputMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        inputMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const dateParseValue = value => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = '';
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
        dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, dateLabelFormat, {
          firstDay: firstDayOfWeek
        });
        // 由于年份和第几周是冲突的行为，所以需要特殊处理，判断是否跨年
        if (dateLabelFormat && type === 'week') {
          const firstWeekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf('yyyy');
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    /**
     * 值变化时处理
     */
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const {
        inputValue
      } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === 'float') {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            emitModel(validValue, {
              type: 'init'
            });
          }
        }
      }
    };
    const validMaxNum = num => {
      return props.max === null || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max);
    };
    const validMinNum = num => {
      return props.min === null || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = date => {
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = date => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      if (multiple) {
        // 如果为多选
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          // 如果是datetime特殊类型
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(dateListValue, val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(date, val, 'yyyyMMdd'));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach(item => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          emitModel(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
            type: 'update'
          });
        } else {
          // 如果是日期类型
          if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
            emitModel(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
              type: 'update'
            });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(','), {
              type: 'update'
            });
          }
        }
      } else {
        // 如果为单选
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          emitModel(inpVal, {
            type: 'update'
          });
        }
      }
    };
    const afterCheckValue = () => {
      const {
        type,
        min,
        max,
        exponential
      } = props;
      const {
        inputValue,
        datetimePanelValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (isNumType) {
          if (inputValue) {
            let inpNumVal = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
            if (!validMinNum(inpNumVal)) {
              inpNumVal = min;
            } else if (!validMaxNum(inpNumVal)) {
              inpNumVal = max;
            }
            if (exponential) {
              const inpStringVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(inputValue).toLowerCase();
              if (inpStringVal === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            emitModel(getNumberValue(inpNumVal), {
              type: 'check'
            });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate(inputValue, dateLabelFormat);
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(inpDateVal)) {
              if (type === 'time') {
                inpDateVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  emitModel(inpDateVal, {
                    type: 'check'
                  });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === 'datetime') {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dateValue, dateLabelFormat) || inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat, {
                  firstDay: firstDayOfWeek
                });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            emitModel('', {
              type: 'check'
            });
          }
        }
      }
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    // 密码
    const passwordToggleEvent = evnt => {
      const {
        showPwd
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!isDisabled && !isReadonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent('toggle-visible', {
        visible: reactData.showPwd
      }, evnt);
    };
    // 密码
    // 搜索
    const searchEvent = evnt => {
      inputMethods.dispatchEvent('search-click', {}, evnt);
    };
    // 搜索
    // 数值
    const numberChange = (isPlus, evnt) => {
      const {
        min,
        max,
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      const newValue = isPlus ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().add(numValue, stepValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    let downbumTimeout;
    const numberNextEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !isReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent('next-number', {}, evnt);
    };
    const numberDownNextEvent = evnt => {
      downbumTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !isReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent('prev-number', {}, evnt);
    };
    const numberKeydownEvent = evnt => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = evnt => {
      const {
        exponential,
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && keyCode >= 65 && keyCode <= 90 || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    // 数值
    const numberStopDown = () => {
      clearTimeout(downbumTimeout);
    };
    const numberDownPrevEvent = evnt => {
      downbumTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = evnt => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, 'is--prev');
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = evnt => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    // 日期
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, offsetMonth, 'first');
    };
    const dateNowHandle = () => {
      const currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -input_yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -input_yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -input_yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        inputMethods.dispatchEvent('date-prev', {
          type
        }, evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent('date-today', {
        type: props.type
      }, evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, input_yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, input_yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, input_yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        inputMethods.dispatchEvent('date-next', {
          type
        }, evnt);
      }
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      return disabledMethod && disabledMethod({
        type: datePanelType,
        viewType: datePanelType,
        date: item.date,
        $input: $xeInput
      });
    };
    const dateSelectItem = date => {
      const {
        type,
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === 'year') {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === 'datetime') {
            // 日期带时间
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = item => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!isDateDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!isDateDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!isDateDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!isDateDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!isDateDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = liElem => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = evnt => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const {
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          // 如果为多选
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            // 如果是datetime特殊类型
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach(item => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            emitModel(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
              type: 'update'
            });
          } else {
            // 如果是日期类型
            emitModel(dateMultipleValue.join(','), {
              type: 'update'
            });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = evnt => {
      const {
        isActivated,
        datePanelValue,
        datePanelType
      } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === 'year') {
          let offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === 'quarter') {
          let offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === 'month') {
          let offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = evnt => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const {
        type
      } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const timeBodyElem = refInputTimeBody.value;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(timeBodyElem.querySelectorAll('li.is--selected'), updateTimePos);
        });
      }
    };
    // 日期
    // 弹出面板
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const transfer = computeTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(targetElem);
          let panelPlacement = 'bottom';
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.top = '';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const datePickerOpenEvent = evnt => {
      const isReadonly = computeIsReadonly.value;
      if (!isReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // 弹出面板
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          // 如果是日期类型
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated,
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $input: $xeInput
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        const labels = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : label)];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // 默认最多支持3个节日重叠
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labels.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-input--date-festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', weekHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--hover': isHover
            },
            // event
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, i18n_getI18n(`vxe.input.date.months.m${item.month}`)));
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, i18n_getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.year));
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-label'
      }, selectDatePanelLabel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn',
        onClick: dateToggleTypeEvent
      }, selectDatePanelLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-prev-btn', {
          'is--disabled': isDisabledPrevDateBtn
        }],
        onClick: datePrevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-left'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-current-btn',
        onClick: dateTodayMonthEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-dot'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-next-btn', {
          'is--disabled': isDisabledNextDateBtn
        }],
        onClick: dateNextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-right'
      })]), multiple && computeSupportMultiples.value ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--date-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, i18n_getI18n('vxe.button.confirm'))]) : null])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-body'
      }, renderDateTable())];
    };
    const renderTimePanel = () => {
      const {
        datetimePanelValue
      } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--time-picker-header'
      }, [hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--time-picker-title'
      }, dateTimeLabel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--time-picker-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--time-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, i18n_getI18n('vxe.button.confirm'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputTimeBody,
        class: 'vxe-input--time-picker-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-hour-list'
      }, hourList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getHours() === item.value
          },
          onClick: evnt => dateHourEvent(evnt, item)
        }, item.label);
      })), hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-minute-list'
      }, minuteList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getMinutes() === item.value
          },
          onClick: evnt => dateMinuteEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), hasTimeMinute && hasTimeSecond ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-second-list'
      }, secondList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getSeconds() === item.value
          },
          onClick: evnt => dateSecondEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])];
    };
    const renderPanel = () => {
      const {
        type
      } = props;
      const {
        inited,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle
      } = reactData;
      const vSize = computeSize.value;
      const transfer = computeTransfer.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === 'datetime') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-input--panel-layout-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-left-wrapper'
          }, renderDatePanel()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-right-wrapper'
          }, renderTimePanel())]));
        } else if (type === 'time') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-input--panel-wrapper'
          }, renderTimePanel()));
        } else {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type || 'default',
            ref: refPanelWrapper,
            class: 'vxe-input--panel-wrapper'
          }, renderDatePanel()));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: transfer ? !inited : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refInputPanel,
          class: ['vxe-table--ignore-clear vxe-input--panel', `type--${type}`, {
            [`size--${vSize}`]: vSize,
            'is--transfer': transfer,
            'ani--leave': isAniVisible,
            'ani--enter': visiblePanel
          }],
          placement: panelPlacement,
          style: panelStyle
        }, renders)]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--number-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--prev', {
          'is--disabled': isDisabledAddNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().NUMBER_INPUT_PREV_NUM
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--next', {
          'is--disabled': isDisabledSubtractNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().NUMBER_INPUT_NEXT_NUM
      })])])]);
    };
    const renderDatePickerIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: datePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    const renderSearchIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: searchEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--search-icon', getIcon().INPUT_SEARCH]
      })]);
    };
    const renderPasswordIcon = () => {
      const {
        showPwd
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: passwordToggleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--password-icon', showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
      })]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--prefix-icon'
      }, prefixSlot ? getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      const isClearable = computeIsClearable.value;
      const isExtraBtn = isPawdType || isNumType || isDatePickerType || isSearchType;
      return isClearable || suffixSlot || suffixIcon || isExtraBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), isExtraBtn ? renderExtraSuffixIcon() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : null;
    };
    const renderExtraSuffixIcon = () => {
      const {
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      if (isPawdType) {
        return renderPasswordIcon();
      }
      if (isNumType) {
        if (controls) {
          return renderNumberIcon();
        }
      }
      if (isDatePickerType) {
        return renderDatePickerIcon();
      }
      if (isSearchType) {
        return renderSearchIcon();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    inputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $input: $xeInput
        }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeInput, inputMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeInput, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeInput, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeInput, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeInput, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      numberStopDown();
      globalEvents.off($xeInput, 'mousewheel');
      globalEvents.off($xeInput, 'mousedown');
      globalEvents.off($xeInput, 'keydown');
      globalEvents.off($xeInput, 'blur');
    });
    initValue();
    const renderVN = () => {
      const {
        className,
        controls,
        type,
        align,
        showWordCount,
        countMethod,
        name,
        autoComplete,
        autocomplete
      } = props;
      const {
        inputValue,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-input--readonly', `type--${type}`, className]
        }, inputValue);
      }
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxlength = computeInpMaxlength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const isWordCount = showWordCount && ['text', 'search'].includes(type);
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-input', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--controls': controls,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--count': isWordCount,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-input--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        maxlength: inpMaxlength,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete || autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      // 下拉面板
      renderPanel(),
      // 字数统计
      isWordCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--count', {
          'is--error': isCountError
        }]
      }, countMethod ? `${countMethod({
        value: inputValue
      })}` : `${inputCount}${inpMaxlength ? `/${inpMaxlength}` : ''}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/radio/src/radio.ts




/* harmony default export */ var src_radio = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeRadio',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: {
      type: Boolean,
      default: () => getConfig().radio.strict
    },
    size: {
      type: String,
      default: () => getConfig().radio.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeRadioGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRadioGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeRadio = {
      xID,
      props,
      context
    };
    const {
      computeSize
    } = useSize(props);
    let radioMethods = {};
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const {
            computeIsDisabled
          } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled.value;
        }
      }
      return disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : props.name;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        label
      } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({
          label
        }, evnt);
      } else {
        emit('update:modelValue', label);
        radioMethods.dispatchEvent('change', {
          label
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    radioMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $radio: $xeRadio
        }, params));
      }
    };
    Object.assign($xeRadio, radioMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        class: ['vxe-radio', {
          [`size--${vSize}`]: vSize,
          'is--checked': isChecked,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked: isChecked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-radio--icon', isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeRadio.renderVN = renderVN;
    return $xeRadio;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/radio/src/button.ts




/* harmony default export */ var radio_src_button = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeRadioButton',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: {
      type: Boolean,
      default: () => getConfig().radioButton.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioButton.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const xeFormItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeRadioGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRadioGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const $xeRadioButton = {
      xID,
      props,
      context
    };
    let radioButtonMethods = {};
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const {
            computeIsDisabled
          } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled.value;
        }
      }
      return disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : null;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        label
      } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : modelValue === label;
    });
    radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $radioButton: $xeRadioButton
        }, params));
      }
    };
    Object.assign($xeRadioButton, radioButtonMethods);
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({
          label
        }, evnt);
      } else {
        emit('update:modelValue', label);
        radioButtonMethods.dispatchEvent('change', {
          label
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && xeFormItemInfo) {
          $xeForm.triggerItemEvent(evnt, xeFormItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const checked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        class: ['vxe-radio', 'vxe-radio-button', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    Object.assign($xeRadioButton, {
      renderVN,
      dispatchEvent
    });
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/radio/src/group.ts





/* harmony default export */ var src_group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeRadioGroup',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => getConfig().radioGroup.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioGroup.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaps = {
      computeIsDisabled
    };
    const $xeradiogroup = {
      xID,
      props,
      context,
      name: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('xegroup_'),
      getComputeMaps: () => computeMaps
    };
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    let radioGroupMethods = {};
    useSize(props);
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        emit('update:modelValue', params.label);
        radioGroupMethods.dispatchEvent('change', params, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, params.label);
        }
      }
    };
    radioGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $radioGroup: $xeradiogroup
        }, params));
      }
    };
    const renderVN = () => {
      const {
        options,
        type
      } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === 'button' ? radio_src_button : src_radio;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-radio-group'
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(btnComp, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    Object.assign($xeradiogroup, radioGroupPrivateMethods, {
      renderVN,
      dispatchEvent
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeRadioGroup', $xeradiogroup);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/select/src/select.ts








function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('opt_');
}
/* harmony default export */ var src_select = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeSelect',
  props: {
    modelValue: [String, Number, Boolean, Array],
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => getConfig().select.multiCharOverflow
    },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    // 已废弃，被 option-config.keyField 替换
    optionId: {
      type: String,
      default: () => getConfig().select.optionId
    },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'blur', 'focus', 'click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      staticOptions: [],
      fullGroupList: [],
      fullOptionList: [],
      visibleGroupList: [],
      visibleOptionList: [],
      remoteValueList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      currentOption: null,
      currentValue: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      searchValue: '',
      searchLoading: false
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInpSearch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let selectMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return i18n_getI18n('vxe.base.pleaseSelect');
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeGroupPropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionGroupProps || {};
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeGroupLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || 'label';
    });
    const computeGroupOptionsField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || 'options';
    });
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple,
        max
      } = props;
      if (multiple && max) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue.length : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? 0 : 1) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const computeOptionOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().select.optionConfig, props.optionConfig);
    });
    const computeIsGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.fullGroupList.some(item => item.options && item.options.length);
    });
    const computeMultiMaxCharNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.multiCharOverflow);
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const findOption = optionValue => {
      const {
        fullOptionList,
        fullGroupList
      } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      if (isGroup) {
        for (let gIndex = 0; gIndex < fullGroupList.length; gIndex++) {
          const group = fullGroupList[gIndex];
          if (group.options) {
            for (let index = 0; index < group.options.length; index++) {
              const option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return fullOptionList.find(item => optionValue === item[valueField]);
    };
    const findVisibleOption = optionValue => {
      const {
        visibleOptionList,
        visibleGroupList
      } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      if (isGroup) {
        for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          const group = visibleGroupList[gIndex];
          if (group.options) {
            for (let index = 0; index < group.options.length; index++) {
              const option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return visibleOptionList.find(item => optionValue === item[valueField]);
    };
    const getRemoteSelectLabel = value => {
      const {
        remoteValueList
      } = reactData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValueList.find(item => value === item.key);
      const item = remoteItem ? remoteItem.result : null;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = value => {
      const labelField = computeLabelField.value;
      const item = findOption(value);
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(item ? item[labelField] : value);
    };
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple,
        remote
      } = props;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (modelValue && multiple) {
        const vals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
        if (remote) {
          return vals.map(val => getRemoteSelectLabel(val)).join(', ');
        }
        return vals.map(val => {
          const label = getSelectLabel(val);
          if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
            return `${label.substring(0, multiMaxCharNum)}...`;
          }
          return label;
        }).join(', ');
      }
      if (remote) {
        return getRemoteSelectLabel(modelValue);
      }
      return getSelectLabel(modelValue);
    });
    const getOptkey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';
    };
    const getOptid = option => {
      const optid = option[getOptkey()];
      return optid ? encodeURIComponent(optid) : '';
    };
    /**
     * 刷新选项，当选项被动态显示/隐藏时可能会用到
     */
    const refreshOption = () => {
      const {
        filterable,
        filterMethod
      } = props;
      const {
        fullOptionList,
        fullGroupList,
        searchValue
      } = reactData;
      const isGroup = computeIsGroup.value;
      const groupLabelField = computeGroupLabelField.value;
      const labelField = computeLabelField.value;
      if (isGroup) {
        if (filterable && filterMethod) {
          reactData.visibleGroupList = fullGroupList.filter(group => isOptionVisible(group) && filterMethod({
            group,
            option: null,
            searchValue
          }));
        } else if (filterable) {
          reactData.visibleGroupList = fullGroupList.filter(group => isOptionVisible(group) && (!searchValue || `${group[groupLabelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);
        }
      } else {
        if (filterable && filterMethod) {
          reactData.visibleOptionList = fullOptionList.filter(option => isOptionVisible(option) && filterMethod({
            group: null,
            option,
            searchValue
          }));
        } else if (filterable) {
          reactData.visibleOptionList = fullOptionList.filter(option => isOptionVisible(option) && (!searchValue || `${option[labelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const cacheItemMap = () => {
      const {
        fullOptionList,
        fullGroupList
      } = reactData;
      const groupOptionsField = computeGroupOptionsField.value;
      const key = getOptkey();
      const handleOptis = item => {
        if (!getOptid(item)) {
          item[key] = getOptUniqueId();
        }
      };
      if (fullGroupList.length) {
        fullGroupList.forEach(group => {
          handleOptis(group);
          if (group[groupOptionsField]) {
            group[groupOptionsField].forEach(handleOptis);
          }
        });
      } else if (fullOptionList.length) {
        fullOptionList.forEach(handleOptis);
      }
      refreshOption();
    };
    const setCurrentOption = option => {
      const valueField = computeValueField.value;
      if (option) {
        reactData.currentOption = option;
        reactData.currentValue = option[valueField];
      }
    };
    const scrollToOption = (option, isAlignBottom) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        if (option) {
          const optWrapperElem = refOptionWrapper.value;
          const panelElem = refOptionPanel.value;
          const optElem = panelElem.querySelector(`[optid='${getOptid(option)}']`);
          if (optWrapperElem && optElem) {
            const wrapperHeight = optWrapperElem.offsetHeight;
            const offsetPadding = 5;
            if (isAlignBottom) {
              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
              }
            } else {
              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
              }
            }
          }
        }
      });
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(el);
          let panelPlacement = 'bottom';
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const {
        loading,
        filterable
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading && !isDisabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          refreshOption();
        }
        setTimeout(() => {
          const {
            modelValue
          } = props;
          const currOption = findOption(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue[0] : modelValue);
          reactData.visiblePanel = true;
          if (currOption) {
            setCurrentOption(currOption);
            scrollToOption(currOption);
          }
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = '';
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      if (selectValue !== props.modelValue) {
        emit('update:modelValue', selectValue);
        selectMethods.dispatchEvent('change', {
          value: selectValue
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      reactData.remoteValueList = [];
      changeEvent(evnt, selectValue);
      selectMethods.dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, selectValue, option) => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        remoteValueList
      } = reactData;
      if (multiple) {
        let multipleValue = [];
        const selectVals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
        const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(selectVals, val => val === selectValue);
        if (index === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter(val => val !== selectValue);
        }
        const remoteItem = remoteValueList.find(item => item.key === selectValue);
        if (remoteItem) {
          remoteItem.result = option;
        } else {
          remoteValueList.push({
            key: selectValue,
            result: option
          });
        }
        changeEvent(evnt, multipleValue);
      } else {
        reactData.remoteValueList = [{
          key: selectValue,
          result: option
        }];
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const findOffsetOption = (optionValue, isUpArrow) => {
      const {
        visibleOptionList,
        visibleGroupList
      } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      let firstOption;
      let prevOption;
      let nextOption;
      let currOption;
      if (isGroup) {
        for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          const group = visibleGroupList[gIndex];
          const groupOptionList = group[groupOptionsField];
          const isGroupDisabled = group.disabled;
          if (groupOptionList) {
            for (let index = 0; index < groupOptionList.length; index++) {
              const option = groupOptionList[index];
              const isVisible = isOptionVisible(option);
              const isDisabled = isGroupDisabled || option.disabled;
              if (!firstOption && !isDisabled) {
                firstOption = option;
              }
              if (currOption) {
                if (isVisible && !isDisabled) {
                  nextOption = option;
                  if (!isUpArrow) {
                    return {
                      offsetOption: nextOption
                    };
                  }
                }
              }
              if (optionValue === option[valueField]) {
                currOption = option;
                if (isUpArrow) {
                  return {
                    offsetOption: prevOption
                  };
                }
              } else {
                if (isVisible && !isDisabled) {
                  prevOption = option;
                }
              }
            }
          }
        }
      } else {
        for (let index = 0; index < visibleOptionList.length; index++) {
          const option = visibleOptionList[index];
          const isDisabled = option.disabled;
          if (!firstOption && !isDisabled) {
            firstOption = option;
          }
          if (currOption) {
            if (!isDisabled) {
              nextOption = option;
              if (!isUpArrow) {
                return {
                  offsetOption: nextOption
                };
              }
            }
          }
          if (optionValue === option[valueField]) {
            currOption = option;
            if (isUpArrow) {
              return {
                offsetOption: prevOption
              };
            }
          } else {
            if (!isDisabled) {
              prevOption = option;
            }
          }
        }
      }
      return {
        firstOption
      };
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel,
        currentValue,
        currentOption
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentValue, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let {
              firstOption,
              offsetOption
            } = findOffsetOption(currentValue, isUpArrow);
            if (!offsetOption && !findVisibleOption(currentValue)) {
              offsetOption = firstOption;
            }
            setCurrentOption(offsetOption);
            scrollToOption(offsetOption, isDwArrow);
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      selectMethods.dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      selectMethods.dispatchEvent('click', {}, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      selectMethods.dispatchEvent('blur', {}, evnt);
    };
    const modelSearchEvent = value => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const triggerSearchEvent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(function () {
      const {
        remote,
        remoteMethod
      } = props;
      const {
        searchValue
      } = reactData;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({
          searchValue
        })).then(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).catch(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).finally(() => {
          reactData.searchLoading = false;
          refreshOption();
        });
      } else {
        refreshOption();
      }
    }, 350, {
      trailing: true
    });
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const checkOptionDisabled = (isSelected, option, group) => {
      if (option.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const renderOption = (list, group) => {
      const {
        optionKey,
        modelValue
      } = props;
      const {
        currentValue
      } = reactData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const isGroup = computeIsGroup.value;
      const {
        useKey
      } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const {
          slots,
          className
        } = option;
        const optionValue = option[valueField];
        const isSelected = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue.indexOf(optionValue) > -1 : modelValue === optionValue;
        const isVisible = !isGroup || isOptionVisible(option);
        const isDisabled = checkOptionDisabled(isSelected, option, group);
        const optid = getOptid(option);
        const defaultSlot = slots ? slots.default : null;
        const optParams = {
          option,
          group: null,
          $select: $xeSelect
        };
        return isVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: useKey || optionKey ? optid : cIndex,
          class: ['vxe-select-option', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(optParams) : className : '', {
            'is--disabled': isDisabled,
            'is--selected': isSelected,
            'is--hover': currentValue === optionValue
          }],
          // attrs
          optid: optid,
          // event
          onMousedown: evnt => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: evnt => {
            if (!isDisabled) {
              changeOptionEvent(evnt, optionValue, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled) {
              setCurrentOption(option);
            }
          }
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(option[labelField])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      });
    };
    const renderOptgroup = () => {
      const {
        optionKey
      } = props;
      const {
        visibleGroupList
      } = reactData;
      const optionOpts = computeOptionOpts.value;
      const groupLabelField = computeGroupLabelField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      const {
        useKey
      } = optionOpts;
      const optionSlot = slots.option;
      return visibleGroupList.map((group, gIndex) => {
        const {
          slots,
          className
        } = group;
        const optid = getOptid(group);
        const isGroupDisabled = group.disabled;
        const defaultSlot = slots ? slots.default : null;
        const optParams = {
          option: group,
          group,
          $select: $xeSelect
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: useKey || optionKey ? optid : gIndex,
          class: ['vxe-optgroup', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(optParams) : className : '', {
            'is--disabled': isGroupDisabled
          }],
          // attrs
          optid: optid
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-optgroup--title'
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(group[groupLabelField])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-optgroup--wrapper'
        }, renderOption(group[groupOptionsField] || [], group))]);
      });
    };
    const renderOpts = () => {
      const {
        visibleGroupList,
        visibleOptionList,
        searchLoading
      } = reactData;
      const isGroup = computeIsGroup.value;
      if (searchLoading) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-select--search-loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-select--search-icon', getIcon().SELECT_LOADED]
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-select--search-text'
        }, i18n_getI18n('vxe.select.loadingText'))])];
      }
      if (isGroup) {
        if (visibleGroupList.length) {
          return renderOptgroup();
        }
      } else {
        if (visibleOptionList.length) {
          return renderOption(visibleOptionList);
        }
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--empty-placeholder'
      }, props.emptyText || i18n_getI18n('vxe.select.emptyText'))];
    };
    selectMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $select: $xeSelect
        }, params));
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      refreshOption,
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeSelect, selectMethods);
    const renderVN = () => {
      const {
        className,
        popupClassName,
        loading,
        filterable
      } = props;
      const {
        initialized,
        isActivated,
        visiblePanel
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const transfer = computeTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-select-slots',
          ref: 'hideOption'
        }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-select-label'
        }, selectLabel)]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $select: $xeSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--filter': filterable,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select-slots',
        ref: 'hideOption'
      }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: inpPlaceholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().SELECT_LOADED : visiblePanel ? getIcon().SELECT_OPEN : getIcon().SELECT_CLOSE,
        modelValue: selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: togglePanelEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: transfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $select: $xeSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': transfer,
          'ani--leave': !loading && reactData.isAniVisible,
          'ani--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized ? [filterable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-search'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInpSearch,
        class: 'vxe-select-search--input',
        modelValue: reactData.searchValue,
        clearable: true,
        placeholder: i18n_getI18n('vxe.select.search'),
        prefixIcon: getIcon().INPUT_SEARCH,
        'onUpdate:modelValue': modelSearchEvent,
        onFocus: focusSearchEvent,
        onChange: triggerSearchEvent,
        onSearch: triggerSearchEvent
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-header'
      }, headerSlot({})) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionWrapper,
        class: 'vxe-select-option--wrapper'
      }, renderOpts())]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-footer'
      }, footerSlot({})) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])] : [])])]);
    };
    $xeSelect.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticOptions, value => {
      if (value.some(item => item.options && item.options.length)) {
        reactData.fullOptionList = [];
        reactData.fullGroupList = value;
      } else {
        reactData.fullGroupList = [];
        reactData.fullOptionList = value || [];
      }
      cacheItemMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, value => {
      reactData.fullGroupList = [];
      reactData.fullOptionList = value || [];
      cacheItemMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.optionGroups, value => {
      reactData.fullOptionList = [];
      reactData.fullGroupList = value || [];
      cacheItemMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          options,
          optionGroups
        } = props;
        if (optionGroups) {
          reactData.fullGroupList = optionGroups;
        } else if (options) {
          reactData.fullOptionList = options;
        }
        cacheItemMap();
      });
      globalEvents.on($xeSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeSelect, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeSelect, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeSelect, 'mousewheel');
      globalEvents.off($xeSelect, 'mousedown');
      globalEvents.off($xeSelect, 'keydown');
      globalEvents.off($xeSelect, 'blur');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeSelect', $xeSelect);
    return $xeSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/default-style-form.ts







const getBoldOptions = () => {
  return [{
    label: i18n_getI18n('vxe.formDesign.styleSetting.fontNormal'),
    value: false
  }, {
    label: i18n_getI18n('vxe.formDesign.styleSetting.fontBold'),
    value: true
  }];
};
const getColonOptions = () => {
  return [{
    label: i18n_getI18n('vxe.formDesign.styleSetting.colonVisible'),
    value: true
  }, {
    label: i18n_getI18n('vxe.formDesign.styleSetting.colonHidden'),
    value: false
  }];
};
const getAlignOptions = () => {
  return [{
    label: i18n_getI18n('vxe.formDesign.styleSetting.alignLeft'),
    value: ''
  }, {
    label: i18n_getI18n('vxe.formDesign.styleSetting.alignRight'),
    value: 'right'
  }];
};
const getWidthUnitOptions = () => {
  return [{
    label: i18n_getI18n('vxe.formDesign.styleSetting.unitPx'),
    value: ''
  }, {
    label: i18n_getI18n('vxe.formDesign.styleSetting.unitPct'),
    value: '%'
  }];
};
const renderLayoutOption = (formData, field, type, changeEvent) => {
  const isVertical = type === 'vertical';
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: ['vxe-form-design--widget-form-item-option', `is--${type}`, {
      'is--active': isVertical ? formData[field] : !formData[field]
    }],
    onClick() {
      formData[field] = isVertical;
      changeEvent();
    }
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form-design--widget-form-item-option-row'
  }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form-design--widget-form-item-option-row'
  }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, isVertical ? i18n_getI18n('vxe.formDesign.styleSetting.verticalLayout') : i18n_getI18n('vxe.formDesign.styleSetting.horizontalLayout'))]);
};
const DefaultPCStyleFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'DefaultPCStyleForm',
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    const verticalField = 'pcVertical';
    const refBoldOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getBoldOptions());
    const refColonOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getColonOptions());
    const refAlignOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getAlignOptions());
    const refWidthUnitOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const {
        formData
      } = props;
      if (!formData.pcTitleWidth) {
        formData.pcTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const {
        formData
      } = props;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.styleSetting.layoutTitle'),
            field: verticalField
          }, {
            default() {
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-layout'
              }, [renderLayoutOption(formData, verticalField, 'vertical', changeLayoutEvent), renderLayoutOption(formData, verticalField, 'horizontal', changeLayoutEvent)])];
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.styleSetting.styleTitle')
          }, {
            default() {
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.boldTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.pcTitleBold,
                options: refBoldOpts.value,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.pcTitleBold = val;
                }
              })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.colonTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.pcTitleColon,
                options: refColonOpts.value,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.pcTitleColon = val;
                }
              })]), formData.pcVertical ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.alignTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.pcTitleAlign,
                options: refAlignOpts.value,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.pcTitleAlign = val;
                }
              })]), formData.pcVertical ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.widthTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                class: 'vxe-form-design--widget-form-item-prop-width',
                modelValue: formData.pcTitleWidth,
                type: 'integer',
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.pcTitleWidth = val;
                }
              }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
                class: 'vxe-form-design--widget-form-item-prop-unit',
                modelValue: formData.pcTitleWidthUnit,
                options: refWidthUnitOpts.value,
                transfer: true,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.pcTitleWidthUnit = val;
                }
              })])];
            }
          })];
        }
      });
    };
  }
});
const DefaultMobileStyleFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'DefaultMobileStyleForm',
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    const verticalField = 'mobileVertical';
    const refBoldOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getBoldOptions());
    const refColonOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getColonOptions());
    const refAlignOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getAlignOptions());
    const refWidthUnitOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const {
        formData
      } = props;
      if (!formData.mobileTitleWidth) {
        formData.mobileTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const {
        formData
      } = props;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.styleSetting.layoutTitle'),
            field: verticalField
          }, {
            default() {
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-layout'
              }, [renderLayoutOption(formData, verticalField, 'vertical', changeLayoutEvent), renderLayoutOption(formData, verticalField, 'horizontal', changeLayoutEvent)])];
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.styleSetting.styleTitle')
          }, {
            default() {
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.boldTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.mobileTitleBold,
                options: refBoldOpts.value,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.mobileTitleBold = val;
                }
              })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.colonTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.mobileTitleColon,
                options: refColonOpts.value,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.mobileTitleColon = val;
                }
              })]), formData.mobileVertical ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.alignTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.mobileTitleAlign,
                options: refAlignOpts.value,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.mobileTitleAlign = val;
                }
              })]), formData.mobileVertical ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.formDesign.styleSetting.widthTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                class: 'vxe-form-design--widget-form-item-prop-width',
                modelValue: formData.mobileTitleWidth,
                type: 'integer',
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.mobileTitleWidth = val;
                }
              }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
                class: 'vxe-form-design--widget-form-item-prop-unit',
                modelValue: formData.mobileTitleWidthUnit,
                options: refWidthUnitOpts.value,
                transfer: true,
                onChange: refreshPreview,
                'onUpdate:modelValue'(val) {
                  formData.mobileTitleWidthUnit = val;
                }
              })])];
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/src/layout-style.ts










/* harmony default export */ var layout_style = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'FormDesignLayoutStyle',
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeTab: 1
    });
    const $xeFormDesignLayoutStyle = {
      reactData,
      renderVN() {
        return [];
      }
    };
    if (!$xeFormDesign) {
      return $xeFormDesignLayoutStyle;
    }
    const {
      props: formDesignProps,
      reactData: formDesignReactData
    } = $xeFormDesign;
    const settingVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const settingConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const settingFormData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
    const updatePreviewView = () => {
      settingConfig.value = $xeFormDesign.getConfig();
    };
    const createFormViewFormConfig = params => {
      const {
        viewRender
      } = params;
      const {
        activeTab
      } = reactData;
      const {
        name
      } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      const createMobileFormConfig = compConf ? compConf.createFormViewMobileFormConfig : null;
      if (activeTab === 2) {
        if (createMobileFormConfig) {
          return createMobileFormConfig(params);
        }
        return createDefaultFormViewMobileFormConfig(params);
      }
      if (createPCFormConfig) {
        return createPCFormConfig(params);
      }
      return createDefaultFormViewPCFormConfig(params);
    };
    const formDesignLayoutStyleMethod = {
      updatePreviewView,
      openStylePreview() {
        const {
          showPc
        } = formDesignProps;
        updatePreviewView();
        reactData.activeTab = showPc ? 1 : 2;
        settingVisible.value = true;
      }
    };
    Object.assign($xeFormDesignLayoutStyle, formDesignLayoutStyleMethod);
    const renderStylePreview = () => {
      const {
        activeTab
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form-design--layout-style-preview', `is--${activeTab === 2 ? 'mobile' : 'pc'}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_view, {
        modelValue: settingFormData.value,
        config: settingConfig.value,
        createFormConfig: createFormViewFormConfig,
        'onUpdate:modelValue'(val) {
          settingFormData.value = val;
        }
      })]);
    };
    const renderMobileStyle = () => {
      const {
        formRender
      } = formDesignProps;
      const {
        formData
      } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingMobileFormView = compConf ? compConf.renderFormDesignMobileStyleFormView : null;
        if (renderSettingMobileFormView) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--custom-setting-mobile-form-view'
          }, getSlotVNs(renderSettingMobileFormView({}, {
            $formDesign: $xeFormDesign,
            formConfig: formData
          })));
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(DefaultMobileStyleFormComponent, {
        formData
      });
    };
    const renderPCStyle = () => {
      const {
        formRender
      } = formDesignProps;
      const {
        formData
      } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderStylePCFormView = compConf ? compConf.renderFormDesignStyleFormView : null;
        if (renderStylePCFormView) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--custom-setting-pc-form-view'
          }, getSlotVNs(renderStylePCFormView({}, {
            $formDesign: $xeFormDesign,
            formConfig: formData
          })));
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(DefaultPCStyleFormComponent, {
        formData
      });
    };
    const renderStyleSetting = () => {
      const {
        showPc,
        showMobile
      } = formDesignProps;
      const {
        activeTab
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--layout-style-setting'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tabs, {
        modelValue: activeTab,
        titleWidth: showPc && showMobile ? '50%' : '100%',
        titleAlign: 'center',
        padding: true,
        onChange: updatePreviewView,
        'onUpdate:modelValue'(val) {
          reactData.activeTab = val;
        }
      }, {
        default() {
          const tabVNs = [];
          if (showPc) {
            tabVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tab_pane, {
              title: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.pc'),
              icon: getIcon().FORM_DESIGN_PROPS_PC,
              k: 1,
              name: 1
            }, {
              default() {
                return renderPCStyle();
              }
            }));
          }
          if (showMobile) {
            tabVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tab_pane, {
              title: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.mobile'),
              icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
              key: 2,
              name: 2
            }, {
              default() {
                return renderMobileStyle();
              }
            }));
          }
          return tabVNs;
        }
      })]);
    };
    const renderVN = () => {
      const {
        showPc,
        showMobile
      } = formDesignProps;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(modal, {
        modelValue: settingVisible.value,
        title: i18n_getI18n('vxe.formDesign.styleSetting.title'),
        height: '90vh',
        width: '90vw',
        escClosable: true,
        maskClosable: true,
        destroyOnClose: true,
        showMaximize: true,
        transfer: true,
        'onUpdate:modelValue'(val) {
          settingVisible.value = val;
        }
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--layout-style'
          }, [renderStylePreview(), showPc || showMobile ? renderStyleSetting() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
        }
      });
    };
    $xeFormDesignLayoutStyle.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormDesignLayoutStyle', $xeFormDesignLayoutStyle);
    return $xeFormDesignLayoutStyle;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/form-design.ts












/* harmony default export */ var form_design = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormDesign',
  props: {
    size: {
      type: String,
      default: () => getConfig().formDesign.size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().formDesign.height
    },
    widgets: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().formDesign.widgets) || []
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().formDesign.showHeader
    },
    showPc: {
      type: Boolean,
      default: () => getConfig().formDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().formDesign.showMobile
    },
    formRender: Object
  },
  emits: ['click-widget', 'add-widget', 'copy-widget', 'remove-widget', 'drag-widget'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refLayoutStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      formData: {},
      widgetConfigs: [],
      widgetObjList: [],
      dragWidget: null,
      sortWidget: null,
      activeWidget: null,
      sortSubWidget: null
    });
    const internalData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeFormDesign = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const createWidget = name => {
      return new FormDesignWidgetInfo($xeFormDesign, name, reactData.widgetObjList);
    };
    const createEmptyWidget = () => {
      return new FormDesignWidgetInfo($xeFormDesign, '', reactData.widgetObjList);
    };
    const loadConfig = config => {
      if (config) {
        const {
          formConfig,
          widgetData
        } = config;
        if (formConfig) {
          loadFormConfig(formConfig);
        }
        if (widgetData) {
          loadWidgetData(widgetData);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const reloadConfig = config => {
      clearConfig();
      return loadConfig(config);
    };
    const getFormConfig = () => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(reactData.formData, true);
    };
    const loadFormConfig = data => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getWidgetData = () => {
      const objList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(reactData.widgetObjList, true);
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(objList, item => {
        item.model.value = null;
      }, {
        children: 'children'
      });
      return objList;
    };
    const loadWidgetData = widgetData => {
      reactData.widgetObjList = (widgetData || []).map(item => configToWidget(item));
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const openStyleSetting = () => {
      const $layoutStyle = refLayoutStyle.value;
      if ($layoutStyle) {
        $layoutStyle.openStylePreview();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const clearConfig = () => {
      reactData.widgetObjList = [];
      initSettingForm();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const formDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $xeFormDesign
        }, params));
      },
      createWidget,
      createEmptyWidget,
      getConfig() {
        return {
          formConfig: getFormConfig(),
          widgetData: getWidgetData()
        };
      },
      clearConfig,
      loadConfig,
      reloadConfig,
      getFormConfig,
      loadFormConfig,
      getFormData() {
        const {
          widgetObjList
        } = reactData;
        const formData = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(widgetObjList, widget => {
          formData[widget.field] = null;
        }, {
          children: 'children'
        });
        return formData;
      },
      getWidgetData,
      loadWidgetData,
      refreshPreviewView() {
        const $layoutStyle = refLayoutStyle.value;
        if ($layoutStyle) {
          $layoutStyle.updatePreviewView();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      openStyleSetting
    };
    const updateWidgetConfigs = () => {
      const {
        widgets
      } = props;
      const widgetConfs = [];
      const baseWidgets = [];
      const layoutWidgets = [];
      const advancedWidgets = [];
      const customGroups = [];
      renderer.forEach((item, name) => {
        const {
          createFormDesignWidgetConfig
        } = item;
        if (createFormDesignWidgetConfig) {
          const widthItem = createWidget(name);
          const widgetGroup = getWidgetConfigGroup(name);
          const widgetCustomGroup = getWidgetConfigCustomGroup(name, $xeFormDesign);
          // 如果自定义组
          if (widgetCustomGroup) {
            const cusGroup = customGroups.find(item => item.title === widgetCustomGroup);
            if (cusGroup) {
              cusGroup.children.push(widthItem);
            } else {
              customGroups.push({
                title: widgetCustomGroup,
                children: [widthItem]
              });
            }
          } else {
            switch (widgetGroup) {
              case 'layout':
                layoutWidgets.push(widthItem);
                break;
              case 'advanced':
                advancedWidgets.push(widthItem);
                break;
              default:
                // 已废弃 title
                if (!['title'].includes(widthItem.name)) {
                  baseWidgets.push(widthItem);
                }
                break;
            }
          }
        }
      });
      if (baseWidgets.length) {
        widgetConfs.push({
          group: 'base',
          children: baseWidgets
        });
      }
      if (layoutWidgets.length) {
        widgetConfs.push({
          group: 'layout',
          children: layoutWidgets
        });
      }
      if (advancedWidgets.length) {
        widgetConfs.push({
          group: 'advanced',
          children: advancedWidgets
        });
      }
      if (customGroups.length) {
        widgetConfs.push(...customGroups);
      }
      if (widgets && widgets.length) {
        reactData.widgetConfigs = props.widgets.map(config => {
          return {
            title: config.customGroup,
            group: config.group,
            children: config.children ? config.children.map(name => {
              const widthItem = createWidget(name);
              return widthItem;
            }) : []
          };
        });
      } else {
        reactData.widgetConfigs = widgetConfs;
      }
    };
    const validWidgetUnique = widgetName => {
      const {
        widgetObjList
      } = reactData;
      const uniqueConf = getWidgetConfigUnique(widgetName);
      if (uniqueConf) {
        const existWidgetList = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(widgetObjList, obj => {
          if (obj.name === widgetName) {
            existWidgetList.push(obj);
          }
        }, {
          children: 'children'
        });
        const status = existWidgetList.length < 1;
        if (!status) {
          if (core_VxeUI.modal) {
            core_VxeUI.modal.message({
              content: i18n_getI18n('vxe.formDesign.error.wdFormUni'),
              status: 'error',
              id: 'wdFormUni'
            });
          }
        }
        return status;
      }
      return true;
    };
    const formDesignPrivateMethods = {
      validWidgetUnique,
      handleClickWidget(evnt, item) {
        if (item && item.name) {
          evnt.stopPropagation();
          reactData.activeWidget = item;
          formDesignMethods.dispatchEvent('click-widget', {
            widget: item
          }, evnt);
        }
      },
      handleCopyWidget(evnt, widget) {
        const {
          widgetObjList
        } = reactData;
        const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, obj => obj.id === widget.id, {
          children: 'children'
        });
        if (rest) {
          evnt.stopPropagation();
          if (validWidgetUnique(widget.name)) {
            const {
              path
            } = rest;
            const rootIndex = Number(path[0]);
            const newWidget = createWidget(widget.name);
            // 标题副本
            if (newWidget.title) {
              newWidget.title = i18n_getI18n('vxe.formDesign.widget.copyTitle', [`${widget.title}`.replace(i18n_getI18n('vxe.formDesign.widget.copyTitle', ['']), '')]);
            }
            if (rootIndex >= widgetObjList.length - 1) {
              widgetObjList.push(newWidget);
            } else {
              widgetObjList.splice(rootIndex + 1, 0, newWidget);
            }
            reactData.activeWidget = newWidget;
            reactData.widgetObjList = [...widgetObjList];
            formDesignMethods.dispatchEvent('copy-widget', {
              widget,
              newWidget
            }, evnt);
          }
        }
      },
      handleRemoveWidget(evnt, widget) {
        const {
          widgetObjList
        } = reactData;
        const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, obj => obj.id === widget.id, {
          children: 'children'
        });
        if (rest) {
          const {
            index,
            parent,
            items
          } = rest;
          evnt.stopPropagation();
          if (index >= items.length - 1) {
            reactData.activeWidget = items[index - 1];
          } else {
            reactData.activeWidget = items[index + 1] || null;
          }
          // 如果是行控件，使用空的控件占位
          if (parent && parent.name === 'row') {
            items[index] = createEmptyWidget();
          } else {
            items.splice(index, 1);
          }
          reactData.widgetObjList = [...widgetObjList];
          formDesignMethods.dispatchEvent('remove-widget', {
            widget
          }, evnt);
        }
      }
    };
    const createSettingForm = () => {
      const {
        formRender,
        showPc,
        showMobile
      } = props;
      let conf = getDefaultSettingFormData({
        pcVisible: showPc,
        mobileVisible: showMobile
      });
      // 如果为自定义渲染
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createFormDesignSettingFormConfig : null;
        conf = (createFormConfig ? createFormConfig({}) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const openStylePreviewEvent = () => {
      openStyleSetting();
    };
    Object.assign($xeFormDesign, formDesignMethods, formDesignPrivateMethods);
    const renderLayoutHeader = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--header-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--header-left'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--header-middle'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--header-right'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        mode: 'text',
        status: 'primary',
        icon: getIcon().FORM_DESIGN_STYLE_SETTING,
        content: i18n_getI18n('vxe.formDesign.styleSetting.btn'),
        onClick: openStylePreviewEvent
      })])]);
    };
    const renderVN = () => {
      const {
        height,
        showHeader
      } = props;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-form-design',
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [showHeader || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--header'
      }, headerSlot ? headerSlot({}) : renderLayoutHeader()) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(layout_widget), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(layout_preview), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(layout_setting), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(layout_style, {
        ref: refLayoutStyle
      })]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--footer'
      }, footerSlot ? footerSlot({}) : []) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeFormDesign.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.config, value => {
      loadConfig(value || {});
    });
    initSettingForm();
    updateWidgetConfigs();
    if (props.config) {
      loadConfig(props.config);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormDesign', $xeFormDesign);
    return $xeFormDesign;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/use/widget-name.ts


function useWidgetName(props) {
  const computeKebabCaseName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderOpts
    } = props;
    return renderOpts ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().kebabCase(renderOpts.name) : '';
  });
  return {
    computeKebabCaseName
  };
}
;// CONCATENATED MODULE: ./packages/form-design/src/use/widget-view.ts

function useWidgetView(props) {
  const currWidget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    return renderParams.widget;
  });
  const isEditMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    return renderParams.isEditMode || false;
  });
  const isViewMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    return renderParams.isViewMode || false;
  });
  const widgetOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      renderParams
    } = props;
    const {
      widget
    } = renderParams;
    return widget ? widget.options : {};
  });
  const widgetModel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get() {
      const {
        renderParams
      } = props;
      const {
        $formView,
        widget
      } = renderParams;
      return $formView ? $formView.getItemValue(widget) : null;
    },
    set(value) {
      const {
        renderParams
      } = props;
      const {
        $formView,
        widget
      } = renderParams;
      if ($formView) {
        $formView.setItemValue(widget, value);
      }
    }
  });
  return {
    currWidget,
    widgetOptions,
    widgetModel,
    isEditMode,
    isViewMode
  };
}
;// CONCATENATED MODULE: ./packages/textarea/src/textarea.ts




let autoTxtElem;
/* harmony default export */ var src_textarea = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTextarea',
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: 2
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => getConfig().textarea.resize
    },
    size: {
      type: String,
      default: () => getConfig().textarea.size || getConfig().size
    },
    // 已废弃
    maxlength: [String, Number]
  },
  emits: ['update:modelValue', 'input', 'keydown', 'keyup', 'click', 'change', 'focus', 'blur'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTextarea = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        editable
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return i18n_getI18n('vxe.base.pleaseInput');
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpMaxLength);
    });
    const computeSizeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        minRows: 1,
        maxRows: 10
      }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const {
        size,
        autosize
      } = props;
      const {
        inputValue
      } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement('div');
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ['vxe-textarea--autosize', size ? `size--${size}` : ''].join(' ');
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ('' + (inputValue || '　')).replace(/\n$/, '\n　');
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const sizeOpts = computeSizeOpts.value;
          const {
            minRows,
            maxRows
          } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.lineHeight);
          const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingTop);
          const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingBottom);
          const borderTopWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test('' + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent = evnt => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, {
        value
      }, evnt);
    };
    const emitUpdate = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = evnt => {
      const {
        immediate
      } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        emitUpdate(value, evnt);
      }
      $xeTextarea.dispatchEvent('input', {
        value
      }, evnt);
      handleResize();
    };
    const changeEvent = evnt => {
      const {
        immediate
      } = props;
      if (immediate) {
        triggerEvent(evnt);
      } else {
        emitUpdate(reactData.inputValue, evnt);
      }
    };
    const blurEvent = evnt => {
      const {
        immediate
      } = props;
      const {
        inputValue
      } = reactData;
      if (!immediate) {
        emitUpdate(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $textarea: $xeTextarea
        }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const {
        autosize
      } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const {
        className,
        resize,
        autosize,
        showWordCount,
        countMethod,
        rows,
        cols
      } = props;
      const {
        inputValue
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-textarea--readonly', className]
        }, inputValue);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-textarea', className, {
          [`size--${vSize}`]: vSize,
          'is--autosize': autosize,
          'is--count': showWordCount,
          'is--disabled': isDisabled,
          'def--rows': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rows),
          'def--cols': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cols)
        }],
        spellcheck: false
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('textarea', {
        ref: refTextarea,
        class: 'vxe-textarea--inner',
        value: inputValue,
        name: props.name,
        placeholder: inpPlaceholder,
        maxlength: inpMaxLength,
        readonly: inputReadonly,
        disabled: isDisabled,
        rows,
        cols,
        style: resize ? {
          resize
        } : null,
        onInput: inputEvent,
        onChange: changeEvent,
        onKeydown: triggerEvent,
        onKeyup: triggerEvent,
        onClick: triggerEvent,
        onFocus: triggerEvent,
        onBlur: blurEvent
      }), showWordCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-textarea--count', {
          'is--error': isCountError
        }]
      }, countMethod ? `${countMethod({
        value: inputValue
      })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ''}`) : null]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tip/src/tip.ts




/* harmony default export */ var tip = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTip',
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tip.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        status,
        content,
        icon,
        title
      } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tip', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'has--title': !!(titleSlot || title)
        }]
      }, [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--icon'
      }, iconSlot ? getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--body'
      }, [titleSlot || title ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--title'
      }, titleSlot ? getSlotVNs(titleSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(title)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--content'
      }, defaultSlot ? getSlotVNs(defaultSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))])]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/src/use/widget-prop-data-source.ts







function useWidgetPropDataSource(props, renderConfig) {
  const renConf = Object.assign({}, renderConfig);
  const isSubOption = renConf.isSubOption;
  const optionsContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)('');
  const expandIndexList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const addOptionEvent = () => {
    const {
      renderParams
    } = props;
    const {
      widget
    } = renderParams;
    const options = widget.options.options || [];
    options.push({
      value: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.defValue', [options.length + 1])
    });
    widget.options.options = [...options];
  };
  const subRE = /^(\s|\t)+/;
  const hasSubOption = str => {
    return subRE.test(str);
  };
  const expandAllOption = () => {
    const {
      renderParams
    } = props;
    const {
      widget
    } = renderParams;
    const options = widget.options.options || [];
    const indexList = [];
    options.forEach((group, gIndex) => {
      const {
        options
      } = group;
      if (options && options.length) {
        indexList.push(gIndex);
      }
    });
    expandIndexList.value = indexList;
  };
  const toggleExpandOption = (item, gIndex) => {
    if (expandIndexList.value.includes(gIndex)) {
      expandIndexList.value = expandIndexList.value.filter(num => num !== gIndex);
    } else {
      expandIndexList.value.push(gIndex);
    }
  };
  const removeOptionEvent = (item, group) => {
    const {
      renderParams
    } = props;
    const {
      widget
    } = renderParams;
    const {
      options
    } = widget;
    if (group) {
      if (group.options) {
        group.options = group.options.filter(obj => obj !== item);
      }
    } else {
      options.options = options.options.filter(obj => obj !== item);
    }
  };
  const confirmBatchAddOptionEvent = () => {
    const {
      renderParams
    } = props;
    const {
      widget
    } = renderParams;
    const optList = [];
    const rowList = optionsContent.value.split('\n');
    let prevGroup = null;
    if (isSubOption) {
      rowList.forEach((str, index) => {
        const nextStr = rowList[index + 1];
        const value = str.trim();
        if (!value) {
          return;
        }
        const item = {
          value
        };
        if (prevGroup) {
          if (hasSubOption(str)) {
            prevGroup.options.push(item);
            return;
          }
          prevGroup = null;
          optList.push(item);
        } else {
          optList.push(item);
        }
        if (nextStr) {
          if (hasSubOption(nextStr)) {
            prevGroup = Object.assign(item, {
              options: []
            });
          }
        }
      });
    } else {
      rowList.forEach(str => {
        optList.push({
          value: str.trim()
        });
      });
    }
    widget.options.options = optList;
    expandAllOption();
  };
  const openPopupEditEvent = () => {
    const {
      renderParams
    } = props;
    const {
      widget
    } = renderParams;
    const contList = [];
    widget.options.options?.forEach(group => {
      contList.push(group.value);
      group.options?.forEach(item => {
        contList.push(`\t${item.value}`);
      });
    });
    optionsContent.value = contList.join('\n');
    core_VxeUI.modal.open({
      title: `${widget.title} - ${i18n_getI18n('vxe.formDesign.widgetProp.dataSource.batchEditOption')}`,
      width: 500,
      height: '50vh ',
      resize: true,
      showFooter: true,
      showCancelButton: true,
      showConfirmButton: true,
      confirmButtonText: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.buildOption'),
      onConfirm: confirmBatchAddOptionEvent,
      slots: {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-form-item-data-source-popup'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tip, {
            status: 'primary',
            title: '',
            content: i18n_getI18n(`vxe.formDesign.widgetProp.dataSource.${isSubOption ? 'batchEditSubTip' : 'batchEditTip'}`)
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_textarea, {
            resize: 'none',
            modelValue: optionsContent.value,
            'onUpdate:modelValue'(val) {
              optionsContent.value = val;
            }
          })]);
        }
      }
    });
  };
  const renderOption = (item, group, isExpand, gIndex, hasSub, isFirst, isLast) => {
    const hasFirstLevel = !group;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: ['vxe-form-design--widget-form-item-data-source-option', {
        'is--first': isFirst,
        'is--last': isLast
      }]
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-form-design--widget-expand-btn'
    }, hasFirstLevel && hasSub ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: isExpand ? getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE : getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN,
      onClick() {
        toggleExpandOption(item, gIndex);
      }
    })] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
      class: 'vxe-default-input',
      value: item.value,
      onInput(evnt) {
        item.value = evnt.target.value;
      }
    }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
      status: 'danger',
      mode: 'text',
      icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
      onClick() {
        removeOptionEvent(item, group);
      }
    })]);
  };
  const renderOptions = () => {
    const {
      renderParams
    } = props;
    const {
      widget
    } = renderParams;
    const {
      options
    } = widget;
    const groups = options.options;
    const optVNs = [];
    if (groups) {
      groups.forEach((group, gIndex) => {
        const {
          options
        } = group;
        const isExpand = expandIndexList.value.includes(gIndex);
        if (options && options.length) {
          optVNs.push(renderOption(group, null, isExpand, gIndex, true, gIndex === 0, gIndex === groups.length - 1));
          if (isExpand) {
            optVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-form-design--widget-form-item-data-source-sub-option'
            }, options.map(item => renderOption(item, group, isExpand, 0, false, false, false))));
          }
        } else {
          optVNs.push(renderOption(group, null, isExpand, gIndex, false, gIndex === 0, gIndex === groups.length - 1));
        }
      });
    }
    return optVNs;
  };
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.renderParams.widget, () => {
    expandAllOption();
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
    expandAllOption();
  });
  const renderDataSourceFormItemContent = () => {
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
      status: 'primary',
      mode: 'text',
      content: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.addOption'),
      onClick: addOptionEvent
    }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
      status: 'primary',
      mode: 'text',
      content: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.batchEditOption'),
      onClick: openPopupEditEvent
    })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-form-design--widget-form-item-data-source-wrapper'
    }, renderOptions())];
  };
  return {
    renderDataSourceFormItem() {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        title: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.name'),
        field: 'options'
      }, {
        default() {
          return renderDataSourceFormItemContent();
        }
      });
    },
    renderDataSourceFormItemContent
  };
}
;// CONCATENATED MODULE: ./packages/form-design/src/use/widget-prop-default-value.ts




function useWidgetPropDefaultValue(props) {
  const defValOptions = ref([{
    value: 'custom',
    label: '自定义'
  }
  // { value: 'linkage', label: '数据联动' }
  ]);
  return {
    renderDefaultValueFormItem() {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        defaultValue
      } = widget.options;
      return h(VxeFormItemComponent, {
        title: '默认值'
      }, {
        default() {
          return [h(VxeSelectComponent, {
            modelValue: defaultValue.type,
            options: defValOptions.value,
            'onUpdate:modelValue'(val) {
              defaultValue.type = val;
            }
          }), h(VxeInputComponent, {
            modelValue: defaultValue.value,
            'onUpdate:modelValue'(val) {
              defaultValue.value = val;
            }
          })];
        }
      });
    }
  };
}
;// CONCATENATED MODULE: ./packages/form-design/src/use/index.ts




;// CONCATENATED MODULE: ./packages/form-design/render/util.ts

const getFormDesignWidgetName = name => {
  return i18n_getI18n(`vxe.formDesign.widget.component.${name}`);
};
const handleGetFormDesignWidgetName = params => {
  return getFormDesignWidgetName(params.name);
};
;// CONCATENATED MODULE: ./packages/form-design/widget-text/text-data.ts

const getWidgetTextConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-text',
    group: 'layout',
    options: {
      color: '',
      align: '',
      bold: false,
      fontSize: ''
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-text/text-form.ts







const getFontSizeOptions = () => {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(12, 27).map(num => {
    return {
      label: `${num}px`,
      value: `${num}px`
    };
  });
};
const text_form_getAlignOptions = () => {
  return [{
    label: i18n_getI18n('vxe.formDesign.widgetProp.textProp.alignLeft'),
    value: ''
  }, {
    label: i18n_getI18n('vxe.formDesign.widgetProp.textProp.alignCenter'),
    value: 'center'
  }, {
    label: i18n_getI18n('vxe.formDesign.widgetProp.textProp.alignRight'),
    value: 'right'
  }];
};
const text_form_getBoldOptions = () => {
  return [{
    label: i18n_getI18n('vxe.formDesign.widgetProp.textProp.fontNormal'),
    value: false
  }, {
    label: i18n_getI18n('vxe.formDesign.widgetProp.textProp.fontBold'),
    value: true
  }];
};
const WidgetTextFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const alignOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(text_form_getAlignOptions());
    const boldOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(text_form_getBoldOptions());
    const fontSizeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getFontSizeOptions());
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.textProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.textProp.boldTitle'),
            field: 'bold',
            itemRender: {
              name: 'VxeRadioGroup',
              options: boldOpts.value
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.textProp.alignTitle'),
            field: 'align',
            itemRender: {
              name: 'VxeRadioGroup',
              options: alignOpts.value
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.textProp.sizeTitle'),
            field: 'fontSize',
            itemRender: {
              name: 'VxeSelect',
              options: fontSizeOpts.value
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-text/text-view.ts



const WidgetTextViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        align: options.align
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            style: {
              fontSize: options.fontSize,
              fontWeight: options.bold ? 'bold' : ''
            }
          }, widget.title);
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-text/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-row/row-data.ts


const getWidgetRowConfig = params => {
  const {
    $formDesign
  } = params;
  const defaultColSize = 2;
  return {
    title: handleGetFormDesignWidgetName,
    group: 'layout',
    icon: 'vxe-icon-row-col',
    options: {
      colSize: defaultColSize,
      colSpan: '12,12'
    },
    children: $formDesign ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, defaultColSize).map(() => {
      return $formDesign.createEmptyWidget();
    }) : []
  };
};
;// CONCATENATED MODULE: ./packages/row/src/row.ts




/* harmony default export */ var row = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeRow',
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        gutter,
        vertical
      } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = '';
        }
        if (lrGutter) {
          const offsetSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleDefaultEvent = evnt => {
      emit(evnt.type, createEvent(evnt, {
        $row: $xeRow
      }));
    };
    const renderVN = () => {
      const {
        vertical,
        wrap
      } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-row', {
          'is--vertical': vertical,
          'is--wrap': wrap
        }],
        style: rowStyle,
        onClick: handleDefaultEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeRow.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeRow', $xeRow);
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/widget-row/row-form.ts








const WidgetRowFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const spanOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([{
      label: i18n_getI18n('vxe.formDesign.widgetProp.rowProp.col3'),
      value: 2,
      list: [{
        value: '12,12',
        spans: [12, 12]
      }, {
        value: '8,16',
        spans: [8, 16]
      }, {
        value: '16,8',
        spans: [16, 8]
      }, {
        value: '6,18',
        spans: [6, 18]
      }, {
        value: '18,6',
        spans: [18, 6]
      }]
    }, {
      label: i18n_getI18n('vxe.formDesign.widgetProp.rowProp.col3'),
      value: 3,
      list: [{
        value: '8,8,8',
        spans: [8, 8, 8]
      }, {
        value: '6,6,12',
        spans: [6, 6, 12]
      }, {
        value: '12,6,6',
        spans: [12, 6, 6]
      }, {
        value: '6,12,6',
        spans: [6, 12, 6]
      }]
    }, {
      label: i18n_getI18n('vxe.formDesign.widgetProp.rowProp.col4'),
      value: 4,
      list: [{
        value: '6,6,6,6',
        spans: [6, 6, 6, 6]
      }]
    }, {
      label: i18n_getI18n('vxe.formDesign.widgetProp.rowProp.col6'),
      value: 6,
      list: [{
        value: '4,4,4,4,4,4',
        spans: [4, 4, 4, 4, 4, 4]
      }]
    }]);
    const labelMaps = {
      18: '3/4',
      16: '2/3',
      12: '1/2',
      8: '1/3',
      6: '1/4',
      4: '1/6'
    };
    const computeSelectSpanItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      return spanOptions.value.find(item => item.value === options.colSize);
    });
    const changeColSpan = item => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      options.colSpan = item.value;
      widget.children = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, options.colSize).map(() => {
        return $xeFormDesign.createEmptyWidget();
      });
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.rowProp.colSize'),
            field: 'colSize',
            itemRender: {
              name: 'VxeRadioGroup',
              options: spanOptions.value,
              props: {
                type: 'button'
              }
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.rowProp.layout')
          }, {
            default() {
              const selectSpanItem = computeSelectSpanItem.value;
              if (selectSpanItem) {
                return selectSpanItem.list.map((item, rIndex) => {
                  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(row, {
                    key: rIndex,
                    class: [`vxe-form-design--widget-${kebabCaseName}-form-row`, {
                      'is--active': item.value === widget.options.colSpan
                    }],
                    onClick() {
                      changeColSpan(item);
                    }
                  }, {
                    default() {
                      return item.spans.map((span, sIndex) => {
                        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(col, {
                          key: `${rIndex}${sIndex}`,
                          class: `vxe-form-design--widget-${kebabCaseName}-form-col`,
                          span
                        }, {
                          default() {
                            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, `${labelMaps[span]}`);
                          }
                        });
                      });
                    }
                  });
                });
              }
              return [];
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-row/row-view.ts










const ViewColItemComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    span: Number,
    colItemIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      reactData: formDesignReactData
    } = $xeFormDesign;
    const handleDragoverColItem = evnt => {
      const {
        parentWidget,
        colItemIndex
      } = props;
      const {
        widgetObjList,
        sortWidget
      } = formDesignReactData;
      const currWidget = parentWidget.children[colItemIndex];
      evnt.stopPropagation();
      if (sortWidget && parentWidget && sortWidget.id !== parentWidget.id) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if ((!currWidget || !currWidget.name) && !hasFormDesignLayoutType(currWidget)) {
          const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item.id === sortWidget.id, {
            children: 'children'
          });
          if (rest) {
            const {
              item,
              index,
              items
            } = rest;
            // 如果数据异常，动态修复
            if (!parentWidget.children.length) {
              parentWidget.children = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, parentWidget.options.colSize).map(() => {
                return $xeFormDesign.createEmptyWidget();
              });
            }
            parentWidget.children[colItemIndex] = item;
            items.splice(index, 1);
            $xeFormDesign.dispatchEvent('drag-widget', {
              widget: item
            }, evnt);
          }
        }
      }
    };
    return () => {
      const {
        widget,
        span
      } = props;
      const {
        dragWidget,
        activeWidget,
        sortWidget
      } = formDesignReactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        span,
        padding: false
      }, {
        default() {
          const name = widget ? widget.name : '';
          const compConf = renderer.get(name) || {};
          const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
          const renderOpts = widget || {
            name
          };
          const params = {
            widget,
            readonly: false,
            disabled: false,
            isEditMode: true,
            isViewMode: false,
            $formDesign: $xeFormDesign,
            $formView: null
          };
          const isActive = activeWidget && widget && activeWidget.id === widget.id;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-form-design--widget-row-view', {
              'is--active': isActive,
              'is--sort': sortWidget && widget && sortWidget.id === widget.id,
              'is--drag': dragWidget && widget && dragWidget.id === widget.id
            }],
            'data-widget-id': widget.id,
            onDragover: handleDragoverColItem,
            onClick(evnt) {
              if (widget) {
                $xeFormDesign.handleClickWidget(evnt, widget);
              }
            }
          }, [renderWidgetDesignView ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-row-view-item-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-row-view-item-box vxe-form--item-row'
          }, getSlotVNs(renderWidgetDesignView(renderOpts, params))), isActive ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--preview-item-operate'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            icon: getIcon().FORM_DESIGN_WIDGET_COPY,
            status: 'primary',
            size: 'mini',
            circle: true,
            onClick(params) {
              $xeFormDesign.handleCopyWidget(params.$event, widget);
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
            status: 'danger',
            size: 'mini',
            circle: true,
            onClick(params) {
              $xeFormDesign.handleRemoveWidget(params.$event, widget);
            }
          })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-row-view-empty'
          }, '控件位置')]);
        }
      });
    };
  }
});
const WidgetRowEditComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const computedColObjList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const {
        colSpan
      } = options;
      const colList = colSpan ? `${colSpan}`.split(',') : [];
      const rest = colList.map(span => Number(span));
      return rest;
    });
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_gather, {}, {
        default() {
          const colObjList = computedColObjList.value;
          return colObjList.map((span, colItemIndex) => {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(ViewColItemComponent, {
              key: colItemIndex,
              parentWidget: widget,
              widget: widget.children[colItemIndex],
              span,
              colItemIndex
            });
          });
        }
      });
    };
  }
});
const WidgetRowViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const computedColObjList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const {
        colSpan
      } = options;
      const colList = colSpan ? `${colSpan}`.split(',') : [];
      const rest = colList.map(span => Number(span));
      return rest;
    });
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const colObjList = computedColObjList.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(row, {}, {
        default() {
          return colObjList.map((span, colItemIndex) => {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(col, {
              key: colItemIndex,
              class: 'vxe-form--item-row',
              span
            }, {
              default() {
                const subWidget = widget.children[colItemIndex];
                if (subWidget) {
                  const {
                    name
                  } = subWidget;
                  const compConf = renderer.get(name) || {};
                  const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                  const renderOpts = subWidget;
                  const isEditMode = !!$xeFormDesign;
                  const params = {
                    widget: subWidget,
                    readonly: false,
                    disabled: false,
                    isEditMode,
                    isViewMode: !isEditMode,
                    $formDesign: $xeFormDesign,
                    $formView: $xeFormView
                  };
                  if (renderWidgetDesignView) {
                    return getSlotVNs(renderWidgetDesignView(renderOpts, params));
                  }
                }
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
              }
            });
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-row/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-subtable/subtable-data.ts

const getWidgetSubtableConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    group: 'layout',
    icon: 'vxe-icon-subtable',
    options: {
      showCheckbox: false
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-subtable/subtable-form.ts







const WidgetSubtableFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.subtableProp.showCheckbox'),
            field: 'showCheckbox'
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: options.showCheckbox,
                'onUpdate:modelValue'(val) {
                  options.showCheckbox = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-subtable/subtable-view.ts










const ViewSubItemComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      reactData: formDesignReactData
    } = $xeFormDesign;
    const sortDragstartEvent = evnt => {
      evnt.stopPropagation();
      const {
        widgetObjList
      } = formDesignReactData;
      const divEl = evnt.currentTarget;
      const widgetId = Number(divEl.getAttribute('data-widget-id'));
      const currRest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item && item.id === widgetId, {
        children: 'children'
      });
      if (currRest) {
        formDesignReactData.dragWidget = null;
        formDesignReactData.sortSubWidget = currRest.item;
        formDesignReactData.sortSubWidget = currRest.item;
      }
    };
    const sortDragendEvent = evnt => {
      evnt.stopPropagation();
      formDesignReactData.activeWidget = formDesignReactData.sortSubWidget;
      formDesignReactData.sortWidget = null;
    };
    let isDragAnimate = false;
    const sortDragenterEvent = evnt => {
      const {
        sortSubWidget
      } = formDesignReactData;
      if (sortSubWidget) {
        evnt.stopPropagation();
      }
      if (isDragAnimate) {
        evnt.preventDefault();
        return;
      }
      const {
        widget,
        parentWidget
      } = props;
      if (parentWidget && widget && sortSubWidget && widget.id !== sortSubWidget.id) {
        evnt.preventDefault();
        const subList = parentWidget.children.map(item => item);
        if (!subList.length) {
          parentWidget.children.push(sortSubWidget);
          isDragAnimate = false;
          return;
        }
        const targetIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(subList, item => item.id === widget.id);
        if (targetIndex > -1) {
          const sortIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(subList, item => item.id === sortSubWidget.id);
          if (sortIndex > -1) {
            // 控件换位置
            subList[sortIndex] = widget;
            subList[targetIndex] = sortSubWidget;
            parentWidget.children = subList;
            isDragAnimate = true;
            $xeFormDesign.dispatchEvent('drag-widget', {
              widget: sortSubWidget
            }, evnt);
            setTimeout(() => {
              isDragAnimate = false;
            }, 150);
          }
        }
      }
    };
    const handleDragoverSubItem = evnt => {
      const {
        sortSubWidget
      } = formDesignReactData;
      if (sortSubWidget) {
        evnt.preventDefault();
      }
    };
    const handleClickEvent = evnt => {
      const {
        widget
      } = props;
      if (widget) {
        formDesignReactData.sortSubWidget = widget;
        $xeFormDesign.handleClickWidget(evnt, widget);
      }
    };
    return () => {
      const {
        widget
      } = props;
      const {
        dragWidget,
        activeWidget,
        sortSubWidget
      } = formDesignReactData;
      const name = widget ? widget.name : '';
      const compConf = renderer.get(name) || {};
      const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
      const renderOpts = widget || {
        name
      };
      const isEditMode = !!$xeFormDesign;
      const params = {
        widget,
        readonly: false,
        disabled: false,
        isEditMode,
        isViewMode: !isEditMode,
        $formDesign: $xeFormDesign,
        $formView: $xeFormView
      };
      const isActive = activeWidget && widget && activeWidget.id === widget.id;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form-design--widget-subtable-view-item', {
          'is--active': isActive,
          'is--sort': sortSubWidget && widget && sortSubWidget.id === widget.id,
          'is--drag': dragWidget && widget && dragWidget.id === widget.id
        }],
        draggable: true,
        'data-widget-id': widget.id,
        onDragstart: sortDragstartEvent,
        onDragend: sortDragendEvent,
        onDragenter: sortDragenterEvent,
        onDragover: handleDragoverSubItem,
        onClick: handleClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--widget-subtable-view-item-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--widget-subtable-view-item-box vxe-form--item-row'
      }, renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : []), isActive ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-design--preview-item-operate'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        icon: getIcon().FORM_DESIGN_WIDGET_COPY,
        status: 'primary',
        size: 'mini',
        circle: true,
        onClick(params) {
          $xeFormDesign.handleCopyWidget(params.$event, widget);
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
        status: 'danger',
        size: 'mini',
        circle: true,
        onClick(params) {
          $xeFormDesign.handleRemoveWidget(params.$event, widget);
        }
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
    };
  }
});
const WidgetSubtableEditComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormDesign', null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const {
      reactData: formDesignReactData
    } = $xeFormDesign;
    const onDragoverEmptyWrapper = evnt => {
      const {
        sortWidget,
        widgetObjList
      } = formDesignReactData;
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      evnt.stopPropagation();
      if (!sortWidget || !widget || widget.id === sortWidget.id) {
        return;
      }
      if (hasFormDesignLayoutType(sortWidget)) {
        if (core_VxeUI.modal) {
          core_VxeUI.modal.message({
            content: i18n_getI18n('vxe.formDesign.widgetProp.subtableProp.errSubDrag'),
            status: 'error',
            id: 'errSubDrag'
          });
        }
        return;
      }
      if (widget.name && !widget.children.some(item => item.id === sortWidget.id)) {
        const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(widgetObjList, item => item.id === sortWidget.id, {
          children: 'children'
        });
        if (rest) {
          const {
            item,
            index,
            items
          } = rest;
          formDesignReactData.sortWidget = null;
          formDesignReactData.sortSubWidget = item;
          formDesignReactData.activeWidget = item;
          widget.children.push(item);
          items.splice(index, 1);
        }
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        title,
        children,
        options
      } = widget;
      const {
        showCheckbox
      } = options;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        title,
        className: 'vxe-form-design--widget-subtable-form-item'
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-view'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-view-left'
          }, [showCheckbox ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-col'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-head'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-body'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox)])]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-col'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-head'
          }, i18n_getI18n('vxe.formDesign.widgetProp.subtableProp.seqTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-body'
          }, '1')])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-view-right'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-form-design--widget-subtable-view-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
            class: 'vxe-form-design--widget-subtable-view-list',
            tag: 'div',
            name: 'vxe-form-design--widget-subtable-view-list'
          }, {
            default: () => {
              return children.map(childWidget => {
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(ViewSubItemComponent, {
                  key: childWidget.id,
                  parentWidget: widget,
                  widget: childWidget
                });
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: 'empty',
            class: 'vxe-form-design--widget-subtable-view-empty',
            onDragover: onDragoverEmptyWrapper
          }, '将控件拖拽进来')])])]);
        }
      });
    };
  }
});
const WidgetSubtableViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const VxeTableGridComponent = core_VxeUI.getComponent('VxeGrid');
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const computeSubtableColumns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        children,
        options
      } = widget;
      const columns = [];
      if (options.showCheckbox) {
        columns.push({
          type: 'checkbox',
          width: 60
        });
      }
      columns.push({
        type: 'seq',
        width: 60
      });
      if (children) {
        children.forEach(childWidget => {
          columns.push({
            field: childWidget.field,
            title: childWidget.title
          });
        });
      }
      return columns;
    });
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      const subtableColumns = computeSubtableColumns.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        span: 24,
        padding: false
      }, {
        default() {
          return VxeTableGridComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeTableGridComponent, {
            border: true,
            columnConfig: {
              resizable: true
            },
            data: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            columns: subtableColumns
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-subtable/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-input/input-data.ts

const getWidgetInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-input',
    query: true,
    options: {
      placeholder: ''
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-input/input-form.ts







const WidgetInputFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-input/input-view.ts




const WidgetInputViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
            class: 'vxe-default-input',
            type: 'text',
            placeholder: options.placeholder || i18n_getI18n('vxe.base.pleaseInput'),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-input/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-textarea/textarea-data.ts

const getWidgetTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-textarea',
    query: true,
    options: {
      placeholder: ''
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-textarea/textarea-form.ts







const WidgetTextareaFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-textarea/textarea-view.ts




const WidgetTextareaViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('textarea', {
            class: 'vxe-default-textarea',
            placeholder: options.placeholder || i18n_getI18n('vxe.base.pleaseInput'),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-textarea/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-select/select-data.ts



const getWidgetSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-select',
    query: true,
    options: {
      options: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, 3).map((v, i) => {
        return {
          value: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.defValue', [i + 1])
        };
      })
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-select/select-form.ts







const WidgetSelectFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      renderDataSourceFormItem
    } = useWidgetPropDataSource(props, {
      isSubOption: true
    });
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          }), renderDataSourceFormItem()];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-select/select-view.ts



const WidgetSelectViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    const renderOptions = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget.options;
      return options ? options.map(group => {
        if (group.options) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('optgroup', {
            label: group.value
          }, group.options.map(item => {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
              value: item.value
            }, item.value);
          }));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {}, group.value);
      }) : [];
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget,
        isViewMode
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
            class: 'vxe-default-select',
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent
          }, isViewMode ? renderOptions() : []);
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-select/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-input/vxe-input-data.ts

const getWidgetVxeInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-input',
    query: true,
    options: {
      placeholder: ''
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-input/vxe-input-form.ts







const WidgetVxeInputFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-input/vxe-input-view.ts




const WidgetVxeInputViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-input/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-number-input/vxe-number-input-data.ts

const getWidgetVxeNumberInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-number',
    query: true,
    options: {
      placeholder: ''
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-number-input/vxe-number-input-form.ts







const WidgetVxeNumberInputFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/number-input/src/number-input.ts






function number_input_handleNumber(val) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val) ? val.replace(/,/g, '') : val;
}
function number_input_toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test('' + inputValue)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(inputValue, digitsValue), digitsValue);
  }
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(inputValue, digitsValue), digitsValue);
}
/* harmony default export */ var number_input = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeNumberInput',
  props: {
    modelValue: [String, Number],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'number'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().numberInput.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: 'off'
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().numberInput.size || getConfig().size
    },
    multiple: Boolean,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().numberInput.exponential
    },
    // number、integer、float
    controls: {
      type: Boolean,
      default: () => getConfig().numberInput.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => getConfig().numberInput.digits
    },
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'prev-number', 'next-number', 'prefix-click', 'suffix-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsNumType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return true;
    });
    const computeDigitsValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(props.digits) || 1;
    });
    const computeStepValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === 'integer') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(step) || 1;
      } else if (type === 'float') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().numberInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return i18n_getI18n('vxe.base.pleaseInput');
    });
    const computeInpMaxlength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      // 数值最大长度限制 16 位，包含小数
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxLength || maxlength) || 16;
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        immediate
      } = props;
      return immediate || !(type === 'number' || type === 'integer' || type === 'float');
    });
    const computeNumValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(number_input_handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(number_input_handleNumber(inputValue));
      }
      return 0;
    });
    const computeNumLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        inputValue
      } = reactData;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toString(inputValue);
    });
    const computeIsDisabledSubtractNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        min
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        max
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const getNumberValue = val => {
      const {
        type,
        exponential
      } = props;
      const inpMaxlength = computeInpMaxlength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === 'float' ? number_input_toFloatValueFixed(val, digitsValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val);
      if (exponential && (val === restVal || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val).toLowerCase() === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxlength);
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      inputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const emitModel = (value, inputValue, evnt) => {
      const isChange = Number(value) !== props.modelValue;
      if (isChange) {
        reactData.inputValue = inputValue || '';
        emit('update:modelValue', value ? Number(value) : null);
      }
      inputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (isChange) {
        inputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (inputValue, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue) : null;
      reactData.inputValue = inputValue;
      if (inpImmediate) {
        emitModel(value, inputValue, evnt);
      } else {
        inputMethods.dispatchEvent('input', {
          value
        }, evnt);
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        inputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      emitModel(null, '', evnt);
      inputMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        inputMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const digitsValue = computeDigitsValue.value;
      if (type === 'float') {
        if (inputValue) {
          let textValue = '';
          let validValue = null;
          if (inputValue) {
            textValue = number_input_toFloatValueFixed(inputValue, digitsValue);
            validValue = Number(textValue);
          }
          if (inputValue !== validValue) {
            emitModel(validValue, textValue, {
              type: 'init'
            });
          }
        }
      }
    };
    const validMaxNum = num => {
      return props.max === null || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max);
    };
    const validMinNum = num => {
      return props.min === null || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min);
    };
    const afterCheckValue = () => {
      const {
        type,
        min,
        max,
        exponential
      } = props;
      const {
        inputValue
      } = reactData;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (inputValue) {
          let inpNumVal = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(number_input_handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(number_input_handleNumber(inputValue));
          if (!validMinNum(inpNumVal)) {
            inpNumVal = min;
          } else if (!validMaxNum(inpNumVal)) {
            inpNumVal = max;
          }
          if (exponential) {
            const inpStringVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(inputValue).toLowerCase();
            if (inpStringVal === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpNumVal).toExponential()) {
              inpNumVal = inpStringVal;
            }
          }
          const inpValue = getNumberValue(inpNumVal);
          emitModel(inpValue === null ? null : Number(inpValue), inpValue, {
            type: 'check'
          });
        }
      }
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? Number(inputValue) : null;
      if (!inpImmediate) {
        emitModel(value, `${inputValue || ''}`, evnt);
      }
      afterCheckValue();
      reactData.isActivated = false;
      inputMethods.dispatchEvent('blur', {
        value
      }, evnt);
    };
    // 数值
    const numberChange = (isPlus, evnt) => {
      const {
        min,
        max,
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(number_input_handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(number_input_handleNumber(inputValue));
      const newValue = isPlus ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().add(numValue, stepValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    let downbumTimeout;
    const numberNextEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !formReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent('next-number', {}, evnt);
    };
    const numberDownNextEvent = evnt => {
      downbumTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !formReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent('prev-number', {}, evnt);
    };
    const numberKeydownEvent = evnt => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = evnt => {
      const {
        exponential,
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && keyCode >= 65 && keyCode <= 90 || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    // 数值
    const numberStopDown = () => {
      clearTimeout(downbumTimeout);
    };
    const numberDownPrevEvent = evnt => {
      downbumTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = evnt => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, 'is--prev');
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = evnt => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const {
        isActivated
      } = reactData;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          afterCheckValue();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        }
        if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        afterCheckValue();
      }
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--number-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--prev', {
          'is--disabled': isDisabledAddNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().NUMBER_INPUT_PREV_NUM
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--next', {
          'is--disabled': isDisabledSubtractNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().NUMBER_INPUT_NEXT_NUM
      })])])]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--prefix-icon'
      }, prefixSlot ? getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-number-input--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), renderExtraSuffixIcon(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    const renderExtraSuffixIcon = () => {
      const {
        controls
      } = props;
      if (controls) {
        return renderNumberIcon();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    inputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $input: $xeInput
        }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeInput, inputMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        inputValue: props.modelValue
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeInput, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeInput, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeInput, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      numberStopDown();
      globalEvents.off($xeInput, 'mousedown');
      globalEvents.off($xeInput, 'keydown');
      globalEvents.off($xeInput, 'blur');
    });
    initValue();
    const renderVN = () => {
      const {
        className,
        controls,
        type,
        align,
        name,
        autocomplete,
        autoComplete
      } = props;
      const {
        inputValue,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const numLabel = computeNumLabel.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-number-input--readonly', `type--${type}`, className]
        }, numLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const inpMaxlength = computeInpMaxlength.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-number-input', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--controls': controls,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-number-input--inner',
        value: inputValue,
        name,
        type: 'text',
        placeholder: inpPlaceholder,
        maxlength: inpMaxlength,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete || autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-number-input/vxe-number-input-view.ts




const WidgetVxeNumberInputViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-number-input/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-date-picker/vxe-date-picker-data.ts

const getWidgetVxeDatePickerConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-calendar',
    options: {
      placeholder: '',
      defaultValue: {
        type: '',
        value: ''
      }
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-date-picker/vxe-date-picker-form.ts







const WidgetVxeDatePickerFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    // const { renderDefaultValueFormItem } = useWidgetPropDefaultValue(props)
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }),
          // renderDefaultValueFormItem(),
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-date-picker/vxe-date-picker-view.ts




const WidgetVxeDatePickerViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(date_picker, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-date-picker/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-textarea/vxe-textarea-data.ts

const getWidgetVxeTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-textarea',
    options: {
      placeholder: ''
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-textarea/vxe-textarea-form.ts







const WidgetVxeTextareaFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-textarea/vxe-textarea-view.ts




const WidgetVxeTextareaViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_textarea, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            resize: 'node',
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-textarea/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-switch/vxe-switch-data.ts

const getWidgetVxeSwitchConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-switch',
    query: true,
    options: {}
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-switch/vxe-switch-form.ts






const WidgetVxeSwitchFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-switch/vxe-switch-view.ts




const WidgetVxeSwitchViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-switch/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-select/vxe-select-data.ts



const getWidgetVxeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-select',
    query: true,
    options: {
      placeholder: '',
      options: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, 3).map((v, i) => {
        return {
          value: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.defValue', [i + 1])
        };
      }),
      multiple: false
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-select/vxe-select-form.ts







const WidgetVxeSelectFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      renderDataSourceFormItem
    } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.multiple'),
            field: 'multiple',
            itemRender: {
              name: 'VxeSwitch'
            }
          }), renderDataSourceFormItem(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-select/vxe-select-view.ts





const WidgetVxeSelectViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget,
        isViewMode
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || i18n_getI18n('vxe.base.pleaseSelect'),
            options: isViewMode ? options.options : [],
            optionProps: {
              label: 'value',
              value: 'value'
            },
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-select/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-tree-select/vxe-tree-select-data.ts



const getWidgetVxeTreeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-tree-select',
    query: true,
    options: {
      placeholder: '',
      options: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, 3).map((v, i) => {
        return {
          value: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.defValue', [i + 1])
        };
      }),
      multiple: false
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-tree-select/vxe-tree-select-form.ts







const WidgetVxeTreeSelectFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.multiple'),
            field: 'multiple',
            itemRender: {
              name: 'VxeSwitch'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/tree/src/tree.ts







/**
 * 生成节点的唯一主键
 */
function getNodeUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('node_');
}
/* harmony default export */ var tree = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTree',
  props: {
    data: Array,
    height: [String, Number],
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    // mapChildrenField: {
    //   type: String as PropType<VxeTreePropTypes.MapChildrenField>,
    //   default: () => getConfig().tree.mapChildrenField
    // },
    transform: Boolean,
    // 已废弃
    isCurrent: Boolean,
    // 已废弃
    isHover: Boolean,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    size: {
      type: String,
      default: () => getConfig().tree.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'update:checkNodeKey', 'update:checkNodeKeys', 'node-click', 'node-dblclick', 'current-change', 'radio-change', 'checkbox-change', 'load-success', 'load-error'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      currentNode: null,
      nodeMaps: {},
      selectRadioKey: props.checkNodeKey,
      treeList: [],
      treeExpandedMaps: {},
      treeExpandLazyLoadedMaps: {},
      selectCheckboxMaps: {},
      indeterminateCheckboxMaps: {}
    });
    const internalData = {};
    const refMaps = {
      refElem
    };
    const computeTitleField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.titleField || 'title';
    });
    const computeKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.keyField || 'id';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.parentField || 'parentId';
    });
    const computeChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.childrenField || 'children';
    });
    const computeHasChildField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.hasChildField || 'hasChild';
    });
    const computeIsRowCurrent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const nodeOpts = computeNodeOpts.value;
      const {
        isCurrent
      } = nodeOpts;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const nodeOpts = computeNodeOpts.value;
      const {
        isHover
      } = nodeOpts;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showIcon: true
      }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showIcon: true
      }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        minHeight
      } = props;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (minHeight) {
        stys.minHeight = toCssUnit(minHeight);
      }
      return stys;
    });
    const computeMaps = {
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = node => {
      const valueField = computeValueField.value;
      const nodeid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, valueField);
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(nodeid) ? '' : encodeURIComponent(nodeid);
    };
    const isExpandByNode = node => {
      const {
        treeExpandedMaps
      } = reactData;
      const nodeid = getNodeId(node);
      return !!treeExpandedMaps[nodeid];
    };
    const isCheckedByRadioNodeId = nodeid => {
      const {
        selectRadioKey
      } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = node => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = nodeid => {
      const {
        selectCheckboxMaps
      } = reactData;
      return !!selectCheckboxMaps[nodeid];
    };
    const isCheckedByCheckboxNode = node => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = nodeid => {
      const {
        indeterminateCheckboxMaps
      } = reactData;
      return !!indeterminateCheckboxMaps[nodeid];
    };
    const isIndeterminateByCheckboxNode = node => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = value => {
      emit('update:checkNodeKeys', value);
    };
    const emitRadioMode = value => {
      emit('update:checkNodeKey', value);
    };
    const setRadioNode = (node, checked) => {
      if (node) {
        reactData.selectRadioKey = checked ? getNodeId(node) : null;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const setCheckboxNode = (nodeList, checked) => {
      if (nodeList) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeList)) {
          nodeList = [nodeList];
        }
        handleCheckedCheckboxNode(nodeList.map(item => getNodeId(item)), checked);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const setCheckboxByNodeId = (nodeIds, checked) => {
      if (nodeIds) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeIds)) {
          nodeIds = [nodeIds];
        }
        handleCheckedCheckboxNode(nodeIds, checked);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleCheckedCheckboxNode = (nodeIds, checked) => {
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      nodeIds.forEach(key => {
        if (checked) {
          selectKeyMaps[key] = true;
        } else if (selectKeyMaps[key]) {
          delete selectKeyMaps[key];
        }
      });
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const updateCheckboxChecked = nodeIds => {
      const selectKeyMaps = {};
      if (nodeIds) {
        nodeIds.forEach(key => {
          selectKeyMaps[key] = true;
        });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tree: $xeTree
      }, params));
    };
    const createNode = records => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map(obj => {
        const item = {
          ...obj
        };
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const treeMethods = {
      dispatchEvent,
      clearRadioNode() {
        reactData.selectRadioKey = null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setRadioNode,
      setCheckboxNode,
      setCheckboxByNodeId,
      clearCheckboxNode() {
        reactData.selectCheckboxMaps = {};
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setAllCheckboxNode(checked) {
        const selectMaps = Object.assign(reactData.selectCheckboxMaps);
        const childrenField = computeChildrenField.value;
        if (checked) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.treeList, node => {
            const nodeid = getNodeId(node);
            selectMaps[nodeid] = true;
          }, {
            children: childrenField
          });
        }
        reactData.selectCheckboxMaps = selectMaps;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearExpandNode() {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(reactData.nodeMaps, nodeItem => {
          nodeItem.treeLoaded = false;
        });
        reactData.treeExpandedMaps = {};
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setExpandByNodeId(nodeids, expanded) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodeids) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach(nodeid => {
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setExpandNode(nodes, expanded) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodes) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach(node => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      toggleExpandByNodeId(nodeids) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodeids) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach(nodeid => {
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      toggleExpandNode(nodes) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodes) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach(node => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setAllExpandNode() {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        const childrenField = computeChildrenField.value;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.treeList, node => {
          const nodeid = getNodeId(node);
          expandedMaps[nodeid] = true;
        }, {
          children: childrenField
        });
        reactData.treeExpandedMaps = expandedMaps;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      reloadExpandNode(node) {
        const {
          lazy
        } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearExpandLoaded(node) {
        const {
          lazy
        } = props;
        const {
          nodeMaps
        } = reactData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadChildrenNode(node, childRecords) {
        const {
          lazy,
          transform
        } = props;
        const {
          nodeMaps
        } = reactData;
        if (!lazy) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        const childrenField = computeChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then(nodeList => {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(nodeList, (childRow, index, items, path, parent, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: node,
              itemIndex: -1,
              items,
              parent: parent || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              lineCount: 0,
              treeLoaded: false
            };
          }, {
            children: childrenField
          });
          node[childrenField] = nodeList;
          if (transform) {
            node[childrenField] = nodeList;
          }
          updateNodeLine(node);
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode
    };
    const cacheNodeMap = () => {
      const {
        treeList
      } = reactData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(treeList, (item, itemIndex, items, path, parent, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          itemIndex,
          items,
          parent,
          nodes,
          level: nodes.length,
          lineCount: 0,
          treeLoaded: false
        };
      }, {
        children: childrenField
      });
      reactData.nodeMaps = keyMaps;
    };
    const updateData = list => {
      const {
        transform
      } = props;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      if (transform) {
        reactData.treeList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(list, {
          key: keyField,
          parentKey: parentField,
          mapChildren: childrenField
        });
      } else {
        reactData.treeList = list ? list.slice(0) : [];
      }
      cacheNodeMap();
    };
    const handleCountLine = (item, isRoot, nodeItem) => {
      const {
        treeExpandedMaps
      } = reactData;
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(item);
      nodeItem.lineCount++;
      if (treeExpandedMaps[nodeid]) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(item[childrenField], (childItem, childIndex, childList) => {
          if (!isRoot || childIndex < childList.length - 1) {
            handleCountLine(childItem, false, nodeItem);
          }
        });
      }
    };
    const updateNodeLine = node => {
      const {
        nodeMaps
      } = reactData;
      if (node) {
        const nodeid = getNodeId(node);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastArrayEach(nodeItem.nodes, childItem => {
            const nodeid = getNodeId(childItem);
            const nodeItem = nodeMaps[nodeid];
            if (nodeItem) {
              nodeItem.lineCount = 0;
              handleCountLine(childItem, true, nodeItem);
            }
          });
        }
      }
    };
    const handleNodeClickEvent = (evnt, node) => {
      const {
        showRadio,
        showCheckbox,
        trigger
      } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === 'node') {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === 'node') {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === 'node') {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent('node-click', {
        node,
        triggerCurrent,
        triggerRadio,
        triggerCheckbox,
        triggerExpand
      }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent('node-dblclick', {
        node
      }, evnt);
    };
    const handleAsyncTreeExpandChilds = node => {
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        loadMethod
      } = props;
      const {
        checkStrictly
      } = checkboxOpts;
      return new Promise(resolve => {
        if (loadMethod) {
          const {
            treeExpandLazyLoadedMaps
          } = reactData;
          const {
            nodeMaps
          } = reactData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          treeExpandLazyLoadedMaps[nodeid] = true;
          Promise.resolve(loadMethod({
            $tree: $xeTree,
            node
          })).then(childRecords => {
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              delete treeExpandLazyLoadedMaps[nodeid];
            }
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return treeMethods.loadChildrenNode(node, childRecords).then(childRows => {
                const {
                  treeExpandedMaps
                } = reactData;
                if (childRows.length && !treeExpandedMaps[nodeid]) {
                  treeExpandedMaps[nodeid] = true;
                }
                // 如果当前节点已选中，则展开后子节点也被选中
                if (!checkStrictly && treeMethods.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows.map(item => getNodeId(item)), true);
                }
                updateNodeLine(node);
                dispatchEvent('load-success', {
                  node,
                  data: childRecords
                }, new Event('load-success'));
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
              });
            } else {
              updateNodeLine(node);
              dispatchEvent('load-success', {
                node,
                data: childRecords
              }, new Event('load-success'));
            }
          }).catch(e => {
            const {
              treeExpandLazyLoadedMaps
            } = reactData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              delete treeExpandLazyLoadedMaps[nodeid];
            }
            updateNodeLine(node);
            dispatchEvent('load-error', {
              node,
              data: e
            }, new Event('load-error'));
          }).finally(() => {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
          });
        } else {
          resolve();
        }
      });
    };
    /**
     * 展开与收起树节点
     * @param nodeList
     * @param expanded
     * @returns
     */
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const {
        lazy,
        accordion,
        toggleMethod
      } = props;
      const {
        nodeMaps,
        treeExpandLazyLoadedMaps
      } = reactData;
      const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter(node => toggleMethod({
        $tree: $xeTree,
        expanded,
        node
      })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        // 同一级只能展开一个
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach(item => {
            const itemNodeId = getNodeId(item);
            if (tempExpandedMaps[itemNodeId]) {
              delete tempExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach(item => {
          const itemNodeId = getNodeId(item);
          if (!tempExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            // 是否使用懒加载
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                tempExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach(item => {
          const itemNodeId = getNodeId(item);
          if (tempExpandedMaps[itemNodeId]) {
            delete tempExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.treeExpandedMaps = tempExpandedMaps;
      expandNodes.forEach(updateNodeLine);
      return Promise.all(result);
    };
    const toggleExpandEvent = (evnt, node) => {
      const {
        lazy
      } = props;
      const {
        treeExpandedMaps,
        treeExpandLazyLoadedMaps
      } = reactData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const handleNodeCheckboxStatus = (node, selectKeyMaps, indeterminateMaps) => {
      const childrenField = computeChildrenField.value;
      const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
      const nodeid = getNodeId(node);
      if (childList && childList.length) {
        let checkSome = false;
        let checkSize = 0;
        childList.forEach(childNode => {
          const childNodeid = getNodeId(childNode);
          const isChecked = selectKeyMaps[childNodeid];
          if (isChecked || indeterminateMaps[childNodeid]) {
            if (isChecked) {
              checkSize++;
            }
            checkSome = true;
          }
        });
        const checkAll = checkSize === childList.length;
        if (checkAll) {
          if (!selectKeyMaps[nodeid]) {
            selectKeyMaps[nodeid] = true;
          }
          if (indeterminateMaps[nodeid]) {
            delete indeterminateMaps[nodeid];
          }
        } else {
          if (selectKeyMaps[nodeid]) {
            delete selectKeyMaps[nodeid];
          }
          indeterminateMaps[nodeid] = checkSome;
        }
      } else {
        if (indeterminateMaps[nodeid]) {
          delete indeterminateMaps[nodeid];
        }
      }
    };
    const updateCheckboxStatus = () => {
      const {
        treeList
      } = reactData;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly
      } = checkboxOpts;
      if (!checkStrictly) {
        const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
        const indeterminateMaps = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(treeList, (node, index, items, path, parent, nodes) => {
          const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
          if (!childList || !childList.length) {
            handleNodeCheckboxStatus(node, selectKeyMaps, indeterminateMaps);
          }
          if (index === items.length - 1) {
            for (let len = nodes.length - 2; len >= 0; len--) {
              const parentItem = nodes[len];
              handleNodeCheckboxStatus(parentItem, selectKeyMaps, indeterminateMaps);
            }
          }
        });
        reactData.selectCheckboxMaps = selectKeyMaps;
        reactData.indeterminateCheckboxMaps = indeterminateMaps;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly,
        checkMethod
      } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectKeyMaps[nodeid]) {
        delete selectKeyMaps[nodeid];
      } else {
        isChecked = true;
        selectKeyMaps[nodeid] = isChecked;
      }
      if (!checkStrictly) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField), childNode => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectKeyMaps[childNodeid]) {
              selectKeyMaps[childNodeid] = true;
            }
          } else {
            if (selectKeyMaps[childNodeid]) {
              delete selectKeyMaps[childNodeid];
            }
          }
        }, {
          children: childrenField
        });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
      updateCheckboxStatus();
      const value = Object.keys(reactData.selectCheckboxMaps);
      emitCheckboxMode(value);
      dispatchEvent('checkbox-change', {
        node,
        value,
        checked: isChecked
      }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const {
        currentMethod,
        trigger
      } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === 'child') {
        if (hasChild) {
          return;
        }
      } else if (trigger === 'parent') {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent('current-change', {
        node,
        checked: isChecked
      }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const {
        checkMethod
      } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const value = getNodeId(node);
      reactData.selectRadioKey = value;
      emitRadioMode(value);
      dispatchEvent('radio-change', {
        node,
        value,
        checked: isChecked
      }, evnt);
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const {
        showRadio
      } = props;
      const radioOpts = computeRadioOpts.value;
      const {
        showIcon,
        checkMethod,
        visibleMethod
      } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({
        node
      });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({
            node
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tree--radio-option', {
            'is--checked': isChecked,
            'is--disabled': isDisabled
          }],
          onClick: evnt => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-radio--icon', isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
        })]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const {
        showCheckbox
      } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        showIcon,
        checkMethod,
        visibleMethod
      } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({
        node
      });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({
            node
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tree--checkbox-option', {
            'is--checked': isChecked,
            'is--indeterminate': isIndeterminate,
            'is--disabled': isDisabled
          }],
          onClick: evnt => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
        })]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderNode = node => {
      const {
        lazy,
        showRadio,
        showCheckbox,
        showLine,
        indent,
        iconOpen,
        iconClose,
        iconLoaded,
        showIcon
      } = props;
      const {
        nodeMaps,
        treeExpandedMaps,
        currentNode,
        selectRadioKey,
        treeExpandLazyLoadedMaps
      } = reactData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
      const hasChild = childList && childList.length;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const nodeid = getNodeId(node);
      const isExpand = treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, titleField);
      const childVns = [];
      if (hasChild && treeExpandedMaps[nodeid]) {
        if (showLine) {
          childVns.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: 'line',
            class: 'vxe-tree--node-child-line',
            style: {
              height: `calc(${nodeItem.lineCount} * var(--vxe-ui-tree-node-height) - var(--vxe-ui-tree-node-height) / 2)`,
              left: `${(nodeItem.level + 1) * (indent || 1)}px`
            }
          }));
        }
        childList.forEach(childItem => {
          childVns.push(renderNode(childItem));
        });
      }
      let isRadioChecked = false;
      if (showRadio) {
        // eslint-disable-next-line eqeqeq
        isRadioChecked = nodeid == selectRadioKey;
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tree--node-wrapper', `node--level-${nodeItem.level}`],
        nodeid
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tree--node-item', {
          'is--current': currentNode && nodeid === getNodeId(currentNode),
          'is-radio--checked': isRadioChecked,
          'is-checkbox--checked': isCheckboxChecked
        }],
        style: {
          paddingLeft: `${(nodeItem.level - 1) * (indent || 1)}px`
        },
        onClick(evnt) {
          handleNodeClickEvent(evnt, node);
        },
        onDblclick(evnt) {
          handleNodeDblclickEvent(evnt, node);
        }
      }, [showIcon || showLine ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-switcher'
      }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-icon',
        onClick(evnt) {
          toggleExpandEvent(evnt, node);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
      })])] : []) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), renderRadio(node, nodeid, isRadioChecked), renderCheckbox(node, nodeid, isCheckboxChecked), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-title'
      }, titleSlot ? getSlotVNs(titleSlot({
        node
      })) : `${nodeValue}`), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-extra'
      }, getSlotVNs(extraSlot({
        node
      }))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]), hasChild && treeExpandedMaps[nodeid] ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-child-wrapper'
      }, childVns) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    const renderNodeList = () => {
      const {
        treeList
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-list-wrapper'
      }, treeList.map(node => renderNode(node)));
    };
    const renderVN = () => {
      const {
        loading,
        trigger,
        showLine
      } = props;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeStyle = computeTreeStyle.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const loadingSlot = slots.loading;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tree', {
          [`size--${vSize}`]: vSize,
          'show--line': showLine,
          'checkbox--highlight': checkboxOpts.highlight,
          'radio--highlight': radioOpts.highlight,
          'node--hover': isRowHover,
          'node--trigger': trigger === 'node',
          'is--loading': loading
        }],
        style: treeStyle
      }, [renderNodeList(),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-tree--loading',
        modelValue: loading,
        icon: loadingOpts.icon,
        text: loadingOpts.text
      }, loadingSlot ? {
        default: () => loadingSlot({
          $tree: $xeTree
        })
      } : {})]);
    };
    $xeTree.renderVN = renderVN;
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      updateData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKey, val => {
      reactData.selectRadioKey = val;
    });
    const checkboxFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      reactData.treeList = [];
      reactData.treeExpandedMaps = {};
      reactData.nodeMaps = {};
    });
    updateData(props.data || []);
    updateCheckboxChecked(props.checkNodeKeys || []);
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tree-select/src/tree-select.ts







function tree_select_getOptUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('node_');
}
/* harmony default export */ var tree_select = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTreeSelect',
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(getConfig().select.placeholder) ? i18n_getI18n('vxe.base.pleaseSelect') : getConfig().select.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    remote: Boolean,
    remoteMethod: Function,
    treeConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'blur', 'focus', 'click', 'node-click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      fullOptionList: [],
      fullNodeMaps: {},
      visibleOptionList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeTreeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig);
    });
    const computeTreeNodeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        isHover: true
      }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: 'node'
      });
    });
    const computeTreeRadioOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: 'node'
      });
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || 'children';
    });
    const computeParentField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || 'parentField';
    });
    const computeHasChildField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || 'hasChild';
    });
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const {
        fullNodeMaps
      } = reactData;
      return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue]).map(value => {
        const cacheItem = fullNodeMaps[value];
        const labelField = computeLabelField.value;
        return cacheItem ? cacheItem.item[labelField] : value;
      }).join(', ');
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const treeSelectMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $treeSelect: $xeTreeSelect
        }, params));
      }
    };
    const getOptid = option => {
      const valueField = computeValueField.value;
      const optid = option[valueField];
      return optid ? encodeURIComponent(optid) : '';
    };
    /**
     * 刷新选项，当选项被动态显示/隐藏时可能会用到
     */
    const refreshOption = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const cacheItemMap = () => {
      const {
        options
      } = props;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const nodeMaps = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(options, (item, index, items, parent, nodes) => {
        let nodeid = getOptid(item);
        if (!nodeid) {
          nodeid = tree_select_getOptUniqueId();
          item[valueField] = nodeid;
        }
        nodeMaps[nodeid] = {
          item,
          index,
          items,
          parent,
          nodes
        };
      }, {
        children: childrenField
      });
      reactData.fullOptionList = options || [];
      reactData.fullNodeMaps = nodeMaps;
      refreshOption();
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(el);
          let panelPlacement = 'bottom';
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const {
        loading
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading && !isDisabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.animatVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.animatVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const {
        fullNodeMaps
      } = reactData;
      if (selectValue !== props.modelValue) {
        const cacheItem = fullNodeMaps[selectValue];
        emit('update:modelValue', selectValue);
        treeSelectMethods.dispatchEvent('change', {
          value: selectValue,
          option: cacheItem ? cacheItem.item : null
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      treeSelectMethods.dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      treeSelectMethods.dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      treeSelectMethods.dispatchEvent('click', {}, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      treeSelectMethods.dispatchEvent('blur', {}, evnt);
    };
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = params => {
      const {
        $event
      } = params;
      treeSelectMethods.dispatchEvent('node-click', params, $event);
    };
    const radioChangeEvent = params => {
      const {
        value,
        $event
      } = params;
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = params => {
      const {
        value,
        $event
      } = params;
      changeEvent($event, value);
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const {
        className,
        modelValue,
        multiple,
        options,
        popupClassName,
        loading
      } = props;
      const {
        initialized,
        isActivated,
        visiblePanel
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const transfer = computeTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-tree-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tree-select-slots',
          ref: 'hideOption'
        }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tree-select-label'
        }, selectLabel)]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tree-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $treeSelect: $xeTreeSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: props.placeholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
        modelValue: selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: togglePanelEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: transfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-tree-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $treeSelect: $xeTreeSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': transfer,
          'animat--leave': !loading && reactData.animatVisible,
          'animat--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-header'
      }, headerSlot({})) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionWrapper,
        class: 'vxe-tree-select-option--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tree, {
        class: 'vxe-tree-select--tree',
        data: options,
        indent: treeOpts.indent,
        showRadio: !multiple,
        radioConfig: treeRadioOpts,
        checkNodeKey: multiple ? null : modelValue,
        showCheckbox: !!multiple,
        checkNodeKeys: multiple ? modelValue : null,
        checkboxConfig: treeCheckboxOpts,
        titleField: labelField,
        valueField: valueField,
        keyField: treeOpts.keyField,
        childrenField: treeOpts.childrenField || childrenField,
        parentField: treeOpts.parentField || parentField,
        hasChildField: treeOpts.hasChildField || hasChildField,
        accordion: treeOpts.accordion,
        nodeConfig: treeNodeOpts,
        lazy: treeOpts.lazy,
        loadMethod: treeOpts.loadMethod,
        toggleMethod: treeOpts.toggleMethod,
        transform: treeOpts.transform,
        trigger: treeOpts.trigger,
        showIcon: treeOpts.showIcon,
        showLine: treeOpts.showLine,
        iconOpen: treeOpts.iconOpen,
        iconLoaded: treeOpts.iconLoaded,
        iconClose: treeOpts.iconClose,
        onNodeClick: nodeClickEvent,
        onRadioChange: radioChangeEvent,
        onCheckboxChange: checkboxChangeEvent
      })])]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-footer'
      }, footerSlot({})) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])] : [])])]);
    };
    $xeTreeSelect.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      cacheItemMap();
    });
    cacheItemMap();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeTreeSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTreeSelect, 'mousewheel');
      globalEvents.off($xeTreeSelect, 'mousedown');
      globalEvents.off($xeTreeSelect, 'blur');
    });
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-tree-select/vxe-tree-select-view.ts





const WidgetVxeTreeSelectViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tree_select, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || i18n_getI18n('vxe.base.pleaseSelect'),
            options: options.options,
            optionProps: {
              label: 'value',
              value: 'value'
            },
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-tree-select/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-radio-group/vxe-radio-group-data.ts



const getWidgetVxeRadioGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-radio-checked',
    options: {
      options: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, 3).map((v, i) => {
        return {
          value: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.defValue', [i + 1])
        };
      })
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-radio-group/vxe-radio-group-form.ts







const WidgetVxeRadioGroupFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      renderDataSourceFormItem
    } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          }), renderDataSourceFormItem()];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-radio-group/vxe-radio-group-view.ts




const WidgetVxeRadioGroupViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: {
              label: 'value',
              value: 'value'
            },
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-radio-group/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-data.ts



const getWidgetVxeCheckboxGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-checkbox-checked',
    options: {
      options: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().range(0, 3).map((v, i) => {
        return {
          value: i18n_getI18n('vxe.formDesign.widgetProp.dataSource.defValue', [i + 1])
        };
      })
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-form.ts







const WidgetVxeCheckboxGroupFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      renderDataSourceFormItem
    } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.placeholder'),
            field: 'placeholder',
            itemRender: {
              name: 'VxeInput'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          }), renderDataSourceFormItem()];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-view.ts




const WidgetVxeCheckboxGroupViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(group, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: {
              label: 'value',
              value: 'value'
            },
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-checkbox-group/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-file/vxe-upload-file-data.ts


function getLimitSizeOptions() {
  const sizeOpts = [{
    label: '无限制',
    value: ''
  }];
  const sizeList = [1, 2, 5, 10, 20, 50, 100, 200, 500];
  sizeList.forEach(num => {
    sizeOpts.push({
      label: `${num}M`,
      value: num
    });
  });
  return sizeOpts;
}
const getWidgetVxeUploadFileConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-file',
    options: {
      limitCount: '',
      limitSize: 100,
      multiple: false
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-file/vxe-upload-file-form.ts








const WidgetVxeUploadFileFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const limitSizeOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getLimitSizeOptions());
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.uploadProp.multiFile'),
            field: 'multiple',
            itemRender: {
              name: 'VxeSwitch'
            }
          }), options.multiple ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.uploadProp.limitFileCount'),
            field: 'limitCount',
            itemRender: {
              name: 'VxeInput',
              props: {
                type: 'integer',
                min: 1,
                clearable: true
              }
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.uploadProp.limitFileSize'),
            field: 'limitSize',
            itemRender: {
              name: 'VxeSelect',
              options: limitSizeOptions.value
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.delete.js
var web_url_search_params_delete = __webpack_require__(4603);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.has.js
var web_url_search_params_has = __webpack_require__(7566);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js
var web_url_search_params_size = __webpack_require__(8721);
;// CONCATENATED MODULE: ./packages/upload/src/util.ts





// 导入
let fileForm = null;
let fileInput = null;
function parseFile(file) {
  const name = file.name;
  const tIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastIndexOf(name, '.');
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return {
    filename,
    type
  };
}
/**
 * 读取本地文件
 */
const readLocalFile = options => {
  const opts = Object.assign({}, options);
  return new Promise((resolve, reject) => {
    if (!fileInput) {
      fileInput = document.createElement('input');
      fileInput.name = 'file';
      fileInput.type = 'file';
    }
    if (!fileForm) {
      fileForm = document.createElement('form');
      fileForm.className = 'vxe-table--file-form';
      fileForm.appendChild(fileInput);
      document.body.appendChild(fileForm);
    }
    const types = opts.types || [];
    const isAllType = !types.length || types.some(type => type === '*');
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? '' : `.${types.join(', .')}`;
    fileInput.onchange = evnt => {
      const eventTarget = evnt.target;
      const files = Array.from(eventTarget.files || []);
      const file = files[0];
      let errType = '';
      // 校验类型
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const {
            type
          } = parseFile(files[fIndex]);
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({
          status: true,
          files,
          file
        });
      } else {
        if (opts.message !== false) {
          if (core_VxeUI.modal) {
            core_VxeUI.modal.message({
              content: i18n_getI18n('vxe.error.notType', [errType]),
              status: 'error'
            });
          }
        }
        const params = {
          status: false,
          files,
          file
        };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function getExportBlobByContent(content, options) {
  return new Blob([content], {
    type: `text/${options.type};charset=utf-8;`
  });
}
/**
 * 保存文件到本地
 */
const saveLocalFile = options => {
  const opts = Object.assign({
    type: ''
  }, options);
  const {
    filename,
    type,
    content
  } = opts;
  const name = type ? `${filename}.${type}` : `${filename}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content), opts);
    const winNavigator = window.navigator;
    if (winNavigator.msSaveBlob) {
      winNavigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement('a');
      linkElem.target = '_blank';
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(i18n_getI18n('vxe.error.notExp')));
};
;// CONCATENATED MODULE: ./packages/upload/src/upload.ts









/* harmony default export */ var upload = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeUpload',
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => getConfig().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    mode: {
      type: String,
      default: () => getConfig().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageTypes, true)
    },
    imageStyle: {
      type: Object,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.fileTypes, true)
    },
    singleMode: Boolean,
    urlMode: Boolean,
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => getConfig().upload.limitSize
    },
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    nameField: {
      type: String,
      default: () => getConfig().upload.nameField
    },
    typeField: {
      type: String,
      default: () => getConfig().upload.typeField
    },
    urlField: {
      type: String,
      default: () => getConfig().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => getConfig().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => getConfig().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => getConfig().upload.showProgress
    },
    autoHiddenButton: {
      type: Boolean,
      default: () => getConfig().upload.autoHiddenButton
    },
    buttonText: {
      type: String,
      default: () => getConfig().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => getConfig().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => getConfig().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => getConfig().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => getConfig().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().upload.showPreview
    },
    tipText: String,
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    removeMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => getConfig().upload.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'add', 'remove', 'download', 'upload-success', 'upload-error'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isDrag: false,
      fileList: []
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsImage = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.mode === 'image';
    });
    const computeNameProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.nameField || 'name';
    });
    const computeTypeProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.typeField || 'type';
    });
    const computeUrlProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.urlField || 'url';
    });
    const computeSizeProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.sizeField || 'size';
    });
    const computeLimitMaxSizeB = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.multiple ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitCount) : 1;
    });
    const computeOverCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const {
        fileList
      } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const limitSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return '';
    });
    const computedDefHintText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        limitSize,
        fileTypes,
        multiple,
        limitCount
      } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(tipText)) {
        return tipText;
      }
      const defHints = [];
      if (isImage) {
        if (multiple && limitCount) {
          defHints.push(i18n_getI18n('vxe.upload.imgCountHint', [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(i18n_getI18n('vxe.upload.imgSizeHint', [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defHints.push(i18n_getI18n('vxe.upload.fileTypeHint', [fileTypes.join('/')]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(i18n_getI18n('vxe.upload.fileSizeHint', [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defHints.push(i18n_getI18n('vxe.upload.fileCountHint', [limitCount]));
        }
      }
      return defHints.join(i18n_getI18n('vxe.base.comma'));
    });
    const computeImageStyleOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.imageStyle);
    });
    const computeImgStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = computeImageStyleOpts.value;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMoreOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showMoreButton: true
      }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateFileList = () => {
      const {
        modelValue,
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue] : []).map(item => {
        if (!item || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
          const url = `${item || ''}`;
          const name = parseFileName(url);
          return {
            [nameProp]: name,
            [typeProp]: parseFileType(name),
            [urlProp]: url,
            [sizeProp]: 0
          };
        }
        const name = item[nameProp] || '';
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || '';
        item[sizeProp] = item[sizeProp] || 0;
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = url => {
      return decodeURIComponent(`${url || ''}`).split('/').pop() || '';
    };
    const parseFileType = name => {
      const index = name ? name.indexOf('.') : -1;
      if (index > -1) {
        return name.substring(index + 1, name.length).toLowerCase();
      }
      return '';
    };
    const uploadMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $upload: $xeUpload
        }, params));
      }
    };
    const emitModel = value => {
      const {
        singleMode,
        urlMode
      } = props;
      const urlProp = computeUrlProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlMode) {
        restList = restList.map(item => item[urlProp]);
      }
      emit('update:modelValue', singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = item => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = item => {
      const getUrlFn = props.getUrlMethod || getConfig().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const imagePreviewTypes = ['jpg', 'jpeg', 'png', 'gif'];
    const handleDefaultFilePreview = item => {
      const {
        imageTypes,
        showDownloadButton
      } = props;
      const typeProp = computeTypeProp.value;
      // 如果是预览图片
      if (imagePreviewTypes.concat(imageTypes || []).some(type => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (core_VxeUI.previewImage) {
          core_VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || getConfig().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index) => {
      const {
        showDownloadButton
      } = props;
      const {
        fileList
      } = reactData;
      if (props.showPreview) {
        if (core_VxeUI.previewImage) {
          core_VxeUI.previewImage({
            urlList: fileList.map(item => getFileUrl(item)),
            activeIndex: index,
            showDownloadButton
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const {
        showErrorStatus
      } = props;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && item._X_DATA) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            Object.assign(item._X_DATA || {}, {
              p: Math.max(0, Math.min(99, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(percentNum)))
            });
          }
        })).then(res => {
          Object.assign(item._X_DATA || {}, {
            l: false,
            p: 100
          });
          Object.assign(item, res);
          uploadMethods.dispatchEvent('upload-success', {
            option: item,
            data: res
          }, null);
        }).catch(res => {
          Object.assign(item._X_DATA || {}, {
            l: false,
            s: 'error'
          });
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter(obj => obj._X_DATA !== item._X_DATA);
          }
          uploadMethods.dispatchEvent('upload-error', {
            option: item,
            data: res
          }, null);
        });
      }
      return Promise.resolve();
    };
    const handleReUpload = item => {
      const {
        uploadMethod,
        urlMode
      } = props;
      const uploadFn = uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && item._X_DATA) {
        const file = item._X_DATA.f;
        Object.assign(item._X_DATA, {
          l: true,
          s: '',
          p: 0
        });
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            emitModel(reactData.fileList);
          }
        });
      }
    };
    const uploadFile = (files, evnt) => {
      const {
        multiple,
        urlMode
      } = props;
      const {
        fileList
      } = reactData;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSizeB = computeLimitMaxSizeB.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        // 校验文件数量
        if (fileList.length >= limitMaxCount) {
          if (core_VxeUI.modal) {
            core_VxeUI.modal.notification({
              title: i18n_getI18n('vxe.modal.errTitle'),
              status: 'error',
              content: i18n_getI18n('vxe.upload.overCountErr', [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (core_VxeUI.modal) {
            core_VxeUI.modal.notification({
              title: i18n_getI18n('vxe.modal.errTitle'),
              status: 'error',
              slots: {
                default() {
                  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                    class: 'vxe-upload--file-message-over-error'
                  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, i18n_getI18n('vxe.upload.overCountExtraErr', [limitMaxCount, overNum])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                    class: 'vxe-upload--file-message-over-extra'
                  }, overExtraList.map((file, index) => {
                    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                      key: index,
                      class: 'vxe-upload--file-message-over-extra-item'
                    }, file.name);
                  }))]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      // 校验文件大小
      if (limitMaxSizeB) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSizeB) {
            if (core_VxeUI.modal) {
              core_VxeUI.modal.notification({
                title: i18n_getI18n('vxe.modal.errTitle'),
                status: 'error',
                content: i18n_getI18n('vxe.upload.overSizeErr', [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach(file => {
        const {
          name
        } = file;
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: ''
        };
        if (uploadFn) {
          fileObj._X_DATA = {
            k: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
            f: file,
            l: true,
            s: '',
            p: 0
          };
        }
        const item = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(fileObj);
        if (uploadFn) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
        uploadMethods.dispatchEvent('add', {
          option: item
        }, evnt);
      });
      reactData.fileList = newFileList;
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        emitModel(newFileList);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const clickEvent = evnt => {
      const {
        multiple,
        imageTypes,
        fileTypes
      } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return;
      }
      readLocalFile({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then(({
        files
      }) => {
        uploadFile(files, evnt);
      }).catch(() => {
        // 错误文件类型
      });
    };
    const handleRemoveEvent = (evnt, item, index) => {
      const {
        fileList
      } = reactData;
      fileList.splice(index, 1);
      emitModel(fileList);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      uploadMethods.dispatchEvent('remove', {
        option: item
      }, evnt);
    };
    const removeFileEvent = (evnt, item, index) => {
      const removeFn = props.removeMethod || getConfig().upload.removeMethod;
      if (removeFn) {
        Promise.resolve(removeFn({
          $upload: $xeUpload,
          option: item
        })).then(() => {
          handleRemoveEvent(evnt, item, index);
        }).catch(e => e);
      } else {
        handleRemoveEvent(evnt, item, index);
      }
    };
    const handleDownloadEvent = (evnt, item) => {
      uploadMethods.dispatchEvent('download', {
        option: item
      }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const downloadFn = props.downloadMethod || getConfig().upload.downloadMethod;
      if (downloadFn) {
        Promise.resolve(downloadFn({
          $upload: $xeUpload,
          option: item
        })).then(() => {
          handleDownloadEvent(evnt, item);
        }).catch(e => e);
      } else {
        handleDownloadEvent(evnt, item);
      }
    };
    const handleDragleaveEvent = evnt => {
      const elem = refElem.value;
      const {
        clientX,
        clientY
      } = evnt;
      if (elem) {
        const {
          x: targetX,
          y: targetY,
          height: targetHeight,
          width: targetWidth
        } = elem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDrag = false;
        }
      }
    };
    const handleDragoverEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDrag = true;
        }
      }
    };
    const handleDropEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          const files = [];
          Array.from(items).forEach(item => {
            const file = item.getAsFile();
            if (file) {
              files.push(file);
            }
          });
          uploadFile(files, evnt);
          evnt.preventDefault();
        }
      }
      reactData.isDrag = false;
    };
    const handleMoreEvent = () => {
      const isImage = computeIsImage.value;
      core_VxeUI.modal.open({
        title: '查看列表',
        width: 660,
        height: 500,
        escClosable: true,
        showMaximize: true,
        resize: true,
        maskClosable: true,
        slots: {
          default() {
            const {
              fileList
            } = reactData;
            if (isImage) {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--image-more-list'
              }, renderImageItemList(fileList, true));
            }
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-upload--file-more-list'
            }, renderFileItemList(fileList));
          }
        }
      });
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = currList => {
      const {
        showRemoveButton,
        showDownloadButton,
        showProgress,
        showPreview,
        showErrorStatus
      } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      return currList.map((item, index) => {
        const isLoading = item._X_DATA && item._X_DATA.l;
        const isError = item._X_DATA && item._X_DATA.s === 'error';
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: index,
          class: ['vxe-upload--file-item', {
            'is--preview': showPreview,
            'is--loading': isLoading,
            'is--error': isError
          }]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || getIcon().UPLOAD_FILE_TYPE_DEFAULT
        })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-name',
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewFileEvent(evnt, item);
            }
          }
        }, `${item[nameProp] || ''}`), isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-loading-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_LOADING
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showProgress && isLoading && item._X_DATA ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-loading-text'
        }, i18n_getI18n('vxe.upload.uploadProgress', [item._X_DATA.p])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showErrorStatus && isError ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-error'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: i18n_getI18n('vxe.upload.reUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showDownloadButton && !isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-download-icon',
          onClick(evnt) {
            downloadFileEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_FILE_DOWNLOAD
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-remove-icon',
          onClick(evnt) {
            removeFileEvent(evnt, item, index);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_FILE_REMOVE
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
      });
    };
    const renderAllMode = () => {
      const {
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const {
        fileList
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const moreOpts = computeMoreOpts.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      const {
        maxCount,
        showMoreButton,
        layout
      } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (formReadonly && maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'all',
        class: 'vxe-upload--file-wrapper'
      }, [formReadonly ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action'
      }, [autoHiddenButton && overCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action-btn',
        onClick: clickEvent
      }, defaultSlot ? getSlotVNs(defaultSlot({
        $upload: $xeUpload
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: showButtonText ? buttonText ? `${buttonText}` : i18n_getI18n('vxe.upload.fileBtnText') : '',
        icon: showButtonIcon ? buttonIcon || getIcon().UPLOAD_FILE_ADD : '',
        disabled: isDisabled
      })]), defHintText || tipSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action-tip'
      }, tipSlot ? getSlotVNs(tipSlot({
        $upload: $xeUpload
      })) : defHintText) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), currList.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-upload--file-list-wrapper', {
          'is--horizontal': layout === 'horizontal'
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-list'
      }, renderFileItemList(currList)), formReadonly && showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-over-more'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        mode: 'text',
        content: i18n_getI18n('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    const renderImageItemList = (currList, isPreview) => {
      const {
        showRemoveButton,
        showProgress,
        showPreview,
        showErrorStatus
      } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imgStyle = computeImgStyle.value;
      return currList.map((item, index) => {
        const isLoading = item._X_DATA && item._X_DATA.l;
        const isError = item._X_DATA && item._X_DATA.s === 'error';
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: index,
          class: ['vxe-upload--image-item', {
            'is--preview': showPreview,
            'is--loading': isLoading,
            'is--error': isError
          }]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-box',
          style: isPreview ? null : imgStyle,
          title: i18n_getI18n('vxe.upload.viewItemTitle'),
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewImageEvent(evnt, item, index);
            }
          }
        }, [isLoading && item._X_DATA ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_LOADING
        })]), showProgress ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading-text'
        }, i18n_getI18n('vxe.upload.uploadProgress', [item._X_DATA.p])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), !isLoading ? isError && showErrorStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-error'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: i18n_getI18n('vxe.upload.reUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-upload--image-item-img',
          src: getThumbnailFileUrl(item)
        }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-remove-icon',
          onClick(evnt) {
            evnt.stopPropagation();
            removeFileEvent(evnt, item, index);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_IMAGE_REMOVE
        })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
      });
    };
    const renderImageMode = () => {
      const {
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const {
        fileList
      } = reactData;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const moreOpts = computeMoreOpts.value;
      const defaultSlot = slots.default;
      const hintSlot = slots.hint;
      const {
        maxCount,
        showMoreButton
      } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (formReadonly && maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'image',
        class: 'vxe-upload--image-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-list'
      }, renderImageItemList(currList, false).concat([formReadonly && showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-over-more'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        mode: 'text',
        content: i18n_getI18n('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), formReadonly || autoHiddenButton && overCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-btn',
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({
        $upload: $xeUpload
      }) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-box',
        style: imgStyle
      }, [showButtonIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: buttonIcon || getIcon().UPLOAD_IMAGE_ADD
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showButtonText ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-content'
      }, buttonText ? `${buttonText}` : i18n_getI18n('vxe.upload.imgBtnText')) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), defHintText || hintSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-hint'
      }, hintSlot ? getSlotVNs(hintSlot({
        $upload: $xeUpload
      })) : defHintText) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])])]))]);
    };
    const renderVN = () => {
      const {
        showErrorStatus
      } = props;
      const {
        isDrag
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-upload', {
          [`size--${vSize}`]: vSize,
          'is--readonly': formReadonly,
          'is--disabled': isDisabled,
          'show--error': showErrorStatus,
          'is--drag': isDrag
        }],
        onDragover: handleDragoverEvent,
        onDragleave: handleDragleaveEvent,
        onDrop: handleDropEvent
      }, [isImage ? renderImageMode() : renderAllMode(), isDrag ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--drag-placeholder'
      }, i18n_getI18n('vxe.upload.dragPlaceholder')) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeUpload.renderVN = renderVN;
    const listFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      listFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(listFlag, () => {
      updateFileList();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (true) {
        if (props.multiple && props.singleMode) {
          errLog('vxe.error.errConflicts', ['multiple', 'single-mode']);
        }
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      reactData.isDrag = false;
    });
    updateFileList();
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-file/vxe-upload-file-view.ts




const WidgetVxeUploadFileViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(upload, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: 'all',
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-file/index.ts



;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-image/vxe-upload-image-data.ts

const getWidgetVxeUploadImageConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: 'vxe-icon-file-image',
    options: {
      limitCount: 9,
      limitSize: 10,
      multiple: false
    }
  };
};
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-image/vxe-upload-image-form.ts








const WidgetVxeUploadImageFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const limitSizeOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getLimitSizeOptions());
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        class: ['vxe-form-design--widget-render-form-wrapper', `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.name')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
                modelValue: widget.title,
                'onUpdate:modelValue'(val) {
                  widget.title = val;
                }
              });
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.uploadProp.multiImg'),
            field: 'multiple',
            itemRender: {
              name: 'VxeSwitch'
            }
          }), options.multiple ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.uploadProp.limitImgCount'),
            field: 'limitCount',
            itemRender: {
              name: 'VxeInput',
              props: {
                type: 'integer',
                min: 1,
                clearable: true
              }
            }
          }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.uploadProp.limitImgSize'),
            field: 'limitSize',
            itemRender: {
              name: 'VxeSelect',
              options: limitSizeOptions.value
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.formDesign.widgetProp.required')
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                modelValue: widget.required,
                'onUpdate:modelValue'(val) {
                  widget.required = val;
                }
              });
            }
          })];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-image/vxe-upload-image-view.ts




const WidgetVxeUploadImageViewComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormView', null);
    const {
      computeKebabCaseName
    } = useWidgetName(props);
    const changeEvent = () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const {
        renderParams
      } = props;
      const {
        widget
      } = renderParams;
      const {
        options
      } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        class: ['vxe-form-design--widget-render-form-item', `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(upload, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: 'image',
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            'onUpdate:modelValue'(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/form-design/widget-vxe-upload-image/index.ts



;// CONCATENATED MODULE: ./packages/form-design/render/index.ts



















/**
 * 表单设计器 - 渲染器
 */
renderer.mixin({
  text: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetTextViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetTextFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  /**
   * 已废弃
   */
  title: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetTextViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetTextFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  row: {
    createFormDesignWidgetConfig: getWidgetRowConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetRowEditComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetRowViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetRowFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  subtable: {
    createFormDesignWidgetConfig: getWidgetSubtableConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetSubtableEditComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetSubtableViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetSubtableFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  input: {
    createFormDesignWidgetConfig: getWidgetInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetInputViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetInputFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  textarea: {
    createFormDesignWidgetConfig: getWidgetTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetTextareaViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetTextareaFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  select: {
    createFormDesignWidgetConfig: getWidgetSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetSelectViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetSelectFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeInput: {
    createFormDesignWidgetConfig: getWidgetVxeInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeInputViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeInputFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeNumberInput: {
    createFormDesignWidgetConfig: getWidgetVxeNumberInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeNumberInputViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeNumberInputFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeDatePicker: {
    createFormDesignWidgetConfig: getWidgetVxeDatePickerConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeDatePickerViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeDatePickerFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeTextarea: {
    createFormDesignWidgetConfig: getWidgetVxeTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeTextareaViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeTextareaFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeSwitch: {
    createFormDesignWidgetConfig: getWidgetVxeSwitchConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeSwitchViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeSwitchFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeSelectViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeSelectFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeTreeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeTreeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeTreeSelectViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeTreeSelectFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeRadioGroup: {
    createFormDesignWidgetConfig: getWidgetVxeRadioGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeRadioGroupViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeRadioGroupFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeCheckboxGroup: {
    createFormDesignWidgetConfig: getWidgetVxeCheckboxGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeCheckboxGroupViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeCheckboxGroupFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeUploadFile: {
    createFormDesignWidgetConfig: getWidgetVxeUploadFileConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeUploadFileViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeUploadFileFormComponent, {
        renderOpts,
        renderParams
      });
    }
  },
  VxeUploadImage: {
    createFormDesignWidgetConfig: getWidgetVxeUploadImageConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeUploadImageViewComponent, {
        renderOpts,
        renderParams
      });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(WidgetVxeUploadImageFormComponent, {
        renderOpts,
        renderParams
      });
    }
  }
});
;// CONCATENATED MODULE: ./packages/form-design/index.ts





const VxeFormDesign = Object.assign({}, form_design, {
  install(app) {
    app.component(form_design.name, form_design);
  }
});
const formDesign = {
  useWidgetName: useWidgetName,
  useWidgetView: useWidgetView,
  useWidgetPropDataSource: useWidgetPropDataSource
};
dynamicApp.component(form_design.name, form_design);
core_VxeUI.component(form_design);
core_VxeUI.formDesign = formDesign;
const FormDesign = VxeFormDesign;
/* harmony default export */ var packages_form_design = (VxeFormDesign);
;// CONCATENATED MODULE: ./packages/form-gather/index.ts



const VxeFormGather = Object.assign(form_gather, {
  install(app) {
    app.component(form_gather.name, form_gather);
  }
});
dynamicApp.component(form_gather.name, form_gather);
core_VxeUI.component(form_gather);
const FormGather = VxeFormGather;
/* harmony default export */ var packages_form_gather = (VxeFormGather);
;// CONCATENATED MODULE: ./packages/form-item/index.ts



const VxeFormItem = Object.assign(form_item, {
  install(app) {
    app.component(form_item.name, form_item);
  }
});
dynamicApp.component(form_item.name, form_item);
core_VxeUI.component(form_item);
const FormItem = VxeFormItem;
/* harmony default export */ var packages_form_item = (VxeFormItem);
;// CONCATENATED MODULE: ./packages/form-view/index.ts



const VxeFormView = Object.assign(form_view, {
  install: function (app) {
    app.component(form_view.name, form_view);
  }
});
dynamicApp.component(form_view.name, form_view);
core_VxeUI.component(form_view);
const FormView = VxeFormView;
/* harmony default export */ var packages_form_view = (VxeFormView);
;// CONCATENATED MODULE: ./packages/icon/index.ts



const VxeIcon = Object.assign({}, icon, {
  install(app) {
    app.component(icon.name, icon);
  }
});
dynamicApp.component(icon.name, icon);
core_VxeUI.component(icon);
const Icon = VxeIcon;
/* harmony default export */ var packages_icon = (VxeIcon);
;// CONCATENATED MODULE: ./packages/icon-picker/src/icon-picker.ts





/* harmony default export */ var icon_picker = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeIconPicker',
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => getConfig().iconPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      selectIcon: '',
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return i18n_getI18n('vxe.base.pleaseSelect');
    });
    const computeIconList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let {
        icons
      } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map(name => {
        return {
          title: name,
          icon: `vxe-icon-${name}`
        };
      });
    });
    const computeIconGroupList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const iconList = computeIconList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(iconList, 4);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(el);
          let panelPlacement = 'bottom';
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit('update:modelValue', selectValue);
        iconPickerMethods.dispatchEvent('change', {
          value: selectValue
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      iconPickerMethods.dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = evnt => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      iconPickerMethods.dispatchEvent('click', {}, evnt);
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            // changeOptionEvent(evnt, currentValue, currentOption)
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            // let { firstOption, offsetOption } = findOffsetOption(currentValue, isUpArrow)
            // if (!offsetOption && !findVisibleOption(currentValue)) {
            //   offsetOption = firstOption
            // }
            // setCurrentOption(offsetOption)
            // scrollToOption(offsetOption, isDwArrow)
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    iconPickerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $iconPicker: $xeIconPicker
        }, params));
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const {
        showIconTitle
      } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--list-wrapper'
      }, iconGroupList.map(list => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-ico-picker--list'
        }, list.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item',
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item-icon'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: item.icon || ''
          })]), showIconTitle ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item-title'
          }, `${item.title || ''}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
        }));
      }));
    };
    const renderVN = () => {
      const {
        className,
        popupClassName,
        clearable
      } = props;
      const {
        initialized,
        isActivated,
        visiblePanel,
        selectIcon
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const transfer = computeTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-ico-picker--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: selectIcon
        })]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-ico-picker', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $iconPicker: $xeIconPicker
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'show--clear': clearable && !isDisabled && !!selectIcon,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--inner',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInput,
        class: 'vxe-ico-picker--input',
        onFocus: focusEvent,
        onBlur: blurEvent
      }), selectIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: selectIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--placeholder'
      }, inpPlaceholder), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--suffix'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--clear-icon',
        onClick: clearEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--suffix-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
      })])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: transfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-ico-picker--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $iconPicker: $xeIconPicker
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': transfer,
          'ani--leave': reactData.isAniVisible,
          'ani--enter': visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, [initialized ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--panel-wrapper'
      }, renderIconWrapper()) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])]);
    };
    $xeIconPicker.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.selectIcon = `${val || ''}`;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeIconPicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeIconPicker, 'mousewheel');
      globalEvents.off($xeIconPicker, 'mousedown');
      globalEvents.off($xeIconPicker, 'keydown');
      globalEvents.off($xeIconPicker, 'blur');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeIconPicker', $xeIconPicker);
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/icon-picker/index.ts



const VxeIconPicker = Object.assign(icon_picker, {
  install: function (app) {
    app.component(icon_picker.name, icon_picker);
  }
});
dynamicApp.component(icon_picker.name, icon_picker);
core_VxeUI.component(icon_picker);
const IconPicker = VxeIconPicker;
/* harmony default export */ var packages_icon_picker = (VxeIconPicker);
;// CONCATENATED MODULE: ./packages/image/src/preview.ts





/* harmony default export */ var preview = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeImagePreview',
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    }
  },
  emits: ['update:modelValue', 'change', 'close'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.urlField || 'url';
    });
    const computeMarginSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize || 0) || 16;
    });
    const computeRotateText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        offsetRotate
      } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}°`;
      }
      return '0°';
    });
    const computeScaleText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        offsetScale
      } = reactData;
      if (offsetScale) {
        return `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil((1 + offsetScale) * 100)}%`;
      }
      return '100%';
    });
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        urlList
      } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return '';
        });
      }
      return [];
    });
    const computeImgTransform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let {
        offsetScale,
        offsetRotate,
        offsetLeft,
        offsetTop
      } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        // 缩放与位移
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          // 转向与位移
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(' ') : '';
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imagePreviewMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $imagePreview: $xeImagePreview
        }, params));
      }
    };
    const emitModel = value => {
      reactData.activeIndex = value;
      emit('update:modelValue', value);
    };
    const handleCloseEvent = evnt => {
      imagePreviewMethods.dispatchEvent('close', {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass(elem, 'is--move');
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const {
        offsetScale
      } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = isAdd => {
      const {
        offsetScale
      } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChange = isNext => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      resetStyle();
      reactData.activeIndex = activeIndex;
      emitModel(activeIndex);
    };
    const handleRotateImg = isRight => {
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (core_VxeUI.print) {
        core_VxeUI.print({
          align: 'center',
          pageBreaks: [{
            bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
          }]
        });
      }
    };
    const handleDownloadImg = () => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (core_VxeUI.saveFile) {
        fetch(imgUrl).then(res => {
          res.blob().then(blob => {
            core_VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
          });
        });
      }
    };
    const handleOperationBtn = code => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code) {
          case 'zoomOut':
            handleZoom(false);
            break;
          case 'zoomIn':
            handleZoom(true);
            break;
          case 'pctFull':
            resetStyle();
            break;
          case 'pct11':
            handlePct11();
            break;
          case 'rotateLeft':
            handleRotateImg(false);
            break;
          case 'rotateRight':
            handleRotateImg(true);
            break;
          case 'print':
            handlePrintImg();
            break;
          case 'download':
            handleDownloadImg();
            break;
        }
      }
    };
    const wheelEvent = evnt => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        handleZoom(false);
      } else if (delta < 0) {
        handleZoom(true);
      }
    };
    const moveEvent = evnt => {
      const {
        offsetTop,
        offsetLeft
      } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = et => {
        const {
          pageX,
          pageY
        } = et;
        const {
          visibleHeight,
          visibleWidth
        } = getDomNode();
        et.preventDefault();
        addClass(elem, 'is--move');
        // 限制边界值
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass(elem, 'is--move');
      };
    };
    const handleGlobalKeydownEvent = evnt => {
      const hasCtrlKey = evnt.ctrlKey;
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChange(false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChange(true);
        }
      } else if (isR && hasCtrlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImg(false);
        } else {
          handleRotateImg(true);
        }
      } else if (isP && hasCtrlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = evnt => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          imagePreviewMethods.dispatchEvent('close', {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--img-list',
        onClick: handleClickMaskEvent
      }, imgList.map((url, index) => {
        const isActive = activeIndex === index;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: ['vxe-image-preview--img-item', {
            'is--active': isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code, icon) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-btn',
        title: i18n_getI18n(`vxe.imagePreview.operBtn.${code}`),
        onClick() {
          handleOperationBtn(code);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon()[icon]
      })]);
    };
    const renderBtnWrapper = () => {
      const {
        showPrintButton,
        showDownloadButton
      } = props;
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-btn',
        onClick: handleCloseEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_CLOSE
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-bg'
      })]), imgList.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--previous-btn',
        onClick() {
          handleChange(false);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_PREVIOUS
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), imgList.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--next-btn',
        onClick() {
          handleChange(true);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_NEXT
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-info'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-deg'
      }, rotateText), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-pct'
      }, scaleText)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-active-count'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-image-preview--operation-active-current'
      }, `${(activeIndex || 0) + 1}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-image-preview--operation-active-total'
      }, `/${imgList.length}`)]), renderOperationBtn('zoomOut', 'IMAGE_PREVIEW_ZOOM_OUT'), renderOperationBtn('zoomIn', 'IMAGE_PREVIEW_ZOOM_IN'), renderOperationBtn('pctFull', 'IMAGE_PREVIEW_PCT_FULL'), renderOperationBtn('pct11', 'IMAGE_PREVIEW_PCT_1_1'), renderOperationBtn('rotateLeft', 'IMAGE_PREVIEW_ROTATE_LEFT'), renderOperationBtn('rotateRight', 'IMAGE_PREVIEW_ROTATE_RIGHT'), showPrintButton ? renderOperationBtn('print', 'IMAGE_PREVIEW_PRINT') : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showDownloadButton ? renderOperationBtn('download', 'IMAGE_PREVIEW_DOWNLOAD') : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
    };
    const renderVN = () => {
      const {
        offsetPct11
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-image-preview', {
          'is--pct11': offsetPct11
        }],
        onWheel: wheelEvent
      }, [renderImgWrapper(), renderBtnWrapper()]);
    };
    $xeImagePreview.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeIndex = val;
      resetStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeImagePreview, 'keydown', handleGlobalKeydownEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const elem = refElem.value;
      removeClass(elem, 'is--move');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeImagePreview, 'keydown');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeImagePreview', $xeImagePreview);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/image/src/util.ts




const openPreviewImage = options => {
  if (core_VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const {
      urlList,
      activeIndex
    } = opts;
    const modalId = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('image-preview');
    core_VxeUI.modal.open({
      id: modalId,
      title: '预览',
      width: '100%',
      height: '100%',
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      className: 'vxe-image-preview-popup-wrapper',
      slots: {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(preview, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            onClose() {
              core_VxeUI.modal.close(modalId);
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};
;// CONCATENATED MODULE: ./packages/image/src/image.ts





/* harmony default export */ var src_image = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeImage',
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeImageGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeImageGroup', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        src
      } = props;
      if (src) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(src) ? src : [src]).map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              url: item,
              alt: ''
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ''}` : '';
    });
    const computeMaps = {};
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $image: $xeImage
        }, params));
      }
    };
    const clickEvent = evnt => {
      const {
        showPreview
      } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, {
          url: imgUrl
        });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList
          });
        }
        imageMethods.dispatchEvent('click', {
          url: imgUrl
        }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const {
        alt,
        loading
      } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
        ref: refElem,
        class: 'vxe-image',
        src: imgUrl,
        alt,
        loading,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/image/index.ts



const VxeImage = Object.assign({}, src_image, {
  install(app) {
    app.component(src_image.name, src_image);
  }
});
dynamicApp.component(src_image.name, src_image);
core_VxeUI.component(src_image);
const Image = VxeImage;
/* harmony default export */ var packages_image = (VxeImage);
;// CONCATENATED MODULE: ./packages/image/src/group.ts





/* harmony default export */ var image_src_group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeImageGroup',
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    size: {
      type: String,
      default: () => getConfig().imageGroup.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        urlList
      } = props;
      if (urlList) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(urlList) ? urlList : [urlList]).map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              url: item,
              alt: ''
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeMaps = {};
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $imageGroup: $xeImageGroup
        }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const {
          showPreview
        } = props;
        const {
          url
        } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(imgList, item => item.url === url)),
            urlList: imgList
          });
        }
        imageGroupMethods.dispatchEvent('click', {
          url,
          urlList: imgList
        }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-group'
      }, imgList ? imgList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_image, {
          key: index,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeImageGroup', $xeImageGroup);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/image-group/index.ts



const VxeImageGroup = Object.assign({}, image_src_group, {
  install(app) {
    app.component(image_src_group.name, image_src_group);
  }
});
dynamicApp.component(image_src_group.name, image_src_group);
core_VxeUI.component(image_src_group);
const ImageGroup = VxeImageGroup;
/* harmony default export */ var image_group = (VxeImageGroup);
;// CONCATENATED MODULE: ./packages/image-preview/index.ts




const VxeImagePreview = Object.assign(preview, {
  install(app) {
    app.component(preview.name, preview);
    core_VxeUI.previewImage = openPreviewImage;
  }
});
dynamicApp.component(preview.name, preview);
core_VxeUI.component(preview);
const ImagePreview = VxeImagePreview;
/* harmony default export */ var image_preview = (VxeImagePreview);
;// CONCATENATED MODULE: ./packages/input/index.ts



const VxeInput = Object.assign(input, {
  install(app) {
    app.component(input.name, input);
  }
});
dynamicApp.component(input.name, input);
core_VxeUI.component(input);
const Input = VxeInput;
/* harmony default export */ var packages_input = (VxeInput);
;// CONCATENATED MODULE: ./packages/layout-aside/src/layout-aside.ts




/* harmony default export */ var layout_aside = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLayoutAside',
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        collapsed,
        collapseWidth
      } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return '';
    });
    const computeMaps = {};
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        width,
        collapsed,
        loading,
        padding
      } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('aside', {
        ref: refElem,
        class: ['vxe-layout-aside', {
          'is--padding': padding,
          'is--default-width': !width,
          'is--collapse': collapsed,
          'is--loading': loading
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-layout-aside--inner'
      }, defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {});
    $xeLayoutAside.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeLayoutAside', $xeLayoutAside);
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-aside/index.ts



const VxeLayoutAside = Object.assign({}, layout_aside, {
  install(app) {
    app.component(layout_aside.name, layout_aside);
  }
});
dynamicApp.component(layout_aside.name, layout_aside);
core_VxeUI.component(layout_aside);
const LayoutAside = VxeLayoutAside;
/* harmony default export */ var packages_layout_aside = (VxeLayoutAside);
;// CONCATENATED MODULE: ./packages/layout-body/src/layout-body.ts



/* harmony default export */ var layout_body = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLayoutBody',
  props: {
    loading: Boolean,
    padding: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        loading,
        padding
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-layout-body', {
          'is--loading': loading,
          'is--padding': padding
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-layout-body--inner'
      }, defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-body/index.ts



const VxeLayoutBody = Object.assign({}, layout_body, {
  install(app) {
    app.component(layout_body.name, layout_body);
  }
});
dynamicApp.component(layout_body.name, layout_body);
core_VxeUI.component(layout_body);
const LayoutBody = VxeLayoutBody;
/* harmony default export */ var packages_layout_body = (VxeLayoutBody);
;// CONCATENATED MODULE: ./packages/layout-container/src/layout-container.ts


/* harmony default export */ var layout_container = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLayoutContainer',
  props: {
    vertical: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        vertical
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-layout-container', {
          'is--vertical': vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-container/index.ts



const VxeLayoutContainer = Object.assign({}, layout_container, {
  install(app) {
    app.component(layout_container.name, layout_container);
  }
});
dynamicApp.component(layout_container.name, layout_container);
core_VxeUI.component(layout_container);
const LayoutContainer = VxeLayoutContainer;
/* harmony default export */ var packages_layout_container = (VxeLayoutContainer);
;// CONCATENATED MODULE: ./packages/layout-footer/src/layout-footer.ts


/* harmony default export */ var layout_footer = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLayoutFooter',
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        fixed,
        align
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('footer', {
        ref: refElem,
        class: ['vxe-layout-footer', align ? `align--${align}` : '', {
          'is--fixed': fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-footer/index.ts



const VxeLayoutFooter = Object.assign({}, layout_footer, {
  install(app) {
    app.component(layout_footer.name, layout_footer);
  }
});
dynamicApp.component(layout_footer.name, layout_footer);
core_VxeUI.component(layout_footer);
const LayoutFooter = VxeLayoutFooter;
/* harmony default export */ var packages_layout_footer = (VxeLayoutFooter);
;// CONCATENATED MODULE: ./packages/layout-header/src/layout-header.ts


/* harmony default export */ var layout_header = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLayoutHeader',
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('header', {
        ref: refElem,
        class: ['vxe-layout-header', {
          'is--fixed': props.fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-header/index.ts



const VxeLayoutHeader = Object.assign({}, layout_header, {
  install(app) {
    app.component(layout_header.name, layout_header);
  }
});
dynamicApp.component(layout_header.name, layout_header);
core_VxeUI.component(layout_header);
const LayoutHeader = VxeLayoutHeader;
/* harmony default export */ var packages_layout_header = (VxeLayoutHeader);
;// CONCATENATED MODULE: ./packages/link/src/link.ts




/* harmony default export */ var src_link = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLink',
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().link.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderContent = () => {
      const {
        icon,
        content
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content);
      return [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-link--icon'
      }, iconSlot ? getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), defaultSlot || textContent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-link--content'
      }, defaultSlot ? defaultSlot({}) : textContent) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
    };
    const renderVN = () => {
      const {
        status,
        target,
        href,
        title,
        underline,
        routerLink
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      if (routerLink) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          class: ['vxe-link', {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            'is--underline': underline
          }],
          title,
          target,
          to: routerLink
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
        ref: refElem,
        href,
        target,
        title,
        class: ['vxe-link', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--underline': underline
        }]
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/link/index.ts



const VxeLink = Object.assign({}, src_link, {
  install(app) {
    app.component(src_link.name, src_link);
  }
});
dynamicApp.component(src_link.name, src_link);
core_VxeUI.component(src_link);
const Link = VxeLink;
/* harmony default export */ var packages_link = (VxeLink);
;// CONCATENATED MODULE: ./packages/list-design/render/util.ts

const getListDesignActionButtonName = name => {
  return getI18n(`vxe.listDesign.activeBtn.${name}`);
};
const handleGetListDesignActionButtonName = params => {
  return getListDesignActionButtonName(params.name);
};
const createListDesignActionButton = btnObj => {
  return Object.assign({
    name: '',
    icon: '',
    type: '',
    classify: '',
    code: '',
    status: '',
    permissionCode: ''
  }, btnObj);
};
;// CONCATENATED MODULE: ./packages/list-design/src/default-setting-data.ts
const default_setting_data_getDefaultSettingFormData = () => {
  return {
    listView: {
      enabled: true
    },
    ganttView: {
      enabled: false
    },
    chartView: {
      enabled: false
    },
    autoFoldFilter: true,
    showCheckbox: 'auto',
    showSeq: true,
    showSummary: true,
    mobileDefaultView: 'list',
    pcDefaultView: 'list',
    actionButtonList: []
  };
};
;// CONCATENATED MODULE: ./packages/list-design/src/layout-preview.ts






/* harmony default export */ var src_layout_preview = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'ListDesignLayoutView',
  props: {},
  emits: [],
  setup() {
    const VxeTableGridComponent = core_VxeUI.getComponent('VxeGrid');
    const $xeListDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeListDesign', null);
    if (!$xeListDesign) {
      return () => [];
    }
    const {
      reactData: listDesignReactData
    } = $xeListDesign;
    const refGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const tableData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
    const computeFormItems = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        searchFormItems
      } = listDesignReactData;
      if (searchFormItems.length) {
        return searchFormItems.concat([{
          field: 'active',
          title: '',
          folding: false,
          collapseNode: searchFormItems.some(item => item.folding),
          itemRender: {
            name: 'VxeButtonGroup',
            options: [{
              content: '查询',
              icon: 'vxe-icon-search',
              status: 'primary',
              type: 'submit'
            }, {
              content: '重置',
              icon: 'vxe-icon-repeat',
              type: 'reset'
            }]
          }
        }]);
      }
      return searchFormItems;
    });
    const computeTableColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        formData,
        listTableColumns
      } = listDesignReactData;
      const {
        showSeq,
        actionButtonList
      } = formData;
      const columns = [];
      if (showSeq) {
        columns.push({
          type: 'seq',
          field: '_seq',
          width: 70
        });
      }
      listTableColumns.forEach(item => {
        columns.push({
          field: item.field,
          title: item.title,
          visible: item.visible,
          width: item.width
        });
      });
      if (actionButtonList && actionButtonList.length) {
        columns.push({
          field: '_active',
          title: i18n_getI18n('vxe.table.actionTitle'),
          fixed: 'right',
          width: 'auto',
          cellRender: {
            name: 'VxeButtonGroup',
            options: []
          }
        });
      }
      return columns;
    });
    const updateColumnWidthEvent = ({
      column,
      resizeWidth
    }) => {
      const {
        listTableColumns
      } = listDesignReactData;
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(listTableColumns, item => item.field === column.field, {
        children: 'children'
      });
      if (rest) {
        const {
          item
        } = rest;
        item.width = resizeWidth;
      }
    };
    const updateTableData = () => {
      const {
        listTableColumns
      } = listDesignReactData;
      const data = [{}, {}];
      data.forEach(row => {
        listTableColumns.forEach(column => {
          row[column.field] = '-';
        });
      });
      tableData.value = data;
    };
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => listDesignReactData.listTableColumns ? listDesignReactData.listTableColumns.length : -1, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => listDesignReactData.listTableColumns, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      updateTableData();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateTableData();
    });
    if (true) {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (!VxeTableGridComponent) {
          errLog('vxe.error.reqComp', ['vxe-grid']);
        }
      });
    }
    return () => {
      const {
        searchFormData,
        searchFormItems
      } = listDesignReactData;
      const formItems = computeFormItems.value;
      const tableColumn = computeTableColumn.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--preview'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--preview-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--preview-search'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--preview-title'
      }, i18n_getI18n('vxe.listDesign.searchTitle')), searchFormItems.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        data: searchFormData,
        items: formItems
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--field-configs-empty-data'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.listDesign.search.emptyText'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--preview-table'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--preview-title'
      }, i18n_getI18n('vxe.listDesign.listTitle')), VxeTableGridComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeTableGridComponent, {
        ref: refGrid,
        columns: tableColumn,
        data: tableData.value,
        showOverflow: true,
        border: true,
        columnConfig: {
          minWidth: 'auto',
          resizable: true
        },
        rowConfig: {
          isHover: true
        },
        scrollX: {
          enabled: false
        },
        scrollY: {
          enabled: false
        },
        onResizableChange: updateColumnWidthEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])]);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/list-design/src/default-setting-form.ts












// 控件原始配置信息，带响应
const default_setting_form_refWidgetReactConfigMaps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
const DefaultFieldSettingFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'DefaultFieldSettingForm',
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeListDesign', null);
    if (!$xeListDesign) {
      return () => [];
    }
    const {
      reactData: listDesignReactData
    } = $xeListDesign;
    const refIsAllChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const refIsAllIndeterminate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const changeVisible = item => {
      item.visible = !item.visible;
      listDesignReactData.listTableColumns = listDesignReactData.listTableColumns.slice(0);
    };
    const addSearchEvent = () => {
      const {
        listTableColumns,
        searchFormItems
      } = listDesignReactData;
      const widgetReactConfigMaps = default_setting_form_refWidgetReactConfigMaps.value;
      const allFormItemList = [];
      listTableColumns.forEach(item => {
        const {
          cellRender
        } = item;
        if (cellRender) {
          const conf = searchFormItems.find(conf => conf.field === item.field);
          const name = cellRender.name || '';
          let widgetConfig = widgetReactConfigMaps[name];
          if (!widgetConfig) {
            const compConf = renderer.get(name);
            if (compConf) {
              const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
              if (createWidgetFormConfig) {
                const params = {
                  name,
                  $formDesign: null
                };
                widgetConfig = createWidgetFormConfig(params) || {};
                widgetReactConfigMaps[name] = widgetConfig;
              }
            }
          }
          if (widgetConfig.query) {
            allFormItemList.push({
              ...item,
              checked: !!conf,
              isHalf: false,
              folding: conf ? !!conf.folding : false
            });
          }
        }
      });
      default_setting_form_refWidgetReactConfigMaps.value = Object.assign({}, widgetReactConfigMaps);
      const refAllFormItemList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(allFormItemList);
      // const foldOptions = ref([
      //   { label: '展开', value: false },
      //   { label: '折叠', value: true }
      // ])
      const checkOptionStatus = () => {
        const allFormItemList = refAllFormItemList.value;
        refIsAllChecked.value = allFormItemList.every(item => item.checked);
        refIsAllIndeterminate.value = !refIsAllChecked.value && allFormItemList.some(item => item.checked || item.isHalf);
      };
      const handleOptionCheck = item => {
        const allFormItemList = refAllFormItemList.value;
        const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(allFormItemList, obj => obj === item);
        if (matchObj && matchObj.parent) {
          const {
            parent
          } = matchObj;
          if (parent.children && parent.children.length) {
            parent.checked = parent.children.every(obj => obj.checked);
            parent.isHalf = !parent.checked && parent.children.some(obj => obj.checked || obj.isHalf);
            handleOptionCheck(parent);
          }
        }
      };
      const changeCheckboxOption = item => {
        const isChecked = !item.checked;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([item], obj => {
          obj.checked = isChecked;
          obj.isHalf = false;
        });
        handleOptionCheck(item);
        checkOptionStatus();
      };
      const allOptionEvent = () => {
        const allFormItemList = refAllFormItemList.value;
        const isAll = !refIsAllChecked.value;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(allFormItemList, item => {
          item.checked = isAll;
          item.isHalf = false;
        });
        refIsAllChecked.value = isAll;
        checkOptionStatus();
      };
      const confirmEvent = () => {
        const allFormItemList = refAllFormItemList.value;
        const searchItems = [];
        allFormItemList.forEach(item => {
          if (item.checked) {
            searchItems.push({
              field: item.field,
              title: item.title,
              folding: item.folding,
              itemRender: {
                ...item.cellRender
              }
            });
          }
        });
        $xeListDesign.setSearchItems(searchItems);
      };
      core_VxeUI.modal.open({
        title: '编辑查询字段',
        width: 680,
        height: 500,
        showFooter: true,
        escClosable: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: '保存',
        showZoom: true,
        resize: true,
        onConfirm: confirmEvent,
        slots: {
          default() {
            const isAllChecked = refIsAllChecked.value;
            const isAllIndeterminate = refIsAllIndeterminate.value;
            const allFormItemList = refAllFormItemList.value;
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-list-design--field-search-popup'
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
              style: {
                width: '80px'
              }
            }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col')
            // h('col', {
            //   style: {
            //     width: '140px'
            //   }
            // })
            ]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: ['vxe-list-design--field-search-checkbox-option', {
                'is--checked': isAllChecked,
                'is--indeterminate': isAllIndeterminate
              }],
              title: i18n_getI18n('vxe.table.allTitle'),
              onClick: allOptionEvent
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
              class: ['vxe-checkbox--icon', isAllIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
            }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
              class: 'vxe-checkbox--label'
            }, i18n_getI18n('vxe.toolbar.customAll'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, '标题')
            // h('th', {}, '展开/折叠')
            ]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', {}, allFormItemList.map(item => {
              const isChecked = item.checked;
              const isIndeterminate = item.isHalf;
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
                class: 'vxe-list-design--field-search-option-item col--visible'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: ['vxe-list-design--field-search-checkbox-option', {
                  'is--checked': isChecked,
                  'is--indeterminate': isIndeterminate
                }],
                title: i18n_getI18n('vxe.custom.setting.colVisible'),
                onClick: () => {
                  changeCheckboxOption(item);
                }
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
                class: ['vxe-checkbox--icon', isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              })])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
                class: 'vxe-list-design--field-search-option-item'
              }, `${item.title || ''}`)
              // h('td', {}, [
              //   h(VxeRadioGroupComponent, {
              //     modelValue: item.folding,
              //     type: 'button',
              //     options: foldOptions.value,
              //     size: 'mini',
              //     'onUpdate:modelValue' (val) {
              //       item.folding = val
              //     }
              //   })
              // ])
              ]);
            }))])]);
          }
        }
      });
    };
    const renderChildOptions = item => {
      const {
        children
      } = item;
      if (children && children.length) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-list-design--field-option-item'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-list-design--field-sub-option',
          onClick() {
            changeVisible(item);
          }
        }, children.map(child => {
          const {
            title,
            visible: isChecked
          } = child;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-list-design--field-checkbox-option', {
              'is--checked': isChecked
            }],
            onClick() {
              changeVisible(child);
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-checkbox--label'
          }, `${title}`)]);
        }))]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderFieldOptions = () => {
      const {
        listTableColumns
      } = listDesignReactData;
      return listTableColumns.map(item => {
        const {
          title,
          visible: isChecked
        } = item;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-list-design--field-options'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-list-design--field-option-item'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-list-design--field-checkbox-option', {
            'is--checked': isChecked
          }],
          onClick() {
            changeVisible(item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, `${title}`)])]), renderChildOptions(item)]);
      });
    };
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.listDesign.searchField')
          }, {
            extra() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
                mode: 'text',
                status: 'primary',
                icon: getIcon().FORM_DESIGN_PROPS_EDIT,
                content: i18n_getI18n('vxe.listDesign.search.addBtn'),
                onClick: addSearchEvent
              });
            },
            default() {
              const {
                searchFormItems
              } = listDesignReactData;
              return [searchFormItems.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: ''
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, searchFormItems.map(item => {
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                  class: ''
                }, `${item.title || ''}`);
              }))]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-list-design--field-configs-empty-data'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, i18n_getI18n('vxe.listDesign.search.emptyText'))])];
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: i18n_getI18n('vxe.listDesign.listField')
          }, {
            default() {
              return renderFieldOptions();
            }
          })];
        }
      });
    };
  }
});
const DefaultParameterSettingFormComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'DefaultListSettingTabComponent',
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeListDesign', null);
    if (!$xeListDesign) {
      return () => [];
    }
    const {
      props: listDesignProps,
      reactData: listDesignReactData
    } = $xeListDesign;
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const {
        createListDesignSettingActionButtonConfig
      } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = {
          name
        };
        const btnConfig = Object.assign(createListDesignActionButton({
          code: name
        }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === 'custom') {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const renderViewList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([{
      label: '列表视图',
      value: 'list',
      isExpand: false
    }]);
    // const refFoldOpts = ref([
    //   { label: '显示', value: true },
    //   { label: '隐藏', value: false }
    // ])
    const refSeqOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([{
      label: '显示',
      value: true
    }, {
      label: '隐藏',
      value: false
    }]);
    const refCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([{
      label: '默认',
      value: 'auto'
    }, {
      label: '允许',
      value: true
    }, {
      label: '不允许',
      value: false
    }]);
    const disableView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        formData
      } = listDesignReactData;
      return [formData.listView.enabled, formData.ganttView.enabled, formData.chartView.enabled].filter(enabled => enabled).length <= 1;
    });
    const openActiveBtnPopup = activeBtnObj => {
      const {
        formData
      } = listDesignReactData;
      const {
        actionCodes
      } = listDesignProps;
      let btnList = formData.actionButtonList;
      if (!btnList) {
        btnList = [];
      }
      const activeBtnItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createListDesignActionButton(activeBtnObj));
      const systemBtnList = systemConfigList.filter(item => {
        if (actionCodes && actionCodes.length) {
          if (!actionCodes.some(conf => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(conf) ? item.code === conf : conf.code === item.code)) {
            return false;
          }
        }
        return !btnList.some(obj => obj.code === item.code);
      });
      const customBtnList = customConfigList.filter(item => !btnList.some(obj => obj.code === item.code));
      const btOptions = [];
      if (systemBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = '';
        }
        btOptions.push({
          value: '',
          label: '系统按钮'
        });
      }
      if (customBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = 'custom';
        }
        btOptions.push({
          value: 'custom',
          label: '自定义按钮'
        });
      }
      const refSystemConfigOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
        return systemBtnList.map(item => {
          const nameConfig = item.name;
          return {
            label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(nameConfig) ? nameConfig({
              name: item.code || ''
            }) : nameConfig),
            value: item.code
          };
        });
      });
      const refBtnTypeOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(btOptions);
      core_VxeUI.modal.open({
        title: '添加按钮',
        width: 600,
        height: 400,
        showFooter: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: '保存',
        onConfirm() {
          if (activeBtnItem.type === 'custom') {
            btnList.push(activeBtnItem);
          } else {
            btnList.push(activeBtnItem);
          }
          formData.actionButtonList = [...btnList];
        },
        slots: {
          default() {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
              vertical: true,
              titleBold: true
            }, {
              default() {
                return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
                  title: '按钮类型',
                  span: 24
                }, {
                  default() {
                    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
                      modelValue: activeBtnItem.type,
                      options: refBtnTypeOptions.value,
                      'onUpdate:modelValue'(val) {
                        activeBtnItem.type = val;
                      }
                    });
                  }
                }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
                  title: '选择系统按钮',
                  span: 24
                }, {
                  default() {
                    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
                      modelValue: activeBtnItem.code,
                      options: refSystemConfigOptions.value,
                      'onUpdate:modelValue'(val) {
                        activeBtnItem.code = val;
                      }
                    });
                  }
                })
                // h(VxeFormItemComponent, {
                //   title: '按钮位置',
                //   span: 24
                // }, {
                //   default () {
                //     return h(VxeSelectComponent, {
                //       modelValue: activeBtnItem.classify,
                //       options: refBtnClassifyOptions.value,
                //       'onUpdate:modelValue' (val) {
                //         activeBtnItem.classify = val
                //       }
                //     })
                //   }
                // })
                ];
              }
            });
          }
        }
      });
    };
    const renderDefaultCellActionButton = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
        title: '功能按钮'
      }, {
        extra() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            mode: 'text',
            status: 'primary',
            icon: getIcon().FORM_DESIGN_PROPS_ADD,
            content: '新增',
            onClick() {
              openActiveBtnPopup();
            }
          });
        },
        default() {
          const {
            formData
          } = listDesignReactData;
          const btnList = formData.actionButtonList;
          return btnList && btnList.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-list-design--field-configs-wrapper'
          }, btnList.map(btnItem => {
            let btnIcon = '';
            let btnName = '';
            if (btnItem.type === 'custom') {
              btnIcon = btnItem.icon;
              btnName = btnItem.name;
            } else {
              const btnConfig = systemConfigList.find(item => item.code === btnItem.code);
              if (btnConfig) {
                const nameConfig = btnConfig.name;
                btnIcon = btnConfig.icon || '';
                btnName = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(nameConfig) ? nameConfig({
                  name: btnConfig.code || ''
                }) : nameConfig);
              }
            }
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-list-design--field-configs-item'
            }, [btnIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-list-design--field-configs-item-icon'
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: btnIcon
            })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-list-design--field-configs-item-title'
            }, `${btnName || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
              class: 'vxe-list-design--field-configs-item-btn'
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
              icon: getIcon().LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE,
              mode: 'text',
              status: 'error',
              onClick() {
                formData.actionButtonList = btnList.filter(item => item !== btnItem);
              }
            })])]);
          })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-list-design--field-configs-empty-data'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, '无操作按钮')]);
        }
      });
    };
    return () => {
      const {
        showPc,
        showMobile
      } = listDesignProps;
      const {
        formData
      } = listDesignReactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_form, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: '视图配置'
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-render-view'
              }, renderViewList.value.map(item => {
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                  key: item.value,
                  class: 'vxe-form-design--widget-form-item-render-view-item'
                }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_switch, {
                  modelValue: formData.listView.enabled,
                  disabled: disableView.value,
                  'onUpdate:modelValue'(val) {
                    formData.listView.enabled = val;
                  }
                }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
                  content: item.label,
                  icon: 'vxe-icon-table'
                })]);
              }));
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: '默认视图'
          }, {
            default() {
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-devices'
              }, [showPc ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-devices-item'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-devices-left'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
                icon: getIcon().FORM_DESIGN_PROPS_PC,
                content: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.pc')
              })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
                modelValue: formData.pcDefaultView,
                className: 'vxe-form-design--widget-form-item-devices-select',
                options: renderViewList.value,
                'onUpdate:modelValue'(val) {
                  formData.pcDefaultView = val;
                }
              })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), showMobile ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-devices-item'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-form-design--widget-form-item-devices-left'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
                icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                content: i18n_getI18n('vxe.formDesign.widgetProp.displaySetting.mobile')
              })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
                modelValue: formData.mobileDefaultView,
                className: 'vxe-form-design--widget-form-item-devices-select',
                options: renderViewList.value,
                'onUpdate:modelValue'(val) {
                  formData.mobileDefaultView = val;
                }
              })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])];
            }
          }),
          // h(VxeFormItemComponent, {
          //   title: '查询配置'
          // }, {
          //   default () {
          //     const { formData } = listDesignReactData
          //     return [
          //       h('div', {
          //         class: 'vxe-list-design--widget-form-item-prop-list'
          //       }, [
          //         h('span', {}, '折叠字段'),
          //         h(VxeRadioGroupComponent, {
          //           modelValue: formData.autoFoldFilter,
          //           options: refFoldOpts.value,
          //           'onUpdate:modelValue' (val) {
          //             formData.autoFoldFilter = val
          //           }
          //         })
          //       ])
          //     ]
          //   }
          // }),
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: '列配置'
          }, {
            default() {
              const {
                formData
              } = listDesignReactData;
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-list-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, '显示序号'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.showSeq,
                options: refSeqOpts.value,
                'onUpdate:modelValue'(val) {
                  formData.showSeq = val;
                }
              })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-list-design--widget-form-item-prop-list'
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, '表尾汇总'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.showSummary,
                options: refSeqOpts.value,
                'onUpdate:modelValue'(val) {
                  formData.showSummary = val;
                }
              })])];
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_item, {
            title: '批量操作'
          }, {
            default() {
              const {
                formData
              } = listDesignReactData;
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_group, {
                modelValue: formData.showCheckbox,
                options: refCheckboxOpts.value,
                'onUpdate:modelValue'(val) {
                  formData.showCheckbox = val;
                }
              });
            }
          }), systemConfigList.length || customConfigList.length ? renderDefaultCellActionButton() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
        }
      });
    };
  }
});
;// CONCATENATED MODULE: ./packages/list-design/src/layout-setting.ts





/* harmony default export */ var src_layout_setting = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'ListDesignLayoutSetting',
  props: {},
  emits: [],
  setup() {
    const activeTab = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(1);
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--setting'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--setting-form'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tabs, {
        modelValue: activeTab.value,
        titleWidth: '50%',
        titleAlign: 'center',
        padding: true,
        class: 'vxe-list-design--setting-form-tabs',
        'onUpdate:modelValue'(val) {
          activeTab.value = val;
        }
      }, {
        default() {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tab_pane, {
            title: i18n_getI18n('vxe.listDesign.fieldSettingTab'),
            icon: getIcon().LIST_DESIGN_FIELD_SETTING,
            name: 1
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(DefaultFieldSettingFormComponent);
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tab_pane, {
            title: i18n_getI18n('vxe.listDesign.listSettingTab'),
            icon: getIcon().LIST_DESIGN_LIST_SETTING,
            name: 2
          }, {
            default() {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(DefaultParameterSettingFormComponent);
            }
          })];
        }
      })])]);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/list-design/src/list-design.ts









/* harmony default export */ var list_design = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeListDesign',
  props: {
    size: {
      type: String,
      default: () => getConfig().listDesign.size
    },
    height: {
      type: [String, Number],
      default: () => getConfig().listDesign.height
    },
    config: Object,
    showPc: {
      type: Boolean,
      default: () => getConfig().listDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().listDesign.showMobile
    },
    actionCodes: Array,
    formRender: Object
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      formData: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeListDesign = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const {
        createListDesignSettingActionButtonConfig
      } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = {
          name
        };
        const btnConfig = Object.assign(createListDesignActionButton({
          code: name
        }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === 'custom') {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const parseWidgetColumn = widget => {
      return {
        title: widget.title,
        field: widget.field,
        visible: !widget.hidden,
        width: '',
        cellRender: {
          name: widget.name,
          props: widget.options
        }
      };
    };
    /**
     * 解析表单设计 JSON
     */
    const parseFormDesignColumns = config => {
      const tableColumns = [];
      if (config) {
        const {
          widgetData
        } = config;
        if (widgetData) {
          widgetData.forEach(item => {
            const {
              name
            } = item;
            if (name) {
              // 如果是行列
              if (name === 'row') {
                item.children.forEach(childItem => {
                  if (childItem.name) {
                    tableColumns.push(parseWidgetColumn(childItem));
                  }
                });
              } else if (name === 'subTable') {
                // 如果是子表
              } else {
                tableColumns.push(parseWidgetColumn(item));
              }
            }
          });
        }
      }
      return tableColumns;
    };
    const configToSearchItems = searchItems => {
      if (searchItems) {
        const data = {};
        const items = searchItems.map(item => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        return {
          items,
          data
        };
      }
      return {
        items: [],
        data: {}
      };
    };
    const configToListColumns = listColumns => {
      if (listColumns) {
        return listColumns.map(item => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const loadConfig = config => {
      const {
        formConfig,
        searchItems,
        listColumns
      } = config;
      if (formConfig) {
        loadFormConfig(formConfig);
      }
      if (searchItems) {
        setSearchItems(searchItems);
      }
      if (listColumns) {
        reactData.listTableColumns = parseColumnConfigs(listColumns);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const parseColumnConfigs = listColumns => {
      return configToListColumns(listColumns);
    };
    const loadFormConfig = data => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getSearchItems = () => {
      return reactData.searchFormItems;
    };
    const setSearchItems = searchItems => {
      const {
        data,
        items
      } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getListColumns = () => {
      return reactData.listTableColumns;
    };
    const setListColumns = listColumns => {
      reactData.listTableColumns = parseColumnConfigs(listColumns);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const createSettingForm = () => {
      const {
        actionCodes,
        formRender
      } = props;
      let conf = default_setting_data_getDefaultSettingFormData();
      // 处理默认按钮
      if (actionCodes && actionCodes.length) {
        if (!conf.actionButtonList || !conf.actionButtonList.length) {
          const defActionBtnList = [];
          actionCodes.forEach(item => {
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(item) && item.default) {
              const sysItem = systemConfigList.find(obj => obj.code === item.code);
              if (sysItem) {
                defActionBtnList.push(createListDesignActionButton({
                  type: sysItem.type,
                  code: sysItem.code
                }));
              }
            }
          });
          conf.actionButtonList = defActionBtnList;
        }
      }
      // 如果为自定义渲染
      if (formRender && formRender.name) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createListDesignSettingFormConfig : null;
        const params = {
          name: formRender.name
        };
        conf = (createFormConfig ? createFormConfig(params) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const clearConfig = () => {
      loadConfig({
        searchItems: [],
        listColumns: []
      });
      initSettingForm();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const listDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $listDesign: $xeListDesign
        }, params));
      },
      loadFormDesignConfig(config) {
        const {
          listTableColumns
        } = reactData;
        const oldMaps = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(listTableColumns, item => {
          oldMaps[item.field] = item;
        }, {
          children: 'children'
        });
        const columns = parseFormDesignColumns(config);
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, item => {
          const oldItem = oldMaps[item.field];
          if (oldItem) {
            if (oldItem.width) {
              item.width = oldItem.width;
            }
            item.visible = oldItem.visible;
          }
        }, {
          children: 'children'
        });
        reactData.listTableColumns = columns;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      reloadFormDesignConfig(config) {
        reactData.listTableColumns = parseFormDesignColumns(config);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getSearchItems,
      setSearchItems,
      getListColumns,
      setListColumns,
      getConfig() {
        return {
          formConfig: reactData.formData,
          searchItems: getSearchItems(),
          listColumns: getListColumns()
        };
      },
      loadConfig,
      reloadConfig(config) {
        clearConfig();
        return loadConfig(config);
      },
      clearConfig
    };
    const listDesignPrivateMethods = {};
    Object.assign($xeListDesign, listDesignMethods, listDesignPrivateMethods);
    const renderVN = () => {
      const {
        height
      } = props;
      const headerSlot = slots.header;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-list-design',
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--header'
      }, headerSlot ? headerSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-design--body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_layout_preview), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_layout_setting)])]);
    };
    $xeListDesign.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeListDesign', $xeListDesign);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.config, value => {
      loadConfig(value || {});
    });
    initSettingForm();
    if (props.config) {
      loadConfig(props.config);
    }
    return $xeListDesign;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/list-design/render/index.ts

// import { handleGetListDesignActionButtonName } from './util'
/**
 * 列表设计器 - 渲染器
 */
renderer.mixin({
  // ActionButtonUpdate: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-edit',
  //       status: 'primary'
  //     }
  //   }
  // },
  // ActionButtonDelete: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-delete',
  //       status: 'error'
  //     }
  //   }
  // }
});
;// CONCATENATED MODULE: ./packages/list-design/index.ts




const VxeListDesign = Object.assign({}, list_design, {
  install(app) {
    app.component(list_design.name, list_design);
  }
});
const listDesign = {};
dynamicApp.component(list_design.name, list_design);
core_VxeUI.component(list_design);
core_VxeUI.listDesign = listDesign;
const ListDesign = VxeListDesign;
/* harmony default export */ var packages_list_design = (VxeListDesign);
;// CONCATENATED MODULE: ./packages/list-design/src/list-view.ts









/* harmony default export */ var list_view = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeListView',
  props: {
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().listView.height
    },
    loading: Boolean,
    formData: Object,
    actionButtons: Array,
    gridOptions: Object,
    gridEvents: Object,
    viewRender: Object
  },
  emits: ['cell-action', 'update:formData', 'update:actionButtons'],
  setup(props, context) {
    const VxeTableGridComponent = core_VxeUI.getComponent('VxeGrid');
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: [],
      tableColumns: []
    });
    const computeGridOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        gridOptions
      } = props;
      const {
        tableColumns,
        searchFormData,
        searchFormItems
      } = reactData;
      const gridOpts = gridOptions || {};
      const columnOpts = Object.assign({
        minWidth: 120
      }, gridOpts.columnConfig);
      let proxyOpts;
      if (gridOpts.proxyConfig) {
        proxyOpts = Object.assign({
          autoLoad: false
        }, gridOpts.proxyConfig);
      }
      return Object.assign({}, gridOpts, {
        columns: tableColumns,
        columnConfig: columnOpts,
        formConfig: {
          data: searchFormData,
          items: searchFormItems
        },
        proxyConfig: proxyOpts
      });
    });
    const computeGridEvents = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        gridEvents
      } = props;
      const ons = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(gridEvents, (fn, key) => {
        ons[external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().camelCase(`on-${key}`)] = fn;
      });
      return ons;
    });
    const refMaps = {
      refElem,
      refGrid
    };
    const computeMaps = {};
    const $xeListView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const {
        createListDesignSettingActionButtonConfig
      } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = {
          name
        };
        const btnConfig = Object.assign(createListDesignActionButton({
          code: name
        }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === 'custom') {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const configToSearchItems = searchItems => {
      if (searchItems && searchItems.length) {
        const data = {};
        const items = searchItems.map(item => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        items.push({
          field: 'active',
          title: '',
          folding: false,
          collapseNode: searchItems.some(item => item.folding),
          itemRender: {
            name: 'VxeButtonGroup',
            options: [{
              content: '查询',
              icon: 'vxe-icon-search',
              status: 'primary',
              type: 'submit'
            }, {
              content: '重置',
              icon: 'vxe-icon-repeat',
              type: 'reset'
            }]
          }
        });
        return {
          items,
          data
        };
      }
      return {
        items: [],
        data: {}
      };
    };
    const configToListColumns = listColumns => {
      if (listColumns) {
        return listColumns.map(item => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const clearConfig = () => {
      emit('update:formData', {});
      reactData.searchFormData = {};
      reactData.searchFormItems = [];
      reactData.listTableColumns = [];
      reactData.tableColumns = [];
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const loadConfig = config => {
      if (config) {
        const {
          formConfig,
          searchItems,
          listColumns
        } = config;
        setSearchItems(searchItems || []);
        loadListColumns(listColumns || [], formConfig || {});
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const parseForm = searchItems => {
      return configToSearchItems(searchItems || []);
    };
    const parseTableColumn = (listColumns, formConfig) => {
      const formOpts = Object.assign({}, formConfig);
      const {
        showSeq,
        actionButtonList
      } = formOpts;
      const columns = [];
      const cellActionSlot = slots.cellAction;
      if (showSeq) {
        columns.push({
          type: 'seq',
          field: '_seq',
          width: 70
        });
      }
      configToListColumns(listColumns || []).forEach(conf => {
        columns.push(conf);
      });
      if (actionButtonList && actionButtonList.length) {
        const actionColumn = {
          field: '_active',
          title: i18n_getI18n('vxe.table.actionTitle'),
          fixed: 'right',
          width: 'auto'
        };
        const btnOptions = [];
        actionButtonList.forEach(btnItem => {
          if (btnItem.type === 'custom') {
            return {
              content: btnItem.name,
              name: btnItem.code,
              icon: btnItem.icon
            };
          }
          const btnConfig = systemConfigList.find(item => item.code === btnItem.code);
          let btnName = btnItem.name;
          let btnIcon = btnItem.icon;
          let btnStatus = btnItem.status;
          let btnPermissionCode = btnItem.permissionCode;
          let btnClassify = btnItem.classify;
          if (btnConfig) {
            const nameConfig = btnConfig.name;
            btnIcon = btnConfig.icon || '';
            btnStatus = btnConfig.status || '';
            btnPermissionCode = btnConfig.permissionCode || '';
            btnClassify = btnConfig.classify || '';
            btnName = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(nameConfig) ? nameConfig({
              name: btnConfig.code || ''
            }) : nameConfig);
          }
          if (!btnClassify || btnClassify === 'cellButton') {
            btnOptions.push({
              content: btnName,
              name: btnItem.code,
              icon: btnIcon,
              status: btnStatus,
              permissionCode: btnPermissionCode
            });
          }
        });
        if (cellActionSlot) {
          actionColumn.slots = {
            default(params) {
              return cellActionSlot({
                ...params,
                buttons: btnOptions
              });
            }
          };
        } else {
          actionColumn.cellRender = {
            name: 'VxeButtonGroup',
            props: {
              mode: 'text'
            },
            options: btnOptions,
            events: {
              click(params, btnParams) {
                const {
                  option
                } = btnParams;
                dispatchEvent('cell-action', {
                  ...params,
                  button: option
                }, btnParams.$event);
              }
            }
          };
        }
        columns.push(actionColumn);
      }
      return {
        columns,
        actionButtons: actionButtonList
      };
    };
    const parseConfig = config => {
      const {
        formConfig,
        searchItems,
        listColumns
      } = config || {};
      const {
        columns,
        actionButtons
      } = parseTableColumn(listColumns || [], formConfig);
      const {
        data,
        items
      } = parseForm(searchItems || []);
      return {
        formData: data,
        formItems: items,
        tableColumns: columns,
        actionButtons
      };
    };
    const getQueryFilter = () => {
      const {
        searchFormData,
        searchFormItems
      } = reactData;
      const items = [];
      const rest = {
        items,
        type: 'and'
      };
      const $grid = refGrid.value;
      if (!$grid) {
        return rest;
      }
      searchFormItems.forEach(item => {
        const {
          field
        } = item;
        const itemValue = searchFormData[field];
        if (itemValue) {
          const condition = [];
          condition.push({
            field,
            value: itemValue,
            match: '',
            type: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(itemValue) ? 'array' : ''
          });
          items.push({
            condition,
            type: 'and'
          });
        }
      });
      return rest;
    };
    const commitProxy = (code, ...args) => {
      const $grid = refGrid.value;
      if ($grid) {
        return $grid.commitProxy(code, ...args);
      }
      return Promise.resolve();
    };
    const loadListColumns = (listColumns, formConfig) => {
      const listTableColumns = listColumns || [];
      const {
        columns,
        actionButtons
      } = parseTableColumn(listTableColumns, formConfig);
      reactData.listTableColumns = listTableColumns;
      reactData.tableColumns = columns;
      emit('update:actionButtons', actionButtons);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const gridOptions = computeGridOptions.value;
        if (gridOptions.proxyConfig) {
          commitProxy('reload');
        }
      });
    };
    const setSearchItems = searchItems => {
      const {
        data,
        items
      } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      emit('update:formData', data);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $listView: $xeListView
      }, params));
    };
    const listViewMethods = {
      dispatchEvent,
      clearConfig,
      loadConfig,
      parseConfig,
      getQueryFilter,
      commitProxy
    };
    const listViewPrivateMethods = {};
    Object.assign($xeListView, listViewMethods, listViewPrivateMethods);
    const renderVN = () => {
      const {
        height,
        loading
      } = props;
      const gridSlot = slots.grid;
      const gridOptions = computeGridOptions.value;
      const gridEvents = computeGridEvents.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-list-view', {
          'is--loading': loading
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-view--body'
      }, [gridSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list-view--grid-wrapper'
      }, getSlotVNs(gridSlot({
        $listView: $xeListView
      }))) : VxeTableGridComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeTableGridComponent, Object.assign({}, gridOptions, gridEvents, {
        ref: refGrid
      }), Object.assign({}, slots, {
        default: undefined
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    $xeListView.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.config, value => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeListView', $xeListView);
    if (true) {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (!VxeTableGridComponent) {
          errLog('vxe.error.reqComp', ['vxe-grid']);
        }
      });
    }
    return $xeListView;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/list-view/index.ts



const VxeListView = Object.assign(list_view, {
  install: function (app) {
    app.component(list_view.name, list_view);
  }
});
dynamicApp.component(list_view.name, list_view);
core_VxeUI.component(list_view);
const ListView = VxeListView;
/* harmony default export */ var packages_list_view = (VxeListView);
;// CONCATENATED MODULE: ./packages/list/src/list.ts





/* harmony default export */ var list = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeList',
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: {
      type: String,
      default: () => getConfig().list.size || getConfig().size
    },
    autoResize: {
      type: Boolean,
      default: () => getConfig().list.autoResize
    },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: ['scroll'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      scrollYLoad: false,
      bodyHeight: 0,
      rowHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const internalData = {
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let listMethods = {};
    const computeSYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().list.scrollY, props.scrollY);
    });
    const computeStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        maxHeight
      } = props;
      const style = {};
      if (height) {
        style.height = `${isNaN(height) ? height : `${height}px`}`;
      } else if (maxHeight) {
        style.height = 'auto';
        style.maxHeight = `${isNaN(maxHeight) ? maxHeight : `${maxHeight}px`}`;
      }
      return style;
    });
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        fullData
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        fullData,
        scrollYStore
      } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // 计算 Y 逻辑
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sYOpts.oSize) : dom_browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
        reactData.rowHeight = rowHeight;
      });
    };
    /**
     * 清除滚动条
     */
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 如果有滚动条，则滚动到对应的位置
     * @param {Number} scrollLeft 左距离
     * @param {Number} scrollTop 上距离
     */
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 刷新滚动条
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * 重新计算列表
     */
    const recalculate = () => {
      const el = refElem.value;
      if (el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = evnt => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      listMethods.dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    listMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $list: $xeList
        }, params));
      },
      /**
       * 加载数据
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const {
          scrollYStore
        } = internalData;
        const sYOpts = computeSYOpts.value;
        const fullData = datas || [];
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 1,
          visibleSize: 0
        });
        internalData.fullData = fullData;
        // 如果gt为0，则总是启用
        reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
        handleData();
        return computeScrollLoad().then(() => {
          refreshScroll();
        });
      },
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return listMethods.loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      listMethods.loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.syncResize, value => {
      if (value) {
        recalculate();
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => setTimeout(() => recalculate()));
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(() => {
      recalculate().then(() => refreshScroll());
    });
    let resizeObserver;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeList, 'resize', () => {
        recalculate();
      });
      if (props.autoResize) {
        const el = refElem.value;
        resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el);
      }
      listMethods.loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, 'resize');
    });
    const renderVN = () => {
      const {
        className,
        loading
      } = props;
      const {
        bodyHeight,
        topSpaceHeight,
        items
      } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-list', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $list: $xeList
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-list--virtual-wrapper',
        style: styles,
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-list--body',
        style: {
          marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ''
        }
      }, defaultSlot ? defaultSlot({
        items,
        $list: $xeList
      }) : [])]),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list--loading',
        modelValue: loading
      })]);
    };
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/list/index.ts



const VxeList = Object.assign(list, {
  install(app) {
    app.component(list.name, list);
  }
});
dynamicApp.component(list.name, list);
core_VxeUI.component(list);
const List = VxeList;
/* harmony default export */ var packages_list = (VxeList);
;// CONCATENATED MODULE: ./packages/menu/src/menu.ts




/* harmony default export */ var menu = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeMenu',
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    collapsed: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    }
  },
  emits: ['update:modelValue', 'click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeLayoutAside = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeLayoutAside', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        collapsed
      } = props;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return $xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeMaps = {};
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = item => {
      return `${item.title || item.name}`;
    };
    const updateItemHeight = () => {
      const wrapperElem = refWrapperElem.value;
      const childEls = wrapperElem ? wrapperElem.children : [];
      if (childEls.length) {
        reactData.itemHeight = childEls[0].offsetHeight;
      }
    };
    const getExpandChildSize = item => {
      let size = 0;
      if (item.isExpand) {
        item.childList.forEach(child => {
          size += getExpandChildSize(child) + 1;
        });
      }
      return size;
    };
    const updateStyle = () => {
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.menuList, item => {
        if (item.hasChild && item.isExpand) {
          item.childHeight = getExpandChildSize(item) * reactData.itemHeight;
        } else {
          item.childHeight = 0;
        }
      }, {
        children: 'childList'
      });
    };
    const updateActiveMenu = isDefExpand => {
      const {
        activeName
      } = reactData;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.menuList, (item, index, items, path, parent, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach(obj => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, {
        children: 'childList'
      });
    };
    const updateMenuConfig = () => {
      const {
        expandAll
      } = props;
      reactData.menuList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(props.options, (item, index, items, path, parent) => {
        const objItem = {
          ...item,
          parentKey: parent ? parent.name || path.slice(0, path.length - 1).join(',') : '',
          level: path.length,
          itemKey: item.name || path.join(','),
          isExactActive: false,
          isActive: false,
          isExpand: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(item.expanded) ? item.expanded : !!expandAll,
          hasChild: item.children && item.children.length > 0,
          childHeight: 0
        };
        return objItem;
      }, {
        children: 'children',
        mapChildren: 'childList'
      });
    };
    const handleClickIconCollapse = (evnt, item) => {
      const {
        hasChild,
        isExpand
      } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        item.isExpand = !isExpand;
        updateItemHeight();
        updateStyle();
      }
    };
    const handleClickMenu = (evnt, item) => {
      const {
        routerLink,
        hasChild
      } = item;
      if (routerLink) {
        reactData.activeName = item.itemKey;
        emit('update:modelValue', item.itemKey);
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item);
        }
      }
      emit('click', createEvent(evnt, {
        $menu: $xeMenu,
        menu: item
      }));
    };
    const renderMenuTitle = item => {
      const {
        icon,
        isExpand,
        hasChild
      } = item;
      const title = getMenuTitle(item);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-menu--item-link-icon'
      }, icon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-menu--item-link-title',
        title
      }, title), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-menu--item-link-collapse',
        onClick(evnt) {
          handleClickIconCollapse(evnt, item);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
    };
    const renderChildren = item => {
      const {
        itemKey,
        level,
        hasChild,
        isActive,
        isExactActive,
        isExpand,
        routerLink,
        childList
      } = item;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: itemKey,
        class: ['vxe-menu--item-wrapper', `vxe-menu--item-level${level}`, {
          'is--exact-active': isExactActive,
          'is--active': isActive,
          'is--expand': !isCollapsed && isExpand
        }]
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-menu--item-link',
        to: routerLink,
        onClick(evnt) {
          handleClickMenu(evnt, item);
        }
      }, {
        default: () => renderMenuTitle(item)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link',
        onClick(evnt) {
          handleClickMenu(evnt, item);
        }
      }, renderMenuTitle(item)), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-group',
        style: {
          // height: `${childHeight}px`
        }
      }, childList.map(child => renderChildren(child))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    const renderVN = () => {
      const {
        loading
      } = props;
      const {
        menuList
      } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-menu', {
          'is--collapsed': isCollapsed,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refWrapperElem,
        class: 'vxe-menu--item-list'
      }, menuList.map(child => renderChildren(child))),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    $xeMenu.renderVN = renderVN;
    const optFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeName = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(updateItemHeight);
    });
    updateMenuConfig();
    updateActiveMenu(true);
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/menu/index.ts



const VxeMenu = Object.assign({}, menu, {
  install(app) {
    app.component(menu.name, menu);
  }
});
dynamicApp.component(menu.name, menu);
core_VxeUI.component(menu);
const Menu = VxeMenu;
/* harmony default export */ var packages_menu = (VxeMenu);
;// CONCATENATED MODULE: ./packages/modal/index.ts





function openModal(options) {
  // 使用动态组件渲染动态弹框
  checkDynamic();
  return new Promise(resolve => {
    if (options && options.id && allActiveModals.some(comp => comp.props.id === options.id)) {
      resolve('exist');
    } else {
      const _onHide = options.onHide;
      const modalOpts = Object.assign(options, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter(item => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveModals, $modal => $modal.props.id === id);
}
/**
 * 全局关闭动态的活动窗口（只能用于关闭动态的创建的活动窗口）
 * 如果传 id 则关闭指定的窗口
 * 如果不传则关闭所有窗口
 */
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach($modal => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(content)) {
    opts = content;
  } else {
    opts = {
      content: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content),
      title
    };
  }
  return openModal({
    ...defOpts,
    ...options,
    ...opts
  });
}
function openAlert(content, title, options) {
  return handleOpen({
    type: 'alert',
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: 'confirm',
    status: 'question',
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: 'message',
    mask: false,
    lockView: false,
    showHeader: false
  }, content, '', options);
}
function openNotification(content, title, options) {
  return handleOpen({
    type: 'notification',
    mask: false,
    lockView: false,
    showHeader: true,
    draggable: false,
    position: 'top-right',
    width: 320
  }, content, title, options);
}
const ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage,
  notification: openNotification
};
const VxeModal = Object.assign(modal, {
  install: function (app) {
    app.component(modal.name, modal);
  }
});
dynamicApp.component(modal.name, modal);
core_VxeUI.component(modal);
core_VxeUI.modal = ModalController;
const Modal = VxeModal;
/* harmony default export */ var packages_modal = (VxeModal);
;// CONCATENATED MODULE: ./packages/number-input/index.ts



const VxeNumberInput = Object.assign({}, number_input, {
  install(app) {
    app.component(number_input.name, number_input);
  }
});
dynamicApp.component(number_input.name, number_input);
core_VxeUI.component(number_input);
const NumberInput = VxeNumberInput;
/* harmony default export */ var packages_number_input = (VxeNumberInput);
;// CONCATENATED MODULE: ./packages/select/src/option-info.ts

class OptionInfo {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('option_'),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/select/src/util.ts



function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      option.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el, option, optGroup) {
  const {
    reactData
  } = $xeSelect;
  const {
    staticOptions
  } = reactData;
  const parentElem = el.parentNode;
  const parentOption = optGroup ? optGroup.option : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option) {
  const {
    reactData
  } = $xeSelect;
  const {
    staticOptions
  } = reactData;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticOptions, item => item.id === option.id, {
    children: 'options'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}
;// CONCATENATED MODULE: ./packages/select/src/optgroup.ts


/* harmony default export */ var optgroup = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeOptgroup',
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', {});
    const option = createOption($xeSelect, props);
    const xeOption = {
      option
    };
    option.options = [];
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeoptgroup', xeOption);
    watchOption(props, option);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assembleOption($xeSelect, elem.value, option);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeSelect, option);
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      }, slots.default ? slots.default() : []);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/optgroup/index.ts



const VxeOptgroup = Object.assign(optgroup, {
  install: function (app) {
    app.component(optgroup.name, optgroup);
  }
});
dynamicApp.component(optgroup.name, optgroup);
core_VxeUI.component(optgroup);
const Optgroup = VxeOptgroup;
/* harmony default export */ var packages_optgroup = (VxeOptgroup);
;// CONCATENATED MODULE: ./packages/select/src/option.ts


/* harmony default export */ var src_option = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeOption',
  props: {
    value: null,
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', {});
    const optGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeoptgroup', null);
    const option = createOption($xeSelect, props);
    option.slots = slots;
    watchOption(props, option);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assembleOption($xeSelect, elem.value, option, optGroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeSelect, option);
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      });
    };
  }
}));
;// CONCATENATED MODULE: ./packages/option/index.ts



const VxeOption = Object.assign(src_option, {
  install: function (app) {
    app.component(src_option.name, src_option);
  }
});
dynamicApp.component(src_option.name, src_option);
core_VxeUI.component(src_option);
const Option = VxeOption;
/* harmony default export */ var packages_option = (VxeOption);
;// CONCATENATED MODULE: ./packages/pager/src/pager.ts







/* harmony default export */ var pager = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxePager',
  props: {
    size: {
      type: String,
      default: () => getConfig().pager.size || getConfig().size
    },
    // 自定义布局
    layouts: {
      type: Array,
      default: () => getConfig().pager.layouts || ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
    },
    // 当前页
    currentPage: {
      type: Number,
      default: 1
    },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: {
      type: Number,
      default: () => getConfig().pager.pageSize || 10
    },
    // 总条数
    total: {
      type: Number,
      default: 0
    },
    // 显示页码按钮的数量
    pagerCount: {
      type: Number,
      default: () => getConfig().pager.pagerCount || 7
    },
    // 每页大小选项列表
    pageSizes: {
      type: Array,
      default: () => getConfig().pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // 列对其方式
    align: {
      type: String,
      default: () => getConfig().pager.align
    },
    // 带边框
    border: {
      type: Boolean,
      default: () => getConfig().pager.border
    },
    // 带背景颜色
    background: {
      type: Boolean,
      default: () => getConfig().pager.background
    },
    // 配套的样式
    perfect: {
      type: Boolean,
      default: () => getConfig().pager.perfect
    },
    // 当只有一页时隐藏
    autoHidden: {
      type: Boolean,
      default: () => getConfig().pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().pager.transfer
    },
    className: [String, Function],
    pageSizePlacement: {
      type: String,
      default: () => getConfig().pager.pageSizePlacement
    },
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: ['update:pageSize', 'update:currentPage', 'page-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inpCurrPage: props.currentPage
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xePager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    let pagerMethods = {};
    let pagerPrivateMethods = {};
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const computePageCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const jumpPageEvent = (evnt, currentPage) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const changeCurrentPage = (currentPage, evnt) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const triggerJumpEvent = params => {
      const {
        $event
      } = params;
      const inputElem = $event.target;
      const inpValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      changeCurrentPage(current, $event);
    };
    const computeNumList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        pagerCount
      } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.pageSizes.map(item => {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(item)) {
          return {
            value: item,
            label: `${i18n_getI18n('vxe.pager.pagesize', [item])}`
          };
        }
        return {
          value: '',
          label: '',
          ...item
        };
      });
    });
    const handleHomePage = evnt => {
      const {
        currentPage
      } = props;
      if (currentPage > 1) {
        changeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = evnt => {
      const numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = evnt => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = params => {
      const {
        value
      } = params;
      const pageSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit('update:currentPage', pageCount);
      }
      emit('update:pageSize', pageSize);
      pagerMethods.dispatchEvent('page-change', {
        type: 'size',
        pageSize,
        currentPage
      }, params.$event);
    };
    const jumpKeydownEvent = params => {
      const {
        $event
      } = params;
      if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ENTER)) {
        triggerJumpEvent(params);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        $event.preventDefault();
        handleNextPage($event);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        $event.preventDefault();
        handlePrevPage($event);
      }
    };
    // 第一页
    const renderHomePage = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': props.currentPage <= 1
        }],
        type: 'button',
        title: i18n_getI18n('vxe.pager.homePageTitle'),
        onClick: handleHomePage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconHomePage || getIcon().PAGER_HOME]
      })]);
    };
    // 上一页
    const renderPrevPage = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': props.currentPage <= 1
        }],
        type: 'button',
        title: i18n_getI18n('vxe.pager.prevPageTitle'),
        onClick: handlePrevPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconPrevPage || getIcon().PAGER_PREV_PAGE]
      })]);
    };
    // 向上翻页
    const renderPrevJump = tagName => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-prev', {
          'is--fixed': !tagName,
          'is--disabled': props.currentPage <= 1
        }],
        type: 'button',
        title: i18n_getI18n('vxe.pager.prevJumpTitle'),
        onClick: handlePrevJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpPrev || getIcon().PAGER_JUMP_PREV]
      })]);
    };
    // 向下翻页
    const renderNextJump = tagName => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-next', {
          'is--fixed': !tagName,
          'is--disabled': props.currentPage >= pageCount
        }],
        type: 'button',
        title: i18n_getI18n('vxe.pager.nextJumpTitle'),
        onClick: handleNextJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpNext || getIcon().PAGER_JUMP_NEXT]
      })]);
    };
    // 下一页
    const renderNextPage = () => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--next-btn', {
          'is--disabled': props.currentPage >= pageCount
        }],
        type: 'button',
        title: i18n_getI18n('vxe.pager.nextPageTitle'),
        onClick: handleNextPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconNextPage || getIcon().PAGER_NEXT_PAGE]
      })]);
    };
    // 最后一页
    const renderEndPage = () => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': props.currentPage >= pageCount
        }],
        type: 'button',
        title: i18n_getI18n('vxe.pager.endPageTitle'),
        onClick: handleEndPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconEndPage || getIcon().PAGER_END]
      })]);
    };
    // 页数
    const renderNumber = showJump => {
      const {
        currentPage,
        pagerCount
      } = props;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => jumpPageEvent(evnt, 1)
        }, 1), renderPrevJump('span'));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
            key: number,
            class: ['vxe-pager--num-btn', {
              'is--active': currentPage === number
            }],
            type: 'button',
            onClick: evnt => jumpPageEvent(evnt, number)
          }, number));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump('button'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => jumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--btn-wrapper'
      }, nums);
    };
    // jumpNumber
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    // sizes
    const renderSizes = () => {
      const sizeList = computeSizeList.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
        class: 'vxe-pager--sizes',
        modelValue: props.pageSize,
        placement: props.pageSizePlacement,
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    // Jump
    const renderJump = isFull => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--jump'
      }, [isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--goto-text'
      }, i18n_getI18n('vxe.pager.goto')) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        class: 'vxe-pager--goto',
        modelValue: reactData.inpCurrPage,
        placeholder: i18n_getI18n('vxe.pager.gotoTitle'),
        align: 'center',
        type: 'integer',
        max: pageCount,
        min: 1,
        controls: false,
        onKeydown: jumpKeydownEvent,
        onBlur: triggerJumpEvent,
        'onUpdate:modelValue'(val) {
          reactData.inpCurrPage = val;
        }
      }), isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--classifier-text'
      }, i18n_getI18n('vxe.pager.pageClassifier')) : null]);
    };
    // FullJump
    const renderFullJump = () => {
      return renderJump(true);
    };
    // PageCount
    const renderPageCount = () => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--count'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--separator'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', pageCount)]);
    };
    // total
    const renderTotal = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--total'
      }, i18n_getI18n('vxe.pager.total', [props.total]));
    };
    pagerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $pager: $xePager
        }, params));
      },
      homePage() {
        handleHomePage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      endPage() {
        handleEndPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevPage() {
        handlePrevPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextPage() {
        handleNextPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevJump() {
        handlePrevJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextJump() {
        handleNextJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xePager, pagerMethods, pagerPrivateMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.currentPage, value => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const {
        align,
        layouts,
        className
      } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--left-wrapper'
        }, slots.left({
          $grid: $xeGrid
        })));
      }
      layouts.forEach(name => {
        let renderFn;
        switch (name) {
          case 'Home':
            renderFn = renderHomePage;
            break;
          case 'PrevJump':
            renderFn = renderPrevJump;
            break;
          case 'PrevPage':
            renderFn = renderPrevPage;
            break;
          case 'Number':
            renderFn = renderNumber;
            break;
          case 'JumpNumber':
            renderFn = renderJumpNumber;
            break;
          case 'NextPage':
            renderFn = renderNextPage;
            break;
          case 'NextJump':
            renderFn = renderNextJump;
            break;
          case 'End':
            renderFn = renderEndPage;
            break;
          case 'Sizes':
            renderFn = renderSizes;
            break;
          case 'FullJump':
            renderFn = renderFullJump;
            break;
          case 'Jump':
            renderFn = renderJump;
            break;
          case 'PageCount':
            renderFn = renderPageCount;
            break;
          case 'Total':
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          if (true) {
            errLog('vxe.error.notProp', [`layouts -> ${name}`]);
          }
        }
      });
      if (slots.right) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--right-wrapper'
        }, slots.right({
          $grid: $xeGrid
        })));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pager', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pager: $xePager
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          'is--border': props.border,
          'is--background': props.background,
          'is--perfect': props.perfect,
          'is--hidden': props.autoHidden && pageCount === 1,
          'is--loading': props.loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pager--wrapper'
      }, childNodes)]);
    };
    $xePager.renderVN = renderVN;
    return $xePager;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pager/index.ts



const VxePager = Object.assign(pager, {
  install: function (app) {
    app.component(pager.name, pager);
  }
});
dynamicApp.component(pager.name, pager);
core_VxeUI.component(pager);
const Pager = VxePager;
/* harmony default export */ var packages_pager = (VxePager);
;// CONCATENATED MODULE: ./packages/password-input/src/password-input.ts





/* harmony default export */ var password_input = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxePasswordInput',
  props: {
    modelValue: String,
    name: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().passwordInput.size || getConfig().size
    },
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'click', 'focus', 'blur', 'clear', 'toggle-visible', 'prefix-click', 'suffix-click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInpReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      return readonly;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return i18n_getI18n('vxe.base.pleaseInput');
    });
    const computeInputType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        showPwd
      } = reactData;
      if (showPwd) {
        return 'text';
      }
      return 'password';
    });
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      reactData.inputValue = value;
      passwordInputMethods.dispatchEvent('input', {
        value
      }, evnt);
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      passwordInputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = evnt => {
      triggerEvent(evnt);
      const {
        inputValue
      } = reactData;
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, inputValue);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      passwordInputMethods.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    const passwordToggleEvent = evnt => {
      const {
        readonly,
        disabled
      } = props;
      const {
        showPwd
      } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      passwordInputMethods.dispatchEvent('toggle-visible', {
        visible: reactData.showPwd
      }, evnt);
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      emitModel('', evnt);
      passwordInputMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        const {
          inputValue
        } = reactData;
        passwordInputMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const clickPrefixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        const {
          inputValue
        } = reactData;
        passwordInputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const {
        showPwd
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'password-input--control-icon',
        onClick: passwordToggleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['password-input--password-icon', showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
      })]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'password-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'password-input--prefix-icon'
      }, prefixSlot ? getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        disabled,
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['password-input--suffix', {
          'is--clear': isClearable && !disabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'password-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), renderExtraSuffixIcon(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'password-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : null;
    };
    const renderExtraSuffixIcon = () => {
      return renderPasswordIcon();
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $passwordInput: $xePasswordInput
        }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const {
        className,
        name,
        disabled,
        readonly,
        autocomplete,
        autoComplete,
        maxLength
      } = props;
      const {
        inputValue,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['password-input', className, {
          [`size--${vSize}`]: vSize,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--readonly': readonly,
          'is--disabled': disabled,
          'is--active': isActivated,
          'show--clear': isClearable && !disabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'password-input--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'password-input--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        readonly: inpReadonly,
        disabled,
        autocomplete: autocomplete || autoComplete,
        maxlength: maxLength,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/password-input/index.ts



const VxePasswordInput = Object.assign({}, password_input, {
  install(app) {
    app.component(password_input.name, password_input);
  }
});
dynamicApp.component(password_input.name, password_input);
core_VxeUI.component(password_input);
const PasswordInput = VxePasswordInput;
/* harmony default export */ var packages_password_input = (VxePasswordInput);
;// CONCATENATED MODULE: ./packages/print/src/util.ts




// 打印
let printFrame;
// 默认导出或打印的 HTML 样式
const defaultHtmlStyle = 'body{margin:0;padding:0;color:#000000;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createPrintFrame() {
  const frame = document.createElement('iframe');
  frame.className = 'vxe-table--print-frame';
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write('');
      } catch (e) {}
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], {
    type: `text/${type};charset=utf-8;`
  });
}
const printMargin = 80;
function createHtmlPage(opts, printHtml) {
  const {
    customStyle
  } = opts;
  return ['<!DOCTYPE html><html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">', `<title>${opts.title}</title>`, opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length ? '<style media="print">@page {size: auto;margin: 0mm;}</style>' : '', `<style>.vxe-print-slots{display: none;}.vxe-print-page-break.align--center{text-align:center;}.vxe-print-page-break.align--left{text-align:left;}.vxe-print-page-break.align--right{text-align:right;}.vxe-print-page-break--header-title{font-size:1.8em;text-align:center;line-height:${printMargin}px;}.vxe-print-page-break{page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow: hidden;}.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;width:${printMargin}px;height:100%;}.vxe-print-page-break--header,.vxe-print-page-break--footer{flex-shrink:0;height:${printMargin}px;width:100%;}.vxe-print-page-break--content{flex-grow: 1;overflow: hidden;}.vxe-print-page-break--footer-page-number{line-height:${printMargin}px;text-align:center;}</style>`, '<style>.vxe-table{white-space:pre;}</style>', `<style>${defaultHtmlStyle}</style>`, customStyle ? `<style>${customStyle}</style>` : '', '</head>', '<body>', `${printHtml}`, '</body>', '</html>'].join('');
}
function handlePrint(opts, printHtml = '') {
  const {
    beforeMethod
  } = opts;
  if (beforeMethod) {
    printHtml = beforeMethod({
      content: printHtml,
      html: printHtml,
      options: opts
    }) || '';
  }
  printHtml = createHtmlPage(opts, printHtml);
  const blob = getExportBlobByString(printHtml, 'html');
  return new Promise(resolve => {
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse().msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      printFrame.contentDocument.write(printHtml);
      printFrame.contentDocument.execCommand('print');
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = evnt => {
          if (evnt.target.src) {
            evnt.target.contentWindow.onafterprint = afterPrintEvent;
            evnt.target.contentWindow.print();
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const {
    title,
    showPageNumber,
    align,
    headerAlign,
    footerAlign,
    showAllPageTitle
  } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [`<div class="${['vxe-print-page-break', align ? `align--${align}` : ''].join(' ')}">`, `<div class="${['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : ''].join(' ')}">`, headerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerHtml) ? headerHtml(params) : headerHtml || ''}` : title && (showAllPageTitle || !index) ? `<div class="vxe-print-page-break--header-title">${title || ''}</div>` : '', '</div>', '<div class="vxe-print-page-break--body">', `<div class="vxe-print-page-break--left">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(leftHtml) ? leftHtml(params) : leftHtml || ''}</div>`, `<div class="vxe-print-page-break--content">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ''}</div>`, `<div class="vxe-print-page-break--right">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rightHtml) ? rightHtml(params) : rightHtml || ''}</div>`, '</div>', `<div class="${['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : ''].join(' ')}">`, footerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerHtml) ? footerHtml(params) : footerHtml || ''}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : '', '</div>', '</div>'].join('');
  }).join('');
}
const printHtml = options => {
  const opts = Object.assign({
    _pageBreaks: false,
    customLayout: true
  }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml = opts.html || opts.content;
  return handlePrint(opts, printHtml);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter(item => item.id !== pageBreakConfig.id);
}
;// CONCATENATED MODULE: ./packages/print/src/page-break.ts



/* harmony default export */ var page_break = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxePrintPageBreak',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xePrint = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xePrint', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => [];
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    $xePrintPageBreak.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if ($xePrint && refElem.value) {
        assemblePageBreak($xePrint, refElem.value, pageBreakConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/print-page-break/index.ts



const VxePrintPageBreak = Object.assign({}, page_break, {
  install(app) {
    app.component(page_break.name, page_break);
  }
});
dynamicApp.component(page_break.name, page_break);
core_VxeUI.component(page_break);
const PrintPageBreak = VxePrintPageBreak;
/* harmony default export */ var print_page_break = (VxePrintPageBreak);
;// CONCATENATED MODULE: ./packages/print/src/print.ts





/* harmony default export */ var print = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxePrint',
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      Boolean: Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const printMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $print: $xePrint
        }, params));
      },
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: (elem ? elem.outerHTML : '') || props.html || props.content || ''
        }));
      }
    };
    Object.assign($xePrint, printMethods);
    const renderPageConfigLayouts = () => {
      const {
        title,
        showPageNumber,
        showAllPageTitle,
        align,
        headerAlign,
        footerAlign
      } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index + 1;
        const params = {
          currentPage,
          pageCount
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break', align ? `align--${align}` : '']
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : '']
        }, headerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerHtml) ? headerHtml(params) : headerHtml || ''}` : [title && (showAllPageTitle || !index) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--header-title'
        }, `${title || ''}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--body'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--left'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(leftHtml) ? leftHtml(params) : leftHtml || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--content'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--right'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rightHtml) ? rightHtml(params) : rightHtml || ''}`)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : '']
        }, footerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerHtml) ? footerHtml(params) : footerHtml || ''}` : [showPageNumber ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--footer-page-number'
        }, `${currentPage}/${pageCount}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
      });
    };
    const renderPageStaticLayouts = () => {
      const {
        title,
        showPageNumber,
        showAllPageTitle,
        align,
        headerAlign,
        footerAlign
      } = props;
      const {
        staticPageBreaks
      } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index) => {
        const itemSlots = item.slots || {};
        const currentPage = index + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break', align ? `align--${align}` : '']
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : '']
        }, headerSlot ? getSlotVNs(headerSlot(params)) : [title && (showAllPageTitle || !index) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--header-title'
        }, `${title || ''}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--body'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--left'
        }, leftSlot ? getSlotVNs(leftSlot(params)) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--content'
        }, defaultSlot ? getSlotVNs(defaultSlot(params)) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--right'
        }, rightSlot ? getSlotVNs(rightSlot(params)) : [])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : '']
        }, footerSlot ? getSlotVNs(footerSlot(params)) : [showPageNumber ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--footer-page-number'
        }, `${currentPage}/${pageCount}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
      });
    };
    const renderVN = () => {
      const {
        customLayout
      } = props;
      const {
        staticPageBreaks
      } = reactData;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-print']
      }, customLayout ? defaultSlot ? getSlotVNs(defaultSlot({})) : [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'slot',
        class: 'vxe-print-slots'
      }, defaultSlot ? getSlotVNs(defaultSlot({})) : [])].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xePrint', $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/print/index.ts




const VxePrint = Object.assign({}, print, {
  install(app) {
    app.component(print.name, print);
  }
});
dynamicApp.component(print.name, print);
core_VxeUI.component(print);
core_VxeUI.print = printHtml;
const Print = VxePrint;
/* harmony default export */ var packages_print = (VxePrint);
;// CONCATENATED MODULE: ./packages/pulldown/src/pulldown.ts





/* harmony default export */ var pulldown = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxePulldown',
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    size: {
      type: String,
      default: () => getConfig().size
    },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'click', 'option-click', 'hide-panel'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      panelStyle: null,
      panelPlacement: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldowContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldowPnanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    /**
     * 手动更新位置
     */
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex,
          visiblePanel
        } = reactData;
        const transfer = computeTransfer.value;
        if (visiblePanel) {
          const targetElem = refPulldowContent.value;
          const panelElem = refPulldowPnanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const {
              boundingTop,
              boundingLeft,
              visibleHeight,
              visibleWidth
            } = getAbsolutePos(targetElem);
            let panelPlacement = 'bottom';
            if (transfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === 'top') {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              } else if (!placement) {
                // 如果下面不够放，则向上
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = 'top';
                  top = boundingTop - panelHeight;
                }
                // 如果上面不够放，则向下（优先）
                if (top < marginSize) {
                  panelPlacement = 'bottom';
                  top = boundingTop + targetHeight;
                }
              }
              // 如果溢出右边
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              // 如果溢出左边
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === 'top') {
                panelPlacement = 'top';
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                // 如果下面不够放，则向上
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  // 如果上面不够放，则向下（优先）
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = 'top';
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      });
    };
    let hidePanelTimeout;
    /**
     * 显示下拉面板
     */
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise(resolve => {
        if (!props.disabled) {
          clearTimeout(hidePanelTimeout);
          reactData.isActivated = true;
          reactData.animatVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit('update:modelValue', true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * 隐藏下拉面板
     */
    const hidePanel = () => {
      reactData.visiblePanel = false;
      emit('update:modelValue', false);
      return new Promise(resolve => {
        if (reactData.animatVisible) {
          hidePanelTimeout = window.setTimeout(() => {
            reactData.animatVisible = false;
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 350);
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * 切换下拉面板
     */
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option) => {
      if (!option.disabled) {
        hidePanel();
        dispatchEvent('option-click', {
          option
        }, evnt);
      }
    };
    const clickTargetEvent = evnt => {
      const {
        trigger
      } = props;
      if (trigger === 'click') {
        if (reactData.visiblePanel) {
          hidePanel();
        } else {
          showPanel();
        }
      }
      dispatchEvent('click', {
        $pulldown: $xePulldown
      }, evnt);
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            dispatchEvent('hide-panel', {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const el = refElem.value;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          dispatchEvent('hide-panel', {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = evnt => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        dispatchEvent('hide-panel', {}, evnt);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $pulldown: $xePulldown
      }, params));
    };
    pulldownMethods = {
      dispatchEvent,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xePulldown, pulldownMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xePulldown, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xePulldown, 'mousewheel');
      globalEvents.off($xePulldown, 'mousedown');
      globalEvents.off($xePulldown, 'blur');
    });
    const renderDefaultPanel = options => {
      const optionSlot = slots.option;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-list'
      }, options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-pulldown--panel-item',
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({
          $pulldown: $xePulldown,
          option: item
        }) : `${item.label || ''}`);
      }) : []);
    };
    const renderVN = () => {
      const {
        className,
        options,
        popupClassName,
        showPopupShadow,
        destroyOnClose,
        disabled
      } = props;
      const {
        initialized,
        isActivated,
        animatVisible,
        visiblePanel,
        panelStyle,
        panelPlacement
      } = reactData;
      const transfer = computeTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pulldown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pulldown: $xePulldown
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': disabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldowContent,
        class: 'vxe-pulldown--content',
        onClick: clickTargetEvent
      }, defaultSlot ? defaultSlot({
        $pulldown: $xePulldown
      }) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: transfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldowPnanel,
        class: ['vxe-table--ignore-clear vxe-pulldown--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $pulldown: $xePulldown
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--shadow': showPopupShadow,
          'is--transfer': transfer,
          'animat--leave': animatVisible,
          'animat--enter': visiblePanel
        }],
        placement: panelPlacement,
        style: panelStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-wrapper'
      }, !initialized || destroyOnClose && !visiblePanel && !animatVisible ? [] : [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-header'
      }, headerSlot({
        $pulldown: $xePulldown
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-body'
      }, dropdownSlot ? dropdownSlot({
        $pulldown: $xePulldown
      }) : [renderDefaultPanel(options)]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-footer'
      }, footerSlot({
        $pulldown: $xePulldown
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])])])]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pulldown/index.ts



const VxePulldown = Object.assign(pulldown, {
  install: function (app) {
    app.component(pulldown.name, pulldown);
  }
});
dynamicApp.component(pulldown.name, pulldown);
core_VxeUI.component(pulldown);
const Pulldown = VxePulldown;
/* harmony default export */ var packages_pulldown = (VxePulldown);
;// CONCATENATED MODULE: ./packages/radio/index.ts



const VxeRadio = Object.assign(src_radio, {
  install: function (app) {
    app.component(src_radio.name, src_radio);
  }
});
dynamicApp.component(src_radio.name, src_radio);
core_VxeUI.component(src_radio);
const Radio = VxeRadio;
/* harmony default export */ var packages_radio = (VxeRadio);
;// CONCATENATED MODULE: ./packages/radio-button/index.ts



const VxeRadioButton = Object.assign(radio_src_button, {
  install: function (app) {
    app.component(radio_src_button.name, radio_src_button);
  }
});
dynamicApp.component(radio_src_button.name, radio_src_button);
core_VxeUI.component(radio_src_button);
const RadioButton = VxeRadioButton;
/* harmony default export */ var radio_button = (VxeRadioButton);
;// CONCATENATED MODULE: ./packages/radio-group/index.ts



const VxeRadioGroup = Object.assign(src_group, {
  install: function (app) {
    app.component(src_group.name, src_group);
  }
});
dynamicApp.component(src_group.name, src_group);
core_VxeUI.component(src_group);
const RadioGroup = VxeRadioGroup;
/* harmony default export */ var radio_group = (VxeRadioGroup);
;// CONCATENATED MODULE: ./packages/row/index.ts



const VxeRow = Object.assign({}, row, {
  install(app) {
    app.component(row.name, row);
  }
});
dynamicApp.component(row.name, row);
core_VxeUI.component(row);
const Row = VxeRow;
/* harmony default export */ var packages_row = (VxeRow);
;// CONCATENATED MODULE: ./packages/select/index.ts



const VxeSelect = Object.assign(src_select, {
  install: function (app) {
    app.component(src_select.name, src_select);
  }
});
dynamicApp.component(src_select.name, src_select);
core_VxeUI.component(src_select);
const Select = VxeSelect;
/* harmony default export */ var packages_select = (VxeSelect);
;// CONCATENATED MODULE: ./packages/switch/index.ts



const VxeSwitch = Object.assign(src_switch, {
  install: function (app) {
    app.component(src_switch.name, src_switch);
  }
});
dynamicApp.component(src_switch.name, src_switch);
core_VxeUI.component(src_switch);
const Switch = VxeSwitch;
/* harmony default export */ var packages_switch = (VxeSwitch);
;// CONCATENATED MODULE: ./packages/tab-pane/index.ts



const VxeTabPane = Object.assign({}, tab_pane, {
  install(app) {
    app.component(tab_pane.name, tab_pane);
  }
});
dynamicApp.component(tab_pane.name, tab_pane);
core_VxeUI.component(tab_pane);
const TabPane = VxeTabPane;
/* harmony default export */ var packages_tab_pane = (VxeTabPane);
;// CONCATENATED MODULE: ./packages/tabs/index.ts



const VxeTabs = Object.assign({}, tabs, {
  install(app) {
    app.component(tabs.name, tabs);
  }
});
dynamicApp.component(tabs.name, tabs);
core_VxeUI.component(tabs);
const Tabs = VxeTabs;
/* harmony default export */ var packages_tabs = (VxeTabs);
;// CONCATENATED MODULE: ./packages/tag/src/tag.ts




/* harmony default export */ var tag = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTag',
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tag.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderContent = () => {
      const {
        icon,
        content
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-tag--icon'
      }, iconSlot ? getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-tag--content'
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))];
    };
    const renderVN = () => {
      const {
        status,
        title
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        title,
        class: ['vxe-tag', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status
        }]
      }, renderContent());
    };
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tag/index.ts



const VxeTag = Object.assign({}, tag, {
  install(app) {
    app.component(tag.name, tag);
  }
});
dynamicApp.component(tag.name, tag);
core_VxeUI.component(tag);
const Tag = VxeTag;
/* harmony default export */ var packages_tag = (VxeTag);
;// CONCATENATED MODULE: ./packages/text/index.ts



const VxeText = Object.assign({}, src_text, {
  install(app) {
    app.component(src_text.name, src_text);
  }
});
dynamicApp.component(src_text.name, src_text);
core_VxeUI.component(src_text);
const Text = VxeText;
/* harmony default export */ var packages_text = (VxeText);
;// CONCATENATED MODULE: ./packages/textarea/index.ts



const VxeTextarea = Object.assign(src_textarea, {
  install: function (app) {
    app.component(src_textarea.name, src_textarea);
  }
});
dynamicApp.component(src_textarea.name, src_textarea);
core_VxeUI.component(src_textarea);
const Textarea = VxeTextarea;
/* harmony default export */ var packages_textarea = (VxeTextarea);
;// CONCATENATED MODULE: ./packages/tip/index.ts



const VxeTip = Object.assign({}, tip, {
  install(app) {
    app.component(tip.name, tip);
    app.component('VxeTipsComponent', tip);
  }
});
dynamicApp.component(tip.name, tip);
core_VxeUI.component(tip);
const Tips = VxeTip;
const Tip = VxeTip;
/* harmony default export */ var packages_tip = (VxeTip);
;// CONCATENATED MODULE: ./packages/tooltip/index.ts



const VxeTooltip = Object.assign({}, tooltip, {
  install(app) {
    app.component(tooltip.name, tooltip);
  }
});
dynamicApp.component(tooltip.name, tooltip);
core_VxeUI.component(tooltip);
const Tooltip = VxeTooltip;
/* harmony default export */ var packages_tooltip = (VxeTooltip);
;// CONCATENATED MODULE: ./packages/tree/index.ts



const VxeTree = Object.assign({}, tree, {
  install(app) {
    app.component(tree.name, tree);
  }
});
dynamicApp.component(tree.name, tree);
core_VxeUI.component(tree);
const Tree = VxeTree;
/* harmony default export */ var packages_tree = (VxeTree);
;// CONCATENATED MODULE: ./packages/tree-select/index.ts



const VxeTreeSelect = Object.assign({}, tree_select, {
  install(app) {
    app.component(tree_select.name, tree_select);
  }
});
dynamicApp.component(tree_select.name, tree_select);
core_VxeUI.component(tree_select);
const TreeSelect = VxeTreeSelect;
/* harmony default export */ var packages_tree_select = (VxeTreeSelect);
;// CONCATENATED MODULE: ./packages/upload/index.ts




const VxeUpload = Object.assign({}, upload, {
  install(app) {
    app.component(upload.name, upload);
  }
});
dynamicApp.component(upload.name, upload);
core_VxeUI.component(upload);
core_VxeUI.saveFile = saveLocalFile;
core_VxeUI.readFile = readLocalFile;
const Upload = VxeUpload;
/* harmony default export */ var packages_upload = (VxeUpload);
;// CONCATENATED MODULE: ./packages/components.ts





































































const components_components = [packages_alert, packages_anchor, packages_anchor_link, packages_breadcrumb, packages_breadcrumb_item, packages_button, packages_button_group, packages_calendar, packages_card, packages_carousel, packages_carousel_item, packages_checkbox, checkbox_group, packages_col, packages_collapse, packages_collapse_pane, packages_date_picker, packages_drawer, packages_form, packages_form_design, packages_form_gather, packages_form_item, packages_form_view, packages_icon, packages_icon_picker, packages_image, image_group, image_preview, packages_input, packages_layout_aside, packages_layout_body, packages_layout_container, packages_layout_footer, packages_layout_header, packages_link, packages_list_design, packages_list_view, packages_list, packages_loading, packages_menu, packages_modal, packages_number_input, packages_optgroup, packages_option, packages_pager, packages_password_input, print_page_break, packages_print, packages_pulldown, packages_radio, radio_button, radio_group, packages_row, packages_select, packages_switch, packages_tab_pane, packages_tabs, packages_tag, packages_text, packages_textarea, packages_tip, packages_tooltip, packages_tree, packages_tree_select, packages_upload];
function install(app, options) {
  setConfig(options);
  components_components.forEach(component => app.use(component));
}
// 默认中文
const defaultLanguage = 'zh-CN';
setI18n(defaultLanguage, zh_CN);
setLanguage(defaultLanguage);
setTheme('light');
// 兼容老版本
const loading = LoadingController;
const components_modal = ModalController;
const components_drawer = DrawerController;
const components_print = printHtml;
const saveFile = saveLocalFile;
const readFile = readLocalFile;

// Components

































































;// CONCATENATED MODULE: ./index.ts



/* harmony default export */ var index = (components_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (index);


}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});