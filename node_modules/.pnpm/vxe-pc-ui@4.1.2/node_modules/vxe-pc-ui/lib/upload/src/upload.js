"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vue = require("vue");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _ui = require("../../ui");
var _vn = require("../..//ui/src/vn");
var _log = require("../../ui/src/log");
var _dom = require("../../ui/src/dom");
var _util = require("./util");
var _button = _interopRequireDefault(require("../../button/src/button"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports.default = (0, _vue.defineComponent)({
  name: 'VxeUpload',
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    mode: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => _xeUtils.default.clone((0, _ui.getConfig)().upload.imageTypes, true)
    },
    imageStyle: {
      type: Object,
      default: () => _xeUtils.default.clone((0, _ui.getConfig)().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => _xeUtils.default.clone((0, _ui.getConfig)().upload.fileTypes, true)
    },
    singleMode: Boolean,
    urlMode: Boolean,
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => (0, _ui.getConfig)().upload.limitSize
    },
    limitCount: {
      type: [String, Number],
      default: () => (0, _ui.getConfig)().upload.limitCount
    },
    nameField: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.nameField
    },
    typeField: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.typeField
    },
    urlField: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showProgress
    },
    autoHiddenButton: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.autoHiddenButton
    },
    buttonText: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().upload.showPreview
    },
    tipText: String,
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    removeMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => (0, _ui.getConfig)().upload.size || (0, _ui.getConfig)().size
    }
  },
  emits: ['update:modelValue', 'add', 'remove', 'download', 'upload-success', 'upload-error'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeForm = (0, _vue.inject)('$xeForm', null);
    const formItemInfo = (0, _vue.inject)('xeFormItemInfo', null);
    const xID = _xeUtils.default.uniqueId();
    const {
      computeSize
    } = (0, _ui.useSize)(props);
    const refElem = (0, _vue.ref)();
    const reactData = (0, _vue.reactive)({
      isDrag: false,
      fileList: []
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0, _vue.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0, _vue.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsImage = (0, _vue.computed)(() => {
      return props.mode === 'image';
    });
    const computeNameProp = (0, _vue.computed)(() => {
      return props.nameField || 'name';
    });
    const computeTypeProp = (0, _vue.computed)(() => {
      return props.typeField || 'type';
    });
    const computeUrlProp = (0, _vue.computed)(() => {
      return props.urlField || 'url';
    });
    const computeSizeProp = (0, _vue.computed)(() => {
      return props.sizeField || 'size';
    });
    const computeLimitMaxSizeB = (0, _vue.computed)(() => {
      return _xeUtils.default.toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = (0, _vue.computed)(() => {
      return props.multiple ? _xeUtils.default.toNumber(props.limitCount) : 1;
    });
    const computeOverCount = (0, _vue.computed)(() => {
      const {
        multiple
      } = props;
      const {
        fileList
      } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = (0, _vue.computed)(() => {
      const limitSize = _xeUtils.default.toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return '';
    });
    const computedDefHintText = (0, _vue.computed)(() => {
      const {
        limitSize,
        fileTypes,
        multiple,
        limitCount
      } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (_xeUtils.default.isString(tipText)) {
        return tipText;
      }
      const defHints = [];
      if (isImage) {
        if (multiple && limitCount) {
          defHints.push((0, _ui.getI18n)('vxe.upload.imgCountHint', [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push((0, _ui.getI18n)('vxe.upload.imgSizeHint', [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defHints.push((0, _ui.getI18n)('vxe.upload.fileTypeHint', [fileTypes.join('/')]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push((0, _ui.getI18n)('vxe.upload.fileSizeHint', [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defHints.push((0, _ui.getI18n)('vxe.upload.fileCountHint', [limitCount]));
        }
      }
      return defHints.join((0, _ui.getI18n)('vxe.base.comma'));
    });
    const computeImageStyleOpts = (0, _vue.computed)(() => {
      return Object.assign({}, props.imageStyle);
    });
    const computeImgStyle = (0, _vue.computed)(() => {
      const {
        width,
        height
      } = computeImageStyleOpts.value;
      const stys = {};
      if (width) {
        stys.width = (0, _dom.toCssUnit)(width);
      }
      if (height) {
        stys.height = (0, _dom.toCssUnit)(height);
      }
      return stys;
    });
    const computeMoreOpts = (0, _vue.computed)(() => {
      return Object.assign({
        showMoreButton: true
      }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateFileList = () => {
      const {
        modelValue,
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? _xeUtils.default.isArray(modelValue) ? modelValue : [modelValue] : []).map(item => {
        if (!item || _xeUtils.default.isString(item)) {
          const url = `${item || ''}`;
          const name = parseFileName(url);
          return {
            [nameProp]: name,
            [typeProp]: parseFileType(name),
            [urlProp]: url,
            [sizeProp]: 0
          };
        }
        const name = item[nameProp] || '';
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || '';
        item[sizeProp] = item[sizeProp] || 0;
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = url => {
      return decodeURIComponent(`${url || ''}`).split('/').pop() || '';
    };
    const parseFileType = name => {
      const index = name ? name.indexOf('.') : -1;
      if (index > -1) {
        return name.substring(index + 1, name.length).toLowerCase();
      }
      return '';
    };
    const uploadMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, (0, _ui.createEvent)(evnt, {
          $upload: $xeUpload
        }, params));
      }
    };
    const emitModel = value => {
      const {
        singleMode,
        urlMode
      } = props;
      const urlProp = computeUrlProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlMode) {
        restList = restList.map(item => item[urlProp]);
      }
      emit('update:modelValue', singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = item => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || (0, _ui.getConfig)().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = item => {
      const getUrlFn = props.getUrlMethod || (0, _ui.getConfig)().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const imagePreviewTypes = ['jpg', 'jpeg', 'png', 'gif'];
    const handleDefaultFilePreview = item => {
      const {
        imageTypes,
        showDownloadButton
      } = props;
      const typeProp = computeTypeProp.value;
      // 如果是预览图片
      if (imagePreviewTypes.concat(imageTypes || []).some(type => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (_ui.VxeUI.previewImage) {
          _ui.VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || (0, _ui.getConfig)().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index) => {
      const {
        showDownloadButton
      } = props;
      const {
        fileList
      } = reactData;
      if (props.showPreview) {
        if (_ui.VxeUI.previewImage) {
          _ui.VxeUI.previewImage({
            urlList: fileList.map(item => getFileUrl(item)),
            activeIndex: index,
            showDownloadButton
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const {
        showErrorStatus
      } = props;
      const uploadFn = props.uploadMethod || (0, _ui.getConfig)().upload.uploadMethod;
      if (uploadFn && item._X_DATA) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            Object.assign(item._X_DATA || {}, {
              p: Math.max(0, Math.min(99, _xeUtils.default.toNumber(percentNum)))
            });
          }
        })).then(res => {
          Object.assign(item._X_DATA || {}, {
            l: false,
            p: 100
          });
          Object.assign(item, res);
          uploadMethods.dispatchEvent('upload-success', {
            option: item,
            data: res
          }, null);
        }).catch(res => {
          Object.assign(item._X_DATA || {}, {
            l: false,
            s: 'error'
          });
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter(obj => obj._X_DATA !== item._X_DATA);
          }
          uploadMethods.dispatchEvent('upload-error', {
            option: item,
            data: res
          }, null);
        });
      }
      return Promise.resolve();
    };
    const handleReUpload = item => {
      const {
        uploadMethod,
        urlMode
      } = props;
      const uploadFn = uploadMethod || (0, _ui.getConfig)().upload.uploadMethod;
      if (uploadFn && item._X_DATA) {
        const file = item._X_DATA.f;
        Object.assign(item._X_DATA, {
          l: true,
          s: '',
          p: 0
        });
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            emitModel(reactData.fileList);
          }
        });
      }
    };
    const uploadFile = (files, evnt) => {
      const {
        multiple,
        urlMode
      } = props;
      const {
        fileList
      } = reactData;
      const uploadFn = props.uploadMethod || (0, _ui.getConfig)().upload.uploadMethod;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSizeB = computeLimitMaxSizeB.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        // 校验文件数量
        if (fileList.length >= limitMaxCount) {
          if (_ui.VxeUI.modal) {
            _ui.VxeUI.modal.notification({
              title: (0, _ui.getI18n)('vxe.modal.errTitle'),
              status: 'error',
              content: (0, _ui.getI18n)('vxe.upload.overCountErr', [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (_ui.VxeUI.modal) {
            _ui.VxeUI.modal.notification({
              title: (0, _ui.getI18n)('vxe.modal.errTitle'),
              status: 'error',
              slots: {
                default() {
                  return (0, _vue.h)('div', {
                    class: 'vxe-upload--file-message-over-error'
                  }, [(0, _vue.h)('div', {}, (0, _ui.getI18n)('vxe.upload.overCountExtraErr', [limitMaxCount, overNum])), (0, _vue.h)('div', {
                    class: 'vxe-upload--file-message-over-extra'
                  }, overExtraList.map((file, index) => {
                    return (0, _vue.h)('div', {
                      key: index,
                      class: 'vxe-upload--file-message-over-extra-item'
                    }, file.name);
                  }))]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      // 校验文件大小
      if (limitMaxSizeB) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSizeB) {
            if (_ui.VxeUI.modal) {
              _ui.VxeUI.modal.notification({
                title: (0, _ui.getI18n)('vxe.modal.errTitle'),
                status: 'error',
                content: (0, _ui.getI18n)('vxe.upload.overSizeErr', [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach(file => {
        const {
          name
        } = file;
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: ''
        };
        if (uploadFn) {
          fileObj._X_DATA = {
            k: _xeUtils.default.uniqueId(),
            f: file,
            l: true,
            s: '',
            p: 0
          };
        }
        const item = (0, _vue.reactive)(fileObj);
        if (uploadFn) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
        uploadMethods.dispatchEvent('add', {
          option: item
        }, evnt);
      });
      reactData.fileList = newFileList;
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        emitModel(newFileList);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const clickEvent = evnt => {
      const {
        multiple,
        imageTypes,
        fileTypes
      } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return;
      }
      (0, _util.readLocalFile)({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then(({
        files
      }) => {
        uploadFile(files, evnt);
      }).catch(() => {
        // 错误文件类型
      });
    };
    const handleRemoveEvent = (evnt, item, index) => {
      const {
        fileList
      } = reactData;
      fileList.splice(index, 1);
      emitModel(fileList);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      uploadMethods.dispatchEvent('remove', {
        option: item
      }, evnt);
    };
    const removeFileEvent = (evnt, item, index) => {
      const removeFn = props.removeMethod || (0, _ui.getConfig)().upload.removeMethod;
      if (removeFn) {
        Promise.resolve(removeFn({
          $upload: $xeUpload,
          option: item
        })).then(() => {
          handleRemoveEvent(evnt, item, index);
        }).catch(e => e);
      } else {
        handleRemoveEvent(evnt, item, index);
      }
    };
    const handleDownloadEvent = (evnt, item) => {
      uploadMethods.dispatchEvent('download', {
        option: item
      }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const downloadFn = props.downloadMethod || (0, _ui.getConfig)().upload.downloadMethod;
      if (downloadFn) {
        Promise.resolve(downloadFn({
          $upload: $xeUpload,
          option: item
        })).then(() => {
          handleDownloadEvent(evnt, item);
        }).catch(e => e);
      } else {
        handleDownloadEvent(evnt, item);
      }
    };
    const handleDragleaveEvent = evnt => {
      const elem = refElem.value;
      const {
        clientX,
        clientY
      } = evnt;
      if (elem) {
        const {
          x: targetX,
          y: targetY,
          height: targetHeight,
          width: targetWidth
        } = elem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDrag = false;
        }
      }
    };
    const handleDragoverEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDrag = true;
        }
      }
    };
    const handleDropEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          const files = [];
          Array.from(items).forEach(item => {
            const file = item.getAsFile();
            if (file) {
              files.push(file);
            }
          });
          uploadFile(files, evnt);
          evnt.preventDefault();
        }
      }
      reactData.isDrag = false;
    };
    const handleMoreEvent = () => {
      const isImage = computeIsImage.value;
      _ui.VxeUI.modal.open({
        title: '查看列表',
        width: 660,
        height: 500,
        escClosable: true,
        showMaximize: true,
        resize: true,
        maskClosable: true,
        slots: {
          default() {
            const {
              fileList
            } = reactData;
            if (isImage) {
              return (0, _vue.h)('div', {
                class: 'vxe-upload--image-more-list'
              }, renderImageItemList(fileList, true));
            }
            return (0, _vue.h)('div', {
              class: 'vxe-upload--file-more-list'
            }, renderFileItemList(fileList));
          }
        }
      });
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = currList => {
      const {
        showRemoveButton,
        showDownloadButton,
        showProgress,
        showPreview,
        showErrorStatus
      } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      return currList.map((item, index) => {
        const isLoading = item._X_DATA && item._X_DATA.l;
        const isError = item._X_DATA && item._X_DATA.s === 'error';
        return (0, _vue.h)('div', {
          key: index,
          class: ['vxe-upload--file-item', {
            'is--preview': showPreview,
            'is--loading': isLoading,
            'is--error': isError
          }]
        }, [(0, _vue.h)('div', {
          class: 'vxe-upload--file-item-icon'
        }, [(0, _vue.h)('i', {
          class: (0, _ui.getIcon)()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || (0, _ui.getIcon)().UPLOAD_FILE_TYPE_DEFAULT
        })]), (0, _vue.h)('div', {
          class: 'vxe-upload--file-item-name',
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewFileEvent(evnt, item);
            }
          }
        }, `${item[nameProp] || ''}`), isLoading ? (0, _vue.h)('div', {
          class: 'vxe-upload--file-item-loading-icon'
        }, [(0, _vue.h)('i', {
          class: (0, _ui.getIcon)().UPLOAD_LOADING
        })]) : (0, _vue.createCommentVNode)(), showProgress && isLoading && item._X_DATA ? (0, _vue.h)('div', {
          class: 'vxe-upload--file-item-loading-text'
        }, (0, _ui.getI18n)('vxe.upload.uploadProgress', [item._X_DATA.p])) : (0, _vue.createCommentVNode)(), showErrorStatus && isError ? (0, _vue.h)('div', {
          class: 'vxe-upload--image-item-error'
        }, [(0, _vue.h)(_button.default, {
          icon: (0, _ui.getIcon)().UPLOAD_IMAGE_RE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: (0, _ui.getI18n)('vxe.upload.reUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : (0, _vue.createCommentVNode)(), showDownloadButton && !isLoading ? (0, _vue.h)('div', {
          class: 'vxe-upload--file-item-download-icon',
          onClick(evnt) {
            downloadFileEvent(evnt, item);
          }
        }, [(0, _vue.h)('i', {
          class: (0, _ui.getIcon)().UPLOAD_FILE_DOWNLOAD
        })]) : (0, _vue.createCommentVNode)(), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0, _vue.h)('div', {
          class: 'vxe-upload--file-item-remove-icon',
          onClick(evnt) {
            removeFileEvent(evnt, item, index);
          }
        }, [(0, _vue.h)('i', {
          class: (0, _ui.getIcon)().UPLOAD_FILE_REMOVE
        })]) : (0, _vue.createCommentVNode)()]);
      });
    };
    const renderAllMode = () => {
      const {
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const {
        fileList
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const moreOpts = computeMoreOpts.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      const {
        maxCount,
        showMoreButton,
        layout
      } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (formReadonly && maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0, _vue.h)('div', {
        key: 'all',
        class: 'vxe-upload--file-wrapper'
      }, [formReadonly ? (0, _vue.createCommentVNode)() : (0, _vue.h)('div', {
        class: 'vxe-upload--file-action'
      }, [autoHiddenButton && overCount ? (0, _vue.createCommentVNode)() : (0, _vue.h)('div', {
        class: 'vxe-upload--file-action-btn',
        onClick: clickEvent
      }, defaultSlot ? (0, _vn.getSlotVNs)(defaultSlot({
        $upload: $xeUpload
      })) : [(0, _vue.h)(_button.default, {
        content: showButtonText ? buttonText ? `${buttonText}` : (0, _ui.getI18n)('vxe.upload.fileBtnText') : '',
        icon: showButtonIcon ? buttonIcon || (0, _ui.getIcon)().UPLOAD_FILE_ADD : '',
        disabled: isDisabled
      })]), defHintText || tipSlot ? (0, _vue.h)('div', {
        class: 'vxe-upload--file-action-tip'
      }, tipSlot ? (0, _vn.getSlotVNs)(tipSlot({
        $upload: $xeUpload
      })) : defHintText) : (0, _vue.createCommentVNode)()]), currList.length ? (0, _vue.h)('div', {
        class: ['vxe-upload--file-list-wrapper', {
          'is--horizontal': layout === 'horizontal'
        }]
      }, [(0, _vue.h)('div', {
        class: 'vxe-upload--file-list'
      }, renderFileItemList(currList)), formReadonly && showMoreButton && overMaxNum ? (0, _vue.h)('div', {
        class: 'vxe-upload--file-over-more'
      }, [(0, _vue.h)(_button.default, {
        mode: 'text',
        content: (0, _ui.getI18n)('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : (0, _vue.createCommentVNode)()]) : (0, _vue.createCommentVNode)()]);
    };
    const renderImageItemList = (currList, isPreview) => {
      const {
        showRemoveButton,
        showProgress,
        showPreview,
        showErrorStatus
      } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imgStyle = computeImgStyle.value;
      return currList.map((item, index) => {
        const isLoading = item._X_DATA && item._X_DATA.l;
        const isError = item._X_DATA && item._X_DATA.s === 'error';
        return (0, _vue.h)('div', {
          key: index,
          class: ['vxe-upload--image-item', {
            'is--preview': showPreview,
            'is--loading': isLoading,
            'is--error': isError
          }]
        }, [(0, _vue.h)('div', {
          class: 'vxe-upload--image-item-box',
          style: isPreview ? null : imgStyle,
          title: (0, _ui.getI18n)('vxe.upload.viewItemTitle'),
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewImageEvent(evnt, item, index);
            }
          }
        }, [isLoading && item._X_DATA ? (0, _vue.h)('div', {
          class: 'vxe-upload--image-item-loading'
        }, [(0, _vue.h)('div', {
          class: 'vxe-upload--image-item-loading-icon'
        }, [(0, _vue.h)('i', {
          class: (0, _ui.getIcon)().UPLOAD_LOADING
        })]), showProgress ? (0, _vue.h)('div', {
          class: 'vxe-upload--image-item-loading-text'
        }, (0, _ui.getI18n)('vxe.upload.uploadProgress', [item._X_DATA.p])) : (0, _vue.createCommentVNode)()]) : (0, _vue.createCommentVNode)(), !isLoading ? isError && showErrorStatus ? (0, _vue.h)('div', {
          class: 'vxe-upload--image-item-error'
        }, [(0, _vue.h)(_button.default, {
          icon: (0, _ui.getIcon)().UPLOAD_IMAGE_RE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: (0, _ui.getI18n)('vxe.upload.reUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : (0, _vue.h)('img', {
          class: 'vxe-upload--image-item-img',
          src: getThumbnailFileUrl(item)
        }) : (0, _vue.createCommentVNode)(), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0, _vue.h)('div', {
          class: 'vxe-upload--image-item-remove-icon',
          onClick(evnt) {
            evnt.stopPropagation();
            removeFileEvent(evnt, item, index);
          }
        }, [(0, _vue.h)('i', {
          class: (0, _ui.getIcon)().UPLOAD_IMAGE_REMOVE
        })]) : (0, _vue.createCommentVNode)()])]);
      });
    };
    const renderImageMode = () => {
      const {
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const {
        fileList
      } = reactData;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const moreOpts = computeMoreOpts.value;
      const defaultSlot = slots.default;
      const hintSlot = slots.hint;
      const {
        maxCount,
        showMoreButton
      } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (formReadonly && maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0, _vue.h)('div', {
        key: 'image',
        class: 'vxe-upload--image-wrapper'
      }, [(0, _vue.h)('div', {
        class: 'vxe-upload--image-list'
      }, renderImageItemList(currList, false).concat([formReadonly && showMoreButton && overMaxNum ? (0, _vue.h)('div', {
        class: 'vxe-upload--image-over-more'
      }, [(0, _vue.h)(_button.default, {
        mode: 'text',
        content: (0, _ui.getI18n)('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : (0, _vue.createCommentVNode)(), formReadonly || autoHiddenButton && overCount ? (0, _vue.createCommentVNode)() : (0, _vue.h)('div', {
        class: 'vxe-upload--image-action'
      }, [(0, _vue.h)('div', {
        class: 'vxe-upload--image-action-btn',
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({
        $upload: $xeUpload
      }) : [(0, _vue.h)('div', {
        class: 'vxe-upload--image-action-box',
        style: imgStyle
      }, [showButtonIcon ? (0, _vue.h)('div', {
        class: 'vxe-upload--image-action-icon'
      }, [(0, _vue.h)('i', {
        class: buttonIcon || (0, _ui.getIcon)().UPLOAD_IMAGE_ADD
      })]) : (0, _vue.createCommentVNode)(), showButtonText ? (0, _vue.h)('div', {
        class: 'vxe-upload--image-action-content'
      }, buttonText ? `${buttonText}` : (0, _ui.getI18n)('vxe.upload.imgBtnText')) : (0, _vue.createCommentVNode)(), defHintText || hintSlot ? (0, _vue.h)('div', {
        class: 'vxe-upload--image-action-hint'
      }, hintSlot ? (0, _vn.getSlotVNs)(hintSlot({
        $upload: $xeUpload
      })) : defHintText) : (0, _vue.createCommentVNode)()])])])]))]);
    };
    const renderVN = () => {
      const {
        showErrorStatus
      } = props;
      const {
        isDrag
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      return (0, _vue.h)('div', {
        ref: refElem,
        class: ['vxe-upload', {
          [`size--${vSize}`]: vSize,
          'is--readonly': formReadonly,
          'is--disabled': isDisabled,
          'show--error': showErrorStatus,
          'is--drag': isDrag
        }],
        onDragover: handleDragoverEvent,
        onDragleave: handleDragleaveEvent,
        onDrop: handleDropEvent
      }, [isImage ? renderImageMode() : renderAllMode(), isDrag ? (0, _vue.h)('div', {
        class: 'vxe-upload--drag-placeholder'
      }, (0, _ui.getI18n)('vxe.upload.dragPlaceholder')) : (0, _vue.createCommentVNode)()]);
    };
    $xeUpload.renderVN = renderVN;
    const listFlag = (0, _vue.ref)(0);
    (0, _vue.watch)(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    (0, _vue.watch)(() => props.modelValue, () => {
      listFlag.value++;
    });
    (0, _vue.watch)(listFlag, () => {
      updateFileList();
    });
    (0, _vue.onMounted)(() => {
      if (process.env.NODE_ENV === 'development') {
        if (props.multiple && props.singleMode) {
          (0, _log.errLog)('vxe.error.errConflicts', ['multiple', 'single-mode']);
        }
      }
    });
    (0, _vue.onUnmounted)(() => {
      reactData.isDrag = false;
    });
    updateFileList();
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
});