"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vue = require("vue");
var _ui = require("../../ui");
var _vn = require("../../ui/src/vn");
var _dom = require("../..//ui/src/dom");
var _log = require("../../ui/src/log");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports.default = (0, _vue.defineComponent)({
  name: 'VxeTabs',
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    beforeCloseMethod: Function
  },
  emits: ['update:modelValue', 'change', 'tab-change-fail', 'tab-close', 'tab-close-fail', 'tab-click', 'tab-load'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = _xeUtils.default.uniqueId();
    const $xeParentTabs = (0, _vue.inject)('$xeTabs', null);
    const refElem = (0, _vue.ref)();
    const refHeadWrapperElem = (0, _vue.ref)();
    const reactData = (0, _vue.reactive)({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: false,
      resizeFlag: 1
    });
    const refMaps = {
      refElem
    };
    const handleFilterTab = item => {
      const {
        permissionCode
      } = item;
      if (permissionCode) {
        if (!_ui.permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const computeTabOptions = (0, _vue.computed)(() => {
      const {
        options
      } = props;
      return (options || []).filter(handleFilterTab);
    });
    const computeTabStaticOptions = (0, _vue.computed)(() => {
      const {
        staticTabs
      } = reactData;
      return staticTabs.filter(handleFilterTab);
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (_xeUtils.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (_xeUtils.default.isFunction(slotFunc)) {
          return (0, _vn.getSlotVNs)(slotFunc(params));
        }
      }
      return [];
    };
    const updateTabStyle = () => {
      (0, _vue.nextTick)(() => {
        const {
          type
        } = props;
        const {
          activeName
        } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        let lintWidth = 0;
        let lintLeft = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index = _xeUtils.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === activeName);
          const {
            children,
            scrollWidth,
            clientWidth
          } = headerWrapperEl;
          isOver = scrollWidth !== clientWidth;
          if (index > -1) {
            const tabEl = children[index];
            const tabWidth = tabEl.clientWidth;
            if (type) {
              if (type === 'card') {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft;
              } else if (type === 'border-card') {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft - 1;
              }
            } else {
              lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
              lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
            }
          }
        }
        reactData.lintLeft = lintLeft;
        reactData.lintWidth = lintWidth;
        reactData.isTabOver = isOver;
      });
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, (0, _ui.createEvent)(evnt, {
        $tabs: $xeTabs
      }, params));
    };
    const addInitName = (name, evnt) => {
      const {
        initNames
      } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent('tab-load', {
          name
        }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = list => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach(item => {
          if (activeName === item.name) {
            validVal = true;
          }
          if (item && item.preload) {
            addInitName(item.name, null);
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emit('update:modelValue', activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const clickEvent = (evnt, item) => {
      const {
        trigger
      } = props;
      const beforeMethod = props.beforeChangeMethod || (0, _ui.getConfig)().tabs.beforeChangeMethod;
      const {
        activeName
      } = reactData;
      const {
        name
      } = item;
      if (trigger === 'manual') {
        dispatchEvent('tab-click', {
          name
        }, evnt);
        return;
      }
      const value = name;
      reactData.activeName = name;
      emit('update:modelValue', value);
      dispatchEvent('tab-click', {
        name
      }, evnt);
      addInitName(name, evnt);
      if (name !== activeName) {
        if (!beforeMethod || beforeMethod({
          $tabs: $xeTabs,
          name,
          oldName: activeName,
          newName: name
        })) {
          dispatchEvent('change', {
            value,
            name,
            oldName: activeName,
            newName: name
          }, evnt);
        } else {
          dispatchEvent('tab-change-fail', {
            value,
            name,
            oldName: activeName,
            newName: name
          }, evnt);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index, list) => {
      evnt.stopPropagation();
      const {
        activeName
      } = reactData;
      const beforeMethod = props.beforeCloseMethod || (0, _ui.getConfig)().tabs.beforeCloseMethod;
      const {
        name
      } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      if (!beforeMethod || beforeMethod({
        $tabs: $xeTabs,
        value,
        name,
        nextName
      })) {
        dispatchEvent('tab-close', {
          value,
          name,
          nextName
        }, evnt);
      } else {
        dispatchEvent('tab-close-fail', {
          value,
          name,
          nextName
        }, evnt);
      }
    };
    let scrollTimeout = null;
    const startScrollAnimation = (offsetPos, offsetSize) => {
      let offsetLeft = offsetSize;
      let scrollCount = 6;
      let delayNum = 35;
      clearTimeout(scrollTimeout);
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const {
              clientWidth,
              scrollWidth,
              scrollLeft
            } = headerWrapperEl;
            offsetLeft = Math.floor(offsetLeft / 2);
            if (offsetPos > 0) {
              if (clientWidth + scrollLeft < scrollWidth) {
                headerWrapperEl.scrollLeft += offsetLeft;
                delayNum -= 4;
                scrollTimeout = setTimeout(scrollAnimate, delayNum);
              }
            } else {
              if (scrollLeft > 0) {
                headerWrapperEl.scrollLeft -= offsetLeft;
                delayNum -= 4;
                scrollTimeout = setTimeout(scrollAnimate, delayNum);
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = offsetPos => {
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const offsetSize = Math.floor(headerWrapperEl.clientWidth * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = name => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      return (0, _vue.nextTick)().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index = _xeUtils.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === name);
          if (index > -1) {
            const {
              scrollLeft,
              clientWidth,
              children
            } = headerWrapperEl;
            const tabEl = children[index];
            if (tabEl) {
              const tabOffsetLeft = tabEl.offsetLeft;
              const tabClientWidth = tabEl.clientWidth;
              // 如果右侧被挡
              const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
              if (overSize > 0) {
                headerWrapperEl.scrollLeft += overSize;
              }
              // 如果左侧被挡，优先
              if (tabOffsetLeft < scrollLeft) {
                headerWrapperEl.scrollLeft = tabOffsetLeft;
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const createHandlePrevNext = isNext => {
      return () => {
        const {
          activeName
        } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
        const index = _xeUtils.default.findIndexOf(list, item => item.name === activeName);
        if (index > -1) {
          let item = null;
          if (isNext) {
            if (index < list.length - 1) {
              item = list[index + 1];
            }
          } else {
            if (index > 0) {
              item = list[index - 1];
            }
          }
          if (item) {
            const name = item.name;
            const value = name;
            reactData.activeName = name;
            emit('update:modelValue', value);
            addInitName(name, null);
          }
        }
        return (0, _vue.nextTick)();
      };
    };
    const tabsMethods = {
      dispatchEvent,
      scrollToTab,
      prev: createHandlePrevNext(false),
      next: createHandlePrevNext(true),
      prevTab() {
        (0, _log.warnLog)('vxe.error.delFunc', ['prevTab', 'prev']);
        return tabsMethods.prev();
      },
      nextTab() {
        (0, _log.warnLog)('vxe.error.delFunc', ['nextTab', 'next']);
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = tabList => {
      const {
        type,
        titleWidth: allTitleWidth,
        titleAlign: allTitleAlign,
        showClose
      } = props;
      const {
        activeName,
        lintLeft,
        lintWidth,
        isTabOver
      } = reactData;
      const extraSlot = slots.extra;
      return (0, _vue.h)('div', {
        class: 'vxe-tabs-header'
      }, [isTabOver ? (0, _vue.h)('div', {
        class: 'vxe-tabs-header--bar vxe-tabs-header--left-bar',
        onClick: scrollLeftEvent
      }, [(0, _vue.h)('span', {
        class: (0, _ui.getIcon)().TABS_TAB_BUTTON_LEFT
      })]) : (0, _vue.createCommentVNode)(), (0, _vue.h)('div', {
        class: 'vxe-tabs-header--wrapper'
      }, [(0, _vue.h)('div', {
        ref: refHeadWrapperElem,
        class: 'vxe-tabs-header--item-wrapper'
      }, tabList.map((item, index) => {
        const {
          title,
          titleWidth,
          titleAlign,
          icon,
          name,
          slots
        } = item;
        const tabSlot = slots ? slots.tab : null;
        const itemWidth = titleWidth || allTitleWidth;
        const itemAlign = titleAlign || allTitleAlign;
        return (0, _vue.h)('div', {
          key: `${name}`,
          class: ['vxe-tabs-header--item', itemAlign ? `align--${itemAlign}` : '', {
            'is--active': activeName === name
          }],
          style: itemWidth ? {
            width: (0, _dom.toCssUnit)(itemWidth)
          } : null,
          onClick(evnt) {
            clickEvent(evnt, item);
          }
        }, [(0, _vue.h)('div', {
          class: 'vxe-tabs-header--item-inner'
        }, [(0, _vue.h)('div', {
          class: 'vxe-tabs-header--item-content'
        }, [icon ? (0, _vue.h)('span', {
          class: 'vxe-tabs-header--item-icon'
        }, [(0, _vue.h)('i', {
          class: icon
        })]) : (0, _vue.createCommentVNode)(), (0, _vue.h)('span', {
          class: 'vxe-tabs-header--item-name'
        }, tabSlot ? callSlot(tabSlot, {
          name,
          title
        }) : `${title}`)]), showClose ? (0, _vue.h)('div', {
          class: 'vxe-tabs-header--close-btn',
          onClick(evnt) {
            handleCloseTabEvent(evnt, item, index, tabList);
          }
        }, [(0, _vue.h)('i', {
          class: (0, _ui.getIcon)().TABS_TAB_CLOSE
        })]) : (0, _vue.createCommentVNode)()])]);
      }).concat([(0, _vue.h)('span', {
        key: 'line',
        class: `vxe-tabs-header--active-line type--${type || 'default'}`,
        style: {
          left: `${lintLeft}px`,
          width: `${lintWidth}px`
        }
      })]))]), isTabOver ? (0, _vue.h)('div', {
        class: 'vxe-tabs-header--bar vxe-tabs-header--right-bar',
        onClick: scrollRightEvent
      }, [(0, _vue.h)('span', {
        class: (0, _ui.getIcon)().TABS_TAB_BUTTON_RIGHT
      })]) : (0, _vue.createCommentVNode)(), extraSlot ? (0, _vue.h)('div', {
        class: 'vxe-tabs-header--extra'
      }, (0, _vn.getSlotVNs)(extraSlot({}))) : (0, _vue.createCommentVNode)()]);
    };
    const renderTabPane = item => {
      const {
        initNames,
        activeName
      } = reactData;
      const {
        name,
        slots
      } = item;
      const defaultSlot = slots ? slots.default : null;
      return name && initNames.includes(name) ? (0, _vue.h)('div', {
        key: name,
        class: ['vxe-tabs-pane--item', {
          'is--visible': activeName === name,
          'has--content': !!defaultSlot
        }]
      }, defaultSlot ? callSlot(defaultSlot, {
        name
      }) : []) : (0, _vue.createCommentVNode)();
    };
    const renderTabContent = tabList => {
      const {
        destroyOnClose
      } = props;
      const {
        activeName
      } = reactData;
      const activeDefaultTab = tabList.find(item => item.name === activeName);
      if (destroyOnClose) {
        return activeDefaultTab ? [renderTabPane(activeDefaultTab)] : (0, _vue.createCommentVNode)();
      }
      return tabList.map(renderTabPane);
    };
    const renderVN = () => {
      const {
        type,
        height,
        padding,
        trigger
      } = props;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const defaultSlot = slots.default;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      return (0, _vue.h)('div', {
        ref: refElem,
        class: ['vxe-tabs', `vxe-tabs--${type || 'default'}`, `trigger--${trigger === 'manual' ? 'trigger' : 'default'}`, {
          'is--padding': padding,
          'is--height': height
        }],
        style: height ? {
          height: (0, _dom.toCssUnit)(height)
        } : null
      }, [(0, _vue.h)('div', {
        class: 'vxe-tabs-slots'
      }, defaultSlot ? defaultSlot({}) : []), renderTabHeader(tabList), (0, _vue.h)('div', {
        class: 'vxe-tabs-pane'
      }, renderTabContent(tabList))]);
    };
    (0, _vue.watch)(() => props.modelValue, val => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    (0, _vue.watch)(() => reactData.activeName, val => {
      scrollToTab(val);
      (0, _vue.nextTick)(() => {
        reactData.resizeFlag++;
      });
    });
    const optsFlag = (0, _vue.ref)(0);
    (0, _vue.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0, _vue.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0, _vue.watch)(optsFlag, () => {
      initDefaultName(props.options);
      updateTabStyle();
    });
    const stFlag = (0, _vue.ref)(0);
    (0, _vue.watch)(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    (0, _vue.watch)(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    (0, _vue.watch)(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      updateTabStyle();
    });
    if ($xeParentTabs) {
      (0, _vue.watch)(() => $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null, () => {
        reactData.resizeFlag++;
      });
    }
    (0, _vue.watch)(() => reactData.resizeFlag, () => {
      (0, _vue.nextTick)(updateTabStyle);
    });
    (0, _vue.nextTick)(() => {
      _ui.globalEvents.on($xeTabs, 'resize', updateTabStyle);
    });
    (0, _vue.onMounted)(() => {
      updateTabStyle();
    });
    (0, _vue.onUnmounted)(() => {
      _ui.globalEvents.off($xeTabs, 'resize');
    });
    $xeTabs.renderVN = renderVN;
    (0, _vue.provide)('$xeTabs', $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
});