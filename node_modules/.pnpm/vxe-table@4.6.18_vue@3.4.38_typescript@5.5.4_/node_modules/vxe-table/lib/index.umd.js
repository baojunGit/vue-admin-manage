(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("xe-utils"));
	else if(typeof define === 'function' && define.amd)
		define([, "xe-utils"], factory);
	else if(typeof exports === 'object')
		exports["VXETable"] = factory(require("vue"), require("xe-utils"));
	else
		root["VXETable"] = factory(root["Vue"], root["XEUtils"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__9274__, __WEBPACK_EXTERNAL_MODULE__8871__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9274:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9274__;

/***/ }),

/***/ 8871:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8871__;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 6955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(2140);
var isCallable = __webpack_require__(4901);
var classofRaw = __webpack_require__(4576);
var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2106:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var makeBuiltIn = __webpack_require__(283);
var defineProperty = __webpack_require__(4913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 9392:
/***/ (function(module) {


module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ 7388:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var userAgent = __webpack_require__(9392);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 8727:
/***/ (function(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = global[TARGET] && global[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 4475:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(4576);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(8622);
var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(4576);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6395:
/***/ (function(module) {


module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4475);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.37.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(7388);
var fails = __webpack_require__(9039);
var global = __webpack_require__(4475);

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 655:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(6955);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 6823:
/***/ (function(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 2812:
/***/ (function(module) {


var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 4603:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var append = uncurryThis(URLSearchParamsPrototype.append);
var $delete = uncurryThis(URLSearchParamsPrototype['delete']);
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
var push = uncurryThis([].push);
var params = new $URLSearchParams('a=1&a=2&b=3');

params['delete']('a', 1);
// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
params['delete']('b', undefined);

if (params + '' !== 'a=2') {
  defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $delete(this, name);
    var entries = [];
    forEach(this, function (v, k) { // also validates `this`
      push(entries, { key: k, value: v });
    });
    validateArgumentsLength(length, 1);
    var key = toString(name);
    var value = toString($value);
    var index = 0;
    var dindex = 0;
    var found = false;
    var entriesLength = entries.length;
    var entry;
    while (index < entriesLength) {
      entry = entries[index++];
      if (found || entry.key === key) {
        found = true;
        $delete(this, entry.key);
      } else dindex++;
    }
    while (dindex < entriesLength) {
      entry = entries[dindex++];
      if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
    }
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 7566:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
var $has = uncurryThis(URLSearchParamsPrototype.has);
var params = new $URLSearchParams('a=1');

// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
if (params.has('a', 2) || !params.has('a', undefined)) {
  defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $has(this, name);
    var values = getAll(this, name); // also validates `this`
    validateArgumentsLength(length, 1);
    var value = toString($value);
    var index = 0;
    while (index < values.length) {
      if (values[index++] === value) return true;
    } return false;
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 8721:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var uncurryThis = __webpack_require__(9504);
var defineBuiltInAccessor = __webpack_require__(2106);

var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
    get: function size() {
      var count = 0;
      forEach(this, function () { count++; });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Button: function() { return /* reexport */ Button; },
  ButtonGroup: function() { return /* reexport */ ButtonGroup; },
  Checkbox: function() { return /* reexport */ Checkbox; },
  CheckboxGroup: function() { return /* reexport */ CheckboxGroup; },
  Colgroup: function() { return /* reexport */ Colgroup; },
  Column: function() { return /* reexport */ Column; },
  Custom: function() { return /* reexport */ Custom; },
  Drawer: function() { return /* reexport */ Drawer; },
  Edit: function() { return /* reexport */ Edit; },
  Export: function() { return /* reexport */ Export; },
  Filter: function() { return /* reexport */ Filter; },
  Form: function() { return /* reexport */ Form; },
  FormGather: function() { return /* reexport */ FormGather; },
  FormItem: function() { return /* reexport */ FormItem; },
  Grid: function() { return /* reexport */ Grid; },
  Icon: function() { return /* reexport */ Icon; },
  Input: function() { return /* reexport */ Input; },
  Keyboard: function() { return /* reexport */ Keyboard; },
  List: function() { return /* reexport */ List; },
  Menu: function() { return /* reexport */ Menu; },
  Modal: function() { return /* reexport */ Modal; },
  Optgroup: function() { return /* reexport */ Optgroup; },
  Option: function() { return /* reexport */ Option; },
  Pager: function() { return /* reexport */ Pager; },
  Pulldown: function() { return /* reexport */ Pulldown; },
  Radio: function() { return /* reexport */ Radio; },
  RadioButton: function() { return /* reexport */ RadioButton; },
  RadioGroup: function() { return /* reexport */ RadioGroup; },
  Select: function() { return /* reexport */ Select; },
  Switch: function() { return /* reexport */ Switch; },
  Table: function() { return /* reexport */ Table; },
  Textarea: function() { return /* reexport */ Textarea; },
  Toolbar: function() { return /* reexport */ Toolbar; },
  Tooltip: function() { return /* reexport */ Tooltip; },
  VXETable: function() { return /* reexport */ VXETable; },
  Validator: function() { return /* reexport */ Validator; },
  VxeButton: function() { return /* reexport */ VxeButton; },
  VxeButtonGroup: function() { return /* reexport */ VxeButtonGroup; },
  VxeCheckbox: function() { return /* reexport */ VxeCheckbox; },
  VxeCheckboxGroup: function() { return /* reexport */ VxeCheckboxGroup; },
  VxeColgroup: function() { return /* reexport */ VxeColgroup; },
  VxeColumn: function() { return /* reexport */ VxeColumn; },
  VxeDrawer: function() { return /* reexport */ VxeDrawer; },
  VxeForm: function() { return /* reexport */ VxeForm; },
  VxeFormGather: function() { return /* reexport */ VxeFormGather; },
  VxeFormItem: function() { return /* reexport */ VxeFormItem; },
  VxeGrid: function() { return /* reexport */ VxeGrid; },
  VxeIcon: function() { return /* reexport */ VxeIcon; },
  VxeInput: function() { return /* reexport */ VxeInput; },
  VxeList: function() { return /* reexport */ VxeList; },
  VxeModal: function() { return /* reexport */ VxeModal; },
  VxeOptgroup: function() { return /* reexport */ VxeOptgroup; },
  VxeOption: function() { return /* reexport */ VxeOption; },
  VxePager: function() { return /* reexport */ VxePager; },
  VxePulldown: function() { return /* reexport */ VxePulldown; },
  VxeRadio: function() { return /* reexport */ VxeRadio; },
  VxeRadioButton: function() { return /* reexport */ VxeRadioButton; },
  VxeRadioGroup: function() { return /* reexport */ VxeRadioGroup; },
  VxeSelect: function() { return /* reexport */ VxeSelect; },
  VxeSwitch: function() { return /* reexport */ VxeSwitch; },
  VxeTable: function() { return /* reexport */ VxeTable; },
  VxeTableCustomModule: function() { return /* reexport */ VxeTableCustomModule; },
  VxeTableEditModule: function() { return /* reexport */ VxeTableEditModule; },
  VxeTableExportModule: function() { return /* reexport */ VxeTableExportModule; },
  VxeTableFilterModule: function() { return /* reexport */ VxeTableFilterModule; },
  VxeTableKeyboardModule: function() { return /* reexport */ VxeTableKeyboardModule; },
  VxeTableMenuModule: function() { return /* reexport */ VxeTableMenuModule; },
  VxeTableValidatorModule: function() { return /* reexport */ VxeTableValidatorModule; },
  VxeTextarea: function() { return /* reexport */ VxeTextarea; },
  VxeToolbar: function() { return /* reexport */ VxeToolbar; },
  VxeTooltip: function() { return /* reexport */ VxeTooltip; },
  VxeUI: function() { return /* reexport */ VxeUI; },
  _t: function() { return /* reexport */ _t; },
  commands: function() { return /* reexport */ commands; },
  component: function() { return /* reexport */ component; },
  config: function() { return /* reexport */ config; },
  "default": function() { return /* binding */ entry_lib; },
  drawer: function() { return /* reexport */ drawer; },
  formats: function() { return /* reexport */ formats; },
  getComponent: function() { return /* reexport */ getComponent; },
  globalConfs: function() { return /* reexport */ globalConfs; },
  globalStore: function() { return /* reexport */ globalStore; },
  hooks: function() { return /* reexport */ hooks; },
  install: function() { return /* reexport */ install; },
  interceptor: function() { return /* reexport */ interceptor; },
  menus: function() { return /* reexport */ menus; },
  modal: function() { return /* reexport */ modal_modal; },
  print: function() { return /* reexport */ print; },
  readFile: function() { return /* reexport */ readLocalFile; },
  renderer: function() { return /* reexport */ renderer; },
  saveFile: function() { return /* reexport */ saveLocalFile; },
  setConfig: function() { return /* reexport */ setConfig; },
  setIcon: function() { return /* reexport */ setIcon; },
  setup: function() { return /* reexport */ setup; },
  t: function() { return /* reexport */ t; },
  tableVersion: function() { return /* reexport */ tableVersion; },
  use: function() { return /* reexport */ use; },
  v: function() { return /* reexport */ v; },
  validators: function() { return /* reexport */ validators; },
  version: function() { return /* reexport */ version; }
});

// NAMESPACE OBJECT: ./packages/all.ts
var all_namespaceObject = {};
__webpack_require__.r(all_namespaceObject);
__webpack_require__.d(all_namespaceObject, {
  Button: function() { return Button; },
  ButtonGroup: function() { return ButtonGroup; },
  Checkbox: function() { return Checkbox; },
  CheckboxGroup: function() { return CheckboxGroup; },
  Colgroup: function() { return Colgroup; },
  Column: function() { return Column; },
  Custom: function() { return Custom; },
  Drawer: function() { return Drawer; },
  Edit: function() { return Edit; },
  Export: function() { return Export; },
  Filter: function() { return Filter; },
  Form: function() { return Form; },
  FormGather: function() { return FormGather; },
  FormItem: function() { return FormItem; },
  Grid: function() { return Grid; },
  Icon: function() { return Icon; },
  Input: function() { return Input; },
  Keyboard: function() { return Keyboard; },
  List: function() { return List; },
  Menu: function() { return Menu; },
  Modal: function() { return Modal; },
  Optgroup: function() { return Optgroup; },
  Option: function() { return Option; },
  Pager: function() { return Pager; },
  Pulldown: function() { return Pulldown; },
  Radio: function() { return Radio; },
  RadioButton: function() { return RadioButton; },
  RadioGroup: function() { return RadioGroup; },
  Select: function() { return Select; },
  Switch: function() { return Switch; },
  Table: function() { return Table; },
  Textarea: function() { return Textarea; },
  Toolbar: function() { return Toolbar; },
  Tooltip: function() { return Tooltip; },
  VXETable: function() { return VXETable; },
  Validator: function() { return Validator; },
  VxeButton: function() { return VxeButton; },
  VxeButtonGroup: function() { return VxeButtonGroup; },
  VxeCheckbox: function() { return VxeCheckbox; },
  VxeCheckboxGroup: function() { return VxeCheckboxGroup; },
  VxeColgroup: function() { return VxeColgroup; },
  VxeColumn: function() { return VxeColumn; },
  VxeDrawer: function() { return VxeDrawer; },
  VxeForm: function() { return VxeForm; },
  VxeFormGather: function() { return VxeFormGather; },
  VxeFormItem: function() { return VxeFormItem; },
  VxeGrid: function() { return VxeGrid; },
  VxeIcon: function() { return VxeIcon; },
  VxeInput: function() { return VxeInput; },
  VxeList: function() { return VxeList; },
  VxeModal: function() { return VxeModal; },
  VxeOptgroup: function() { return VxeOptgroup; },
  VxeOption: function() { return VxeOption; },
  VxePager: function() { return VxePager; },
  VxePulldown: function() { return VxePulldown; },
  VxeRadio: function() { return VxeRadio; },
  VxeRadioButton: function() { return VxeRadioButton; },
  VxeRadioGroup: function() { return VxeRadioGroup; },
  VxeSelect: function() { return VxeSelect; },
  VxeSwitch: function() { return VxeSwitch; },
  VxeTable: function() { return VxeTable; },
  VxeTableCustomModule: function() { return VxeTableCustomModule; },
  VxeTableEditModule: function() { return VxeTableEditModule; },
  VxeTableExportModule: function() { return VxeTableExportModule; },
  VxeTableFilterModule: function() { return VxeTableFilterModule; },
  VxeTableKeyboardModule: function() { return VxeTableKeyboardModule; },
  VxeTableMenuModule: function() { return VxeTableMenuModule; },
  VxeTableValidatorModule: function() { return VxeTableValidatorModule; },
  VxeTextarea: function() { return VxeTextarea; },
  VxeToolbar: function() { return VxeToolbar; },
  VxeTooltip: function() { return VxeTooltip; },
  VxeUI: function() { return VxeUI; },
  _t: function() { return _t; },
  commands: function() { return commands; },
  component: function() { return component; },
  config: function() { return config; },
  drawer: function() { return drawer; },
  formats: function() { return formats; },
  getComponent: function() { return getComponent; },
  globalConfs: function() { return globalConfs; },
  globalStore: function() { return globalStore; },
  hooks: function() { return hooks; },
  install: function() { return install; },
  interceptor: function() { return interceptor; },
  menus: function() { return menus; },
  modal: function() { return modal_modal; },
  print: function() { return print; },
  readFile: function() { return readLocalFile; },
  renderer: function() { return renderer; },
  saveFile: function() { return saveLocalFile; },
  setConfig: function() { return setConfig; },
  setIcon: function() { return setIcon; },
  setup: function() { return setup; },
  t: function() { return t; },
  tableVersion: function() { return tableVersion; },
  use: function() { return use; },
  v: function() { return v; },
  validators: function() { return validators; },
  version: function() { return version; }
});

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: external {"root":"XEUtils","commonjs":"xe-utils","commonjs2":"xe-utils","amd":"xe-utils"}
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_ = __webpack_require__(8871);
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default = /*#__PURE__*/__webpack_require__.n(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/conf.ts
const iconPrefix = 'vxe-icon-';
const GlobalConfig = {
  size: null,
  zIndex: 999,
  version: 0,
  // resizeInterval: 500,
  emptyCell: '　',
  // loadingText: null, // 自定义loading提示内容，如果为null则不显示文本
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '暂无数据',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 行数据的唯一主键字段名
    // },
    resizeConfig: {
      refreshDelay: 250
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: 'inline',
      msgMode: 'single'
    },
    columnConfig: {
      maxFixedSize: 4
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      allowFixed: true,
      showFooter: true
      //  storage: false,
      //  checkMethod () {}
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      iconLayout: 'vertical'
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      showIcon: true
    },
    treeConfig: {
      rowField: 'id',
      parentField: 'parentId',
      childrenField: 'children',
      hasChildField: 'hasChild',
      mapChildrenField: '_X_ROW_CHILD',
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true
    },
    importConfig: {
      _typeMaps: {},
      modes: ['insert', 'covering']
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      },
      modes: ['current', 'selected']
    },
    printConfig: {
      modes: ['current', 'selected']
    },
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    scrollX: {
      // enabled: false,
      gt: 60
      // oSize: 0
    },
    scrollY: {
      // enabled: false,
      gt: 100
      // oSize: 0
    }
  },
  export: {
    types: {}
  },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      message: true,
      props: {
        list: null,
        result: 'result',
        total: 'page.total',
        message: 'message'
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  },
  icon: {
    // loading
    LOADING: iconPrefix + 'spinner roll vxe-loading--default-icon',
    // table
    TABLE_SORT_ASC: iconPrefix + 'caret-up',
    TABLE_SORT_DESC: iconPrefix + 'caret-down',
    TABLE_FILTER_NONE: iconPrefix + 'funnel',
    TABLE_FILTER_MATCH: iconPrefix + 'funnel',
    TABLE_EDIT: iconPrefix + 'edit',
    TABLE_TITLE_PREFIX: iconPrefix + 'question-circle-fill',
    TABLE_TITLE_SUFFIX: iconPrefix + 'question-circle-fill',
    TABLE_TREE_LOADED: iconPrefix + 'spinner roll',
    TABLE_TREE_OPEN: iconPrefix + 'caret-right rotate90',
    TABLE_TREE_CLOSE: iconPrefix + 'caret-right',
    TABLE_EXPAND_LOADED: iconPrefix + 'spinner roll',
    TABLE_EXPAND_OPEN: iconPrefix + 'arrow-right rotate90',
    TABLE_EXPAND_CLOSE: iconPrefix + 'arrow-right',
    TABLE_CHECKBOX_CHECKED: iconPrefix + 'checkbox-checked',
    TABLE_CHECKBOX_UNCHECKED: iconPrefix + 'checkbox-unchecked',
    TABLE_CHECKBOX_INDETERMINATE: iconPrefix + 'checkbox-indeterminate',
    TABLE_RADIO_CHECKED: iconPrefix + 'radio-checked',
    TABLE_RADIO_UNCHECKED: iconPrefix + 'radio-unchecked',
    // button
    BUTTON_DROPDOWN: iconPrefix + 'arrow-down',
    BUTTON_LOADING: iconPrefix + 'spinner roll',
    // select
    SELECT_LOADED: iconPrefix + 'spinner roll',
    SELECT_OPEN: iconPrefix + 'caret-down rotate180',
    SELECT_CLOSE: iconPrefix + 'caret-down',
    // pager
    PAGER_HOME: iconPrefix + 'home-page',
    PAGER_END: iconPrefix + 'end-page',
    PAGER_JUMP_PREV: iconPrefix + 'arrow-double-left',
    PAGER_JUMP_NEXT: iconPrefix + 'arrow-double-right',
    PAGER_PREV_PAGE: iconPrefix + 'arrow-left',
    PAGER_NEXT_PAGE: iconPrefix + 'arrow-right',
    PAGER_JUMP_MORE: iconPrefix + 'ellipsis-h',
    // input
    INPUT_CLEAR: iconPrefix + 'error-circle-fill',
    INPUT_PWD: iconPrefix + 'eye-fill',
    INPUT_SHOW_PWD: iconPrefix + 'eye-fill-close',
    INPUT_PREV_NUM: iconPrefix + 'caret-up',
    INPUT_NEXT_NUM: iconPrefix + 'caret-down',
    INPUT_DATE: iconPrefix + 'calendar',
    INPUT_SEARCH: iconPrefix + 'search',
    // modal
    MODAL_ZOOM_IN: iconPrefix + 'square',
    MODAL_ZOOM_OUT: iconPrefix + 'maximize',
    MODAL_CLOSE: iconPrefix + 'close',
    MODAL_INFO: iconPrefix + 'info-circle-fill',
    MODAL_SUCCESS: iconPrefix + 'success-circle-fill',
    MODAL_WARNING: iconPrefix + 'warnion-circle-fill',
    MODAL_ERROR: iconPrefix + 'error-circle-fill',
    MODAL_QUESTION: iconPrefix + 'question-circle-fill',
    MODAL_LOADING: iconPrefix + 'spinner roll',
    // toolbar
    TOOLBAR_TOOLS_REFRESH: iconPrefix + 'repeat',
    TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + 'repeat roll',
    TOOLBAR_TOOLS_IMPORT: iconPrefix + 'upload',
    TOOLBAR_TOOLS_EXPORT: iconPrefix + 'download',
    TOOLBAR_TOOLS_PRINT: iconPrefix + 'print',
    TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + 'fullscreen',
    TOOLBAR_TOOLS_MINIMIZE: iconPrefix + 'minimize',
    TOOLBAR_TOOLS_CUSTOM: iconPrefix + 'custom-column',
    TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + 'fixed-left',
    TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED: iconPrefix + 'fixed-left-fill',
    TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + 'fixed-right',
    TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED: iconPrefix + 'fixed-right-fill',
    // form
    FORM_PREFIX: iconPrefix + 'question-circle-fill',
    FORM_SUFFIX: iconPrefix + 'question-circle-fill',
    FORM_FOLDING: iconPrefix + 'arrow-up rotate180',
    FORM_UNFOLDING: iconPrefix + 'arrow-up'
  },
  tooltip: {
    // size: null,
    trigger: 'hover',
    theme: 'dark',
    enterDelay: 500,
    leaveDelay: 300
  },
  pager: {
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: true,
      autoPos: true
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  textarea: {
    // size: null,
    // autosize: {
    //   minRows: 1,
    //   maxRows: 10
    // }
  },
  select: {
    // size: null,
    // transfer: false,
    // optionConfig: {
    //   keyField: '_X_OPTION_KEY'
    // },
    multiCharOverflow: 8
  },
  button: {
    // size: null,
    // transfer: false
  },
  buttonGroup: {
    // size: null
  },
  radio: {
    // size: null,
    strict: true
  },
  radioButton: {
    // size: null,
    strict: true
  },
  radioGroup: {
    // size: null,
    strict: true
  },
  checkbox: {
    // size: null
  },
  checkboxGroup: {
    // size: null
  },
  switch: {
    // size: null
  },
  modal: {
    // size: null,
    top: 15,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3000,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    draggable: true,
    showConfirmButton: null,
    // storage: false,
    storageKey: 'VXE_MODAL_POSITION'
  },
  drawer: {
    // size: null,
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true
  },
  list: {
    // size: null,
    scrollY: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  i18n: key => key
};
/* harmony default export */ var conf = (GlobalConfig);
;// CONCATENATED MODULE: ./node_modules/dom-zindex/es/index.esm.js
var storeEl = null;
var storeId = 'z-index-manage';
var storeMainKey = 'm';
var storeSubKey = 's';
var storeData = {
  m: 1000,
  s: 1000
};
function isDocument() {
  return typeof document !== 'undefined';
}
function getDomMaxZIndex() {
  var max = 0;
  if (isDocument()) {
    var allElem = document.body.getElementsByTagName('*');
    for (var i = 0; i < allElem.length; i++) {
      var elem = allElem[i];
      if (elem && elem.style && elem.nodeType === 1) {
        var zIndex = elem.style.zIndex;
        if (zIndex && /^\d+$/.test(zIndex)) {
          max = Math.max(max, Number(zIndex));
        }
      }
    }
  }
  return max;
}
function getDom() {
  if (!storeEl) {
    if (isDocument()) {
      storeEl = document.getElementById(storeId);
      if (!storeEl) {
        storeEl = document.createElement('div');
        storeEl.id = storeId;
        storeEl.style.display = 'none';
        document.body.appendChild(storeEl);
        setCurrent(storeData.m);
        setSubCurrent(storeData.s);
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function (value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var doc = getDom();
      if (doc) {
        if (doc.dataset) {
          doc.dataset[key] = value + '';
        } else {
          doc.setAttribute('data-' + key, value + '');
        }
      }
    }
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent(currZindex) {
    var zIndex;
    var doc = getDom();
    if (doc) {
      var domVal = doc.dataset ? doc.dataset[key] : doc.getAttribute('data-' + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
/**
 * Web common z-index style management
 */
var DomZIndex = {
  setCurrent: setCurrent,
  getCurrent: getCurrent,
  getNext: getNext,
  setSubCurrent: setSubCurrent,
  getSubCurrent: getSubCurrent,
  getSubNext: getSubNext,
  getMax: getDomMaxZIndex
};
/* harmony default export */ var index_esm = (DomZIndex);
;// CONCATENATED MODULE: ./packages/tools/log.ts

function getLog(message, params) {
  return `[vxe-table v${"4.6.18"}] ${conf.i18n(message, params)}`;
}
function outLog(type) {
  return function (message, params) {
    const msg = getLog(message, params);
    console[type](msg);
    return msg;
  };
}
const warnLog = outLog('warn');
const errLog = outLog('error');
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/interceptor.ts



const storeMap = {};
const interceptor = {
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (callback, type) => interceptor.add(type, callback));
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, callback) {
    // 检测类型
    if (true) {
      const eventTypes = ['created', 'mounted', 'activated', 'beforeUnmount', 'unmounted', 'event.clearEdit', 'event.clearActived', 'event.clearFilter', 'event.clearAreas', 'event.showMenu', 'event.keydown', 'event.export', 'event.import'];
      if (eventTypes.indexOf(type) === -1) {
        warnLog('vxe.error.errProp', [`Interceptor.${type}`, eventTypes.join('|')]);
      }
    }
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      // 检测重复
      if (true) {
        if (eList.indexOf(callback) > -1) {
          warnLog('vxe.error.coverProp', ['Interceptor', type]);
        }
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, callback) {
    const eList = storeMap[type];
    if (eList) {
      if (callback) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eList, fn => fn === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(9274);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

;// CONCATENATED MODULE: ./packages/v-x-e-table/src/formats.ts



class VXEFormatsStore {
  constructor() {
    _defineProperty(this, "store", {});
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      if (true) {
        warnLog('vxe.error.delProp', ['formats -> callback', 'cellFormatMethod']);
      }
      render = {
        cellFormatMethod: render
      };
    }
    // 检测是否覆盖
    if (true) {
      const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog('vxe.error.coverProp', [name, key]);
        }
      });
    }
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const formats = new VXEFormatsStore();
if (true) {
  Object.assign(formats, {
    _name: 'Formats'
  });
}
;// CONCATENATED MODULE: ./packages/tools/utils.ts



function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === undefined || cellValue === '';
}
function parseFile(file) {
  const name = file.name;
  const tIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastIndexOf(name, '.');
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return {
    filename,
    type
  };
}
function nextZIndex() {
  return index_esm.getNext();
}
function getLastZIndex() {
  return index_esm.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content) {
  return content ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(conf.translate ? conf.translate('' + content) : content) : '';
}
function formatText(value, placeholder) {
  return '' + (isEmptyValue(value) ? placeholder ? conf.emptyCell : '' : value);
}
/**
 * 判断值为：'' | null | undefined 时都属于空值
 */
function eqEmptyValue(cellValue) {
  return cellValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue);
}
;// CONCATENATED MODULE: ./packages/table/src/columnInfo.ts






class ColumnInfo {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xetable, _vm, {
    renderHeader,
    renderCell,
    renderFooter,
    renderData
  } = {}) {
    const $xegrid = $xetable.xegrid;
    const formatter = _vm.formatter;
    const visible = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.visible) ? _vm.visible : true;
    if (true) {
      const types = ['seq', 'checkbox', 'radio', 'expand', 'html'];
      if (_vm.type && types.indexOf(_vm.type) === -1) {
        warnLog('vxe.error.errProp', [`type=${_vm.type}`, types.join(', ')]);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.cellRender) || _vm.cellRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.cellRender)) {
        warnLog('vxe.error.errProp', [`column.cell-render=${_vm.cellRender}`, 'column.cell-render={}']);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.editRender) || _vm.editRender && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(_vm.editRender)) {
        warnLog('vxe.error.errProp', [`column.edit-render=${_vm.editRender}`, 'column.edit-render={}']);
      }
      if (_vm.cellRender && _vm.editRender) {
        warnLog('vxe.error.errConflicts', ['column.cell-render', 'column.edit-render']);
      }
      if (_vm.type === 'expand') {
        const {
          props: tableProps
        } = $xetable;
        const {
          treeConfig
        } = tableProps;
        const {
          computeTreeOpts
        } = $xetable.getComputeMaps();
        const treeOpts = computeTreeOpts.value;
        if (treeConfig && (treeOpts.showLine || treeOpts.line)) {
          errLog('vxe.error.errConflicts', ['tree-config.showLine', 'column.type=expand']);
        }
      }
      if (formatter) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
          const gFormatOpts = formats.get(formatter) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter];
          if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.cellFormatMethod)) {
            errLog('vxe.error.notFormats', [formatter]);
          }
        } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
          const gFormatOpts = formats.get(formatter[0]) || (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[formatter[0]];
          if (!gFormatOpts || !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(gFormatOpts.cellFormatMethod)) {
            errLog('vxe.error.notFormats', [formatter[0]]);
          }
        }
      }
    }
    Object.assign(this, {
      // 基本属性
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter: formatter,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: toFilters(_vm.filters),
      filterMultiple: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      treeNode: _vm.treeNode,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      // 自定义参数
      params: _vm.params,
      // 渲染属性
      id: _vm.colId || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('col_'),
      parentId: null,
      visible,
      // 内部属性（一旦被使用，将导致不可升级版本）
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      checked: false,
      halfChecked: false,
      disabled: false,
      // 分组层级
      level: 1,
      // 跨行
      rowSpan: 1,
      // 跨列
      colSpan: 1,
      // 数据排序
      order: null,
      sortTime: 0,
      // 列排序
      sortNumber: 0,
      renderSortNumber: 0,
      renderWidth: 0,
      renderHeight: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData: renderData,
      // 单元格插槽，只对 grid 有效
      slots: _vm.slots
    });
    if ($xegrid) {
      const {
        computeProxyOpts
      } = $xegrid.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({
          $grid: $xegrid,
          column: this
        });
      }
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === 'seq' ? conf.i18n('vxe.table.seqTitle') : ''));
  }
  getKey() {
    return this.field || (this.type ? `type=${this.type}` : null);
  }
  update(name, value) {
    // 不支持直接修改的属性
    if (name !== 'filters') {
      if (name === 'field') {
        // 兼容旧属性
        this.property = value;
      }
      this[name] = value;
    }
  }
}
;// CONCATENATED MODULE: ./packages/tools/dom.ts

const reClsMap = {};
const browse = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
function getPropClass(property, params) {
  return property ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(property) ? property(params) : property : '';
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, 'g');
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), '');
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingTop);
    const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
// export function setScrollLeftAndTop (elem: HTMLElement | null, scrollLeft: number, scrollTop: number) {
//   if (elem) {
//     elem.scrollLeft = scrollLeft
//     elem.scrollTop = scrollTop
//   }
// }
function updateCellTitle(overflowElem, column) {
  const content = column.type === 'html' ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute('title') !== content) {
    overflowElem.setAttribute('title', content);
  }
}
/**
 * 检查触发源是否属于目标节点
 */
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return {
        flag: queryCls ? !!targetElem : true,
        container,
        targetElem: targetElem
      };
    }
    target = target.parentNode;
  }
  return {
    flag: false
  };
}
/**
 * 获取元素相对于 document 的位置
 */
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, {
    left: 0,
    top: 0
  });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const {
    scrollTop,
    scrollLeft,
    visibleHeight,
    visibleWidth
  } = getDomNode();
  return {
    boundingTop,
    top: scrollTop + boundingTop,
    boundingLeft,
    left: scrollLeft + boundingLeft,
    visibleHeight,
    visibleWidth
  };
}
const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
const scrollIntoView = 'scrollIntoView';
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
;// CONCATENATED MODULE: ./packages/table/src/util.ts





const getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach(column => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some(column => column.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
const convertHeaderColumnToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.children && column.children.length && column.children.some(column => column.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function restoreScrollLocation($xetable, scrollLeft, scrollTop) {
  const {
    internalData
  } = $xetable;
  return $xetable.clearScroll().then(() => {
    if (scrollLeft || scrollTop) {
      // 重置最后滚动状态
      internalData.lastScrollLeft = 0;
      internalData.lastScrollTop = 0;
      // 还原滚动状态
      return $xetable.scrollTo(scrollLeft, scrollTop);
    }
  });
}
function removeScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = null;
  }
}
function restoreScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = scrollElem._onscroll;
  }
}
/**
 * 生成行的唯一主键
 */
function getRowUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('row_');
}
// 行主键 key
function getRowkey($xetable) {
  const {
    props
  } = $xetable;
  const {
    computeRowOpts
  } = $xetable.getComputeMaps();
  const {
    rowId
  } = props;
  const rowOpts = computeRowOpts.value;
  return rowId || rowOpts.keyField || '_X_ROW_KEY';
}
// 行主键 value
function getRowid($xetable, row) {
  const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, getRowkey($xetable));
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rowid) ? '' : encodeURIComponent(rowid);
}
const handleFieldOrColumn = ($xetable, fieldOrColumn) => {
  if (fieldOrColumn) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
  }
  return null;
};
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingLeft);
    const paddingRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElemenMarginWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginLeft);
    const marginRight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function queryCellElement(cell, selector) {
  return cell.querySelector('.vxe-cell' + selector);
}
function toFilters(filters) {
  if (filters && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(filters)) {
    return filters.map(({
      label,
      value,
      data,
      resetValue,
      checked
    }) => {
      return {
        label,
        value,
        data,
        resetValue,
        checked: !!checked,
        _checked: !!checked
      };
    });
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
}
function getCellValue(row, column) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field);
}
function setCellValue(row, column, value) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, column.field, value);
}
/**
 * 列宽拖动最大宽度
 * @param params
 * @returns
 */
function getColReMaxWidth(params) {
  const {
    $table
  } = params;
  const {
    computeResizableOpts
  } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const {
    maxWidth: reMaxWidth
  } = resizableOpts;
  // 如果自定义调整宽度逻辑
  if (reMaxWidth) {
    const customMaxWidth = XEUtils.isFunction(reMaxWidth) ? reMaxWidth(params) : reMaxWidth;
    if (customMaxWidth !== 'auto') {
      return Math.max(1, XEUtils.toNumber(customMaxWidth));
    }
  }
  return -1;
}
/**
 * 列宽拖动最小宽度
 * @param params
 * @returns
 */
function getColReMinWidth(params) {
  const {
    $table,
    column,
    cell
  } = params;
  const {
    props: tableProps
  } = $table;
  const {
    computeResizableOpts
  } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const {
    minWidth: reMinWidth
  } = resizableOpts;
  // 如果自定义调整宽度逻辑
  if (reMinWidth) {
    const customMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== 'auto') {
      return Math.max(1, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(customMinWidth));
    }
  }
  const {
    showHeaderOverflow: allColumnHeaderOverflow
  } = tableProps;
  const {
    showHeaderOverflow,
    minWidth: colMinWidth
  } = column;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === 'ellipsis';
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ''));
  let mWidth = minTitleWidth + paddingLeftRight;
  // 默认最小宽处理
  if (hasEllipsis) {
    const checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, '--title>.vxe-cell--checkbox'));
    const requiredIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--required-icon'));
    const editIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--edit-icon'));
    const prefixIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell-title-prefix-icon'));
    const suffixIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell-title-suffix-icon'));
    const sortIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--sort'));
    const filterIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--filter'));
    mWidth += checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  // 如果设置最小宽
  if (colMinWidth) {
    const {
      refTableBody
    } = $table.getRefMaps();
    const tableBody = refTableBody.value;
    const bodyElem = tableBody ? tableBody.$el : null;
    if (bodyElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column) {
  return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);
}
function createColumn($xetable, options, renderOptions) {
  return isColumnInfo(options) ? options : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(new ColumnInfo($xetable, options, renderOptions));
}
function watchColumn($xetable, props, column) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      column.update(name, value);
      if ($xetable) {
        if (name === 'filters') {
          $xetable.setFilter(column, value);
          $xetable.handleUpdateDataQueue();
        } else if (['visible', 'fixed', 'width', 'minWidth', 'maxWidth'].includes(name)) {
          $xetable.handleRefreshColumnQueue();
        }
      }
    });
  });
}
function assemColumn($xetable, elem, column, colgroup) {
  const {
    reactData
  } = $xetable;
  const {
    staticColumns
  } = reactData;
  const parentElem = elem.parentNode;
  const parentColumn = colgroup ? colgroup.column : null;
  const parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    parentCols.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, column);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xetable, column) {
  const {
    reactData
  } = $xetable;
  const {
    staticColumns
  } = reactData;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticColumns, item => item.id === column.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function getRootColumn($xetable, column) {
  const {
    internalData
  } = $xetable;
  const {
    fullColumnIdData
  } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column = fullColumnIdData[parentColId].column;
    parentColId = column.parentId;
    if (!parentColId) {
      return column;
    }
  }
  return column;
}
function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeList.length; mIndex++) {
    const {
      row: mergeRowIndex,
      col: mergeColIndex,
      rowspan: mergeRowspan,
      colspan: mergeColspan
    } = mergeList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return {
          rowspan: mergeRowspan,
          colspan: mergeColspan
        };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return {
          rowspan: 0,
          colspan: 0
        };
      }
    }
  }
}
function clearTableDefaultStatus($xetable) {
  const {
    props,
    internalData
  } = $xetable;
  internalData.initStatus = false;
  $xetable.clearSort();
  $xetable.clearCurrentRow();
  $xetable.clearCurrentColumn();
  $xetable.clearRadioRow();
  $xetable.clearRadioReserve();
  $xetable.clearCheckboxRow();
  $xetable.clearCheckboxReserve();
  $xetable.clearRowExpand();
  $xetable.clearTreeExpand();
  $xetable.clearTreeExpandReserve();
  $xetable.clearPendingRow();
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  if ($xetable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    $xetable.clearSelected();
  }
  if ($xetable.clearCellAreas && props.mouseConfig) {
    $xetable.clearCellAreas();
    $xetable.clearCopyCellArea();
  }
  return $xetable.clearScroll();
}
function clearTableAllStatus($xetable) {
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  return clearTableDefaultStatus($xetable);
}
function rowToVisible($xetable, row) {
  const {
    reactData,
    internalData
  } = $xetable;
  const {
    refTableBody
  } = $xetable.getRefMaps();
  const {
    scrollYLoad
  } = reactData;
  const {
    afterFullData,
    scrollYStore
  } = internalData;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (bodyElem) {
    const trElem = bodyElem.querySelector(`[rowid="${getRowid($xetable, row)}"]`);
    if (trElem) {
      const bodyHeight = bodyElem.clientHeight;
      const bodySrcollTop = bodyElem.scrollTop;
      const trOffsetParent = trElem.offsetParent;
      const trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);
      const trHeight = trElem.clientHeight;
      // 检测行是否在可视区中
      if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {
        // 向上定位
        return $xetable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {
        // 向下定位
        return $xetable.scrollTo(null, bodySrcollTop + trHeight);
      }
    } else {
      // 如果是虚拟渲染跨行滚动
      if (scrollYLoad) {
        return $xetable.scrollTo(null, (afterFullData.indexOf(row) - 1) * scrollYStore.rowHeight);
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xetable, column) {
  const {
    reactData,
    internalData
  } = $xetable;
  const {
    refTableBody
  } = $xetable.getRefMaps();
  const {
    scrollXLoad
  } = reactData;
  const {
    visibleColumn
  } = internalData;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (bodyElem) {
    const tdElem = bodyElem.querySelector(`.${column.id}`);
    if (tdElem) {
      const bodyWidth = bodyElem.clientWidth;
      const bodySrcollLeft = bodyElem.scrollLeft;
      const tdOffsetParent = tdElem.offsetParent;
      const tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);
      const tdWidth = tdElem.clientWidth;
      // 检测行是否在可视区中
      if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {
        // 向左定位
        return $xetable.scrollTo(tdOffsetLeft);
      } else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {
        // 向右定位
        return $xetable.scrollTo(bodySrcollLeft + tdWidth);
      }
    } else {
      // 如果是虚拟渲染跨行滚动
      if (scrollXLoad) {
        let scrollLeft = 0;
        for (let index = 0; index < visibleColumn.length; index++) {
          if (visibleColumn[index] === column) {
            break;
          }
          scrollLeft += visibleColumn[index].renderWidth;
        }
        return $xetable.scrollTo(scrollLeft);
      }
    }
  }
  return Promise.resolve();
}
;// CONCATENATED MODULE: ./packages/tools/vn.ts

function getOnName(type) {
  return 'on' + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getSlotVNs(vns) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return [vns];
}
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/renderer.ts







const componentDefaultModelProp = 'modelValue';
const defaultCompProps = {
  transfer: true
};
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
      return 'input';
  }
  return 'update:modelValue';
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case 'input':
    case 'textarea':
    case 'VxeInput':
    case 'VxeTextarea':
    case '$input':
    case '$textarea':
      return 'input';
  }
  return 'change';
}
function parseDate(value, props) {
  return value && props.valueFormat ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const {
    dateConfig = {}
  } = props;
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, conf.i18n(`vxe.input.date.labelFormat.${props.type}`));
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponentName(name) {
  return `vxe-${name.replace('$', '')}`;
}
function getDefaultComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(name);
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(getOldComponentName(name));
}
function handleConfirmFilter(params, checked, option) {
  const {
    $panel
  } = params;
  $panel.changeOption({}, checked, option);
}
function getNativeAttrs(renderOpts) {
  let {
    name,
    attrs
  } = renderOpts;
  if (name === 'input') {
    attrs = Object.assign({
      type: 'text'
    }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const {
    name,
    immediate,
    props
  } = renderOpts;
  if (!immediate) {
    if (name === 'VxeInput' || name === '$input') {
      const {
        type
      } = props || {};
      return !(!type || type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    }
    if (name === 'input' || name === 'textarea' || name === '$textarea') {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({
    immediate: getInputImmediateModel(renderOpts)
  }, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultCompProps, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === 'cell' || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel) {
  const {
    placeholder
  } = renderOpts;
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--label'
  }, placeholder && isEmptyValue(cellLabel) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--placeholder'
  }, formatText(getFuncText(placeholder), 1))] : formatText(cellLabel, 1))];
}
/**
 * 原生事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getElementOns(renderOpts, params, modelFunc, changeFunc) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
      ons[getOnName(key)] = function (...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
/**
 * 组件事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
    ons[getOnName(key)] = function (...args) {
      if (true) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
          errLog('vxe.error.errFunc', [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const {
    model
  } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, cellValue => {
    // 处理 model 值双向绑定
    if (isImmediate) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, eventParams => {
    // 处理 change 事件相关逻辑
    if (!isImmediate && ['VxeInput', 'VxeTextarea', '$input', '$textarea'].includes(name)) {
      const cellValue = eventParams.value;
      model.update = true;
      model.value = cellValue;
      $table.updateStatus(params, cellValue);
    } else {
      $table.updateStatus(params);
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, value => {
    // 处理 model 值双向绑定
    option.data = value;
  }, () => {
    handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
  });
}
function getItemOns(renderOpts, params) {
  const {
    $form,
    data,
    property
  } = params;
  return getComponentOns(renderOpts, params, value => {
    // 处理 model 值双向绑定
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, property, value);
  }, () => {
    // 处理 change 事件相关逻辑
    $form.updateStatus(params);
  });
}
function getNativeEditOns(renderOpts, params) {
  const {
    $table,
    row,
    column
  } = params;
  const {
    model
  } = column;
  return getElementOns(renderOpts, params, evnt => {
    // 处理 model 值双向绑定
    const cellValue = evnt.target.value;
    if (isImmediateCell(renderOpts, params)) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, evnt => {
    // 处理 change 事件相关逻辑
    const cellValue = evnt.target.value;
    $table.updateStatus(params, cellValue);
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getElementOns(renderOpts, params, evnt => {
    // 处理 model 值双向绑定
    option.data = evnt.target.value;
  }, () => {
    handleConfirmFilter(params, !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(option.data), option);
  });
}
function getNativeItemOns(renderOpts, params) {
  const {
    $form,
    data,
    property
  } = params;
  return getElementOns(renderOpts, params, evnt => {
    // 处理 model 值双向绑定
    const itemValue = evnt.target.value;
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, property, itemValue);
  }, () => {
    // 处理 change 事件相关逻辑
    $form.updateStatus(params);
  });
}
/**
 * 单元格可编辑渲染-原生的标签
 * input、textarea、select
 */
function nativeEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    name
  } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(name, {
    class: `vxe-default-${name}`,
    ...getNativeAttrs(renderOpts),
    value: cellValue,
    ...getNativeEditOns(renderOpts, params)
  })];
}
function defaultCellRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
function defaultEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonEditRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-button'), {
    ...getCellEditProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map(childRenderOpts => oldButtonEditRender(childRenderOpts, params)[0]);
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const {
    optionGroups,
    optionGroupProps = {}
  } = renderOpts;
  const groupOptions = optionGroupProps.options || 'options';
  const groupLabel = optionGroupProps.label || 'label';
  return optionGroups.map((group, gIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('optgroup', {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
/**
 * 渲染原生的 option 标签
 */
function renderNativeOptions(options, renderOpts, params) {
  const {
    optionProps = {}
  } = renderOpts;
  const {
    row,
    column
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return options.map((option, oIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
      key: oIndex,
      value: option[valueProp],
      disabled: option[disabledProp],
      /* eslint-disable eqeqeq */
      selected: option[valueProp] == cellValue
    }, option[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(name, {
      key: oIndex,
      class: `vxe-default-${name}`,
      ...attrs,
      value: option.data,
      ...getNativeFilterOns(renderOpts, params, option)
    });
  });
}
function defaultFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
      key: oIndex,
      ...getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      ...getFilterOns(renderOpts, params, option)
    });
  });
}
/**
 * 已废弃
 * @deprecated
 */
function oldFilterRender(renderOpts, params) {
  const {
    column
  } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
      key: oIndex,
      ...getCellEditFilterProps(renderOpts, renderOpts, optionValue),
      ...getFilterOns(renderOpts, params, option)
    });
  });
}
function handleFilterMethod({
  option,
  row,
  column
}) {
  const {
    data
  } = option;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.property);
  /* eslint-disable eqeqeq */
  return cellValue == data;
}
function nativeSelectEditRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
    class: 'vxe-default-select',
    ...getNativeAttrs(renderOpts),
    ...getNativeEditOns(renderOpts, params)
  }, renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))];
}
function defaultSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldSelectEditRender(renderOpts, params) {
  const {
    row,
    column
  } = params;
  const {
    options,
    optionProps,
    optionGroups,
    optionGroupProps
  } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getCellEditProps(renderOpts, params, cellValue, {
      options,
      optionProps,
      optionGroups,
      optionGroupProps
    }),
    ...getEditOns(renderOpts, params)
  })];
}
function getSelectCellValue(renderOpts, {
  row,
  column
}) {
  const {
    props = {},
    options,
    optionGroups,
    optionProps = {},
    optionGroupProps = {}
  } = renderOpts;
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.property);
  let selectItem;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  if (!isEmptyValue(cellValue)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().map(props.multiple ? cellValue : [cellValue], optionGroups ? value => {
      const groupOptions = optionGroupProps.options || 'options';
      for (let index = 0; index < optionGroups.length; index++) {
        /* eslint-disable eqeqeq */
        selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(optionGroups[index][groupOptions], item => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : value => {
      /* eslint-disable eqeqeq */
      selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(options, item => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(', ');
  }
  return '';
}
/**
 * 渲染表单-项
 * 用于渲染原生的标签
 */
function nativeItemRender(renderOpts, params) {
  const {
    data,
    property
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(name, {
    class: `vxe-default-${name}`,
    ...attrs,
    value: attrs && name === 'input' && (attrs.type === 'submit' || attrs.type === 'reset') ? null : itemValue,
    ...getNativeItemOns(renderOpts, params)
  })];
}
function defaultItemRender(renderOpts, params) {
  const {
    data,
    property
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldItemRender(renderOpts, params) {
  const {
    data,
    property
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonItemRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-button'), {
    ...getComponentFormItemProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map(childRenderOpts => oldButtonItemRender(childRenderOpts, params)[0]);
}
/**
 * 渲染原生的 select 标签
 */
function renderNativeFormOptions(options, renderOpts, params) {
  const {
    data,
    property
  } = params;
  const {
    optionProps = {}
  } = renderOpts;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
  return options.map((item, oIndex) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function handleExportSelectMethod(params) {
  const {
    row,
    column,
    options
  } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
/**
 * 渲染表单-项
 */
function defaultFormItemRender(renderOpts, params) {
  const {
    data,
    property
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    options,
    optionProps
  } = renderOpts;
  const {
    data,
    property
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    options,
    optionProps,
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    name,
    options,
    optionProps = {}
  } = renderOpts;
  const {
    data,
    property
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
  const compName = getOldComponentName(name);
  // 如果是分组
  if (options) {
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(`${compName}-group`), {
      ...getComponentFormItemProps(renderOpts, params, itemValue),
      ...getItemOns(renderOpts, params)
    }, {
      default: () => {
        return options.map((item, index) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
            key: index,
            label: item[valueProp],
            content: item[labelProp],
            disabled: item[disabledProp]
          });
        });
      }
    })];
  }
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 内置的组件渲染
 */
const renderMap = {
  input: {
    autofocus: 'input',
    renderEdit: nativeEditRender,
    renderDefault: nativeEditRender,
    renderFilter: nativeFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: nativeItemRender
  },
  textarea: {
    autofocus: 'textarea',
    renderEdit: nativeEditRender,
    renderItemContent: nativeItemRender
  },
  select: {
    renderEdit: nativeSelectEditRender,
    renderDefault: nativeSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const {
        column
      } = params;
      return column.filters.map((option, oIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
          key: oIndex,
          class: 'vxe-default-select',
          ...getNativeAttrs(renderOpts),
          ...getNativeFilterOns(renderOpts, params, option)
        }, renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
        class: 'vxe-default-select',
        ...getNativeAttrs(renderOpts),
        ...getNativeItemOns(renderOpts, params)
      }, renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))];
    },
    exportMethod: handleExportSelectMethod
  },
  VxeInput: {
    autofocus: '.vxe-input--inner',
    renderEdit: defaultEditRender,
    renderCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const digits = props.digits || conf.input.digits;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.property);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderDefault: defaultEditRender,
    renderFilter: defaultFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: defaultItemRender
  },
  VxeTextarea: {
    autofocus: '.vxe-textarea--inner',
    renderItemContent: defaultItemRender
  },
  VxeButton: {
    renderDefault: defaultCellRender,
    renderItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderDefault: defaultCellRender,
    renderItemContent(renderOpts, params) {
      const {
        options
      } = renderOpts;
      const {
        data,
        property
      } = params;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        options,
        ...getComponentFormItemProps(renderOpts, params, itemValue),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeSelect: {
    autofocus: '.vxe-input--inner',
    renderEdit: defaultSelectEditRender,
    renderDefault: defaultSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
          key: oIndex,
          ...getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          ...getFilterOns(renderOpts, params, option)
        });
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      const {
        data,
        property
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    },
    exportMethod: handleExportSelectMethod
  },
  VxeRadio: {
    autofocus: '.vxe-radio--input',
    renderItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    autofocus: '.vxe-radio--input',
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    autofocus: '.vxe-checkbox--input',
    renderItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    autofocus: '.vxe-checkbox--input',
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    autofocus: '.vxe-switch--button',
    renderEdit: defaultEditRender,
    renderDefault: defaultEditRender,
    renderItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    autofocus: '.vxe-input--inner',
    renderEdit: oldEditRender,
    renderCell(renderOpts, params) {
      const {
        props = {}
      } = renderOpts;
      const {
        row,
        column
      } = params;
      const digits = props.digits || conf.input.digits;
      let cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.property);
      if (cellValue) {
        switch (props.type) {
          case 'date':
          case 'week':
          case 'month':
          case 'year':
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case 'float':
            cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderDefault: oldEditRender,
    renderFilter: oldFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: oldItemRender
  },
  $textarea: {
    autofocus: '.vxe-textarea--inner',
    renderItemContent: oldItemRender
  },
  $button: {
    renderDefault: oldButtonEditRender,
    renderItemContent: oldButtonItemRender
  },
  $buttons: {
    renderDefault: oldButtonsEditRender,
    renderItemContent: oldButtonsItemRender
  },
  $select: {
    autofocus: '.vxe-input--inner',
    renderEdit: oldSelectEditRender,
    renderDefault: oldSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const {
        column
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
          key: oIndex,
          ...getCellEditFilterProps(renderOpts, params, optionValue, {
            options,
            optionProps,
            optionGroups,
            optionGroupProps
          }),
          ...getFilterOns(renderOpts, params, option)
        });
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      const {
        data,
        property
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    },
    exportMethod: handleExportSelectMethod
  },
  $radio: {
    autofocus: '.vxe-radio--input',
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    autofocus: '.vxe-checkbox--input',
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    autofocus: '.vxe-switch--button',
    renderEdit: oldEditRender,
    renderDefault: oldEditRender,
    renderItemContent: oldItemRender
  }
  // 以上已废弃
};
/**
 * 全局渲染器
 */
const renderer = {
  mixin(opts) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        // 检测是否覆盖
        if (true) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (val, key) => {
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(renders[key]) && renders[key] !== val) {
              warnLog('vxe.error.coverProp', [`Renderer.${name}`, key]);
            }
          });
        }
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/commands.ts



class VXECommandsStore {
  constructor() {
    _defineProperty(this, "store", {});
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      if (true) {
        warnLog('vxe.error.delProp', ['commands -> callback', 'commandMethod']);
      }
      render = {
        commandMethod: render
      };
    }
    // 检测是否覆盖
    if (true) {
      const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog('vxe.error.coverProp', [name, key]);
        }
      });
    }
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const commands = new VXECommandsStore();
if (true) {
  Object.assign(commands, {
    _name: 'Commands'
  });
}
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/menus.ts



class VXEMenusStore {
  constructor() {
    _defineProperty(this, "store", {});
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      if (true) {
        warnLog('vxe.error.delProp', ['menus -> callback', 'menuMethod']);
      }
      render = {
        menuMethod: render
      };
    }
    // 检测是否覆盖
    if (true) {
      const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog('vxe.error.coverProp', [name, key]);
        }
      });
    }
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const menus = new VXEMenusStore();
if (true) {
  Object.assign(menus, {
    _name: 'Menus'
  });
}
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/store.ts



/**
 * 创建数据仓库
 */
class Store {
  constructor() {
    _defineProperty(this, "store", {});
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    // 检测是否覆盖
    if (true) {
      const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog('vxe.error.coverProp', [name, key]);
        }
      });
    }
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
/* harmony default export */ var store = (Store);
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/validators.ts

const validators = new store();
if (true) {
  Object.assign(validators, {
    _name: 'Validators'
  });
}
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/hooks.ts

const hooks = new store();
;// CONCATENATED MODULE: ./packages/v-x-e-table/src/theme.ts

function setTheme(name) {
  let theme = name || conf.theme;
  if (!theme || theme === 'default') {
    theme = 'light';
  }
  conf.theme = theme;
  if (typeof document !== 'undefined') {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute('data-vxe-ui-theme', theme);
    }
  }
}
function getTheme() {
  return conf.theme;
}
;// CONCATENATED MODULE: ./packages/v-x-e-table/index.ts














function getExportOrImpotType(types, flag) {
  const rest = [];
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(types, (val, type) => {
    if (val === 0 || val === flag) {
      rest.push(type);
    }
  });
  return rest;
}
const installedPlugins = [];
function use(Plugin, options) {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(VXETable, options);
      installedPlugins.push(Plugin);
    }
  }
  return VXETable;
}
function t(key, args) {
  return conf.i18n(key, args);
}
function _t(key, args) {
  return key ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(conf.translate ? conf.translate(key, args) : key) : '';
}
/**
 * 全局参数设置
 */
const setConfig = options => {
  if (options) {
    if (options.theme) {
      setTheme(options.theme);
    }
    if (options.zIndex) {
      index_esm.setCurrent(options.zIndex);
    }
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, options);
  }
  return VXETable;
};
class VXETableConfig {
  /**
   * 获取当前的 zIndex
   */
  get zIndex() {
    return getLastZIndex();
  }
  /**
   * 获取下一个 zIndex
   */
  get nextZIndex() {
    return nextZIndex();
  }
  /**
   * 获取所有导出类型
   */
  get exportTypes() {
    return getExportOrImpotType(conf.export.types, 1);
  }
  /**
   * 获取所有导入类型
   */
  get importTypes() {
    return getExportOrImpotType(conf.export.types, 2);
  }
}
// 已废弃
const globalConfs = new VXETableConfig();
const v = 'v4';
/**
 * 已废弃，请使用 setConfig
 * @deprecated
 */
const setup = options => {
  if (true) {
    warnLog('vxe.error.delFunc', ['setup', 'setConfig']);
  }
  setConfig(options);
  return conf;
};
/**
 * 已废弃，请使用 setConfig
 * @deprecated
 */
const config = options => {
  if (true) {
    warnLog('vxe.error.delFunc', ['setup', 'setConfig']);
  }
  setConfig(options);
  return conf;
};
function setIcon(options) {
  if (options) {
    Object.assign(conf.icon, options);
  }
  return VXETable;
}
const globalStore = {};
const components = {};
function getComponent(name) {
  return components[name] || null;
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
  }
}
const version = "4.6.18";
const tableVersion = version;
const VXETable = {
  v,
  version,
  tableVersion,
  setConfig,
  setIcon,
  globalStore,
  interceptor: interceptor,
  renderer: renderer,
  commands: commands,
  formats: formats,
  validators: validators,
  menus: menus,
  hooks: hooks,
  use,
  t,
  _t,
  setTheme: setTheme,
  getTheme: getTheme,
  getComponent,
  // 已废弃
  config,
  setup,
  globalConfs
};
const VxeUI = VXETable;
setTheme('light');







/* harmony default export */ var v_x_e_table = ((/* unused pure expression or super */ null && (VXETable)));
;// CONCATENATED MODULE: ./packages/filter/src/panel.ts






/* harmony default export */ var panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableFilterPanel',
  props: {
    filterStore: Object
  },
  setup(props) {
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const {
      reactData: tableReactData,
      internalData: tableInternalData,
      getComputeMaps
    } = $xetable;
    const {
      computeFilterOpts
    } = getComputeMaps();
    const computeHasCheckOption = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        filterStore
      } = props;
      return filterStore && filterStore.options.some(option => option.checked);
    });
    // 全部筛选事件
    const filterCheckAllEvent = (evnt, value) => {
      const {
        filterStore
      } = props;
      filterStore.options.forEach(option => {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    /*************************
     * Publish methods
     *************************/
    // 确认筛选
    const confirmFilter = evnt => {
      const {
        filterStore
      } = props;
      filterStore.options.forEach(option => {
        option.checked = option._checked;
      });
      $xetable.confirmFilterEvent(evnt);
    };
    // （单选）筛选发生改变
    const changeRadioOption = (evnt, checked, item) => {
      const {
        filterStore
      } = props;
      filterStore.options.forEach(option => {
        option._checked = false;
      });
      item._checked = checked;
      $xetable.checkFilterOptions();
      confirmFilter(evnt);
    };
    /**
     * 重置筛选
     * 当筛选面板中的重置按钮被按下时触发
     * @param {Event} evnt 事件
     */
    const resetFilter = evnt => {
      const {
        filterStore
      } = props;
      $xetable.handleClearFilter(filterStore.column);
      $xetable.confirmFilterEvent(evnt);
    };
    // （多选）筛选发生改变
    const changeMultipleOption = (evnt, checked, item) => {
      item._checked = checked;
      $xetable.checkFilterOptions();
    };
    // 筛选发生改变
    const changeOption = (evnt, checked, item) => {
      const {
        filterStore
      } = props;
      if (filterStore.multiple) {
        changeMultipleOption(evnt, checked, item);
      } else {
        changeRadioOption(evnt, checked, item);
      }
    };
    const changeAllOption = (evnt, checked) => {
      const {
        filterStore
      } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    /*************************
     * Publish methods
     *************************/
    const $panel = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    const renderOptions = (filterRender, compConf) => {
      const {
        filterStore
      } = props;
      const {
        column,
        multiple,
        maxHeight
      } = filterStore;
      const {
        slots
      } = column;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, {
        $panel,
        $table: $xetable
      });
      if (filterSlot) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-table--filter-template'
        }, $xetable.callSlot(filterSlot, params))];
      } else if (compConf && compConf.renderFilter) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-table--filter-template'
        }, getSlotVNs(compConf.renderFilter(filterRender, params)))];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some(item => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table--filter-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
        class: ['vxe-table--filter-option', {
          'is--checked': isAllChecked,
          'is--indeterminate': isAllIndeterminate
        }],
        title: conf.i18n(multiple ? 'vxe.table.allTitle' : 'vxe.table.allFilter'),
        onClick: evnt => {
          changeAllOption(evnt, !filterStore.isAllSelected);
        }
      }, (multiple ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isAllIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
      })] : []).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, conf.i18n('vxe.table.allFilter'))]))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table--filter-body',
        style: maxHeight ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, filterStore.options.map(item => {
        const isChecked = item._checked;
        const isIndeterminate = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          class: ['vxe-table--filter-option', {
            'is--checked': item._checked
          }],
          title: item.label,
          onClick: evnt => {
            changeOption(evnt, !item._checked, item);
          }
        }, (multiple ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', isIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
        })] : []).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, formatText(item.label, 1))]));
      }))];
    };
    const renderFooters = () => {
      const {
        filterStore
      } = props;
      const {
        column,
        multiple
      } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const filterRender = column.filterRender;
      const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (!compConf || compConf.showFilterFooter !== false) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--filter-footer'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: {
          'is--disabled': isDisabled
        },
        disabled: isDisabled,
        onClick: confirmFilter
      }, filterOpts.confirmButtonText || conf.i18n('vxe.table.confirmFilter')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        onClick: resetFilter
      }, filterOpts.resetButtonText || conf.i18n('vxe.table.resetFilter'))])] : [];
    };
    const renderVN = () => {
      const {
        filterStore
      } = props;
      const {
        initStore
      } = tableReactData;
      const {
        column
      } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.filterClassName : '';
      const params = Object.assign({}, tableInternalData._currFilterParams, {
        $panel,
        $table: $xetable
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-table--filter-wrapper', 'filter--prevent-default', getPropClass(filterClassName, params), {
          'is--animat': $xetable.props.animat,
          'is--multiple': filterStore.multiple,
          'is--active': filterStore.visible
        }],
        style: filterStore.style
      }, initStore.filter && filterStore.visible ? renderOptions(filterRender, compConf).concat(renderFooters()) : []);
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/filter/src/hook.ts






const tableFilterMethodKeys = ['setFilter', 'clearFilter', 'getCheckedFilters'];
const tableFilterHook = {
  setupTable($xetable) {
    const {
      props,
      reactData,
      internalData
    } = $xetable;
    const {
      refTableBody,
      refTableFilter
    } = $xetable.getRefMaps();
    const {
      computeFilterOpts,
      computeMouseOpts
    } = $xetable.getComputeMaps();
    const filterPrivateMethods = {
      checkFilterOptions() {
        const {
          filterStore
        } = reactData;
        filterStore.isAllSelected = filterStore.options.every(item => item._checked);
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some(item => item._checked);
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(evnt, column, params) {
        const {
          initStore,
          filterStore
        } = reactData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const {
            target: targetElem,
            pageX
          } = evnt;
          const {
            visibleWidth
          } = getDomNode();
          const {
            filters,
            filterMultiple,
            filterRender
          } = column;
          const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
          const filterRecoverMethod = column.filterRecoverMethod || (compConf ? compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          // 复原状态
          filterStore.options.forEach(option => {
            const {
              _checked,
              checked
            } = option;
            option._checked = checked;
            if (!checked && _checked !== checked) {
              if (filterRecoverMethod) {
                filterRecoverMethod({
                  option,
                  column,
                  $table: $xetable
                });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const tableBody = refTableBody.value;
            const bodyElem = tableBody.$el;
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.$el : null;
            let filterWidth = 0;
            let filterHeight = 0;
            let filterHeadElem = null;
            let filterFootElem = null;
            if (filterWrapperElem) {
              filterWidth = filterWrapperElem.offsetWidth;
              filterHeight = filterWrapperElem.offsetHeight;
              filterHeadElem = filterWrapperElem.querySelector('.vxe-table--filter-header');
              filterFootElem = filterWrapperElem.querySelector('.vxe-table--filter-footer');
            }
            const centerWidth = filterWidth / 2;
            const minMargin = 10;
            const maxLeft = bodyElem.clientWidth - filterWidth - minMargin;
            let left, right;
            const style = {
              top: `${targetElem.offsetTop + targetElem.offsetParent.offsetTop + targetElem.offsetHeight + 8}px`
            };
            // 判断面板不能大于表格高度
            let maxHeight = null;
            if (filterHeight >= bodyElem.clientHeight) {
              maxHeight = Math.max(60, bodyElem.clientHeight - (filterFootElem ? filterFootElem.offsetHeight : 0) - (filterHeadElem ? filterHeadElem.offsetHeight : 0));
            }
            if (column.fixed === 'left') {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth;
            } else if (column.fixed === 'right') {
              right = targetElem.offsetParent.offsetWidth - targetElem.offsetLeft + (targetElem.offsetParent.offsetParent.offsetWidth - targetElem.offsetParent.offsetLeft) - column.renderWidth - centerWidth;
            } else {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth - bodyElem.scrollLeft;
            }
            if (left) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                left -= overflowWidth;
              }
              style.left = `${Math.min(maxLeft, Math.max(minMargin, left))}px`;
            } else if (right) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                right += overflowWidth;
              }
              style.right = `${Math.max(minMargin, right)}px`;
            }
            filterStore.style = style;
            filterStore.maxHeight = maxHeight;
          });
        }
        $xetable.dispatchEvent('filter-visible', {
          column,
          field: column.field,
          property: column.field,
          filterList: $xetable.getCheckedFilters(),
          visible: filterStore.visible
        }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const {
            filters,
            filterRender
          } = column;
          if (filters) {
            const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
            const filterResetMethod = column.filterResetMethod || (compConf ? compConf.filterResetMethod : null);
            filters.forEach(item => {
              item._checked = false;
              item.checked = false;
              if (!filterResetMethod) {
                item.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(item.resetValue, true);
              }
            });
            if (filterResetMethod) {
              filterResetMethod({
                options: filters,
                column,
                $table: $xetable
              });
            }
          }
        }
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent(evnt) {
        const {
          mouseConfig
        } = props;
        const {
          filterStore,
          scrollXLoad: oldScrollXLoad,
          scrollYLoad: oldScrollYLoad
        } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const {
          column
        } = filterStore;
        const {
          field
        } = column;
        const values = [];
        const datas = [];
        column.filters.forEach(item => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xetable.getCheckedFilters();
        const params = {
          $table: $xetable,
          $event: evnt,
          column,
          field,
          property: field,
          values,
          datas,
          filters: filterList,
          filterList
        };
        // 如果是服务端筛选，则跳过本地筛选处理
        if (!filterOpts.remote) {
          $xetable.handleTableData(true);
          $xetable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xetable.handleFilterEvent) {
          $xetable.handleFilterEvent(evnt, params);
        }
        $xetable.dispatchEvent('filter-change', params, evnt);
        $xetable.closeFilter();
        $xetable.updateFooter().then(() => {
          const {
            scrollXLoad,
            scrollYLoad
          } = reactData;
          if (oldScrollXLoad || scrollXLoad || oldScrollYLoad || scrollYLoad) {
            if (oldScrollXLoad || scrollXLoad) {
              $xetable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xetable.updateScrollYSpace();
            }
            return $xetable.refreshScroll();
          }
        }).then(() => {
          $xetable.updateCellAreas();
          return $xetable.recalculate(true);
        }).then(() => {
          // 存在滚动行为未结束情况
          setTimeout(() => $xetable.recalculate(), 50);
        });
      }
    };
    const filterMethods = {
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.filters) {
          const {
            elemStore
          } = internalData;
          const {
            fixed
          } = column;
          return $xetable.scrollToColumn(column).then(() => {
            const headerWrapperRef = elemStore[`${fixed || 'main'}-header-wrapper`] || elemStore['main-header-wrapper'];
            const headerWrapperElem = headerWrapperRef ? headerWrapperRef.value : null;
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-filter--btn`);
              triggerEvent(filterBtnElem, 'click');
            }
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(fieldOrColumn, options) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || []);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(fieldOrColumn) {
        const {
          filterStore
        } = reactData;
        const {
          tableFullColumn
        } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xetable, fieldOrColumn);
          if (column) {
            filterPrivateMethods.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach(filterPrivateMethods.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xetable.updateData();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getCheckedFilters() {
        const {
          tableFullColumn
        } = internalData;
        const filterList = [];
        tableFullColumn.forEach(column => {
          const {
            field,
            filters
          } = column;
          const valueList = [];
          const dataList = [];
          if (filters && filters.length) {
            filters.forEach(item => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({
                column,
                field,
                property: field,
                values: valueList,
                datas: dataList
              });
            }
          }
        });
        return filterList;
      }
    };
    return {
      ...filterMethods,
      ...filterPrivateMethods
    };
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableFilterMethodKeys);
  }
};
/* harmony default export */ var hook = (tableFilterHook);
;// CONCATENATED MODULE: ./packages/dynamics/index.ts

let dynamicContainerElem;
const dynamicStore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  modals: [],
  drawers: []
});
/**
 * 动态组件
 */
const VxeDynamics = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  setup() {
    return () => {
      const {
        modals,
        drawers
      } = dynamicStore;
      return [modals.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-dynamics--modal'
      }, modals.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-modal'), item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), drawers.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-dynamics--drawer'
      }, drawers.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-drawer'), item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
    };
  }
});
const dynamicApp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createApp)(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement('div');
    dynamicContainerElem.className = 'vxe-dynamics';
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}
;// CONCATENATED MODULE: ./packages/filter/index.ts




const VxeTableFilterModule = {
  Panel: panel,
  install(app) {
    VXETable.hooks.add('$tableFilter', hook);
    app.component(panel.name, panel);
  }
};
const Filter = VxeTableFilterModule;
dynamicApp.component(panel.name, panel);
/* harmony default export */ var filter = ((/* unused pure expression or super */ null && (VxeTableFilterModule)));
;// CONCATENATED MODULE: ./packages/menu/src/panel.ts



/* harmony default export */ var src_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableMenuPanel',
  setup(props, context) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const {
      reactData: tableReactData
    } = $xetable;
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xemenupanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const {
        ctxMenuStore
      } = tableReactData;
      const {
        computeMenuOpts
      } = $xetable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: false
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--context-menu-wrapper', menuOpts.className, {
          'is--visible': ctxMenuStore.visible
        }],
        style: ctxMenuStore.style
      }, ctxMenuStore.list.map((options, gIndex) => {
        return options.every(item => item.visible === false) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
          class: 'vxe-context-menu--option-wrapper',
          key: gIndex
        }, options.map((item, index) => {
          const hasChildMenus = item.children && item.children.some(child => child.visible !== false);
          return item.visible === false ? null : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            class: [item.className, {
              'link--disabled': item.disabled,
              'link--active': item === ctxMenuStore.selected
            }],
            key: `${gIndex}_${index}`
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
            class: 'vxe-context-menu--link',
            onClick(evnt) {
              $xetable.ctxMenuLinkEvent(evnt, item);
            },
            onMouseover(evnt) {
              $xetable.ctxMenuMouseoverEvent(evnt, item);
            },
            onMouseout(evnt) {
              $xetable.ctxMenuMouseoutEvent(evnt, item);
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: ['vxe-context-menu--link-prefix', item.prefixIcon]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-context-menu--link-content'
          }, getFuncText(item.name)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: ['vxe-context-menu--link-suffix', hasChildMenus ? item.suffixIcon || 'suffix--haschild' : item.suffixIcon]
          })]), hasChildMenus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: ['vxe-table--context-menu-clild-wrapper', {
              'is--show': item === ctxMenuStore.selected && ctxMenuStore.showChild
            }]
          }, item.children.map((child, cIndex) => {
            return child.visible === false ? null : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
              class: [child.className, {
                'link--disabled': child.disabled,
                'link--active': child === ctxMenuStore.selectChild
              }],
              key: `${gIndex}_${index}_${cIndex}`
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
              class: 'vxe-context-menu--link',
              onClick(evnt) {
                $xetable.ctxMenuLinkEvent(evnt, child);
              },
              onMouseover(evnt) {
                $xetable.ctxMenuMouseoverEvent(evnt, item, child);
              },
              onMouseout(evnt) {
                $xetable.ctxMenuMouseoutEvent(evnt, item);
              }
            }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: ['vxe-context-menu--link-prefix', child.prefixIcon]
            }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
              class: 'vxe-context-menu--link-content'
            }, getFuncText(child.name))])]);
          })) : null]);
        }));
      }))]);
    };
    $xemenupanel.renderVN = renderVN;
    return $xemenupanel;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tools/event.ts



const EVENT_KEYS = {
  F2: 'F2',
  ESCAPE: 'Escape',
  ENTER: 'Enter',
  TAB: 'Tab',
  DELETE: 'Delete',
  BACKSPACE: 'Backspace',
  SPACEBAR: ' ',
  CONTEXT_MENU: 'ContextMenu',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  PAGE_UP: 'PageUp',
  PAGE_DOWN: 'PageDown'
};
const convertEventKeys = {
  ' ': 'Spacebar',
  Apps: EVENT_KEYS.CONTEXT_MENU,
  Del: EVENT_KEYS.DELETE,
  Up: EVENT_KEYS.ARROW_UP,
  Down: EVENT_KEYS.ARROW_DOWN,
  Left: EVENT_KEYS.ARROW_LEFT,
  Right: EVENT_KEYS.ARROW_RIGHT
};
// 监听全局事件
const wheelName = browse.firefox ? 'DOMMouseScroll' : 'mousewheel';
const eventStore = [];
const hasEventKey = (evnt, targetKey) => {
  const {
    key
  } = evnt;
  targetKey = targetKey.toLowerCase();
  return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
};
function event_triggerEvent(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({
    type,
    cb
  }) => {
    // 如果被取消冒泡，不再执行
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === 'mousewheel') {
        cb(evnt);
      }
    }
  });
}
const GlobalEvent = {
  on(comp, type, cb) {
    eventStore.push({
      comp,
      type,
      cb
    });
  },
  off(comp, type) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eventStore, item => item.comp === comp && item.type === type);
  },
  trigger: event_triggerEvent,
  eqKeypad(evnt, keyVal) {
    const {
      key
    } = evnt;
    if (keyVal.toLowerCase() === key.toLowerCase()) {
      return true;
    }
    return false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener('copy', event_triggerEvent, false);
    window.addEventListener('cut', event_triggerEvent, false);
    window.addEventListener('paste', event_triggerEvent, false);
  }
  document.addEventListener('keydown', event_triggerEvent, false);
  document.addEventListener('contextmenu', event_triggerEvent, false);
  window.addEventListener('mousedown', event_triggerEvent, false);
  window.addEventListener('blur', event_triggerEvent, false);
  window.addEventListener('resize', event_triggerEvent, false);
  window.addEventListener(wheelName, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(event_triggerEvent, 100, {
    leading: true,
    trailing: false
  }), {
    passive: true,
    capture: false
  });
}
;// CONCATENATED MODULE: ./packages/menu/src/hooks.ts






const tableMenuMethodKeys = ['closeMenu'];
const tableMenuHook = {
  setupTable($xetable) {
    const {
      xID,
      props,
      reactData,
      internalData
    } = $xetable;
    const {
      refElem,
      refTableFilter,
      refTableMenu
    } = $xetable.getRefMaps();
    const {
      computeMouseOpts,
      computeIsMenu,
      computeMenuOpts
    } = $xetable.getComputeMaps();
    let menuMethods = {};
    let menuPrivateMethods = {};
    /**
     * 显示快捷菜单
     */
    const handleOpenMenuEvent = (evnt, type, params) => {
      const {
        ctxMenuStore
      } = reactData;
      const isMenu = computeIsMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config = menuOpts[type];
      const visibleMethod = menuOpts.visibleMethod;
      if (config) {
        const {
          options,
          disabled
        } = config;
        if (disabled) {
          evnt.preventDefault();
        } else if (isMenu && options && options.length) {
          params.options = options;
          $xetable.preventEvent(evnt, 'event.showMenu', params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xetable.updateZindex();
              const {
                scrollTop,
                scrollLeft,
                visibleHeight,
                visibleWidth
              } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const {
                    boundingTop,
                    boundingLeft
                  } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const {
                keyboard,
                row,
                column
              } = params;
              if (keyboard && row && column) {
                $xetable.scrollToRow(row, column).then(() => {
                  const cell = $xetable.getCell(row, column);
                  if (cell) {
                    const {
                      boundingTop,
                      boundingLeft
                    } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xetable.closeFilter();
    };
    menuMethods = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    menuPrivateMethods = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(menuList, item => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN)) {
          for (let index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (hasEventKey(evnt, EVENT_KEYS.ENTER) || hasEventKey(evnt, EVENT_KEYS.SPACEBAR))) {
          menuPrivateMethods.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(evnt) {
        const {
          mouseConfig,
          menuConfig
        } = props;
        const {
          editStore,
          ctxMenuStore
        } = reactData;
        const {
          visibleColumn
        } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el = refElem.value;
        const {
          selected
        } = editStore;
        const layoutList = ['header', 'body', 'footer'];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = 'body';
            const params = {
              type,
              $table: $xetable,
              keyboard: true,
              columns: visibleColumn.slice(0),
              $event: evnt
            };
            // 如果开启单元格区域
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xetable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              // 如果启用键盘导航且已选中单元格
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          // 分别匹配表尾、内容、表尾的快捷菜单
          for (let index = 0; index < layoutList.length; index++) {
            const layout = layoutList[index];
            const columnTargetNode = getEventTargetNode(evnt, el, `vxe-${layout}--column`, target => {
              // target=td|th，直接向上找 table 去匹配即可
              return target.parentNode.parentNode.parentNode.getAttribute('xid') === xID;
            });
            const params = {
              type: layout,
              $table: $xetable,
              columns: visibleColumn.slice(0),
              $event: evnt
            };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xetable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, {
                  column,
                  columnIndex: $xetable.getColumnIndex(column),
                  cell
                });
              }
              if (layout === 'body') {
                const rowNodeRest = $xetable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = '';
                if (row) {
                  params.row = row;
                  params.rowIndex = $xetable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xetable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el, `vxe-table--${layout}-wrapper`, target => target.getAttribute('xid') === xID).flag) {
              if (menuOpts.trigger === 'cell') {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.$el).flag) {
          $xetable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const {
          ctxMenuStore
        } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const {
                  boundingTop,
                  boundingLeft,
                  visibleHeight,
                  visibleWidth
                } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = '';
                let right = '';
                // 是否超出右侧
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = 'auto';
                  right = `${menuElem.offsetWidth}px`;
                }
                // 是否超出底部
                let top = '';
                let bottom = '';
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = 'auto';
                  bottom = '0';
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const {
          ctxMenuStore
        } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(evnt, menu) {
        // 如果一级菜单有配置 code 则允许点击，否则不能点击
        if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = VXETable.menus.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, {
            menu,
            $table: $xetable,
            $grid: $xetable.xegrid,
            $event: evnt
          });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xetable.dispatchEvent('menu-click', params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return {
      ...menuMethods,
      ...menuPrivateMethods
    };
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableMenuMethodKeys);
  }
};
/* harmony default export */ var src_hooks = (tableMenuHook);
;// CONCATENATED MODULE: ./packages/menu/index.ts




const VxeTableMenuModule = {
  Panel: src_panel,
  install(app) {
    VXETable.hooks.add('$tableMenu', src_hooks);
    app.component(src_panel.name, src_panel);
  }
};
const Menu = VxeTableMenuModule;
dynamicApp.component(src_panel.name, src_panel);
/* harmony default export */ var menu = ((/* unused pure expression or super */ null && (VxeTableMenuModule)));
;// CONCATENATED MODULE: ./packages/edit/src/hook.ts









const tableEditMethodKeys = ['insert', 'insertAt', 'insertNextAt', 'remove', 'removeCheckboxRow', 'removeRadioRow', 'removeCurrentRow', 'getRecordset', 'getInsertRecords', 'getRemoveRecords', 'getUpdateRecords', 'getEditRecord', 'getActiveRecord', 'getSelectedCell', 'clearEdit', 'clearActived', 'clearSelected', 'isEditByRow', 'isActiveByRow', 'setEditRow', 'setActiveRow', 'setEditCell', 'setActiveCell', 'setSelectCell'];
const editHook = {
  setupTable($xetable) {
    const {
      props,
      reactData,
      internalData
    } = $xetable;
    const {
      refElem
    } = $xetable.getRefMaps();
    const {
      computeMouseOpts,
      computeEditOpts,
      computeCheckboxOpts,
      computeTreeOpts
    } = $xetable.getComputeMaps();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const {
        model,
        editRender
      } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const {
        model,
        editRender
      } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el = refElem.value;
      if (el) {
        const cell = el.querySelector('.col--selected');
        if (cell) {
          removeClass(cell, 'col--selected');
        }
      }
    };
    function syncActivedCell() {
      const {
        editStore,
        tableColumn
      } = reactData;
      const editOpts = computeEditOpts.value;
      const {
        actived
      } = editStore;
      const {
        row,
        column
      } = actived;
      if (row || column) {
        if (editOpts.mode === 'row') {
          tableColumn.forEach(column => setEditColumnModel(row, column));
        } else {
          setEditColumnModel(row, column);
        }
      }
    }
    function insertTreeRow(newRecords, isAppend) {
      const {
        tableFullTreeData,
        afterFullData,
        fullDataRowIdData,
        fullAllDataRowIdData
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        rowField,
        parentField,
        mapChildrenField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? 'push' : 'unshift';
      newRecords.forEach(item => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xetable, item);
        const matchObj = parentRowId ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => parentRowId === item[rowField], {
          children: mapChildrenField
        }) : null;
        if (matchObj) {
          const {
            item: parentRow
          } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let parentChilds = parentRow[childrenField];
          let mapChilds = parentRow[mapChildrenField];
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(parentChilds)) {
            parentChilds = parentRow[childrenField] = [];
          }
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(mapChilds)) {
            mapChilds = parentRow[childrenField] = [];
          }
          parentChilds[funcName](item);
          mapChilds[funcName](item);
          const rest = {
            row: item,
            rowid,
            seq: -1,
            index: -1,
            _index: -1,
            $index: -1,
            items: parentChilds,
            parent: parentRow,
            level: parentLevel + 1
          };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (true) {
            if (parentRowId) {
              warnLog('vxe.error.unableInsert');
            }
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = {
            row: item,
            rowid,
            seq: -1,
            index: -1,
            _index: -1,
            $index: -1,
            items: tableFullTreeData,
            parent: null,
            level: 0
          };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    }
    const handleInsertRowAt = (records, row, isInsertNextRow) => {
      const {
        treeConfig
      } = props;
      const {
        mergeList,
        editStore
      } = reactData;
      const {
        tableFullTreeData,
        afterFullData,
        tableFullData,
        fullDataRowIdData,
        fullAllDataRowIdData
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        transform,
        rowField,
        mapChildrenField
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
        records = [records];
      }
      const newRecords = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)($xetable.defineField(records.map(record => Object.assign(treeConfig && transform ? {
        [mapChildrenField]: [],
        [childrenField]: []
      } : {}, record))));
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(row)) {
        // 如果为虚拟树
        if (treeConfig && transform) {
          insertTreeRow(newRecords, false);
        } else {
          afterFullData.unshift(...newRecords);
          tableFullData.unshift(...newRecords);
          // 刷新单元格合并
          mergeList.forEach(mergeItem => {
            const {
              row: mergeRowIndex
            } = mergeItem;
            if (mergeRowIndex > 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (row === -1) {
          // 如果为虚拟树
          if (treeConfig && transform) {
            insertTreeRow(newRecords, true);
          } else {
            afterFullData.push(...newRecords);
            tableFullData.push(...newRecords);
            // 刷新单元格合并
            mergeList.forEach(mergeItem => {
              const {
                row: mergeRowIndex,
                rowspan: mergeRowspan
              } = mergeItem;
              if (mergeRowIndex + mergeRowspan > afterFullData.length) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        } else {
          // 如果为虚拟树
          if (treeConfig && transform) {
            const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => row[rowField] === item[rowField], {
              children: mapChildrenField
            });
            if (matchMapObj) {
              const {
                parent: parentRow
              } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              newRecords.forEach((item, i) => {
                const rowid = getRowid($xetable, item);
                if (true) {
                  if (item[treeOpts.parentField]) {
                    if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                      errLog('vxe.error.errProp', [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
                    }
                  }
                }
                if (parentRow) {
                  item[treeOpts.parentField] = parentRow[rowField];
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, item);
                const rest = {
                  row: item,
                  rowid,
                  seq: -1,
                  index: -1,
                  _index: -1,
                  $index: -1,
                  items: parentMapChilds,
                  parent: parentRow,
                  level: parentLevel + 1
                };
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              });
              // 源
              if (parentRow) {
                const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => row[rowField] === item[rowField], {
                  children: childrenField
                });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...newRecords);
                }
              }
            } else {
              if (true) {
                warnLog('vxe.error.unableInsert');
              }
              insertTreeRow(newRecords, true);
            }
          } else {
            if (treeConfig) {
              throw new Error(getLog('vxe.error.noTree', ['insert']));
            }
            let afIndex = -1;
            // 如果是可视索引
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)) {
              if (row < afterFullData.length) {
                afIndex = row;
              }
            } else {
              afIndex = $xetable.findRowIndexOf(afterFullData, row);
            }
            // 如果是插入指定行的下一行
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(errLog('vxe.error.unableInsert'));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            tableFullData.splice($xetable.findRowIndexOf(tableFullData, row), 0, ...newRecords);
            // 刷新单元格合并
            mergeList.forEach(mergeItem => {
              const {
                row: mergeRowIndex,
                rowspan: mergeRowspan
              } = mergeItem;
              if (mergeRowIndex > afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      const {
        insertMaps
      } = editStore;
      newRecords.forEach(newRow => {
        const rowid = getRowid($xetable, newRow);
        insertMaps[rowid] = newRow;
      });
      $xetable.cacheRowMap();
      $xetable.updateScrollYStatus();
      $xetable.handleTableData(treeConfig && transform);
      if (!(treeConfig && transform)) {
        $xetable.updateAfterDataIndex();
      }
      $xetable.updateFooter();
      $xetable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xetable.updateScrollYSpace();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        $xetable.updateCellAreas();
        return $xetable.recalculate();
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    editMethods = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} row 指定行
       */
      insertAt(records, row) {
        return handleInsertRowAt(records, row);
      },
      insertNextAt(records, row) {
        return handleInsertRowAt(records, row, true);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(rows) {
        const {
          treeConfig
        } = props;
        const {
          mergeList,
          editStore,
          selectCheckboxMaps
        } = reactData;
        const {
          tableFullTreeData,
          afterFullData,
          tableFullData
        } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const {
          transform,
          mapChildrenField
        } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const {
          actived,
          removeMaps,
          insertMaps
        } = editStore;
        const {
          checkField
        } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
          rows = [rows];
        }
        // 如果是新增，则保存记录
        rows.forEach(row => {
          if (!$xetable.isInsertByRow(row)) {
            const rowid = getRowid($xetable, row);
            removeMaps[rowid] = row;
          }
        });
        // 如果绑定了多选属性，则更新状态
        if (!checkField) {
          const selectRowMaps = {
            ...selectCheckboxMaps
          };
          rows.forEach(row => {
            const rowid = getRowid($xetable, row);
            if (selectRowMaps[rowid]) {
              delete selectRowMaps[rowid];
            }
          });
          reactData.selectCheckboxMaps = selectRowMaps;
        }
        // 从数据源中移除
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xetable.clearMergeCells();
        } else {
          // 如果为虚拟树
          if (treeConfig && transform) {
            rows.forEach(row => {
              const rowid = getRowid($xetable, row);
              const matchMapObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid($xetable, item), {
                children: mapChildrenField
              });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullTreeData, item => rowid === getRowid($xetable, item), {
                children: childrenField
              });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xetable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else {
            rows.forEach(row => {
              const tfIndex = $xetable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xetable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                // 刷新单元格合并
                mergeList.forEach(mergeItem => {
                  const {
                    row: mergeRowIndex,
                    rowspan: mergeRowspan
                  } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        // 如果当前行被激活编辑，则清除激活状态
        if (actived.row && $xetable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        // 从新增中移除已删除的数据
        rows.forEach(row => {
          const rowid = getRowid($xetable, row);
          if (insertMaps[rowid]) {
            delete insertMaps[rowid];
          }
        });
        $xetable.updateFooter();
        $xetable.cacheRowMap();
        $xetable.handleTableData(treeConfig && transform);
        if (!(treeConfig && transform)) {
          $xetable.updateAfterDataIndex();
        }
        $xetable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xetable.updateScrollYSpace();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          $xetable.updateCellAreas();
          return $xetable.recalculate();
        }).then(() => {
          return {
            row: delList.length ? delList[delList.length - 1] : null,
            rows: delList
          };
        });
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return editMethods.remove($xetable.getCheckboxRecords()).then(params => {
          $xetable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const radioRecord = $xetable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then(params => {
          $xetable.clearRadioRow();
          return params;
        });
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const currentRecord = $xetable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then(params => {
          $xetable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords: editMethods.getRemoveRecords(),
          updateRecords: editMethods.getUpdateRecords(),
          pendingRecords: $xetable.getPendingRecords()
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const {
          editStore
        } = reactData;
        const {
          fullAllDataRowIdData
        } = internalData;
        const {
          insertMaps
        } = editStore;
        const insertRecords = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(insertMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const {
          editStore
        } = reactData;
        const {
          removeMaps
        } = editStore;
        const removeRecords = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(removeMaps, row => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const {
          keepSource,
          treeConfig
        } = props;
        const {
          tableFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(tableFullData, row => $xetable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter(row => $xetable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        if (true) {
          warnLog('vxe.error.delFunc', ['getActiveRecord', 'getEditRecord']);
        }
        return this.getEditRecord();
      },
      getEditRecord() {
        const {
          editStore
        } = reactData;
        const {
          afterFullData
        } = internalData;
        const el = refElem.value;
        const {
          args,
          row
        } = editStore.actived;
        if (args && $xetable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll('.vxe-body--column.col--active').length) {
          return Object.assign({}, args);
        }
        return null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const {
          editStore
        } = reactData;
        const {
          args,
          column
        } = editStore.selected;
        if (args && column) {
          return Object.assign({}, args);
        }
        return null;
      },
      clearActived(evnt) {
        // 即将废弃
        if (true) {
          warnLog('vxe.error.delFunc', ['clearActived', 'clearEdit']);
        }
        return this.clearEdit(evnt);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(evnt) {
        const {
          editStore
        } = reactData;
        const {
          actived,
          focused
        } = editStore;
        const {
          row,
          column
        } = actived;
        if (row || column) {
          syncActivedCell();
          actived.args = null;
          actived.row = null;
          actived.column = null;
          $xetable.updateFooter();
          $xetable.dispatchEvent('edit-closed', {
            row,
            rowIndex: $xetable.getRowIndex(row),
            $rowIndex: $xetable.getVMRowIndex(row),
            column,
            columnIndex: $xetable.getColumnIndex(column),
            $columnIndex: $xetable.getVMColumnIndex(column)
          }, evnt || null);
        }
        if (conf.cellVaildMode === 'obsolete') {
          if ($xetable.clearValidate) {
            return $xetable.clearValidate();
          }
        }
        focused.row = null;
        focused.column = null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const {
          editStore
        } = reactData;
        const {
          selected
        } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      isActiveByRow(row) {
        if (true) {
          warnLog('vxe.error.delFunc', ['isActiveByRow', 'isEditByRow']);
        }
        // 即将废弃
        return this.isEditByRow(row);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(row) {
        const {
          editStore
        } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        if (true) {
          warnLog('vxe.error.delFunc', ['setActiveRow', 'setEditRow']);
        }
        // 即将废弃
        return editMethods.setEditRow(row);
      },
      /**
       * 激活行编辑
       */
      setEditRow(row, fieldOrColumn) {
        const {
          visibleColumn
        } = internalData;
        let column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(visibleColumn, column => isEnableConf(column.editRender));
        if (fieldOrColumn) {
          column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        }
        return $xetable.setEditCell(row, column);
      },
      setActiveCell(row, fieldOrColumn) {
        if (true) {
          warnLog('vxe.error.delFunc', ['setActiveCell', 'setEditCell']);
        }
        // 即将废弃
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(row, fieldOrColumn) {
        const {
          editConfig
        } = props;
        const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {
          return $xetable.scrollToRow(row, column).then(() => {
            const cell = $xetable.getCell(row, column);
            if (cell) {
              editPrivateMethods.handleActived({
                row,
                rowIndex: $xetable.getRowIndex(row),
                column,
                columnIndex: $xetable.getColumnIndex(column),
                cell,
                $table: $xetable
              });
              internalData._lastCallTime = Date.now();
            }
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(row, fieldOrColumn) {
        const {
          tableData
        } = reactData;
        const editOpts = computeEditOpts.value;
        const column = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== 'manual') {
          const rowIndex = $xetable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xetable.getCell(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xetable.getColumnIndex(column),
              cell
            };
            $xetable.handleSelected(params, {});
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    editPrivateMethods = {
      /**
       * 处理激活编辑
       */
      handleActived(params, evnt) {
        const {
          editConfig,
          mouseConfig
        } = props;
        const {
          editStore,
          tableColumn
        } = reactData;
        const editOpts = computeEditOpts.value;
        const {
          mode
        } = editOpts;
        const {
          actived,
          focused
        } = editStore;
        const {
          row,
          column
        } = params;
        const {
          editRender
        } = column;
        const cell = params.cell || $xetable.getCell(row, column);
        const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
        params.cell = cell;
        if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
          // 激活编辑
          if (!$xetable.hasPendingByRow(row)) {
            if (actived.row !== row || (mode === 'cell' ? actived.column !== column : false)) {
              // 判断是否禁用编辑
              let type = 'edit-disabled';
              if (!beforeEditMethod || beforeEditMethod({
                ...params,
                $table: $xetable,
                $grid: $xetable.xegrid
              })) {
                if (mouseConfig) {
                  editMethods.clearSelected();
                  if ($xetable.clearCellAreas) {
                    $xetable.clearCellAreas();
                    $xetable.clearCopyCellArea();
                  }
                }
                $xetable.closeTooltip();
                if (actived.column) {
                  editMethods.clearEdit(evnt);
                }
                type = 'edit-activated';
                column.renderHeight = cell.offsetHeight;
                actived.args = params;
                actived.row = row;
                actived.column = column;
                if (mode === 'row') {
                  tableColumn.forEach(column => getEditColumnModel(row, column));
                } else {
                  getEditColumnModel(row, column);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                  editPrivateMethods.handleFocus(params, evnt);
                  if (afterEditMethod) {
                    afterEditMethod({
                      ...params,
                      $table: $xetable,
                      $grid: $xetable.xegrid
                    });
                  }
                });
              }
              $xetable.dispatchEvent(type, {
                row,
                rowIndex: $xetable.getRowIndex(row),
                $rowIndex: $xetable.getVMRowIndex(row),
                column,
                columnIndex: $xetable.getColumnIndex(column),
                $columnIndex: $xetable.getVMColumnIndex(column)
              }, evnt);
              // v4已废弃
              if (type === 'edit-activated') {
                $xetable.dispatchEvent('edit-actived', {
                  row,
                  rowIndex: $xetable.getRowIndex(row),
                  $rowIndex: $xetable.getVMRowIndex(row),
                  column,
                  columnIndex: $xetable.getColumnIndex(column),
                  $columnIndex: $xetable.getVMColumnIndex(column)
                }, evnt);
              }
            } else {
              const {
                column: oldColumn
              } = actived;
              if (mouseConfig) {
                editMethods.clearSelected();
                if ($xetable.clearCellAreas) {
                  $xetable.clearCellAreas();
                  $xetable.clearCopyCellArea();
                }
              }
              if (oldColumn !== column) {
                const {
                  model: oldModel
                } = oldColumn;
                if (oldModel.update) {
                  setCellValue(row, oldColumn, oldModel.value);
                }
                if ($xetable.clearValidate) {
                  $xetable.clearValidate(row, column);
                }
              }
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.column = column;
              setTimeout(() => {
                editPrivateMethods.handleFocus(params, evnt);
              });
            }
            focused.column = null;
            focused.row = null;
            $xetable.focus();
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 处理聚焦
       */
      handleFocus(params) {
        const {
          row,
          column,
          cell
        } = params;
        const {
          editRender
        } = column;
        if (isEnableConf(editRender)) {
          const compRender = renderer.get(editRender.name);
          let {
            autofocus,
            autoselect
          } = editRender;
          let inputElem;
          if (!autofocus && compRender) {
            autofocus = compRender.autofocus;
          }
          if (!autoselect && compRender) {
            autoselect = compRender.autoselect;
          }
          // 如果指定了聚焦 class
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(autofocus)) {
            inputElem = autofocus.call(this, params);
          } else if (autofocus) {
            inputElem = cell.querySelector(autofocus);
            if (inputElem) {
              inputElem.focus();
            }
          }
          if (inputElem) {
            if (autoselect) {
              inputElem.select();
            } else {
              // 保持一致行为，光标移到末端
              if (browse.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            // 显示到可视区中
            $xetable.scrollToRow(row, column);
          }
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(params, evnt) {
        const {
          mouseConfig
        } = props;
        const {
          editStore
        } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const {
          actived,
          selected
        } = editStore;
        const {
          row,
          column
        } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === 'cell' ? actived.column !== column : false)) {
              editMethods.clearEdit(evnt);
              editMethods.clearSelected();
              if ($xetable.clearCellAreas) {
                $xetable.clearCellAreas();
                $xetable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xetable.focus();
              if (evnt) {
                $xetable.dispatchEvent('cell-selected', params, evnt);
              }
            }
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const {
          editStore
        } = reactData;
        const {
          selected
        } = editStore;
        const {
          row,
          column
        } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xetable.getCell(row, column);
          if (cell) {
            addClass(cell, 'col--selected');
          }
        }
      }
    };
    return {
      ...editMethods,
      ...editPrivateMethods
    };
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableEditMethodKeys);
  }
};
/* harmony default export */ var src_hook = (editHook);
;// CONCATENATED MODULE: ./packages/edit/index.ts


const VxeTableEditModule = {
  install() {
    VXETable.hooks.add('$tableEdit', src_hook);
  }
};
const Edit = VxeTableEditModule;
/* harmony default export */ var edit = ((/* unused pure expression or super */ null && (VxeTableEditModule)));
;// CONCATENATED MODULE: ./packages/hooks/size.ts

function useSize(props) {
  // 组件尺寸上下文
  const xesize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xesize', null);
  const computeSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.size || (xesize ? xesize.value : null);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xesize', computeSize);
  return computeSize;
}
;// CONCATENATED MODULE: ./packages/button/src/button.ts








/* harmony default export */ var src_button = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeButton',
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: {
      type: String,
      default: () => conf.button.size || conf.size
    },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的图标
     */
    icon: String,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: Boolean,
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: {
      type: Boolean,
      default: () => conf.button.transfer
    }
  },
  emits: ['click', 'mouseenter', 'mouseleave', 'dropdown-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      showPanel: false,
      animatVisible: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ''
    });
    const internalData = {
      showTime: null
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBtnPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xebutton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const $xebuttonggroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xebuttongroup', null);
    let buttonMethods = {};
    const computeIsFormBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      if (type) {
        return ['submit', 'reset', 'button'].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        mode
      } = props;
      if (mode === 'text' || type === 'text' || $xebuttonggroup && $xebuttonggroup.props.mode === 'text') {
        return 'text';
      }
      return 'button';
    });
    const computeBtnStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        status
      } = props;
      if (status) {
        return status;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.status;
      }
      return '';
    });
    const computeBtnRound = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        round
      } = props;
      if (round) {
        return round;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        circle
      } = props;
      if (circle) {
        return circle;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.circle;
      }
      return false;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          transfer,
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const targetElem = refButton.value;
        const panelElem = refBtnPanel.value;
        if (panelElem && targetElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            top,
            left,
            boundingTop,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(targetElem);
          let panelPlacement = 'bottom';
          if (transfer) {
            let btnLeft = left + targetWidth - panelWidth;
            let btnTop = top + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              btnTop = top - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                btnTop = top - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (btnTop < marginSize) {
                panelPlacement = 'bottom';
                btnTop = top + targetHeight;
              }
            }
            // 如果溢出右边
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${btnLeft}px`,
              right: 'auto',
              top: `${btnTop}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const clickEvent = evnt => {
      if ($xebuttonggroup) {
        $xebuttonggroup.handleClick({
          name: props.name
        }, evnt);
      } else {
        buttonMethods.dispatchEvent('click', {
          $event: evnt
        }, evnt);
      }
    };
    const mousedownDropdownEvent = evnt => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = evnt => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const {
        flag,
        targetElem
      } = getEventTargetNode(evnt, dropdownElem, 'vxe-button');
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = 'N';
        }
        reactData.showPanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== 'Y') {
            reactData.animatVisible = false;
          }
        }, 350);
        buttonMethods.dispatchEvent('dropdown-click', {
          name: targetElem.getAttribute('name'),
          $event: evnt
        }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        reactData.animatVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            reactData.showPanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.showPanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = evnt => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        if (!reactData.inited) {
          reactData.inited = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            mouseenterDropdownEvent();
          } else {
            reactData.animatVisible = false;
          }
        }, 250);
      }
      mouseenterEvent(evnt);
    };
    const mouseleaveTargetEvent = evnt => {
      closePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = evnt => {
      emit('mouseenter', {
        $event: evnt
      });
    };
    const mouseleaveEvent = evnt => {
      emit('mouseleave', {
        $event: evnt
      });
    };
    const closePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = 'N';
        setTimeout(() => {
          if (panelElem.dataset.active !== 'Y') {
            reactData.showPanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== 'Y') {
                reactData.animatVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.animatVisible = false;
        reactData.showPanel = false;
      }
    };
    const mouseleaveDropdownEvent = () => {
      closePanel();
    };
    const renderContent = () => {
      const {
        content,
        icon,
        loading
      } = props;
      const contVNs = [];
      if (loading) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--loading-icon', conf.icon.BUTTON_LOADING]
        }));
      } else if (slots.icon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--custom-icon'
        }, slots.icon({})));
      } else if (icon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--icon', icon]
        }));
      }
      if (slots.default) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--content'
        }, slots.default({})));
      } else if (content) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--content'
        }, getFuncText(content)));
      }
      return contVNs;
    };
    buttonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $button: $xebutton,
          $event: evnt
        }, params));
      },
      focus() {
        const btnElem = refButton.value;
        btnElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xebutton, buttonMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      // if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {
      //   if (props.type === 'text') {
      //     warnLog('vxe.error.delProp', ['type=text', 'mode=text'])
      //   }
      // }
      GlobalEvent.on($xebutton, 'mousewheel', evnt => {
        const panelElem = refBtnPanel.value;
        if (reactData.showPanel && !getEventTargetNode(evnt, panelElem).flag) {
          closePanel();
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      GlobalEvent.off($xebutton, 'mousewheel');
    });
    const renderVN = () => {
      const {
        className,
        popupClassName,
        transfer,
        title,
        type,
        destroyOnClose,
        name,
        disabled,
        loading
      } = props;
      const {
        inited,
        showPanel
      } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnCircle = computeBtnCircle.value;
      const vSize = computeSize.value;
      if (slots.dropdowns) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-button--dropdown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xebutton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            'is--active': showPanel
          }]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          ref: refButton,
          class: ['vxe-button', `type--${btnMode}`, {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': disabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: disabled || loading,
          onMouseenter: mouseenterTargetEvent,
          onMouseleave: mouseleaveTargetEvent,
          onClick: clickEvent
        }, renderContent().concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: `vxe-button--dropdown-arrow ${conf.icon.BUTTON_DROPDOWN}`
        })])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: transfer ? !inited : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refBtnPanel,
          class: ['vxe-button--dropdown-panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
            $button: $xebutton
          }) : popupClassName : '', {
            [`size--${vSize}`]: vSize,
            'animat--leave': reactData.animatVisible,
            'animat--enter': showPanel
          }],
          placement: reactData.panelPlacement,
          style: reactData.panelStyle
        }, inited ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-button--dropdown-wrapper',
          onMousedown: mousedownDropdownEvent,
          onClick: clickDropdownEvent,
          onMouseenter: mouseenterDropdownEvent,
          onMouseleave: mouseleaveDropdownEvent
        }, destroyOnClose && !showPanel ? [] : slots.dropdowns({}))] : [])])]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: ['vxe-button', `type--${btnMode}`, className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $button: $xebutton
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          'is--round': btnRound,
          'is--circle': btnCircle,
          'is--disabled': disabled || loading,
          'is--loading': loading
        }],
        title,
        name,
        type: isFormBtn ? type : 'button',
        disabled: disabled || loading,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xebutton.renderVN = renderVN;
    return $xebutton;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/loading/src/loading.ts


/* harmony default export */ var loading = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeLoading',
  props: {
    modelValue: Boolean,
    icon: String,
    text: String
  },
  setup(props, {
    slots
  }) {
    const computeLoadingIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.icon || conf.icon.LOADING;
    });
    const computeLoadingText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const loadingText = conf.loadingText;
      return props.text || (loadingText === null ? loadingText : conf.i18n('vxe.loading.text'));
    });
    return () => {
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-loading', {
          'is--visible': props.modelValue
        }]
      }, slots.default ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--wrapper'
      }, slots.default({}))] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--chunk'
      }, [loadingIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: loadingIcon
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--spinner'
      }), loadingText ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--text'
      }, `${loadingText}`) : null])]);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/loading/index.ts

const VxeLoading = Object.assign(loading, {
  install(app) {
    app.component(loading.name, loading);
  }
});
const Loading = (/* unused pure expression or super */ null && (VxeLoading));
/* harmony default export */ var packages_loading = (VxeLoading);
;// CONCATENATED MODULE: ./packages/modal/src/modal.ts












const allActiveModals = [];
const msgQueue = [];
/* harmony default export */ var modal = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeModal',
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: 'modal'
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => conf.modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => conf.modal.duration
    },
    message: [Number, String],
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => conf.modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => conf.modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => conf.modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => conf.modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => conf.modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => conf.modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => conf.modal.escClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => conf.modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => conf.modal.showFooter
    },
    showZoom: Boolean,
    showClose: {
      type: Boolean,
      default: () => conf.modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => conf.modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => conf.modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => conf.modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => conf.modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => conf.modal.draggable
    },
    remember: {
      type: Boolean,
      default: () => conf.modal.remember
    },
    destroyOnClose: {
      type: Boolean,
      default: () => conf.modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => conf.modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => conf.modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => conf.modal.storage
    },
    storageKey: {
      type: String,
      default: () => conf.modal.storageKey
    },
    animat: {
      type: Boolean,
      default: () => conf.modal.animat
    },
    size: {
      type: String,
      default: () => conf.modal.size || conf.size
    },
    beforeHideMethod: {
      type: Function,
      default: () => conf.modal.beforeHideMethod
    },
    slots: Object
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel', 'zoom', 'resize', 'move'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      zoomLocat: null,
      firstOpen: true
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refModalBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xemodal = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let modalMethods = {};
    const computeIsMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'message';
    });
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ''}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ''}`;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        modalZindex
      } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else if (modalZindex < getLastZIndex()) {
        reactData.modalZindex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          position
        } = props;
        const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
        const boxElem = getBox();
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === 'center';
        const {
          top,
          left
        } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(position) ? {
          top: position,
          left: position
        } : Object.assign({}, position);
        const topCenter = isPosCenter || top === 'center';
        const leftCenter = isPosCenter || left === 'center';
        let posTop = '';
        let posLeft = '';
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        let offsetTop = 0;
        msgQueue.forEach(comp => {
          const boxElem = comp.getBox();
          offsetTop += external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(comp.props.top);
          comp.reactData.modalTop = offsetTop;
          offsetTop += boxElem.clientHeight;
        });
      });
    };
    const removeMsgQueue = () => {
      if (msgQueue.indexOf($xemodal) > -1) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(msgQueue, comp => comp === $xemodal);
      }
      updateStyle();
    };
    const closeModal = type => {
      const {
        remember,
        beforeHideMethod
      } = props;
      const {
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              reactData.zoomLocat = null;
            }
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveModals, item => item === $xemodal);
            modalMethods.dispatchEvent('before-hide', params);
            setTimeout(() => {
              reactData.visible = false;
              emit('update:modelValue', false);
              modalMethods.dispatchEvent('hide', params);
            }, 200);
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      modalMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const confirmEvent = evnt => {
      const type = 'confirm';
      modalMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const cancelEvent = evnt => {
      const type = 'cancel';
      modalMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const getStorageMap = key => {
      const version = conf.version;
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(key) || '');
      return rest && rest._v === version ? rest : {
        _v: version
      };
    };
    const hasPosStorage = () => {
      const {
        id,
        remember,
        storage,
        storageKey
      } = props;
      return !!(id && remember && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const {
        id,
        remember,
        storage,
        storageKey
      } = props;
      if (id && remember && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(',');
          if (left) {
            boxElem.style.left = `${left}px`;
          }
          if (top) {
            boxElem.style.top = `${top}px`;
          }
          if (width) {
            boxElem.style.width = `${width}px`;
          }
          if (height) {
            boxElem.style.height = `${height}px`;
          }
          if (zoomLeft && zoomTop) {
            reactData.zoomLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      if (msgQueue.indexOf($xemodal) === -1) {
        msgQueue.push($xemodal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const {
        id,
        remember,
        storage,
        storageKey
      } = props;
      const {
        zoomLocat
      } = reactData;
      if (id && remember && storage) {
        const boxElem = getBox();
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [boxElem.style.left, boxElem.style.top, boxElem.style.width, boxElem.style.height].concat(zoomLocat ? [zoomLocat.left, zoomLocat.top, zoomLocat.width, zoomLocat.height] : []).map(val => val ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : '').join(',');
        localStorage.setItem(storageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(posStorageMap));
      }
    };
    const maximize = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        if (!reactData.zoomLocat) {
          const marginSize = Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize));
          const boxElem = getBox();
          const {
            visibleHeight,
            visibleWidth
          } = getDomNode();
          reactData.zoomLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
          Object.assign(boxElem.style, {
            top: `${marginSize}px`,
            left: `${marginSize}px`,
            width: `${visibleWidth - marginSize * 2}px`,
            height: `${visibleHeight - marginSize * 2}px`
          });
          savePosStorage();
        }
      });
    };
    const openModal = () => {
      const {
        duration,
        remember,
        showFooter
      } = props;
      const {
        inited,
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      if (!inited) {
        reactData.inited = true;
      }
      if (!visible) {
        if (!remember) {
          recalculate();
        }
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xemodal);
        setTimeout(() => {
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emit('update:modelValue', true);
            modalMethods.dispatchEvent('show', params);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          if (duration !== -1) {
            setTimeout(() => closeModal('close'), external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(duration));
          }
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const {
              fullscreen
            } = props;
            const {
              firstOpen
            } = reactData;
            if (!remember || firstOpen) {
              updatePosition().then(() => {
                setTimeout(() => updatePosition(), 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => maximize());
              }
            } else {
              if (fullscreen) {
                (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => maximize());
              }
            }
          });
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeModal(type);
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveModals, item => item.reactData.modalZindex);
        // 多个时，只关掉最上层的窗口
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xemodal && lastModal.props.escClosable) {
              closeModal('exit');
            }
          }, 10);
        }
      }
    };
    const isMaximized = () => {
      return !!reactData.zoomLocat;
    };
    const revert = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          zoomLocat
        } = reactData;
        if (zoomLocat) {
          const boxElem = getBox();
          reactData.zoomLocat = null;
          Object.assign(boxElem.style, {
            top: `${zoomLocat.top}px`,
            left: `${zoomLocat.left}px`,
            width: `${zoomLocat.width}px`,
            height: `${zoomLocat.height}px`
          });
          savePosStorage();
        }
      });
    };
    const zoom = () => {
      if (reactData.zoomLocat) {
        return revert().then(() => isMaximized());
      }
      return maximize().then(() => isMaximized());
    };
    const toggleZoomEvent = evnt => {
      const {
        zoomLocat
      } = reactData;
      const params = {
        type: zoomLocat ? 'revert' : 'max'
      };
      return zoom().then(() => {
        modalMethods.dispatchEvent('zoom', params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(top)) {
          boxElem.style.top = `${top}px`;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(left)) {
          boxElem.style.left = `${left}px`;
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const boxMousedownEvent = () => {
      const {
        modalZindex
      } = reactData;
      if (allActiveModals.some(comp => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = evnt => {
      const {
        remember,
        storage
      } = props;
      const {
        zoomLocat
      } = reactData;
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const boxElem = getBox();
      if (!zoomLocat && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, 'trigger--btn').flag) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const {
          visibleHeight,
          visibleWidth
        } = getDomNode();
        document.onmousemove = evnt => {
          evnt.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt.clientX - disX;
          let top = evnt.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
          emit('move', {
            type: 'move',
            $event: evnt
          });
        };
        document.onmouseup = () => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          if (remember && storage) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              savePosStorage();
            });
          }
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
          }, 50);
        };
      }
    };
    const dragEvent = evnt => {
      evnt.preventDefault();
      const {
        remember,
        storage
      } = props;
      const {
        visibleHeight,
        visibleWidth
      } = getDomNode();
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute('type');
      const minWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minWidth);
      const minHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = {
        type: 'resize'
      };
      document.onmousemove = evnt => {
        evnt.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case 'wl':
            dragLeft = disX - evnt.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case 'swst':
            dragLeft = disX - evnt.clientX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'swlb':
            dragLeft = disX - evnt.clientX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'st':
            dragTop = disY - evnt.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'wr':
            dragLeft = evnt.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'sest':
            dragLeft = evnt.clientX - disX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'selb':
            dragLeft = evnt.clientX - disX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'sb':
            dragTop = evnt.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
        if (remember && storage) {
          savePosStorage();
        }
        modalMethods.dispatchEvent('resize', params, evnt);
      };
      document.onmouseup = () => {
        reactData.zoomLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
        }, 50);
      };
    };
    modalMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $modal: $xemodal,
          $event: evnt
        }, params));
      },
      open: openModal,
      close() {
        return closeModal('close');
      },
      getBox,
      getPosition,
      setPosition,
      isMaximized,
      zoom,
      maximize,
      revert
    };
    Object.assign($xemodal, modalMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        showZoom,
        title
      } = props;
      const {
        zoomLocat
      } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const titVNs = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-title'
      }, titleSlot ? getSlotVNs(titleSlot({
        $modal: $xemodal
      })) : title ? getFuncText(title) : conf.i18n('vxe.alert.title'))];
      const rightVNs = [];
      if (cornerSlot) {
        rightVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-modal--corner-wrapper'
        }, getSlotVNs(cornerSlot({
          $modal: $xemodal
        }))));
      }
      if (showZoom) {
        rightVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-modal--zoom-btn', 'trigger--btn', zoomLocat ? conf.icon.MODAL_ZOOM_OUT : conf.icon.MODAL_ZOOM_IN],
          title: conf.i18n(`vxe.modal.zoom${zoomLocat ? 'Out' : 'In'}`),
          onClick: toggleZoomEvent
        }));
      }
      if (showClose) {
        rightVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-modal--close-btn', 'trigger--btn', conf.icon.MODAL_CLOSE],
          title: conf.i18n('vxe.modal.close'),
          onClick: closeEvent
        }));
      }
      titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-right'
      }, rightVNs));
      return titVNs;
    };
    const renderHeaders = () => {
      const {
        slots: propSlots = {},
        showZoom,
        draggable
      } = props;
      const isMsg = computeIsMsg.value;
      const headerSlot = slots.header || propSlots.header;
      const headVNs = [];
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if (showZoom && props.dblclickZoom && props.type === 'modal') {
          headerOns.onDblclick = toggleZoomEvent;
        }
        headVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-modal--header', {
            'is--draggable': draggable,
            'is--ellipsis': !isMsg && props.showTitleOverflow
          }],
          ...headerOns
        }, headerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(headerSlot({
          $modal: $xemodal
        })) : renderTitles()));
      }
      return headVNs;
    };
    const renderBodys = () => {
      const {
        slots: propSlots = {},
        status,
        message
      } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const contVNs = [];
      if (status) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--status-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-modal--status-icon', props.iconStatus || conf.icon[`MODAL_${status}`.toLocaleUpperCase()]]
        })]));
      }
      contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--content'
      }, defaultSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(defaultSlot({
        $modal: $xemodal
      })) : getFuncText(content)));
      if (!isMsg) {
        /**
         * 加载中
         */
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
          class: 'vxe-modal--loading',
          modelValue: props.loading
        }));
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body'
      }, contVNs)];
    };
    const renderBtns = () => {
      const {
        showCancelButton,
        showConfirmButton,
        type
      } = props;
      const btnVNs = [];
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showCancelButton) ? showCancelButton : type === 'confirm') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || conf.i18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showConfirmButton) ? showConfirmButton : type === 'confirm' || type === 'alert') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          status: 'primary',
          content: props.confirmButtonText || conf.i18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return btnVNs;
    };
    const renderFooters = () => {
      const {
        slots: propSlots = {}
      } = props;
      const isMsg = computeIsMsg.value;
      const footerSlot = slots.footer || propSlots.footer;
      const footVNs = [];
      if (props.showFooter) {
        footVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--footer'
        }, footerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(footerSlot({
          $modal: $xemodal
        })) : renderBtns()));
      }
      if (!isMsg && props.resize) {
        footVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-modal--resize'
        }, ['wl', 'wr', 'swst', 'sest', 'st', 'swlb', 'selb', 'sb'].map(type => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: `${type}-resize`,
            type: type,
            onMousedown: dragEvent
          });
        })));
      }
      return footVNs;
    };
    const renderVN = () => {
      const {
        className,
        type,
        animat,
        loading,
        status,
        lockScroll,
        lockView,
        mask,
        resize
      } = props;
      const {
        inited,
        zoomLocat,
        modalTop,
        contentVisible,
        visible
      } = reactData;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: props.transfer ? !inited : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-modal--wrapper', `type--${type}`, className || '', {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          'is--animat': animat,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--resize': resize,
          'is--mask': mask,
          'is--maximize': zoomLocat,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        },
        onClick: selfClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refModalBox,
        class: 'vxe-modal--box',
        onMousedown: boxMousedownEvent
      }, renderHeaders().concat(renderBodys(), renderFooters()))])]);
    };
    $xemodal.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openModal();
      } else {
        closeModal('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.storage && !props.id) {
          errLog('vxe.error.reqProp', ['modal.id']);
        }
        if (props.modelValue) {
          openModal();
        }
        recalculate();
      });
      if (props.escClosable) {
        GlobalEvent.on($xemodal, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      GlobalEvent.off($xemodal, 'keydown');
      removeMsgQueue();
    });
    return $xemodal;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/input/src/date.ts

function toStringTimeDate(str) {
  if (str) {
    const rest = new Date();
    let h = 0;
    let m = 0;
    let s = 0;
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDate(str)) {
      h = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[1]);
        m = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[3]);
        s = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[5]);
      }
    }
    rest.setHours(h);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return new Date('');
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
;// CONCATENATED MODULE: ./packages/input/src/number.ts

function handleNumber(val) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val) ? val.replace(/,/g, '') : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test('' + inputValue)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(inputValue, digitsValue), digitsValue);
  }
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(inputValue, digitsValue), digitsValue);
}
;// CONCATENATED MODULE: ./packages/input/src/input.ts










const yearSize = 12;
const monthSize = 20;
const quarterSize = 8;
/* harmony default export */ var input = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeInput',
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'text'
    },
    clearable: {
      type: Boolean,
      default: () => conf.input.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(conf.input.placeholder) ? conf.i18n('vxe.base.pleaseInput') : conf.input.placeholder
    },
    maxlength: [String, Number],
    autocomplete: {
      type: String,
      default: 'off'
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => conf.input.size || conf.size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => conf.input.exponential
    },
    // number、integer、float、password
    controls: {
      type: Boolean,
      default: () => conf.input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => conf.input.digits
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => conf.input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => conf.input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => conf.input.startDay
    },
    labelFormat: {
      type: String,
      default: () => conf.input.labelFormat
    },
    valueFormat: {
      type: String,
      default: () => conf.input.valueFormat
    },
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => conf.input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => conf.input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => conf.input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: () => conf.input.transfer
    }
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'search-click', 'toggle-visible', 'prev-number', 'next-number', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      animatVisible: false,
      panelStyle: null,
      panelPlacement: '',
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTimeBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeinput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate = (value, format) => {
      const {
        type
      } = props;
      if (type === 'time') {
        return toStringTimeDate(value);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsNumType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['number', 'integer', 'float'].indexOf(props.type) > -1;
    });
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      return props.maxlength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.maxlength);
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsPawdType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'password';
    });
    const computeIsSearchType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'search';
    });
    const computeDigitsValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(props.digits) || 1;
    });
    const computeStepValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === 'integer') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(step) || 1;
      } else if (type === 'float') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === 'text' || type === 'search');
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.startDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.endDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].includes(props.type);
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' ? 'HH:mm:ss' : props.valueFormat || (type === 'datetime' ? 'yyyy-MM-dd HH:mm:ss' : 'yyyy-MM-dd');
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        datetimePanelValue
      } = reactData;
      if (datetimePanelValue) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(datetimePanelValue, 'HH:mm:ss');
      }
      return '';
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return props.labelFormat || conf.i18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter') {
          return conf.i18n('vxe.input.date.quarterLabel', [year]);
        } else if (datePanelType === 'month') {
          return conf.i18n('vxe.input.date.monthLabel', [year]);
        } else if (datePanelType === 'year') {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        }
        return conf.i18n('vxe.input.date.dayLabel', [year, month ? conf.i18n(`vxe.input.date.m${month}`) : '-']);
      }
      return '';
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay,
        startWeek
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(startDay) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: conf.i18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: conf.i18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInpReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        readonly,
        editable,
        multiple
      } = props;
      return readonly || multiple || !editable || type === 'week' || type === 'quarter';
    });
    const computeInputType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        showPwd
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === 'number') {
        return 'text';
      }
      return type;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      return '';
    });
    const computeInpMaxlength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxlength
      } = props;
      const isNumType = computeIsNumType.value;
      // 数值最大长度限制 16 位，包含小数
      return isNumType && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxlength) ? 16 : maxlength;
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        immediate
      } = props;
      return immediate || !(type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    });
    const computeNumValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        min
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        max
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const getNumberValue = val => {
      const {
        type,
        exponential
      } = props;
      const inpMaxlength = computeInpMaxlength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === 'float' ? toFloatValueFixed(val, digitsValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val);
      if (exponential && (val === restVal || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val).toLowerCase() === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxlength);
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      inputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      inputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          inputMethods.dispatchEvent('input', {
            value
          }, evnt);
        }
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        const {
          inputValue
        } = reactData;
        inputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    let hidePanelTimeout;
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(() => {
          reactData.animatVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const {
        type
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ['text', 'search', 'password'].indexOf(type) > -1) {
        focus();
      }
      inputMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        if (hasClass(evnt.currentTarget, 'is--clear')) {
          emitModel('', evnt);
          clearValueEvent(evnt, '');
        } else {
          const {
            inputValue
          } = reactData;
          inputMethods.dispatchEvent('suffix-click', {
            value: inputValue
          }, evnt);
        }
      }
    };
    const dateParseValue = value => {
      const {
        type
      } = props;
      const {
        valueFormat
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = '';
      if (value) {
        dValue = parseDate(value, valueFormat);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
        dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, dateLabelFormat, {
          firstDay: firstDayOfWeek
        });
        // 由于年份和第几周是冲突的行为，所以需要特殊处理，判断是否跨年
        if (dateLabelFormat && type === 'week') {
          const firstWeekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf('yyyy');
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    /**
     * 值变化时处理
     */
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const {
        inputValue
      } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === 'float') {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            emitModel(validValue, {
              type: 'init'
            });
          }
        }
      }
    };
    const vaildMaxNum = num => {
      return props.max === null || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max);
    };
    const vaildMinNum = num => {
      return props.min === null || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = date => {
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = date => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      if (multiple) {
        // 如果为多选
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          // 如果是datetime特殊类型
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(dateListValue, val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(date, val, 'yyyyMMdd'));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach(item => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          emitModel(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
            type: 'update'
          });
        } else {
          // 如果是日期类型
          if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
            emitModel(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
              type: 'update'
            });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(','), {
              type: 'update'
            });
          }
        }
      } else {
        // 如果为单选
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          emitModel(inpVal, {
            type: 'update'
          });
        }
      }
    };
    const afterCheckValue = () => {
      const {
        type,
        min,
        max,
        exponential
      } = props;
      const {
        inputValue,
        datetimePanelValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inpReadonly = computeInpReadonly.value;
      if (!inpReadonly) {
        if (isNumType) {
          if (inputValue) {
            let inpNumVal = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
            if (!vaildMinNum(inpNumVal)) {
              inpNumVal = min;
            } else if (!vaildMaxNum(inpNumVal)) {
              inpNumVal = max;
            }
            if (exponential) {
              const inpStringVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(inputValue).toLowerCase();
              if (inpStringVal === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            emitModel(getNumberValue(inpNumVal), {
              type: 'check'
            });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate(inputValue, dateLabelFormat);
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(inpDateVal)) {
              if (type === 'time') {
                inpDateVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  emitModel(inpDateVal, {
                    type: 'check'
                  });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === 'datetime') {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dateValue, dateLabelFormat) || inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat, {
                  firstDay: firstDayOfWeek
                });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            emitModel('', {
              type: 'check'
            });
          }
        }
      }
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    // 密码
    const passwordToggleEvent = evnt => {
      const {
        readonly,
        disabled
      } = props;
      const {
        showPwd
      } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent('toggle-visible', {
        visible: reactData.showPwd
      }, evnt);
    };
    // 密码
    // 搜索
    const searchEvent = evnt => {
      inputMethods.dispatchEvent('search-click', {}, evnt);
    };
    // 搜索
    // 数值
    const numberChange = (isPlus, evnt) => {
      const {
        min,
        max,
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      const newValue = isPlus ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().add(numValue, stepValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().subtract(numValue, stepValue);
      let restNum;
      if (!vaildMinNum(newValue)) {
        restNum = min;
      } else if (!vaildMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    let downbumTimeout;
    const numberNextEvent = evnt => {
      const {
        readonly,
        disabled
      } = props;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled && !readonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent('next-number', {}, evnt);
    };
    const numberDownNextEvent = evnt => {
      downbumTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = evnt => {
      const {
        readonly,
        disabled
      } = props;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled && !readonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent('prev-number', {}, evnt);
    };
    const numberKeydownEvent = evnt => {
      const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
      const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = evnt => {
      const {
        exponential,
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (hasEventKey(evnt, EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && keyCode >= 65 && keyCode <= 90 || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    // 数值
    const numberStopDown = () => {
      clearTimeout(downbumTimeout);
    };
    const numberDownPrevEvent = evnt => {
      downbumTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = evnt => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, 'is--prev');
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = evnt => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    // 日期
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, offsetMonth, 'first');
    };
    const dateNowHandle = () => {
      const currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        inputMethods.dispatchEvent('date-prev', {
          type
        }, evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent('date-today', {
        type: props.type
      }, evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        inputMethods.dispatchEvent('date-next', {
          type
        }, evnt);
      }
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      return disabledMethod && disabledMethod({
        type: datePanelType,
        viewType: datePanelType,
        date: item.date,
        $input: $xeinput
      });
    };
    const dateSelectItem = date => {
      const {
        type,
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === 'year') {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === 'datetime') {
            // 日期带时间
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = item => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!isDateDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!isDateDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!isDateDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!isDateDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!isDateDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = liElem => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = evnt => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const {
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          // 如果为多选
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            // 如果是datetime特殊类型
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach(item => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            emitModel(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
              type: 'update'
            });
          } else {
            // 如果是日期类型
            emitModel(dateMultipleValue.join(','), {
              type: 'update'
            });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = evnt => {
      const {
        isActivated,
        datePanelValue,
        datePanelType
      } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === 'year') {
          let offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === 'quarter') {
          let offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === 'month') {
          let offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = evnt => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        const isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const {
        type
      } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const timeBodyElem = refInputTimeBody.value;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(timeBodyElem.querySelectorAll('li.is--selected'), updateTimePos);
        });
      }
    };
    // 日期
    // 弹出面板
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          transfer,
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(targetElem);
          let panelPlacement = 'bottom';
          console.log(getAbsolutePos(targetElem));
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const showPanel = () => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!disabled && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const datePickerOpenEvent = evnt => {
      const {
        readonly
      } = props;
      if (!readonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // 弹出面板
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      if (!disabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          // 如果是日期类型
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable,
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!disabled) {
        const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        const isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        const isPgDn = hasEventKey(evnt, EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      if (!disabled) {
        if (visiblePanel) {
          const panelElem = refInputPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated,
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $input: $xeinput
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        const labels = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : label)];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // 默认最多支持3个节日重叠
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labels.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-input--date-festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', weekHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--hover': isHover
            },
            // event
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, conf.i18n(`vxe.input.date.months.m${item.month}`)));
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, conf.i18n(`vxe.input.date.quarters.q${item.quarter}`)));
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.year));
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-label'
      }, selectDatePanelLabel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn',
        onClick: dateToggleTypeEvent
      }, selectDatePanelLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-prev-btn', {
          'is--disabled': isDisabledPrevDateBtn
        }],
        onClick: datePrevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-left'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-current-btn',
        onClick: dateTodayMonthEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-dot'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-next-btn', {
          'is--disabled': isDisabledNextDateBtn
        }],
        onClick: dateNextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-right'
      })]), multiple && computeSupportMultiples.value ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--date-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, conf.i18n('vxe.button.confirm'))]) : null])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-body'
      }, renderDateTable())];
    };
    const renderTimePanel = () => {
      const {
        datetimePanelValue
      } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const minuteList = computeMinuteList.value;
      const secondList = computeSecondList.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--time-picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--time-picker-title'
      }, dateTimeLabel), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--time-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, conf.i18n('vxe.button.confirm'))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputTimeBody,
        class: 'vxe-input--time-picker-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-hour-list'
      }, hourList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getHours() === item.value
          },
          onClick: evnt => dateHourEvent(evnt, item)
        }, item.label);
      })), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-minute-list'
      }, minuteList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getMinutes() === item.value
          },
          onClick: evnt => dateMinuteEvent(evnt, item)
        }, item.label);
      })), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-second-list'
      }, secondList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getSeconds() === item.value
          },
          onClick: evnt => dateSecondEvent(evnt, item)
        }, item.label);
      }))])];
    };
    const renderPanel = () => {
      const {
        type,
        transfer
      } = props;
      const {
        inited,
        animatVisible,
        visiblePanel,
        panelPlacement,
        panelStyle
      } = reactData;
      const vSize = computeSize.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === 'datetime') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-layout-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-left-wrapper'
          }, renderDatePanel()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-right-wrapper'
          }, renderTimePanel())]));
        } else if (type === 'time') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-wrapper'
          }, renderTimePanel()));
        } else {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-wrapper'
          }, renderDatePanel()));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: transfer ? !inited : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refInputPanel,
          class: ['vxe-table--ignore-clear vxe-input--panel', `type--${type}`, {
            [`size--${vSize}`]: vSize,
            'is--transfer': transfer,
            'animat--leave': animatVisible,
            'animat--enter': visiblePanel
          }],
          placement: panelPlacement,
          style: panelStyle
        }, renders)]);
      }
      return null;
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--number-suffix'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--number-prev is--prev', {
          'is--disabled': isDisabledAddNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--number-prev-icon', conf.icon.INPUT_PREV_NUM]
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--number-next is--next', {
          'is--disabled': isDisabledSubtractNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--number-next-icon', conf.icon.INPUT_NEXT_NUM]
      })])]);
    };
    const renderDatePickerIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-suffix',
        onClick: datePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--date-picker-icon', conf.icon.INPUT_DATE]
      })]);
    };
    const renderSearchIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--search-suffix',
        onClick: searchEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--search-icon', conf.icon.INPUT_SEARCH]
      })]);
    };
    const renderPasswordIcon = () => {
      const {
        showPwd
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--password-suffix',
        onClick: passwordToggleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--password-icon', showPwd ? conf.icon.INPUT_SHOW_PWD : conf.icon.INPUT_PWD]
      })]);
    };
    const rendePrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      const icons = [];
      if (prefixSlot) {
        icons.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-input--prefix-icon'
        }, prefixSlot({})));
      } else if (prefixIcon) {
        icons.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-input--prefix-icon', prefixIcon]
        }));
      }
      return icons.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--prefix',
        onClick: clickPrefixEvent
      }, icons) : null;
    };
    const renderSuffixIcon = () => {
      const {
        disabled,
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      const icons = [];
      if (suffixSlot) {
        icons.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-input--suffix-icon'
        }, suffixSlot({})));
      } else if (suffixIcon) {
        icons.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-input--suffix-icon', suffixIcon]
        }));
      }
      if (isClearable) {
        icons.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-input--clear-icon', conf.icon.INPUT_CLEAR]
        }));
      }
      return icons.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--suffix', {
          'is--clear': isClearable && !disabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        onClick: clickSuffixEvent
      }, icons) : null;
    };
    const renderExtraSuffixIcon = () => {
      const {
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      let icons;
      if (isPawdType) {
        icons = renderPasswordIcon();
      } else if (isNumType) {
        if (controls) {
          icons = renderNumberIcon();
        }
      } else if (isDatePickerType) {
        icons = renderDatePickerIcon();
      } else if (isSearchType) {
        icons = renderSearchIcon();
      }
      return icons ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--extra-suffix'
      }, [icons]) : null;
    };
    inputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $input: $xeinput,
          $event: evnt
        }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeinput, inputMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      GlobalEvent.on($xeinput, 'mousewheel', handleGlobalMousewheelEvent);
      GlobalEvent.on($xeinput, 'mousedown', handleGlobalMousedownEvent);
      GlobalEvent.on($xeinput, 'keydown', handleGlobalKeydownEvent);
      GlobalEvent.on($xeinput, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      numberStopDown();
      GlobalEvent.off($xeinput, 'mousewheel');
      GlobalEvent.off($xeinput, 'mousedown');
      GlobalEvent.off($xeinput, 'keydown');
      GlobalEvent.off($xeinput, 'blur');
    });
    initValue();
    const renderVN = () => {
      const {
        className,
        controls,
        type,
        align,
        showWordCount,
        countMethod,
        name,
        disabled,
        readonly,
        autocomplete
      } = props;
      const {
        inputValue,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const inpReadonly = computeInpReadonly.value;
      const inpMaxlength = computeInpMaxlength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const childs = [];
      const prefix = rendePrefixIcon();
      const suffix = renderSuffixIcon();
      // 前缀图标
      if (prefix) {
        childs.push(prefix);
      }
      // 输入框
      childs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-input--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        maxlength: inpMaxlength,
        readonly: inpReadonly,
        disabled,
        autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }));
      // 后缀图标
      if (suffix) {
        childs.push(suffix);
      }
      // 特殊功能图标
      childs.push(renderExtraSuffixIcon());
      // 面板容器
      if (isDatePickerType) {
        childs.push(renderPanel());
      }
      let isWordCount = false;
      // 统计字数
      if (showWordCount && ['text', 'search'].includes(type)) {
        isWordCount = true;
        childs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--count', {
            'is--error': isCountError
          }]
        }, countMethod ? `${countMethod({
          value: inputValue
        })}` : `${inputCount}${inpMaxlength ? `/${inpMaxlength}` : ''}`));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-input', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--controls': controls,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--readonly': readonly,
          'is--visivle': visiblePanel,
          'is--count': isWordCount,
          'is--disabled': disabled,
          'is--active': isActivated
        }]
      }, childs);
    };
    $xeinput.renderVN = renderVN;
    return $xeinput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.ts





/* harmony default export */ var src_checkbox = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCheckbox',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: Boolean,
    size: {
      type: String,
      default: () => conf.checkbox.size || conf.size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xecheckbox = {
      xID,
      props,
      context
    };
    let checkboxMethods = {};
    const computeSize = useSize(props);
    const $xecheckboxgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xecheckboxgroup', null);
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xecheckboxgroup) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes($xecheckboxgroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (props.disabled) {
        return true;
      }
      if ($xecheckboxgroup) {
        const {
          props: groupProps
        } = $xecheckboxgroup;
        const {
          computeIsMaximize
        } = $xecheckboxgroup.getComputeMaps();
        const isMaximize = computeIsMaximize.value;
        const isChecked = computeIsChecked.value;
        return groupProps.disabled || isMaximize && !isChecked;
      }
      return false;
    });
    const changeEvent = evnt => {
      const {
        checkedValue,
        uncheckedValue
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = {
          checked,
          value,
          label: props.label
        };
        if ($xecheckboxgroup) {
          $xecheckboxgroup.handleChecked(params, evnt);
        } else {
          emit('update:modelValue', value);
          checkboxMethods.dispatchEvent('change', params, evnt);
          // 自动更新校验状态
          if ($xeform && $xeformiteminfo) {
            $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
          }
        }
      }
    };
    checkboxMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $checkbox: $xecheckbox,
          $event: evnt
        }, params));
      }
    };
    Object.assign($xecheckbox, checkboxMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = props.indeterminate;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        class: ['vxe-checkbox', {
          [`size--${vSize}`]: vSize,
          'is--indeterminate': indeterminate,
          'is--disabled': isDisabled,
          'is--checked': isChecked
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-checkbox--input',
        type: 'checkbox',
        disabled: isDisabled,
        checked: isChecked,
        onChange: changeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? 'vxe-icon-checkbox-indeterminate' : isChecked ? 'vxe-icon-checkbox-checked' : 'vxe-icon-checkbox-unchecked']
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xecheckbox.renderVN = renderVN;
    return $xecheckbox;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/select/src/select.ts










function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('opt_');
}
/* harmony default export */ var src_select = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeSelect',
  props: {
    modelValue: null,
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(conf.select.placeholder) ? conf.i18n('vxe.base.pleaseSelect') : conf.select.placeholder
    },
    loading: Boolean,
    disabled: Boolean,
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => conf.select.multiCharOverflow
    },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => conf.select.size || conf.size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    // 已废弃，被 option-config.keyField 替换
    optionId: {
      type: String,
      default: () => conf.select.optionId
    },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean,
    transfer: {
      type: Boolean,
      default: () => conf.select.transfer
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'blur', 'focus'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      staticOptions: [],
      fullGroupList: [],
      fullOptionList: [],
      visibleGroupList: [],
      visibleOptionList: [],
      remoteValueList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      currentOption: null,
      currentValue: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false,
      searchValue: '',
      searchLoading: false
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInpSearch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeselect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let selectMethods = {};
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeGroupPropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionGroupProps || {};
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeGroupLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || 'label';
    });
    const computeGroupOptionsField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || 'options';
    });
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple,
        max
      } = props;
      if (multiple && max) {
        return (modelValue ? modelValue.length : 0) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const computeOptionOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.select.optionConfig, props.optionConfig);
    });
    const computeIsGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.fullGroupList.some(item => item.options && item.options.length);
    });
    const computeMultiMaxCharNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.multiCharOverflow);
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const findOption = optionValue => {
      const {
        fullOptionList,
        fullGroupList
      } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      if (isGroup) {
        for (let gIndex = 0; gIndex < fullGroupList.length; gIndex++) {
          const group = fullGroupList[gIndex];
          if (group.options) {
            for (let index = 0; index < group.options.length; index++) {
              const option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return fullOptionList.find(item => optionValue === item[valueField]);
    };
    const getRemoteSelectLabel = value => {
      const {
        remoteValueList
      } = reactData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValueList.find(item => value === item.key);
      const item = remoteItem ? remoteItem.result : null;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = value => {
      const labelField = computeLabelField.value;
      const item = findOption(value);
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(item ? item[labelField] : value);
    };
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple,
        remote
      } = props;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (modelValue && multiple) {
        const vals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
        if (remote) {
          return vals.map(val => getRemoteSelectLabel(val)).join(', ');
        }
        return vals.map(val => {
          const label = getSelectLabel(val);
          if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
            return `${label.substring(0, multiMaxCharNum)}...`;
          }
          return label;
        }).join(', ');
      }
      if (remote) {
        return getRemoteSelectLabel(modelValue);
      }
      return getSelectLabel(modelValue);
    });
    const getOptkey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';
    };
    const getOptid = option => {
      const optid = option[getOptkey()];
      return optid ? encodeURIComponent(optid) : '';
    };
    /**
     * 刷新选项，当选项被动态显示/隐藏时可能会用到
     */
    const refreshOption = () => {
      const {
        filterable,
        filterMethod
      } = props;
      const {
        fullOptionList,
        fullGroupList,
        searchValue
      } = reactData;
      const isGroup = computeIsGroup.value;
      const groupLabelField = computeGroupLabelField.value;
      const labelField = computeLabelField.value;
      if (isGroup) {
        if (filterable && filterMethod) {
          reactData.visibleGroupList = fullGroupList.filter(group => isOptionVisible(group) && filterMethod({
            group,
            option: null,
            searchValue
          }));
        } else if (filterable) {
          reactData.visibleGroupList = fullGroupList.filter(group => isOptionVisible(group) && (!searchValue || `${group[groupLabelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);
        }
      } else {
        if (filterable && filterMethod) {
          reactData.visibleOptionList = fullOptionList.filter(option => isOptionVisible(option) && filterMethod({
            group: null,
            option,
            searchValue
          }));
        } else if (filterable) {
          reactData.visibleOptionList = fullOptionList.filter(option => isOptionVisible(option) && (!searchValue || `${option[labelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const cacheItemMap = () => {
      const {
        fullOptionList,
        fullGroupList
      } = reactData;
      const groupOptionsField = computeGroupOptionsField.value;
      const key = getOptkey();
      const handleOptis = item => {
        if (!getOptid(item)) {
          item[key] = getOptUniqueId();
        }
      };
      if (fullGroupList.length) {
        fullGroupList.forEach(group => {
          handleOptis(group);
          if (group[groupOptionsField]) {
            group[groupOptionsField].forEach(handleOptis);
          }
        });
      } else if (fullOptionList.length) {
        fullOptionList.forEach(handleOptis);
      }
      refreshOption();
    };
    const setCurrentOption = option => {
      const valueField = computeValueField.value;
      if (option) {
        reactData.currentOption = option;
        reactData.currentValue = option[valueField];
      }
    };
    const scrollToOption = (option, isAlignBottom) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        if (option) {
          const optWrapperElem = refOptionWrapper.value;
          const panelElem = refOptionPanel.value;
          const optElem = panelElem.querySelector(`[optid='${getOptid(option)}']`);
          if (optWrapperElem && optElem) {
            const wrapperHeight = optWrapperElem.offsetHeight;
            const offsetPadding = 5;
            if (isAlignBottom) {
              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
              }
            } else {
              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
              }
            }
          }
        }
      });
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          transfer,
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(el);
          let panelPlacement = 'bottom';
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const {
        loading,
        disabled,
        filterable
      } = props;
      if (!loading && !disabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.inited) {
          reactData.inited = true;
        }
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (filterable) {
          refreshOption();
        }
        setTimeout(() => {
          const {
            modelValue,
            multiple
          } = props;
          const currOption = findOption(multiple && modelValue ? modelValue[0] : modelValue);
          reactData.visiblePanel = true;
          if (currOption) {
            setCurrentOption(currOption);
            scrollToOption(currOption);
          }
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = '';
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.animatVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      if (selectValue !== props.modelValue) {
        emit('update:modelValue', selectValue);
        selectMethods.dispatchEvent('change', {
          value: selectValue
        }, evnt);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      reactData.remoteValueList = [];
      changeEvent(evnt, selectValue);
      selectMethods.dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, selectValue, option) => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        remoteValueList
      } = reactData;
      if (multiple) {
        let multipleValue;
        if (modelValue) {
          if (modelValue.indexOf(selectValue) === -1) {
            multipleValue = modelValue.concat([selectValue]);
          } else {
            multipleValue = modelValue.filter(val => val !== selectValue);
          }
        } else {
          multipleValue = [selectValue];
        }
        const remoteItem = remoteValueList.find(item => item.key === selectValue);
        if (remoteItem) {
          remoteItem.result = option;
        } else {
          remoteValueList.push({
            key: selectValue,
            result: option
          });
        }
        changeEvent(evnt, multipleValue);
      } else {
        reactData.remoteValueList = [{
          key: selectValue,
          result: option
        }];
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      if (!disabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      if (!disabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const findOffsetOption = (optionValue, isUpArrow) => {
      const {
        visibleOptionList,
        visibleGroupList
      } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      let firstOption;
      let prevOption;
      let nextOption;
      let currOption;
      if (isGroup) {
        for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          const group = visibleGroupList[gIndex];
          const groupOptionList = group[groupOptionsField];
          const isGroupDisabled = group.disabled;
          if (groupOptionList) {
            for (let index = 0; index < groupOptionList.length; index++) {
              const option = groupOptionList[index];
              const isVisible = isOptionVisible(option);
              const isDisabled = isGroupDisabled || option.disabled;
              if (!firstOption && !isDisabled) {
                firstOption = option;
              }
              if (currOption) {
                if (isVisible && !isDisabled) {
                  nextOption = option;
                  if (!isUpArrow) {
                    return {
                      offsetOption: nextOption
                    };
                  }
                }
              }
              if (optionValue === option[valueField]) {
                currOption = option;
                if (isUpArrow) {
                  return {
                    offsetOption: prevOption
                  };
                }
              } else {
                if (isVisible && !isDisabled) {
                  prevOption = option;
                }
              }
            }
          }
        }
      } else {
        for (let index = 0; index < visibleOptionList.length; index++) {
          const option = visibleOptionList[index];
          const isDisabled = option.disabled;
          if (!firstOption && !isDisabled) {
            firstOption = option;
          }
          if (currOption) {
            if (!isDisabled) {
              nextOption = option;
              if (!isUpArrow) {
                return {
                  offsetOption: nextOption
                };
              }
            }
          }
          if (optionValue === option[valueField]) {
            currOption = option;
            if (isUpArrow) {
              return {
                offsetOption: prevOption
              };
            }
          } else {
            if (!isDisabled) {
              prevOption = option;
            }
          }
        }
      }
      return {
        firstOption
      };
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable,
        disabled
      } = props;
      const {
        visiblePanel,
        currentValue,
        currentOption
      } = reactData;
      if (!disabled) {
        const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        const isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentValue, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let {
              firstOption,
              offsetOption
            } = findOffsetOption(currentValue, isUpArrow);
            if (!offsetOption && !findOption(currentValue)) {
              offsetOption = firstOption;
            }
            setCurrentOption(offsetOption);
            scrollToOption(offsetOption, isDwArrow);
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = evnt => {
      if (!props.disabled) {
        reactData.isActivated = true;
      }
      selectMethods.dispatchEvent('focus', {}, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      selectMethods.dispatchEvent('blur', {}, evnt);
    };
    const modelSearchEvent = value => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const keydownSearchEvent = params => {
      const {
        $event
      } = params;
      const isEnter = hasEventKey($event, EVENT_KEYS.ENTER);
      if (isEnter) {
        $event.preventDefault();
        $event.stopPropagation();
      }
    };
    const triggerSearchEvent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(function () {
      const {
        remote,
        remoteMethod
      } = props;
      const {
        searchValue
      } = reactData;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({
          searchValue
        })).then(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).catch(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).finally(() => {
          reactData.searchLoading = false;
          refreshOption();
        });
      } else {
        refreshOption();
      }
    }, 350, {
      trailing: true
    });
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const checkOptionDisabled = (isSelected, option, group) => {
      if (option.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const renderOption = (list, group) => {
      const {
        optionKey,
        modelValue,
        multiple
      } = props;
      const {
        currentValue
      } = reactData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const isGroup = computeIsGroup.value;
      const {
        useKey
      } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const {
          slots,
          className
        } = option;
        const optionValue = option[valueField];
        const isSelected = multiple ? modelValue && modelValue.indexOf(optionValue) > -1 : modelValue === optionValue;
        const isVisible = !isGroup || isOptionVisible(option);
        const isDisabled = checkOptionDisabled(isSelected, option, group);
        const optid = getOptid(option);
        const defaultSlot = slots ? slots.default : null;
        const optParams = {
          option,
          group: null,
          $select: $xeselect
        };
        return isVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: useKey || optionKey ? optid : cIndex,
          class: ['vxe-select-option', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(optParams) : className : '', {
            'is--disabled': isDisabled,
            'is--selected': isSelected,
            'is--hover': currentValue === optionValue
          }],
          // attrs
          optid: optid,
          // event
          onMousedown: evnt => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: evnt => {
            if (!isDisabled) {
              changeOptionEvent(evnt, optionValue, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled) {
              setCurrentOption(option);
            }
          }
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : formatText(getFuncText(option[labelField]))) : null;
      });
    };
    const renderOptgroup = () => {
      const {
        optionKey
      } = props;
      const {
        visibleGroupList
      } = reactData;
      const optionOpts = computeOptionOpts.value;
      const groupLabelField = computeGroupLabelField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      const {
        useKey
      } = optionOpts;
      const optionSlot = slots.option;
      return visibleGroupList.map((group, gIndex) => {
        const {
          slots,
          className
        } = group;
        const optid = getOptid(group);
        const isGroupDisabled = group.disabled;
        const defaultSlot = slots ? slots.default : null;
        const optParams = {
          option: group,
          group,
          $select: $xeselect
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: useKey || optionKey ? optid : gIndex,
          class: ['vxe-optgroup', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(optParams) : className : '', {
            'is--disabled': isGroupDisabled
          }],
          // attrs
          optid: optid
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-optgroup--title'
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(group[groupLabelField])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-optgroup--wrapper'
        }, renderOption(group[groupOptionsField] || [], group))]);
      });
    };
    const renderOpts = () => {
      const {
        visibleGroupList,
        visibleOptionList,
        searchLoading
      } = reactData;
      const isGroup = computeIsGroup.value;
      if (searchLoading) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-select--search-loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-select--search-icon', conf.icon.SELECT_LOADED]
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-select--search-text'
        }, conf.i18n('vxe.select.loadingText'))])];
      }
      if (isGroup) {
        if (visibleGroupList.length) {
          return renderOptgroup();
        }
      } else {
        if (visibleOptionList.length) {
          return renderOption(visibleOptionList);
        }
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--empty-placeholder'
      }, props.emptyText || conf.i18n('vxe.select.emptyText'))];
    };
    selectMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $select: $xeselect,
          $event: evnt
        }, params));
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      refreshOption,
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeselect, selectMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticOptions, value => {
      if (value.some(item => item.options && item.options.length)) {
        reactData.fullOptionList = [];
        reactData.fullGroupList = value;
      } else {
        reactData.fullGroupList = [];
        reactData.fullOptionList = value || [];
      }
      cacheItemMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, value => {
      reactData.fullGroupList = [];
      reactData.fullOptionList = value || [];
      cacheItemMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.optionGroups, value => {
      reactData.fullOptionList = [];
      reactData.fullGroupList = value || [];
      cacheItemMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          options,
          optionGroups
        } = props;
        if (optionGroups) {
          reactData.fullGroupList = optionGroups;
        } else if (options) {
          reactData.fullOptionList = options;
        }
        cacheItemMap();
      });
      GlobalEvent.on($xeselect, 'mousewheel', handleGlobalMousewheelEvent);
      GlobalEvent.on($xeselect, 'mousedown', handleGlobalMousedownEvent);
      GlobalEvent.on($xeselect, 'keydown', handleGlobalKeydownEvent);
      GlobalEvent.on($xeselect, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      GlobalEvent.off($xeselect, 'mousewheel');
      GlobalEvent.off($xeselect, 'mousedown');
      GlobalEvent.off($xeselect, 'keydown');
      GlobalEvent.off($xeselect, 'blur');
    });
    const renderVN = () => {
      const {
        className,
        popupClassName,
        transfer,
        disabled,
        loading,
        filterable
      } = props;
      const {
        inited,
        isActivated,
        visiblePanel
      } = reactData;
      const vSize = computeSize.value;
      const selectLabel = computeSelectLabel.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $select: $xeselect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visivle': visiblePanel,
          'is--disabled': disabled,
          'is--filter': filterable,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select-slots',
        ref: 'hideOption'
      }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: props.placeholder,
        readonly: true,
        disabled: disabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? conf.icon.SELECT_LOADED : visiblePanel ? conf.icon.SELECT_OPEN : conf.icon.SELECT_CLOSE,
        modelValue: selectLabel,
        onClear: clearEvent,
        onClick: togglePanelEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: togglePanelEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: transfer ? !inited : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $select: $xeselect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': transfer,
          'animat--leave': !loading && reactData.animatVisible,
          'animat--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, inited ? [filterable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-search'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInpSearch,
        class: 'vxe-select-search--input',
        modelValue: reactData.searchValue,
        clearable: true,
        placeholder: conf.i18n('vxe.select.search'),
        prefixIcon: conf.icon.INPUT_SEARCH,
        'onUpdate:modelValue': modelSearchEvent,
        onFocus: focusSearchEvent,
        onKeydown: keydownSearchEvent,
        onChange: triggerSearchEvent,
        onSearch: triggerSearchEvent
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-header'
      }, headerSlot({})) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionWrapper,
        class: 'vxe-select-option--wrapper'
      }, renderOpts())]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-footer'
      }, footerSlot({})) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])] : [])])]);
    };
    $xeselect.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeselect', $xeselect);
    return $xeselect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/export/src/export-panel.ts










/* harmony default export */ var export_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableExportPanel',
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const {
      computeExportOpts,
      computePrintOpts
    } = $xetable.getComputeMaps();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const xInputFilename = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const xInputSheetname = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeCheckedAll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return storeData.columns.every(column => column.checked);
    });
    const computeShowSheet = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultOptions
      } = props;
      return ['html', 'xml', 'xlsx', 'pdf'].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData,
        defaultOptions
      } = props;
      return !defaultOptions.original && defaultOptions.mode === 'current' && (storeData.isPrint || ['html', 'xlsx'].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        defaultOptions
      } = props;
      return !defaultOptions.original && ['xlsx'].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = column => {
      const {
        storeData
      } = props;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(storeData.columns, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every(column => column.checked);
          parent.halfChecked = !parent.checked && parent.children.some(column => column.checked || column.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const {
        storeData
      } = props;
      const columns = storeData.columns;
      reactData.isAll = columns.every(column => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some(column => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = column => {
      const isChecked = !column.checked;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const {
        storeData
      } = props;
      const isAll = !reactData.isAll;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(storeData.columns, column => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      const {
        hasMerge,
        columns
      } = storeData;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(columns, column => column.checked, {
        children: 'children',
        mapChildren: 'childNodes',
        original: true
      });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const {
        storeData
      } = props;
      const printOpts = computePrintOpts.value;
      storeData.visible = false;
      $xetable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const {
        storeData
      } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xetable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const {
        storeData
      } = props;
      storeData.visible = false;
    };
    const confirmEvent = () => {
      const {
        storeData
      } = props;
      if (storeData.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const {
        defaultOptions,
        storeData
      } = props;
      const {
        isAll: isAllChecked,
        isIndeterminate: isAllIndeterminate
      } = reactData;
      const {
        hasTree,
        hasMerge,
        isPrint,
        hasColgroup
      } = storeData;
      const {
        isHeader
      } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(storeData.columns, column => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        cols.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          class: ['vxe-export--panel-column-option', `level--${column.level}`, {
            'is--group': isColGroup,
            'is--checked': isChecked,
            'is--indeterminate': indeterminate,
            'is--disabled': column.disabled
          }],
          title: colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', indeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, colTitle)]));
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(modal, {
        modelValue: storeData.visible,
        title: conf.i18n(isPrint ? 'vxe.export.printTitle' : 'vxe.export.expTitle'),
        className: 'vxe-table-export-popup-wrapper',
        width: 660,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        'onUpdate:modelValue'(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-export--panel'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', [[isPrint ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.export.expName')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
            ref: xInputFilename,
            modelValue: defaultOptions.filename,
            type: 'text',
            clearable: true,
            placeholder: conf.i18n('vxe.export.expNamePlaceholder'),
            'onUpdate:modelValue'(value) {
              defaultOptions.filename = value;
            }
          })])]), isPrint ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.export.expType')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
            modelValue: defaultOptions.type,
            options: storeData.typeList.map(item => {
              return {
                value: item.value,
                label: conf.i18n(item.label)
              };
            }),
            'onUpdate:modelValue'(value) {
              defaultOptions.type = value;
            }
          })])]), isPrint || showSheet ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.export.expSheetName')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
            ref: xInputSheetname,
            modelValue: defaultOptions.sheetName,
            type: 'text',
            clearable: true,
            placeholder: conf.i18n('vxe.export.expSheetNamePlaceholder'),
            'onUpdate:modelValue'(value) {
              defaultOptions.sheetName = value;
            }
          })])]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.export.expMode')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
            modelValue: defaultOptions.mode,
            options: storeData.modeList.map(item => {
              return {
                value: item.value,
                label: conf.i18n(item.label)
              };
            }),
            'onUpdate:modelValue'(value) {
              defaultOptions.mode = value;
            }
          })])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [conf.i18n('vxe.export.expColumn')]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-export--panel-column'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: 'vxe-export--panel-column-header'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            class: ['vxe-export--panel-column-option', {
              'is--checked': isAllChecked,
              'is--indeterminate': isAllIndeterminate
            }],
            title: conf.i18n('vxe.table.allTitle'),
            onClick: allColumnEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isAllIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-checkbox--label'
          }, conf.i18n('vxe.export.expCurrentColumn'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
            class: 'vxe-export--panel-column-body'
          }, cols)])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.export.expOpts')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-export--panel-option-row'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
            modelValue: defaultOptions.isHeader,
            title: conf.i18n('vxe.export.expHeaderTitle'),
            content: conf.i18n('vxe.export.expOptHeader'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isHeader = value;
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
            modelValue: defaultOptions.isFooter,
            disabled: !storeData.hasFooter,
            title: conf.i18n('vxe.export.expFooterTitle'),
            content: conf.i18n('vxe.export.expOptFooter'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isFooter = value;
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
            modelValue: defaultOptions.original,
            title: conf.i18n('vxe.export.expOriginalTitle'),
            content: conf.i18n('vxe.export.expOptOriginal'),
            'onUpdate:modelValue'(value) {
              defaultOptions.original = value;
            }
          })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-export--panel-option-row'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
            title: conf.i18n('vxe.export.expColgroupTitle'),
            disabled: !isHeader || !hasColgroup || !supportMerge,
            content: conf.i18n('vxe.export.expOptColgroup'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isColgroup = value;
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
            title: conf.i18n('vxe.export.expMergeTitle'),
            disabled: !hasMerge || !supportMerge || !checkedAll,
            content: conf.i18n('vxe.export.expOptMerge'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isMerge = value;
            }
          }), isPrint ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
            modelValue: supportStyle ? defaultOptions.useStyle : false,
            disabled: !supportStyle,
            title: conf.i18n('vxe.export.expUseStyleTitle'),
            content: conf.i18n('vxe.export.expOptUseStyle'),
            'onUpdate:modelValue'(value) {
              defaultOptions.useStyle = value;
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
            modelValue: hasTree ? defaultOptions.isAllExpand : false,
            disabled: !hasTree,
            title: conf.i18n('vxe.export.expAllExpandTitle'),
            content: conf.i18n('vxe.export.expOptAllExpand'),
            'onUpdate:modelValue'(value) {
              defaultOptions.isAllExpand = value;
            }
          })])])])]])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-export--panel-btns'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            content: conf.i18n('vxe.export.expCancel'),
            onClick: cancelEvent
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            ref: xButtonConfirm,
            status: 'primary',
            content: conf.i18n(isPrint ? 'vxe.export.expPrint' : 'vxe.export.expConfirm'),
            onClick: confirmEvent
          })])]);
        }
      });
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/radio/src/radio.ts





/* harmony default export */ var src_radio = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeRadio',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    name: String,
    strict: {
      type: Boolean,
      default: () => conf.radio.strict
    },
    size: {
      type: String,
      default: () => conf.radio.size || conf.size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeradio = {
      xID,
      props,
      context
    };
    const computeSize = useSize(props);
    const $xeradiogroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeradiogroup', null);
    let radioMethods = {};
    const computeDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeradiogroup ? $xeradiogroup.name : props.name;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        label
      } = props;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({
          label
        }, evnt);
      } else {
        emit('update:modelValue', label);
        radioMethods.dispatchEvent('change', {
          label
        }, evnt);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    radioMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $radio: $xeradio,
          $event: evnt
        }, params));
      }
    };
    Object.assign($xeradio, radioMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        class: ['vxe-radio', {
          [`size--${vSize}`]: vSize,
          'is--checked': isChecked,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked: isChecked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-radio--icon', isChecked ? 'vxe-icon-radio-checked' : 'vxe-icon-radio-unchecked']
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeradio.renderVN = renderVN;
    return $xeradio;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/radio/src/button.ts





/* harmony default export */ var radio_src_button = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeRadioButton',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    strict: {
      type: Boolean,
      default: () => conf.radioButton.strict
    },
    size: {
      type: String,
      default: () => conf.radioButton.size || conf.size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const $xeradiobutton = {
      xID,
      props,
      context
    };
    let radioButtonMethods = {};
    const $xeradiogroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeradiogroup', null);
    const computeDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeradiogroup ? $xeradiogroup.name : null;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        label
      } = props;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue === label;
    });
    radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $radioButton: $xeradiobutton,
          $event: evnt
        }, params));
      }
    };
    Object.assign($xeradiobutton, radioButtonMethods);
    const handleValue = (label, evnt) => {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({
          label
        }, evnt);
      } else {
        emit('update:modelValue', label);
        radioButtonMethods.dispatchEvent('change', {
          label
        }, evnt);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeDisabled.value;
      const name = computeName.value;
      const checked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        class: ['vxe-radio', 'vxe-radio-button', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    Object.assign($xeradiobutton, {
      renderVN,
      dispatchEvent
    });
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/radio/src/group.ts






/* harmony default export */ var group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeRadioGroup',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => conf.radioGroup.strict
    },
    size: {
      type: String,
      default: () => conf.radioGroup.size || conf.size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeradiogroup = {
      xID,
      props,
      context,
      name: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('xegroup_')
    };
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    let radioGroupMethods = {};
    useSize(props);
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        emit('update:modelValue', params.label);
        radioGroupMethods.dispatchEvent('change', params);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, params.label);
        }
      }
    };
    radioGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $radioGroup: $xeradiogroup,
          $event: evnt
        }, params));
      }
    };
    const renderVN = () => {
      const {
        options,
        type
      } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === 'button' ? radio_src_button : src_radio;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-radio-group'
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(btnComp, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    Object.assign($xeradiogroup, radioGroupPrivateMethods, {
      renderVN,
      dispatchEvent
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeradiogroup', $xeradiogroup);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/export/src/import-panel.ts








/* harmony default export */ var import_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableImportPanel',
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const {
      computeImportOpts
    } = $xetable.getComputeMaps();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      loading: false
    });
    const refFileBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeSelectName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return `${storeData.filename}.${storeData.type}`;
    });
    const computeHasFile = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      return storeData.file && storeData.type;
    });
    const computeParseTypeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        storeData
      } = props;
      const {
        type,
        typeList
      } = storeData;
      if (type) {
        const selectItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(typeList, item => type === item.value);
        return selectItem ? conf.i18n(selectItem.label) : '*.*';
      }
      return `*.${typeList.map(item => item.value).join(', *.')}`;
    });
    const clearFileEvent = () => {
      const {
        storeData
      } = props;
      Object.assign(storeData, {
        filename: '',
        sheetName: '',
        type: ''
      });
    };
    const selectFileEvent = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      $xetable.readFile(defaultOptions).then(params => {
        const {
          file
        } = params;
        Object.assign(storeData, parseFile(file), {
          file
        });
      }).catch(e => e);
    };
    const showEvent = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const {
        storeData
      } = props;
      storeData.visible = false;
    };
    const importEvent = () => {
      const {
        storeData,
        defaultOptions
      } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xetable.importByFile(storeData.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const {
        defaultOptions,
        storeData
      } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(modal, {
        modelValue: storeData.visible,
        title: conf.i18n('vxe.import.impTitle'),
        className: 'vxe-table-import-popup-wrapper',
        width: 440,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        'onUpdate:modelValue'(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-export--panel'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.import.impFile')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [hasFile ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-import-selected--file',
            title: selectName
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', selectName), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: conf.icon.INPUT_CLEAR,
            onClick: clearFileEvent
          })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
            ref: refFileBtn,
            class: 'vxe-import-select--file',
            onClick: selectFileEvent
          }, conf.i18n('vxe.import.impSelect'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.import.impType')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', parseTypeLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', conf.i18n('vxe.import.impOpts')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(group, {
            modelValue: defaultOptions.mode,
            'onUpdate:modelValue'(value) {
              defaultOptions.mode = value;
            }
          }, {
            default: () => storeData.modeList.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_radio, {
              label: item.value,
              content: conf.i18n(item.label)
            }))
          })])])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-export--panel-btns'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            content: conf.i18n('vxe.import.impCancel'),
            onClick: cancelEvent
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            status: 'primary',
            disabled: !hasFile,
            content: conf.i18n('vxe.import.impConfirm'),
            onClick: importEvent
          })])]);
        }
      });
    };
    return renderVN;
  }
}));
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.delete.js
var web_url_search_params_delete = __webpack_require__(4603);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.has.js
var web_url_search_params_has = __webpack_require__(7566);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js
var web_url_search_params_size = __webpack_require__(8721);
;// CONCATENATED MODULE: ./packages/export/src/util.ts









// 导入
let fileForm;
let fileInput;
// 打印
let printFrame;
// 默认导出或打印的 HTML 样式
const defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createFrame() {
  const frame = document.createElement('iframe');
  frame.className = 'vxe-table--print-frame';
  return frame;
}
function getExportBlobByContent(content, options) {
  return new Blob([content], {
    type: `text/${options.type};charset=utf-8;`
  });
}
function createHtmlPage(opts, content) {
  const {
    style
  } = opts;
  return ['<!DOCTYPE html><html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">', `<title>${opts.sheetName}</title>`, '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>', `<style>${defaultHtmlStyle}</style>`, style ? `<style>${style}</style>` : '', '</head>', `<body>${content}</body>`, '</html>'].join('');
}
/**
 * 读取本地文件
 * @param {*} options 参数
 */
const readLocalFile = options => {
  const opts = Object.assign({}, options);
  if (!fileForm) {
    fileForm = document.createElement('form');
    fileInput = document.createElement('input');
    fileForm.className = 'vxe-table--file-form';
    fileInput.name = 'file';
    fileInput.type = 'file';
    fileForm.appendChild(fileInput);
    document.body.appendChild(fileForm);
  }
  return new Promise((resolve, reject) => {
    const types = opts.types || [];
    const isAllType = !types.length || types.some(type => type === '*');
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? '' : `.${types.join(', .')}`;
    fileInput.onchange = evnt => {
      const {
        files
      } = evnt.target;
      const file = files[0];
      let errType = '';
      // 校验类型
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const {
            type
          } = parseFile(files[fIndex]);
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({
          status: true,
          files,
          file
        });
      } else {
        if (opts.message !== false) {
          // 检测弹窗模块
          if (true) {
            if (!VXETable.modal) {
              errLog('vxe.error.reqModule', ['Modal']);
            }
          }
          VXETable.modal.message({
            content: conf.i18n('vxe.error.notType', [errType]),
            status: 'error'
          });
        }
        const params = {
          status: false,
          files,
          file
        };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function removePrintFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write('');
      } catch (e) {}
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removePrintFrame);
}
function handlePrint($xetable, opts, content = '') {
  const {
    beforePrintMethod
  } = opts;
  if (beforePrintMethod) {
    content = beforePrintMethod({
      content,
      options: opts,
      $table: $xetable
    }) || '';
  }
  content = createHtmlPage(opts, content);
  const blob = getExportBlobByContent(content, opts);
  if (browse.msie) {
    removePrintFrame();
    printFrame = createFrame();
    appendPrintFrame();
    printFrame.contentDocument.write(content);
    printFrame.contentDocument.execCommand('print');
  } else {
    if (!printFrame) {
      printFrame = createFrame();
      printFrame.onload = evnt => {
        if (evnt.target.src) {
          evnt.target.contentWindow.onafterprint = afterPrintEvent;
          evnt.target.contentWindow.print();
        }
      };
    }
    appendPrintFrame();
    printFrame.src = URL.createObjectURL(blob);
  }
}
/**
 * 保存文件到本地
 * @param {*} options 参数
 */
const saveLocalFile = options => {
  const {
    filename,
    type,
    content
  } = options;
  const name = `${filename}.${type}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content), options);
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement('a');
      linkElem.target = '_blank';
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getLog('vxe.error.notExp')));
};
;// CONCATENATED MODULE: ./packages/export/src/hook.ts









let htmlCellElem;
const csvBOM = '\ufeff';
const enterSymbol = '\r\n';
function defaultFilterExportColumn(column) {
  return column.property || ['seq', 'checkbox', 'radio'].indexOf(column.type) > -1;
}
const getConvertColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach(column => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return 'full';
  }
  if (border) {
    return border;
  }
  return 'default';
}
function getBooleanValue(cellValue) {
  return cellValue === 'TRUE' || cellValue === 'true' || cellValue === true;
}
function getFooterData(opts, footerTableData) {
  const {
    footerFilterMethod
  } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({
    items,
    $rowIndex: index
  })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === 'seq') {
      return `\t${cellValue}`;
    }
    switch (column.cellType) {
      case 'string':
        if (!isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
      case 'number':
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `\t${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, key => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, qVal => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function parseCsvAndTxt(columns, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach(rVal => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : '\n';
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map(val => getTxtCellValue(val.trim(), vMaps));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return {
    fields,
    rows
  };
}
function parseCsv(columns, content) {
  return parseCsvAndTxt(columns, content, ',');
}
function parseTxt(columns, content) {
  return parseCsvAndTxt(columns, content, '\t');
}
function parseHTML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'text/html');
  const bodyNodes = getElementsByTagName(xmlDoc, 'body');
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], 'table');
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], 'thead');
      if (theadNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(theadNodes[0], 'tr'), rowNode => {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'th'), cellNode => {
            fields.push(cellNode.textContent);
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');
        if (tbodyNodes.length) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(tbodyNodes[0], 'tr'), rowNode => {
            const item = {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNode, 'td'), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || '';
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return {
    fields,
    rows
  };
}
function parseXML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, 'application/xml');
  const sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], 'Table');
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], 'Row');
      if (rowNodes.length) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(getElementsByTagName(rowNodes[0], 'Cell'), cellNode => {
          fields.push(cellNode.textContent);
        });
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, 'Cell');
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return {
    fields,
    rows
  };
}
function clearColumnConvert(columns) {
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, {
    children: 'children'
  });
}
/**
 * 检查导入的列是否完整
 * @param {Array} fields 字段名列表
 * @param {Array} rows 数据列表
 */
function checkImportData(columns, fields) {
  const tableFields = [];
  columns.forEach(column => {
    const field = column.property;
    if (field) {
      tableFields.push(field);
    }
  });
  return fields.some(field => tableFields.indexOf(field) > -1);
}
const tableExportMethodKeys = ['exportData', 'importByFile', 'importData', 'saveFile', 'readFile', 'print', 'openImport', 'openExport', 'openPrint'];
const tableExportHook = {
  setupTable($xetable) {
    const {
      props,
      reactData,
      internalData
    } = $xetable;
    const {
      computeTreeOpts,
      computePrintOpts,
      computeExportOpts,
      computeImportOpts,
      computeCustomOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeColumnOpts
    } = $xetable.getComputeMaps();
    const $xegrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xegrid', null);
    const hasTreeChildren = row => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMethod = seqOpts.seqMethod || column.seqMethod;
      if (seqMethod) {
        return seqMethod({
          row,
          rowIndex: $xetable.getRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xetable.getColumnIndex(column),
          $columnIndex
        });
      }
      return $xetable.getRowSeq(row);
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({
        column,
        options: opts,
        $table: $xetable
      }) : (opts.original ? column.property : column.getTitle()) || '';
    }
    const toBooleanValue = cellValue => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(cellValue) ? cellValue ? 'TRUE' : 'FALSE' : cellValue;
    };
    const getLabelData = (opts, columns, datas) => {
      const {
        isAllExpand,
        mode
      } = opts;
      const {
        treeConfig
      } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement('div');
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        // 如果是树表格只允许导出数据源
        const rest = [];
        const expandMaps = new Map();
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const parentRow = parent && parent._row ? parent._row : parent;
          if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xetable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xetable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = '';
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = VXETable.renderer.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({
                  $table: $xetable,
                  row,
                  column,
                  options: opts
                });
              } else {
                switch (column.type) {
                  case 'seq':
                    cellValue = mode === 'all' ? path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('') : getSeq(row, $rowIndex, column, $columnIndex);
                    break;
                  case 'checkbox':
                    cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));
                    item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
                    item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
                      row
                    });
                    break;
                  case 'radio':
                    cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));
                    item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
                    item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
                      row
                    });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = $xetable.getCellLabel(row, column);
                      if (column.type === 'html') {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xetable.getCell(row, column);
                        if (cell) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item[column.id] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue);
            });
            expandMaps.set(row, 1);
            rest.push(Object.assign(item, row));
          }
        }, {
          children: childrenField
        });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = '';
          const renderOpts = column.editRender || column.cellRender;
          let exportLabelMethod = column.exportMethod;
          if (!exportLabelMethod && renderOpts && renderOpts.name) {
            const compConf = VXETable.renderer.get(renderOpts.name);
            if (compConf) {
              exportLabelMethod = compConf.exportMethod;
            }
          }
          if (exportLabelMethod) {
            cellValue = exportLabelMethod({
              $table: $xetable,
              row,
              column,
              options: opts
            });
          } else {
            switch (column.type) {
              case 'seq':
                cellValue = mode === 'all' ? $rowIndex + 1 : getSeq(row, $rowIndex, column, $columnIndex);
                break;
              case 'checkbox':
                cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkboxOpts.labelField) : '';
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({
                  row
                });
                break;
              case 'radio':
                cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, radioOpts.labelField) : '';
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({
                  row
                });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xetable.getCellLabel(row, column);
                  if (column.type === 'html') {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xetable.getCell(row, column);
                    if (cell) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue);
        });
        return item;
      });
    };
    const getExportData = opts => {
      const {
        columns,
        dataFilterMethod
      } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index) => dataFilterMethod({
          row,
          $rowIndex: index
        }));
      }
      return getLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, items, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = VXETable.renderer.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      const _columnIndex = $xetable.getVTColumnIndex(column);
      const cellValue = footLabelMethod ? footLabelMethod({
        $table: $xetable,
        items,
        itemIndex: _columnIndex,
        row: items,
        _columnIndex,
        column,
        options: opts
      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(items[_columnIndex]);
      return cellValue;
    };
    const toCsv = (opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join(',') + enterSymbol;
      }
      datas.forEach(row => {
        content += columns.map(column => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(',') + enterSymbol;
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach(rows => {
          content += columns.map(column => toTxtCellLabel(getFooterCellValue(opts, rows, column))).join(',') + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = (opts, columns, datas) => {
      let content = '';
      if (opts.isHeader) {
        content += columns.map(column => toTxtCellLabel(getHeaderTitle(opts, column))).join('\t') + enterSymbol;
      }
      datas.forEach(row => {
        content += columns.map(column => toTxtCellLabel(row[column.id])).join('\t') + enterSymbol;
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach(rows => {
          content += columns.map(column => toTxtCellLabel(getFooterCellValue(opts, rows, column))).join(',') + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === 'ellipsis';
      const showTitle = headOverflow === 'title';
      const showTooltip = headOverflow === true || headOverflow === 'tooltip';
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      // 虚拟滚动不支持动态高度
      const {
        scrollXLoad,
        scrollYLoad
      } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const {
        id,
        border,
        treeConfig,
        headerAlign: allHeaderAlign,
        align: allAlign,
        footerAlign: allFooterAlign,
        showOverflow: allColumnOverflow,
        showHeaderOverflow: allColumnHeaderOverflow
      } = props;
      const {
        isAllSelected,
        isIndeterminate,
        mergeList
      } = reactData;
      const treeOpts = computeTreeOpts.value;
      const {
        print: isPrint,
        isHeader,
        isFooter,
        isColgroup,
        isMerge,
        colgroups,
        original
      } = opts;
      const allCls = 'check-all';
      const clss = ['vxe-table', `border--${toTableBorder(border)}`, isPrint ? 'is--print' : '', isHeader ? 'is--header' : ''].filter(cls => cls);
      const tables = [`<table class="${clss.join(' ')}" border="0" cellspacing="0" cellpadding="0">`, `<colgroup>${columns.map(column => `<col style="width:${column.renderWidth}px">`).join('')}</colgroup>`];
      if (isHeader) {
        tables.push('<thead>');
        if (isColgroup && !original) {
          colgroups.forEach(cols => {
            tables.push(`<tr>${cols.map(column => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, {
                children: 'childNodes'
              });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === 'checkbox') {
                return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(' ')}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join('')}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map(column => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === 'checkbox') {
              return `<th class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? 'checked' : ''}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(' ')}" title="${cellTitle}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join('')}</tr>`);
        }
        tables.push('</thead>');
      }
      if (datas.length) {
        tables.push('<tbody>');
        if (treeConfig) {
          datas.forEach(item => {
            tables.push('<tr>' + columns.map(column => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = item[column.id];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = '';
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? 'vxe-table--tree-fold-icon' : 'vxe-table--tree-unfold-icon'}"></i>`;
                }
                classNames.push('vxe-table--tree-node');
                if (column.type === 'radio') {
                  return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === 'checkbox') {
                  return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === 'radio') {
                return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === 'checkbox') {
                return `<td class="${classNames.join(' ')}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('') + '</tr>');
          });
        } else {
          datas.forEach(item => {
            tables.push('<tr>' + columns.map(column => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge && mergeList.length) {
                const _rowIndex = $xetable.getVTRowIndex(item._row);
                const _columnIndex = $xetable.getVTColumnIndex(column);
                const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const {
                    rowspan,
                    colspan
                  } = spanRest;
                  if (!rowspan || !colspan) {
                    return '';
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === 'radio') {
                return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === 'checkbox') {
                return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? 'disabled ' : ''}${getBooleanValue(cellValue) ? 'checked' : ''}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(' ')}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('') + '</tr>');
          });
        }
        tables.push('</tbody>');
      }
      if (isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData(opts, footerTableData);
        if (footers.length) {
          tables.push('<tfoot>');
          footers.forEach(rows => {
            tables.push(`<tr>${columns.map(column => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];
              const cellValue = getFooterCellValue(opts, rows, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(' ')}" title="${cellValue}"><div ${isPrint ? '' : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join('')}</tr>`);
          });
          tables.push('</tfoot>');
        }
      }
      // 是否半选状态
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()</script>` : '';
      tables.push('</table>', script);
      return isPrint ? tables.join('') : createHtmlPage(opts, tables.join(''));
    };
    const toXML = (opts, columns, datas) => {
      let xml = ['<?xml version="1.0"?>', '<?mso-application progid="Excel.Sheet"?>', '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">', '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">', '<Version>16.00</Version>', '</DocumentProperties>', '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">', '<WindowHeight>7920</WindowHeight>', '<WindowWidth>21570</WindowWidth>', '<WindowTopX>32767</WindowTopX>', '<WindowTopY>32767</WindowTopY>', '<ProtectStructure>False</ProtectStructure>', '<ProtectWindows>False</ProtectWindows>', '</ExcelWorkbook>', `<Worksheet ss:Name="${opts.sheetName}">`, '<Table>', columns.map(column => `<Column ss:Width="${column.renderWidth}"/>`).join('')].join('');
      if (opts.isHeader) {
        xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join('')}</Row>`;
      }
      datas.forEach(row => {
        xml += '<Row>' + columns.map(column => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join('') + '</Row>';
      });
      if (opts.isFooter) {
        const {
          footerTableData
        } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach(rows => {
          xml += `<Row>${columns.map(column => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, rows, column)}</Data></Cell>`).join('')}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = (opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case 'csv':
            return toCsv(opts, columns, datas);
          case 'txt':
            return toTxt(opts, columns, datas);
          case 'html':
            return toHtml(opts, columns, datas);
          case 'xml':
            return toXML(opts, columns, datas);
        }
      }
      return '';
    };
    const downloadFile = (opts, content) => {
      const {
        filename,
        type,
        download
      } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({
          type,
          content,
          blob
        });
      }
      saveLocalFile({
        filename,
        type,
        content
      }).then(() => {
        if (opts.message !== false) {
          // 检测弹窗模块
          if (true) {
            if (!VXETable.modal) {
              errLog('vxe.error.reqModule', ['Modal']);
            }
          }
          VXETable.modal.message({
            content: conf.i18n('vxe.table.expSuccess'),
            status: 'success'
          });
        }
      });
    };
    const handleExport = opts => {
      const {
        remote,
        columns,
        colgroups,
        exportMethod,
        afterExportMethod
      } = opts;
      return new Promise(resolve => {
        if (remote) {
          const params = {
            options: opts,
            $table: $xetable,
            $grid: $xegrid
          };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xetable.preventEvent(null, 'event.export', {
            options: opts,
            columns,
            colgroups,
            datas
          }, () => {
            return downloadFile(opts, getContent(opts, columns, datas));
          }));
        }
      }).then(params => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({
              status: true,
              options: opts,
              $table: $xetable,
              $grid: $xegrid
            });
          }
        }
        return Object.assign({
          status: true
        }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({
              status: false,
              options: opts,
              $table: $xetable,
              $grid: $xegrid
            });
          }
        }
        const params = {
          status: false
        };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const {
        tableFullColumn,
        _importResolve,
        _importReject
      } = internalData;
      let rest = {
        fields: [],
        rows: []
      };
      switch (opts.type) {
        case 'csv':
          rest = parseCsv(tableFullColumn, content);
          break;
        case 'txt':
          rest = parseTxt(tableFullColumn, content);
          break;
        case 'html':
          rest = parseHTML(tableFullColumn, content);
          break;
        case 'xml':
          rest = parseXML(tableFullColumn, content);
          break;
      }
      const {
        fields,
        rows
      } = rest;
      const status = checkImportData(tableFullColumn, fields);
      if (status) {
        $xetable.createData(rows).then(data => {
          let loadRest;
          if (opts.mode === 'insert') {
            loadRest = $xetable.insert(data);
          } else {
            loadRest = $xetable.reloadData(data);
          }
          if (opts.message !== false) {
            // 检测弹窗模块
            if (true) {
              if (!VXETable.modal) {
                errLog('vxe.error.reqModule', ['Modal']);
              }
            }
            VXETable.modal.message({
              content: conf.i18n('vxe.table.impSuccess', [rows.length]),
              status: 'success'
            });
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({
                status: true
              });
            }
          });
        });
      } else if (opts.message !== false) {
        // 检测弹窗模块
        if (true) {
          if (!VXETable.modal) {
            errLog('vxe.error.reqModule', ['Modal']);
          }
        }
        VXETable.modal.message({
          content: conf.i18n('vxe.error.impFields'),
          status: 'error'
        });
        if (_importReject) {
          _importReject({
            status: false
          });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const {
        importMethod,
        afterImportMethod
      } = opts;
      const {
        type,
        filename
      } = parseFile(file);
      // 检查类型，如果为自定义导出，则不需要校验类型
      if (!importMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(VXETable.globalConfs.importTypes, type)) {
        if (opts.message !== false) {
          // 检测弹窗模块
          if (true) {
            if (!VXETable.modal) {
              errLog('vxe.error.reqModule', ['Modal']);
            }
          }
          VXETable.modal.message({
            content: conf.i18n('vxe.error.notType', [type]),
            status: 'error'
          });
        }
        const params = {
          status: false
        };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = params => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = params => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({
            mode: 'insert'
          }, opts, {
            type,
            filename
          });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({
                file,
                options,
                $table: $xetable
              })).then(() => {
                _importResolve({
                  status: true
                });
              }).catch(() => {
                _importResolve({
                  status: true
                });
              });
            } else {
              _importResolve({
                status: true
              });
            }
          } else {
            const {
              tableFullColumn
            } = internalData;
            $xetable.preventEvent(null, 'event.import', {
              file,
              options,
              columns: tableFullColumn
            }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog('vxe.error.notType', [type]);
                _importReject({
                  status: false
                });
              };
              reader.onload = e => {
                handleImport(e.target.result, options);
              };
              reader.readAsText(file, options.encoding || 'UTF-8');
            });
          }
        } else {
          // 不支持的浏览器
          if (true) {
            errLog('vxe.error.notExp');
          }
          _importResolve({
            status: true
          });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({
            status: true,
            options: opts,
            $table: $xetable
          });
        }
      }).catch(e => {
        if (afterImportMethod) {
          afterImportMethod({
            status: false,
            options: opts,
            $table: $xetable
          });
        }
        return Promise.reject(e);
      });
    };
    const handleExportAndPrint = (options, isPrint) => {
      const {
        treeConfig,
        showHeader,
        showFooter
      } = props;
      const {
        initStore,
        mergeList,
        isGroup,
        footerTableData,
        exportStore,
        exportParams
      } = reactData;
      const {
        collectColumn
      } = internalData;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xetable.getCheckboxRecords();
      const hasFooter = !!footerTableData.length;
      const hasMerge = !hasTree && mergeList.length;
      const defOpts = Object.assign({
        message: true,
        isHeader: showHeader,
        isFooter: showFooter
      }, options);
      const types = defOpts.types || VXETable.globalConfs.exportTypes;
      const modes = defOpts.modes;
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const {
        columns
      } = defOpts;
      // 处理类型
      const typeList = types.map(value => {
        return {
          value,
          label: `vxe.export.types.${value}`
        };
      });
      const modeList = modes.map(value => {
        return {
          value,
          label: `vxe.export.modes.${value}`
        };
      });
      // 默认选中
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(exportColumns, (column, index, items, path, parent) => {
        const isColGroup = column.children && column.children.length;
        if (isColGroup || defaultFilterExportColumn(column)) {
          column.checked = columns ? columns.some(item => {
            if (isColumnInfo(item)) {
              return column === item;
            } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
              return column.field === item;
            } else {
              const colid = item.id || item.colId;
              const type = item.type;
              const field = item.property || item.field;
              if (colid) {
                return column.id === colid;
              } else if (field && type) {
                return column.property === field && column.type === type;
              } else if (field) {
                return column.property === field;
              } else if (type) {
                return column.type === type;
              }
            }
            return false;
          }) : column.visible;
          column.halfChecked = false;
          column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({
            column
          }) : false);
        }
      });
      // 更新条件
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      // 默认参数
      Object.assign(exportParams, {
        mode: selectRecords.length ? 'selected' : 'current'
      }, defOpts);
      if (modes.indexOf(exportParams.mode) === -1) {
        exportParams.mode = modes[0];
      }
      if (types.indexOf(exportParams.type) === -1) {
        exportParams.type = types[0];
      }
      initStore.export = true;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const exportMethods = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据
       * @param {Object} options 参数
       */
      exportData(options) {
        const {
          treeConfig
        } = props;
        const {
          isGroup,
          tableGroupColumn
        } = reactData;
        const {
          tableFullColumn,
          afterFullData
        } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const opts = Object.assign({
          // filename: '',
          // sheetName: '',
          // original: false,
          // message: false,
          isHeader: true,
          isFooter: true,
          isColgroup: true,
          // isMerge: false,
          // isAllExpand: false,
          download: true,
          type: 'csv',
          mode: 'current'
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, {
          print: false
        }, options);
        const {
          type,
          mode,
          columns,
          original,
          beforeExportMethod
        } = opts;
        let groups = [];
        const customCols = columns && columns.length ? columns : null;
        let columnFilterMethod = opts.columnFilterMethod;
        // 如果设置源数据，则默认导出设置了字段的列
        if (!customCols && !columnFilterMethod) {
          columnFilterMethod = original ? ({
            column
          }) => column.property : ({
            column
          }) => defaultFilterExportColumn(column);
        }
        if (customCols) {
          opts._isCustomColumn = true;
          groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(customCols, item => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
                targetColumn = $xetable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type = item.type;
                const field = item.property || item.field;
                if (colid) {
                  targetColumn = $xetable.getColumnById(colid);
                } else if (field && type) {
                  targetColumn = tableFullColumn.find(column => column.property === field && column.type === type);
                } else if (field) {
                  targetColumn = $xetable.getColumnByField(field);
                } else if (type) {
                  targetColumn = tableFullColumn.find(column => column.type === type);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: 'childNodes',
            mapChildren: '_children'
          }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({
            column: column,
            $columnIndex: index
          })), {
            children: '_children',
            mapChildren: 'childNodes',
            original: true
          });
        } else {
          groups = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(isGroup ? tableGroupColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({
            column,
            $columnIndex: index
          })), {
            children: 'children',
            mapChildren: 'childNodes',
            original: true
          });
        }
        // 获取所有列
        const cols = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(groups, column => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, {
          children: 'childNodes'
        });
        // 构建分组层级
        opts.columns = cols;
        opts.colgroups = convertToRows(groups);
        if (!opts.filename) {
          opts.filename = conf.i18n(opts.original ? 'vxe.table.expOriginFilename' : 'vxe.table.expFilename', [external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(Date.now(), 'yyyyMMddHHmmss')]);
        }
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        // 检查类型，如果为自定义导出，则不需要校验类型
        if (!opts.exportMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(VXETable.globalConfs.exportTypes, type)) {
          if (true) {
            errLog('vxe.error.notType', [type]);
          }
          const params = {
            status: false
          };
          return Promise.reject(params);
        }
        if (!opts.print) {
          if (beforeExportMethod) {
            beforeExportMethod({
              options: opts,
              $table: $xetable,
              $grid: $xegrid
            });
          }
        }
        if (!opts.data) {
          opts.data = afterFullData;
          if (mode === 'selected') {
            const selectRecords = $xetable.getCheckboxRecords();
            if (['html', 'pdf'].indexOf(type) > -1 && treeConfig) {
              opts.data = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree($xetable.getTableData().fullData, item => $xetable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, {
                data: '_row'
              }));
            } else {
              opts.data = selectRecords;
            }
          } else if (mode === 'all') {
            if (true) {
              if (!$xegrid) {
                warnLog('vxe.error.errProp', ['all', 'mode=current,selected']);
              }
            }
            if ($xegrid && !opts.remote) {
              const {
                reactData: gridReactData
              } = $xegrid;
              const {
                computeProxyOpts
              } = $xegrid.getComputeMaps();
              const proxyOpts = computeProxyOpts.value;
              const {
                beforeQueryAll,
                afterQueryAll,
                ajax = {},
                props = {}
              } = proxyOpts;
              const ajaxMethods = ajax.queryAll;
              if (true) {
                if (!ajaxMethods) {
                  warnLog('vxe.error.notFunc', ['proxy-config.ajax.queryAll']);
                }
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xetable,
                  $grid: $xegrid,
                  sort: gridReactData.sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  target: ajaxMethods,
                  options: opts
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).catch(e => e).then(rest => {
                  opts.data = (props.list ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, props.list) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  return handleExport(opts);
                });
              }
            }
          }
        }
        return handleExport(opts);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const {
          beforeImportMethod
        } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({
            options: opts,
            $table: $xetable
          });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: VXETable.globalConfs.importTypes
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const {
          beforeImportMethod,
          afterImportMethod
        } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({
            options: opts,
            $table: $xetable
          });
        }
        return readLocalFile(opts).catch(e => {
          if (afterImportMethod) {
            afterImportMethod({
              status: false,
              options: opts,
              $table: $xetable
            });
          }
          return Promise.reject(e);
        }).then(params => {
          const {
            file
          } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return saveLocalFile(options);
      },
      readFile(options) {
        return readLocalFile(options);
      },
      print(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: 'html',
          download: false,
          remote: false,
          print: true
        });
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        return new Promise(resolve => {
          if (opts.content) {
            resolve(handlePrint($xetable, opts, opts.content));
          } else {
            resolve(exportMethods.exportData(opts).then(({
              content
            }) => {
              return handlePrint($xetable, opts, content);
            }));
          }
        });
      },
      openImport(options) {
        const {
          treeConfig,
          importConfig
        } = props;
        const {
          initStore,
          importStore,
          importParams
        } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({
          mode: 'insert',
          message: true,
          types: VXETable.globalConfs.importTypes
        }, options, importOpts);
        const {
          types
        } = defOpts;
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            VXETable.modal.message({
              content: conf.i18n('vxe.error.treeNotImp'),
              status: 'error'
            });
          }
          return;
        }
        if (!importConfig) {
          errLog('vxe.error.reqProp', ['import-config']);
        }
        // 处理类型
        const typeList = types.map(value => {
          return {
            value,
            label: `vxe.export.types.${value}`
          };
        });
        const modeList = defOpts.modes.map(value => {
          return {
            value,
            label: `vxe.import.modes.${value}`
          };
        });
        Object.assign(importStore, {
          file: null,
          type: '',
          filename: '',
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        initStore.import = true;
      },
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        if (true) {
          if (!props.exportConfig) {
            errLog('vxe.error.reqProp', ['export-config']);
          }
        }
        handleExportAndPrint(Object.assign({}, exportOpts, options));
      },
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        if (true) {
          if (!props.printConfig) {
            errLog('vxe.error.reqProp', ['print-config']);
          }
        }
        handleExportAndPrint(Object.assign({}, printOpts, options), true);
      }
    };
    return exportMethods;
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableExportMethodKeys);
  }
};
/* harmony default export */ var export_src_hook = (tableExportHook);
;// CONCATENATED MODULE: ./packages/export/index.ts







const print = options => {
  const opts = Object.assign({}, options, {
    type: 'html'
  });
  handlePrint(null, opts, opts.content);
};
const VxeTableExportModule = {
  ExportPanel: export_panel,
  ImportPanel: import_panel,
  install(app) {
    VXETable.saveFile = saveLocalFile;
    VXETable.readFile = readLocalFile;
    VXETable.print = print;
    VXETable.setConfig({
      export: {
        types: {
          csv: 0,
          html: 0,
          xml: 0,
          txt: 0
        }
      }
    });
    VXETable.hooks.add('$tableExport', export_src_hook);
    app.component(export_panel.name, export_panel);
    app.component(import_panel.name, import_panel);
  }
};
const Export = VxeTableExportModule;
dynamicApp.component(export_panel.name, export_panel);
dynamicApp.component(import_panel.name, import_panel);
/* harmony default export */ var packages_export = ((/* unused pure expression or super */ null && (VxeTableExportModule)));
;// CONCATENATED MODULE: ./packages/keyboard/src/hook.ts



function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !browse.firefox && hasClass(target, 'vxe-checkbox--label');
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxStyle.paddingTop);
      offsetLeft -= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(checkboxStyle.paddingLeft);
    }
  }
  return {
    offsetTop,
    offsetLeft
  };
}
const tableKeyboardHook = {
  setupTable($xetable) {
    const {
      props,
      reactData,
      internalData
    } = $xetable;
    const {
      refElem
    } = $xetable.getRefMaps();
    const {
      computeEditOpts,
      computeCheckboxOpts,
      computeMouseOpts,
      computeTreeOpts
    } = $xetable.getComputeMaps();
    function getCheckboxRangeRows(params, targetTrElem, moveRange) {
      let countHeight = 0;
      let rangeRows = [];
      const isDown = moveRange > 0;
      const moveSize = moveRange > 0 ? moveRange : Math.abs(moveRange) + targetTrElem.offsetHeight;
      const {
        scrollYLoad
      } = reactData;
      const {
        afterFullData,
        scrollYStore
      } = internalData;
      if (scrollYLoad) {
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        if (isDown) {
          rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / scrollYStore.rowHeight));
        } else {
          rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / scrollYStore.rowHeight) + 1, _rowIndex + 1);
        }
      } else {
        const siblingProp = isDown ? 'next' : 'previous';
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xetable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const {
        column,
        cell
      } = params;
      if (column.type === 'checkbox') {
        const el = refElem.value;
        const {
          elemStore
        } = internalData;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const bodyWrapperRef = elemStore[`${column.fixed || 'main'}-body-wrapper`] || elemStore['main-body-wrapper'];
        const bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;
        if (!bodyWrapperElem) {
          return;
        }
        const checkboxRangeElem = bodyWrapperElem.querySelector('.vxe-table--checkbox-range');
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const trElem = cell.parentNode;
        const selectRecords = $xetable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent = (type, evnt) => {
          $xetable.dispatchEvent(`checkbox-range-${type}`, {
            records: $xetable.getCheckboxRecords(),
            reserves: $xetable.getCheckboxReserveRecords()
          }, evnt);
        };
        const handleChecked = evnt => {
          const {
            clientX,
            clientY
          } = evnt;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            // 向上
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            // 向下
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            // 向左
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            // 向右
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = 'block';
          const rangeRows = getCheckboxRangeRows(params, trElem, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          // 至少滑动 10px 才能有效匹配
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            lastRangeRows = rangeRows;
            if (evnt.ctrlKey) {
              rangeRows.forEach(row => {
                $xetable.handleSelectRow({
                  row
                }, selectRecords.indexOf(row) === -1);
              });
            } else {
              $xetable.setAllCheckboxRow(false);
              $xetable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent('change', evnt);
          }
        };
        // 停止鼠标滚动
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        // 开始鼠标滚动
        const startMouseScroll = evnt => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const {
                scrollLeft,
                scrollTop,
                clientHeight,
                scrollHeight
              } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xetable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xetable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt);
                  handleChecked(evnt);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, 'drag--range');
        document.onmousemove = evnt => {
          evnt.preventDefault();
          evnt.stopPropagation();
          const {
            clientY
          } = evnt;
          const {
            boundingTop
          } = getAbsolutePos(bodyWrapperElem);
          // 如果超过可视区，触发滚动
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt);
        };
        document.onmouseup = evnt => {
          stopMouseScroll();
          removeClass(el, 'drag--range');
          checkboxRangeElem.removeAttribute('style');
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          triggerEvent('end', evnt);
        };
        triggerEvent('start', evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const {
        editConfig,
        checkboxConfig,
        mouseConfig
      } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xetable.handleCellAreaEvent) {
        return $xetable.handleCellAreaEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === 'cell') {
            $xetable.handleSelected(params, evnt);
          }
        }
      }
    };
    const keyboardMethods = {
      // 处理 Tab 键移动
      moveTabSelected(args, isLeft, evnt) {
        const {
          editConfig
        } = props;
        const {
          afterFullData,
          visibleColumn
        } = internalData;
        const editOpts = computeEditOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        const _columnIndex = $xetable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          // 向左
          if (_columnIndex <= 0) {
            // 如果已经是第一列，则移动到上一行
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            // 如果已经是第一列，则移动到上一行
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xetable.getCell(params.row, params.column);
          if (editConfig) {
            if (editOpts.trigger === 'click' || editOpts.trigger === 'dblclick') {
              if (editOpts.mode === 'row') {
                $xetable.handleActived(params, evnt);
              } else {
                $xetable.scrollToRow(params.row, params.column).then(() => $xetable.handleSelected(params, evnt));
              }
            }
          } else {
            $xetable.scrollToRow(params.row, params.column).then(() => $xetable.handleSelected(params, evnt));
          }
        }
      },
      // 处理当前行方向键移动
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const {
          treeConfig
        } = props;
        const {
          currentRow
        } = reactData;
        const {
          afterFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        evnt.preventDefault();
        if (currentRow) {
          if (treeConfig) {
            const {
              index,
              items
            } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, item => item === currentRow, {
              children: childrenField
            });
            if (isUpArrow && index > 0) {
              targetRow = items[index - 1];
            } else if (isDwArrow && index < items.length - 1) {
              targetRow = items[index + 1];
            }
          } else {
            const _rowIndex = $xetable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          const params = {
            $table: $xetable,
            row: targetRow,
            rowIndex: $xetable.getRowIndex(targetRow),
            $rowIndex: $xetable.getVMRowIndex(targetRow)
          };
          $xetable.scrollToRow(targetRow).then(() => $xetable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 处理可编辑方向键移动
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const {
          afterFullData,
          visibleColumn
        } = internalData;
        const params = Object.assign({}, args);
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        const _columnIndex = $xetable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isUpArrow && _rowIndex > 0) {
          // 移动到上一行
          params.rowIndex = _rowIndex - 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
          // 移动到下一行
          params.rowIndex = _rowIndex + 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isLeftArrow && _columnIndex) {
          // 移动到左侧单元格
          params.columnIndex = _columnIndex - 1;
          params.column = visibleColumn[params.columnIndex];
        } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
          // 移动到右侧单元格
          params.columnIndex = _columnIndex + 1;
          params.column = visibleColumn[params.columnIndex];
        }
        $xetable.scrollToRow(params.row, params.column).then(() => {
          params.cell = $xetable.getCell(params.row, params.column);
          $xetable.handleSelected(params, evnt);
        });
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const {
          mouseConfig
        } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xetable.handleHeaderCellAreaEvent) {
          const cell = evnt.currentTarget;
          const triggerSort = getEventTargetNode(evnt, cell, 'vxe-cell--sort').flag;
          const triggerFilter = getEventTargetNode(evnt, cell, 'vxe-cell--filter').flag;
          $xetable.handleHeaderCellAreaEvent(evnt, Object.assign({
            cell,
            triggerSort,
            triggerFilter
          }, params));
        }
        $xetable.focus();
        if ($xetable.closeMenu) {
          $xetable.closeMenu();
        }
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(evnt, params) {
        const cell = evnt.currentTarget;
        params.cell = cell;
        handleCellMousedownEvent(evnt, params);
        $xetable.focus();
        $xetable.closeFilter();
        if ($xetable.closeMenu) {
          $xetable.closeMenu();
        }
      }
    };
    return keyboardMethods;
  }
};
/* harmony default export */ var keyboard_src_hook = (tableKeyboardHook);
;// CONCATENATED MODULE: ./packages/keyboard/index.ts


const VxeTableKeyboardModule = {
  install() {
    VXETable.hooks.add('$tableKeyboard', keyboard_src_hook);
  }
};
const Keyboard = VxeTableKeyboardModule;
/* harmony default export */ var keyboard = ((/* unused pure expression or super */ null && (VxeTableKeyboardModule)));
;// CONCATENATED MODULE: ./packages/validator/src/hook.ts









/**
 * 校验规则
 */
class Rule {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
const tableValidatorMethodKeys = ['fullValidate', 'validate', 'clearValidate'];
const validatorHook = {
  setupTable($xetable) {
    const {
      props,
      reactData,
      internalData
    } = $xetable;
    const {
      refValidTooltip
    } = $xetable.getRefMaps();
    const {
      computeValidOpts,
      computeTreeOpts,
      computeEditOpts
    } = $xetable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    /**
     * 聚焦到校验通过的单元格并弹出校验错误提示
     */
    const handleValidError = params => {
      return new Promise(resolve => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xetable.dispatchEvent('valid-error', params, null);
          resolve();
        } else {
          $xetable.handleActived(params, {
            type: 'valid-error',
            trigger: 'call'
          }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = validErrMaps => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === 'single') {
        const keys = Object.keys(validErrMaps);
        const resMaps = validErrMaps;
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    /**
     * 对表格数据进行校验
     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改
     * 如果传 true 则校验当前表格数据
     * 如果传 row 指定行记录，则只验证传入的行
     * 如果传 rows 为多行记录，则只验证传入的行
     * 如果只传 callback 否则默认验证整个表格数据
     * 返回 Promise 对象，或者使用回调方式
     */
    const beginValidate = (rows, cb, isFull) => {
      const validRest = {};
      const {
        editRules,
        treeConfig
      } = props;
      const {
        afterFullData,
        visibleColumn
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rows)) {
          cb = rows;
        } else {
          validList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xetable.getInsertRecords) {
          validList = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = $xetable.getColumns();
        const handleVaild = row => {
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach(column => {
              if ((isFull || !validRuleErr) && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(editRules, column.property)) {
                colVailds.push(validatorPrivateMethods.validCellRules('all', row, column).catch(({
                  rule,
                  rules
                }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xetable.getRowIndex(row),
                    row,
                    columnIndex: $xetable.getColumnIndex(column),
                    column,
                    field: column.property,
                    $table: $xetable
                  };
                  if (!validRest[column.property]) {
                    validRest[column.property] = [];
                  }
                  validErrMaps[`${getRowid($xetable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[column.property].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(validList, handleVaild, {
            children: childrenField
          });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch(firstErrParams => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (conf.validToReject === 'obsolete') {
                    // 已废弃，校验失败将不会执行catch
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            /**
             * 当校验不通过时
             * 将表格滚动到可视区
             * 由于提示信息至少需要占一行，定位向上偏移一行
             */
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              const rowIndex = afterFullData.indexOf(row);
              const columnIndex = visibleColumn.indexOf(column);
              const targetRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;
              const targetColumn = columnIndex > 0 ? visibleColumn[columnIndex - 1] : column;
              $xetable.scrollToRow(targetRow, targetColumn).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        if (cb) {
          cb();
        }
      });
    };
    validatorMethods = {
      /**
       * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(rows, cb) {
        if (true) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cb)) {
            warnLog('vxe.error.notValidators', ['fullValidate(rows, callback)', 'fullValidate(rows)']);
          }
        }
        return beginValidate(rows, cb, true);
      },
      /**
       * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(rows, cb) {
        if (true) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cb)) {
            warnLog('vxe.error.notValidators', ['validate(rows, callback)', 'validate(rows)']);
          }
        }
        return beginValidate(rows, cb);
      },
      clearValidate(rows, fieldOrColumn) {
        const {
          validErrorMaps
        } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows) ? rows : rows ? [rows] : [];
        const colList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrColumn) ? fieldOrColumn : (fieldOrColumn ? [fieldOrColumn] : []).map(column => handleFieldOrColumn($xetable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        // 如果是单个提示模式
        if (validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {};
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach(row => {
            colList.forEach(column => {
              const validKey = `${getRowid($xetable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map(row => `${getRowid($xetable, row)}`);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(':')[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map(column => `${column.id}`);
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(':')[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const validErrorRuleValue = (rule, val) => {
      const {
        type,
        min,
        max,
        pattern
      } = rule;
      const isNumType = type === 'number';
      const numVal = isNumType ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(val);
      // 判断数值
      if (isNumType && isNaN(val)) {
        return true;
      }
      // 如果存在 min，判断最小值
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && numVal < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
        return true;
      }
      // 如果存在 max，判断最大值
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && numVal > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
        return true;
      }
      // 如果存在 pattern，正则校验
      if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
        return true;
      }
      return false;
    };
    validatorPrivateMethods = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(validType, row, column, val) {
        const {
          editRules
        } = props;
        const {
          field
        } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, field);
          if (rules) {
            const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, field) : val;
            rules.forEach(rule => {
              const {
                type,
                trigger,
                required,
                validator
              } = rule;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xetable.getRowIndex(row),
                    column,
                    columnIndex: $xetable.getColumnIndex(column),
                    field: column.field,
                    $table: $xetable,
                    $grid: $xetable.xegrid
                  };
                  let customValid;
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                    const gvItem = VXETable.validators.get(validator);
                    if (gvItem) {
                      if (gvItem.cellValidatorMethod) {
                        customValid = gvItem.cellValidatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog('vxe.error.notValidators', [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog('vxe.error.notValidators', [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger,
                        content: customValid.message,
                        rule: new Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // 如果为异步校验（注：异步校验是并发无序的）
                      syncValidList.push(customValid.catch(e => {
                        validRuleErr = true;
                        errorRules.push(new Rule({
                          type: 'custom',
                          trigger,
                          content: e && e.message ? e.message : rule.content || rule.message,
                          rule: new Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === 'array';
                  const isArrVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(cellValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !cellValue.length;
                  } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(cellValue)) {
                    hasEmpty = eqEmptyValue(cellValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(cellValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, cellValue) : !hasEmpty && validErrorRuleValue(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = {
              rules: errorRules,
              rule: errorRules[0]
            };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const {
          editRules
        } = props;
        const {
          field
        } = column;
        if (field && editRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, field);
          return rules && !!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(rules, rule => type === 'all' || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 触发校验
       */
      triggerValidate(type) {
        const {
          editConfig,
          editRules
        } = props;
        const {
          editStore
        } = reactData;
        const {
          actived
        } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        // 检查清除校验消息
        if (editRules && validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {};
        }
        // 校验单元格
        if (editConfig && editRules && actived.row) {
          const {
            row,
            column,
            cell
          } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === 'row') {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({
              rule
            }) => {
              // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理
              if (!rule.trigger || type === rule.trigger) {
                const rest = {
                  rule,
                  row,
                  column,
                  cell
                };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(params) {
        const {
          height
        } = props;
        const {
          tableData,
          validStore,
          validErrorMaps
        } = reactData;
        const {
          rule,
          row,
          column,
          cell
        } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === 'single') {
          reactData.validErrorMaps = {
            [`${getRowid($xetable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xetable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xetable.dispatchEvent('valid-error', params, null);
        if (validTip) {
          if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    return {
      ...validatorMethods,
      ...validatorPrivateMethods
    };
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableValidatorMethodKeys);
  }
};
/* harmony default export */ var validator_src_hook = (validatorHook);
;// CONCATENATED MODULE: ./packages/validator/index.ts


const VxeTableValidatorModule = {
  install() {
    VXETable.hooks.add('$tableValidator', validator_src_hook);
  }
};
const Validator = VxeTableValidatorModule;
/* harmony default export */ var validator = ((/* unused pure expression or super */ null && (VxeTableValidatorModule)));
;// CONCATENATED MODULE: ./packages/tooltip/src/tooltip.ts







/* harmony default export */ var tooltip = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTooltip',
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => conf.tooltip.size || conf.size
    },
    trigger: {
      type: String,
      default: () => conf.tooltip.trigger || 'hover'
    },
    theme: {
      type: String,
      default: () => conf.tooltip.theme || 'dark'
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: {
      type: Boolean,
      default: true
    },
    enterable: Boolean,
    enterDelay: {
      type: Number,
      default: () => conf.tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => conf.tooltip.leaveDelay
    }
  },
  emits: ['update:modelValue'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: '',
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: '',
        arrowStyle: {}
      }
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xetooltip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const {
        tipTarget,
        tipStore
      } = reactData;
      if (tipTarget) {
        const {
          scrollTop,
          scrollLeft,
          visibleWidth
        } = getDomNode();
        const {
          top,
          left
        } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = 'bottom';
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = value => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit('update:modelValue', value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        tooltipMethods.open();
      }
    };
    const targetMouseenterEvent = () => {
      tooltipMethods.open();
    };
    const targetMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const {
        tipStore
      } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = 'top';
      tipStore.style = {
        width: 'auto',
        left: 0,
        top: 0,
        zIndex: props.zIndex || reactData.tipZindex
      };
      tipStore.arrowStyle = {
        left: '50%'
      };
      return tooltipMethods.updatePlacement();
    };
    const showDelayTip = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(() => {
      if (reactData.tipActive) {
        showTip();
      }
    }, props.enterDelay, {
      leading: false,
      trailing: true
    });
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $tooltip: $xetooltip,
          $event: evnt
        }, params));
      },
      open(target, content) {
        return tooltipMethods.toVisible(target || reactData.target, content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: '',
          arrowStyle: null
        });
        updateValue(false);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      toVisible(target, content) {
        if (target) {
          const {
            trigger,
            enterDelay
          } = props;
          reactData.tipActive = true;
          reactData.tipTarget = target;
          if (content) {
            reactData.tipContent = content;
          }
          if (enterDelay && trigger === 'hover') {
            showDelayTip();
          } else {
            return showTip();
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      updatePlacement() {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          const {
            tipTarget
          } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(updateTipStyle);
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(actived) {
        reactData.tipActive = !!actived;
      }
    };
    Object.assign($xetooltip, tooltipMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, () => {
      reactData.tipContent = props.content;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      if (!reactData.isUpdate) {
        if (props.modelValue) {
          tooltipMethods.open();
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          trigger,
          content,
          modelValue
        } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const {
              target
            } = reactData;
            if (target) {
              if (trigger === 'hover') {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === 'click') {
                target.onclick = clickEvent;
              }
            }
            if (modelValue) {
              tooltipMethods.open();
            }
          }
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const {
        trigger
      } = props;
      const {
        target
      } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        if (trigger === 'hover') {
          target.onmouseenter = null;
          target.onmouseleave = null;
        } else if (trigger === 'click') {
          target.onclick = null;
        }
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    const renderContent = () => {
      const {
        useHTML
      } = props;
      const {
        tipContent
      } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 1,
          class: 'vxe-table--tooltip-content'
        }, getSlotVNs(contentSlot({})));
      }
      if (useHTML) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 2,
          class: 'vxe-table--tooltip-content',
          innerHTML: tipContent
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 3,
        class: 'vxe-table--tooltip-content'
      }, formatText(tipContent));
    };
    const renderVN = () => {
      const {
        popupClassName,
        theme,
        isArrow,
        enterable
      } = props;
      const {
        tipActive,
        visible,
        tipStore
      } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--tooltip-wrapper', `theme--${theme}`, popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $tooltip: $xetooltip
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          [`placement--${tipStore.placement}`]: tipStore.placement,
          'is--enterable': enterable,
          'is--visible': visible,
          'is--arrow': isArrow,
          'is--active': tipActive
        }],
        style: tipStore.style,
        ...ons
      }, [renderContent(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--tooltip-arrow',
        style: tipStore.arrowStyle
      }), ...(defaultSlot ? getSlotVNs(defaultSlot({})) : [])]);
    };
    $xetooltip.renderVN = renderVN;
    return $xetooltip;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/custom/src/panel.ts











/* harmony default export */ var custom_src_panel = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableCustomPanel',
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const {
      reactData
    } = $xetable;
    const {
      computeCustomOpts,
      computeColumnOpts,
      computeIsMaxFixedColumn
    } = $xetable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const bodyElemRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const dragHintElemRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const dragColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let prevDropTrEl;
    const handleWrapperMouseenterEvent = evnt => {
      const {
        customStore
      } = props;
      customStore.activeWrapper = true;
      $xetable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = evnt => {
      const {
        customStore
      } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xetable.customColseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = evnt => {
      updateColumnSort();
      $xetable.closeCustom();
      $xetable.emitCustomEvent('confirm', evnt);
    };
    const cancelCustomEvent = evnt => {
      $xetable.closeCustom();
      $xetable.emitCustomEvent('cancel', evnt);
    };
    const resetCustomEvent = evnt => {
      $xetable.resetColumn(true);
      $xetable.closeCustom();
      $xetable.emitCustomEvent('reset', evnt);
    };
    const resetPopupCustomEvent = evnt => {
      if (VXETable.modal) {
        VXETable.modal.confirm({
          content: conf.i18n('vxe.custom.cstmConfirmRestore'),
          className: 'vxe-table--ignore-clear',
          escClosable: true
        }).then(type => {
          if (type === 'confirm') {
            resetCustomEvent(evnt);
          }
        });
      } else {
        resetCustomEvent(evnt);
      }
    };
    const handleOptionCheck = column => {
      const {
        customColumnList
      } = reactData;
      const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(customColumnList, item => item === column);
      if (matchObj && matchObj.parent) {
        const {
          parent
        } = matchObj;
        if (parent.children && parent.children.length) {
          parent.visible = parent.children.every(column => column.visible);
          parent.halfVisible = !parent.visible && parent.children.some(column => column.visible || column.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = column => {
      const isChecked = !column.visible;
      const customOpts = computeCustomOpts.value;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([column], item => {
        item.visible = isChecked;
        item.halfVisible = false;
      });
      handleOptionCheck(column);
      if (customOpts.immediate) {
        $xetable.handleCustom();
      }
      $xetable.checkCustomStatus();
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      if (column.fixed === colFixed) {
        $xetable.clearColumnFixed(column);
      } else {
        if (!isMaxFixedColumn || column.fixed) {
          $xetable.setColumnFixed(column, colFixed);
        }
      }
    };
    const changePopupFixedOption = column => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      if (!isMaxFixedColumn) {
        $xetable.setColumnFixed(column, column.fixed);
      }
    };
    const allCustomEvent = () => {
      const {
        customStore
      } = props;
      const {
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        checkMethod
      } = customOpts;
      const isAll = !customStore.isAll;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, column => {
        if (!checkMethod || checkMethod({
          column
        })) {
          column.visible = isAll;
          column.halfVisible = false;
        }
      });
      customStore.isAll = isAll;
      $xetable.checkCustomStatus();
    };
    const sortMousedownEvent = evnt => {
      const btnEl = evnt.currentTarget;
      const tdEl = btnEl.parentNode;
      const trEl = tdEl.parentNode;
      const colid = trEl.getAttribute('colid');
      const column = $xetable.getColumnById(colid);
      trEl.draggable = true;
      dragColumn.value = column;
      addClass(trEl, 'active--drag-origin');
    };
    const sortMouseupEvent = evnt => {
      const btnEl = evnt.currentTarget;
      const tdEl = btnEl.parentNode;
      const trEl = tdEl.parentNode;
      const dragHintEl = dragHintElemRef.value;
      trEl.draggable = false;
      dragColumn.value = null;
      removeClass(trEl, 'active--drag-origin');
      if (dragHintEl) {
        dragHintEl.style.display = '';
      }
    };
    const sortDragstartEvent = evnt => {
      const img = new Image();
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(img, 0, 0);
      }
    };
    const updateColumnSort = () => {
      const {
        customColumnList
      } = reactData;
      // 更新顺序
      customColumnList.forEach((column, index) => {
        const sortIndex = index + 1;
        column.renderSortNumber = sortIndex;
      });
    };
    const sortDragendEvent = evnt => {
      const {
        customColumnList
      } = reactData;
      const trEl = evnt.currentTarget;
      const dragHintEl = dragHintElemRef.value;
      if (prevDropTrEl) {
        // 判断是否有拖动
        if (prevDropTrEl !== trEl) {
          const dragOffset = prevDropTrEl.getAttribute('drag-pos');
          const colid = trEl.getAttribute('colid');
          const column = $xetable.getColumnById(colid);
          if (!column) {
            return;
          }
          const cIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === column.id);
          const targetColid = prevDropTrEl.getAttribute('colid');
          const targetColumn = $xetable.getColumnById(targetColid);
          if (!targetColumn) {
            return;
          }
          // 移出源位置
          customColumnList.splice(cIndex, 1);
          const tcIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(customColumnList, item => item.id === targetColumn.id);
          // 插新位置
          customColumnList.splice(tcIndex + (dragOffset === 'bottom' ? 1 : 0), 0, column);
        }
        prevDropTrEl.draggable = false;
        prevDropTrEl.removeAttribute('drag-pos');
        removeClass(prevDropTrEl, 'active--drag-target');
      }
      dragColumn.value = null;
      trEl.draggable = false;
      trEl.removeAttribute('drag-pos');
      if (dragHintEl) {
        dragHintEl.style.display = '';
      }
      removeClass(trEl, 'active--drag-target');
      removeClass(trEl, 'active--drag-origin');
      // 更新顺序
      updateColumnSort();
    };
    const sortDragoverEvent = evnt => {
      const trEl = evnt.currentTarget;
      if (prevDropTrEl !== trEl) {
        removeClass(prevDropTrEl, 'active--drag-target');
      }
      const colid = trEl.getAttribute('colid');
      const column = $xetable.getColumnById(colid);
      // 是否移入有效元行
      if (column && column.level === 1) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
        const dragOffset = offsetY < trEl.clientHeight / 2 ? 'top' : 'bottom';
        addClass(trEl, 'active--drag-target');
        trEl.setAttribute('drag-pos', dragOffset);
        prevDropTrEl = trEl;
      }
      updateDropHint(evnt);
    };
    const updateDropHint = evnt => {
      const dragHintEl = dragHintElemRef.value;
      const bodyEl = bodyElemRef.value;
      if (!bodyEl) {
        return;
      }
      if (dragHintEl) {
        const wrapperEl = bodyEl.parentNode;
        const wrapperRect = wrapperEl.getBoundingClientRect();
        dragHintEl.style.display = 'block';
        dragHintEl.style.top = `${Math.min(wrapperEl.clientHeight - wrapperEl.scrollTop - dragHintEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        dragHintEl.style.left = `${Math.min(wrapperEl.clientWidth - wrapperEl.scrollLeft - dragHintEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
      }
    };
    const renderSimplePanel = () => {
      const {
        customStore
      } = props;
      const {
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        maxHeight
      } = customStore;
      const {
        checkMethod,
        visibleMethod,
        trigger
      } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const colVNs = [];
      const customWrapperOns = {};
      // hover 触发
      if (trigger === 'hover') {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({
          column
        }) : true;
        if (isVisible) {
          const isChecked = column.visible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({
            column
          }) : false;
          colVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
            key: column.id,
            class: ['vxe-table-custom--option', `level--${column.level}`, {
              'is--group': isColGroup
            }]
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            title: colTitle,
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isChecked,
              'is--indeterminate': isIndeterminate,
              'is--disabled': isDisabled
            }],
            onClick: () => {
              if (!isDisabled) {
                changeCheckboxOption(column);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-checkbox--label'
          }, colTitle)]), !parent && customOpts.allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom--fixed-option'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-table-custom--fixed-left-option', column.fixed === 'left' ? conf.icon.TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED : conf.icon.TOOLBAR_TOOLS_FIXED_LEFT, {
              'is--checked': column.fixed === 'left',
              'is--disabled': isMaxFixedColumn && !column.fixed
            }],
            title: conf.i18n(column.fixed === 'left' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedLeft'),
            onClick: () => {
              changeFixedOption(column, 'left');
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-table-custom--fixed-right-option', column.fixed === 'right' ? conf.icon.TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED : conf.icon.TOOLBAR_TOOLS_FIXED_RIGHT, {
              'is--checked': column.fixed === 'right',
              'is--disabled': isMaxFixedColumn && !column.fixed
            }],
            title: conf.i18n(column.fixed === 'right' ? 'vxe.toolbar.cancelFixed' : 'vxe.toolbar.fixedRight'),
            onClick: () => {
              changeFixedOption(column, 'right');
            }
          })]) : null]));
        }
      });
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        key: 'simple',
        class: ['vxe-table-custom-wrapper', {
          'is--active': customStore.visible
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table-custom--header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
        class: 'vxe-table-custom--option'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-table-custom--checkbox-option', {
          'is--checked': isAllChecked,
          'is--indeterminate': isAllIndeterminate
        }],
        title: conf.i18n('vxe.table.allTitle'),
        onClick: allCustomEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isAllIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, conf.i18n('vxe.toolbar.customAll'))])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-table-custom--body',
        style: maxHeight ? {
          maxHeight: `${maxHeight}px`
        } : {},
        ...customWrapperOns
      }, colVNs), customOpts.showFooter ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-custom--footer'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'btn--reset',
        onClick: resetCustomEvent
      }, customOpts.resetButtonText || conf.i18n('vxe.toolbar.customRestore')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'btn--confirm',
        onClick: confirmCustomEvent
      }, customOpts.confirmButtonText || conf.i18n('vxe.toolbar.customConfirm'))]) : null]);
    };
    const renderPopupPanel = () => {
      const {
        customStore
      } = props;
      const {
        customColumnList
      } = reactData;
      const customOpts = computeCustomOpts.value;
      const {
        checkMethod,
        visibleMethod
      } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const trVNs = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({
          column
        }) : true;
        if (isVisible) {
          const isChecked = column.visible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({
            column
          }) : false;
          trVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              'is--group': isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--sort'
          }, [column.level === 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-table-custom-popup--column-sort-btn',
            onMousedown: sortMousedownEvent,
            onMouseup: sortMouseupEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: 'vxe-icon-sort'
          })]) : null]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--name'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--name',
            title: colTitle
          }, colTitle)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--visible'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-table-custom--checkbox-option', {
              'is--checked': isChecked,
              'is--indeterminate': isIndeterminate,
              'is--disabled': isDisabled
            }],
            onClick: () => {
              if (!isDisabled) {
                changeCheckboxOption(column);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-checkbox--icon', isIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
          })])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: 'vxe-table-custom-popup--column-item col--fixed'
          }, [!parent && customOpts.allowFixed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(group, {
            modelValue: column.fixed || '',
            type: 'button',
            size: 'mini',
            options: [{
              label: conf.i18n('vxe.custom.setting.fixedLeft'),
              value: 'left',
              disabled: isMaxFixedColumn
            }, {
              label: conf.i18n('vxe.custom.setting.fixedUnset'),
              value: ''
            }, {
              label: conf.i18n('vxe.custom.setting.fixedRight'),
              value: 'right',
              disabled: isMaxFixedColumn
            }],
            'onUpdate:modelValue'(value) {
              column.fixed = value;
            },
            onChange() {
              changePopupFixedOption(column);
            }
          }) : null])]));
        }
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(modal, {
        key: 'popup',
        className: 'vxe-table-custom-popup-wrapper vxe-table--ignore-clear',
        modelValue: customStore.visible,
        title: conf.i18n('vxe.custom.cstmTitle'),
        width: '40vw',
        minWidth: 520,
        height: '50vh',
        minHeight: 300,
        mask: true,
        lockView: true,
        showFooter: true,
        resize: true,
        escClosable: true,
        destroyOnClose: true,
        'onUpdate:modelValue'(value) {
          customStore.visible = value;
        }
      }, {
        default: () => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            ref: bodyElemRef,
            class: 'vxe-table-custom-popup--body'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--table-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            style: {
              width: '80px'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            style: {
              width: '80px'
            }
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
            style: {
              width: '200px'
            }
          })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-table-custom-popup--table-sort-help-title'
          }, conf.i18n('vxe.custom.setting.colSort')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
            enterable: true,
            content: conf.i18n('vxe.custom.setting.sortHelpTip')
          }, {
            default: () => {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
                class: 'vxe-table-custom-popup--table-sort-help-icon vxe-icon-question-circle-fill'
              });
            }
          })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, conf.i18n('vxe.custom.setting.colTitle')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, conf.i18n('vxe.custom.setting.colVisible')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {}, conf.i18n('vxe.custom.setting.colFixed', [columnOpts.maxFixedSize || 0]))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
            class: 'vxe-table-custom--body',
            tag: 'tbody',
            name: 'vxe-table-custom--list'
          }, {
            default: () => trVNs
          })])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            ref: dragHintElemRef,
            class: 'vxe-table-custom-popup--drag-hint'
          }, conf.i18n('vxe.custom.cstmDragTarget', [dragColumn.value ? dragColumn.value.getTitle() : '']))]);
        },
        footer: () => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-table-custom-popup--footer'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            content: customOpts.resetButtonText || conf.i18n('vxe.custom.cstmRestore'),
            onClick: resetPopupCustomEvent
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            content: customOpts.resetButtonText || conf.i18n('vxe.custom.cstmCancel'),
            onClick: cancelCustomEvent
          }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
            status: 'primary',
            content: customOpts.confirmButtonText || conf.i18n('vxe.custom.cstmConfirm'),
            onClick: confirmCustomEvent
          })]);
        }
      });
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.mode === 'popup') {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/custom/src/hook.ts

const tableCustomMethodKeys = ['openCustom', 'closeCustom'];
const customHook = {
  setupTable($xetable) {
    const {
      reactData,
      internalData
    } = $xetable;
    const {
      computeCustomOpts
    } = $xetable.getComputeMaps();
    const {
      refTableHeader,
      refTableBody,
      refTableCustom
    } = $xetable.getRefMaps();
    const $xegrid = $xetable.xegrid;
    const calcMaxHeight = () => {
      const {
        customStore
      } = reactData;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableCustom = refTableCustom.value;
      const customWrapperElem = tableCustom ? tableCustom.$el : null;
      const headElem = tableHeader.$el;
      const bodyElem = tableBody.$el;
      // 判断面板不能大于表格高度
      let tableHeight = 0;
      if (headElem) {
        tableHeight += headElem.clientHeight;
      }
      if (bodyElem) {
        tableHeight += bodyElem.clientHeight;
      }
      customStore.maxHeight = Math.max(0, customWrapperElem ? Math.min(customWrapperElem.clientHeight, tableHeight - 80) : 0);
    };
    const openCustom = () => {
      const {
        initStore,
        customStore
      } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      reactData.customColumnList = internalData.collectColumn.slice(0);
      checkCustomStatus();
      calcMaxHeight();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => calcMaxHeight());
    };
    const closeCustom = () => {
      const {
        customStore
      } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xetable.handleCustom();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const customMethods = {
      openCustom,
      closeCustom
    };
    const checkCustomStatus = () => {
      const {
        customStore
      } = reactData;
      const {
        collectColumn
      } = internalData;
      const customOpts = computeCustomOpts.value;
      const {
        checkMethod
      } = customOpts;
      customStore.isAll = collectColumn.every(column => (checkMethod ? !checkMethod({
        column
      }) : false) || column.visible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some(column => (!checkMethod || checkMethod({
        column
      })) && (column.visible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      const comp = $xegrid || $xetable;
      comp.dispatchEvent('custom', {
        type
      }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const {
          customStore
        } = $xetable.reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent('close', evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent('open', evnt);
        }
      },
      customOpenEvent(evnt) {
        const {
          customStore
        } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xetable.openCustom();
          $xetable.emitCustomEvent('open', evnt);
        }
      },
      customColseEvent(evnt) {
        const {
          customStore
        } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xetable.closeCustom();
          $xetable.emitCustomEvent('close', evnt);
        }
      }
    };
    return {
      ...customMethods,
      ...customPrivateMethods
    };
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableCustomMethodKeys);
  }
};
/* harmony default export */ var custom_src_hook = (customHook);
;// CONCATENATED MODULE: ./packages/custom/index.ts




const VxeTableCustomModule = {
  Panel: custom_src_panel,
  install(app) {
    VXETable.hooks.add('$tableCustom', custom_src_hook);
    app.component(custom_src_panel.name, custom_src_panel);
  }
};
const Custom = VxeTableCustomModule;
dynamicApp.component(custom_src_panel.name, custom_src_panel);
/* harmony default export */ var custom = ((/* unused pure expression or super */ null && (VxeTableCustomModule)));
;// CONCATENATED MODULE: ./packages/icon/src/icon.ts

/* harmony default export */ var icon = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeIcon',
  props: {
    name: String,
    roll: Boolean,
    status: String
  },
  emits: ['click'],
  setup(props, {
    emit
  }) {
    const clickEvent = evnt => {
      emit('click', {
        $event: evnt
      });
    };
    return () => {
      const {
        name,
        roll,
        status
      } = props;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: [`vxe-icon-${name}`, roll ? 'roll' : '', status ? [`theme--${status}`] : ''],
        onClick: clickEvent
      });
    };
  }
}));
;// CONCATENATED MODULE: ./packages/icon/index.ts


const VxeIcon = Object.assign(icon, {
  install(app) {
    app.component(icon.name, icon);
  }
});
const Icon = VxeIcon;
dynamicApp.component(VxeIcon.name, VxeIcon);
/* harmony default export */ var packages_icon = ((/* unused pure expression or super */ null && (VxeIcon)));
;// CONCATENATED MODULE: ./packages/table/src/cell.ts









function renderTitlePrefixIcon(params) {
  const {
    $table,
    column
  } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  return titlePrefix ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: ['vxe-cell-title-prefix-icon', titlePrefix.icon || conf.icon.TABLE_TITLE_PREFIX],
    onMouseenter(evnt) {
      $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
    },
    onMouseleave(evnt) {
      $table.handleTargetLeaveEvent(evnt);
    }
  })] : [];
}
function renderTitleSuffixIcon(params) {
  const {
    $table,
    column
  } = params;
  const titleSuffix = column.titleSuffix;
  return titleSuffix ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: ['vxe-cell-title-suffix-icon', titleSuffix.icon || conf.icon.TABLE_TITLE_SUFFIX],
    onMouseenter(evnt) {
      $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
    },
    onMouseleave(evnt) {
      $table.handleTargetLeaveEvent(evnt);
    }
  })] : [];
}
function renderTitleContent(params, content) {
  const {
    $table,
    column
  } = params;
  const {
    props,
    reactData
  } = $table;
  const {
    computeTooltipOpts
  } = $table.getComputeMaps();
  const {
    showHeaderOverflow: allColumnHeaderOverflow
  } = props;
  const {
    type,
    showHeaderOverflow
  } = column;
  const tooltipOpts = computeTooltipOpts.value;
  const showAllTip = tooltipOpts.showAll;
  const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === 'title';
  const showTooltip = headOverflow === true || headOverflow === 'tooltip';
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.onMouseenter = evnt => {
      if (reactData._isResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.onMouseleave = evnt => {
      if (reactData._isResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [type === 'html' && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(content) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--title',
    innerHTML: content,
    ...ons
  }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-cell--title',
    ...ons
  }, getSlotVNs(content))];
}
function getFooterContent(params) {
  const {
    $table,
    column,
    _columnIndex,
    items,
    row
  } = params;
  const {
    slots,
    editRender,
    cellRender
  } = column;
  const renderOpts = editRender || cellRender;
  const footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  if (renderOpts) {
    const compConf = VXETable.renderer.get(renderOpts.name);
    if (compConf && compConf.renderFooter) {
      return getSlotVNs(compConf.renderFooter(renderOpts, params));
    }
  }
  // 兼容老模式
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(items)) {
    return [formatText(items[_columnIndex], 1)];
  }
  return [formatText(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field), 1)];
}
function getDefaultCellLabel(params) {
  const {
    $table,
    row,
    column
  } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
const Cell = {
  createColumn($xetable, columnOpts) {
    const {
      type,
      sortable,
      filters,
      editRender,
      treeNode
    } = columnOpts;
    const {
      props
    } = $xetable;
    const {
      editConfig
    } = props;
    const {
      computeEditOpts,
      computeCheckboxOpts
    } = $xetable.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const editOpts = computeEditOpts.value;
    const renConfs = {
      renderHeader: Cell.renderDefaultHeader,
      renderCell: treeNode ? Cell.renderTreeCell : Cell.renderDefaultCell,
      renderFooter: Cell.renderDefaultFooter
    };
    switch (type) {
      case 'seq':
        renConfs.renderHeader = Cell.renderSeqHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeIndexCell : Cell.renderSeqCell;
        break;
      case 'radio':
        renConfs.renderHeader = Cell.renderRadioHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeRadioCell : Cell.renderRadioCell;
        break;
      case 'checkbox':
        renConfs.renderHeader = Cell.renderCheckboxHeader;
        renConfs.renderCell = checkboxOpts.checkField ? treeNode ? Cell.renderTreeSelectionCellByProp : Cell.renderCheckboxCellByProp : treeNode ? Cell.renderTreeSelectionCell : Cell.renderCheckboxCell;
        break;
      case 'expand':
        renConfs.renderCell = Cell.renderExpandCell;
        renConfs.renderData = Cell.renderExpandData;
        break;
      case 'html':
        renConfs.renderCell = treeNode ? Cell.renderTreeHTMLCell : Cell.renderHTMLCell;
        if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
        break;
      default:
        if (editConfig && editRender) {
          renConfs.renderHeader = Cell.renderEditHeader;
          renConfs.renderCell = editOpts.mode === 'cell' ? treeNode ? Cell.renderTreeCellEdit : Cell.renderCellEdit : treeNode ? Cell.renderTreeRowEdit : Cell.renderRowEdit;
        } else if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
    }
    return createColumn($xetable, columnOpts, renConfs);
  },
  /**
   * 单元格
   */
  renderHeaderTitle(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      editRender,
      cellRender
    } = column;
    const renderOpts = editRender || cellRender;
    const headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      const compConf = VXETable.renderer.get(renderOpts.name);
      if (compConf && compConf.renderHeader) {
        return renderTitleContent(params, getSlotVNs(compConf.renderHeader(renderOpts, params)));
      }
    }
    return renderTitleContent(params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(params) {
    return renderTitlePrefixIcon(params).concat(Cell.renderHeaderTitle(params)).concat(renderTitleSuffixIcon(params));
  },
  renderDefaultCell(params) {
    const {
      $table,
      row,
      column
    } = params;
    const {
      slots,
      editRender,
      cellRender
    } = column;
    const renderOpts = editRender || cellRender;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (renderOpts) {
      const funName = editRender ? 'renderCell' : 'renderDefault';
      const compConf = VXETable.renderer.get(renderOpts.name);
      const compFn = compConf ? compConf[funName] : null;
      if (compFn) {
        return getSlotVNs(compFn(renderOpts, Object.assign({
          $type: editRender ? 'edit' : 'cell'
        }, params)));
      }
    }
    const cellValue = $table.getCellLabel(row, column);
    const cellPlaceholder = editRender ? editRender.placeholder : '';
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--label'
    }, editRender && eqEmptyValue(cellValue) ? [
    // 如果设置占位符
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--placeholder'
    }, formatText(getFuncText(cellPlaceholder), 1))] : formatText(cellValue, 1))];
  },
  renderTreeCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter(params) {
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--item'
    }, getFooterContent(params))];
  },
  /**
   * 树节点
   */
  renderTreeIcon(params, cellVNodes) {
    const {
      $table,
      isHidden
    } = params;
    const {
      reactData
    } = $table;
    const {
      computeTreeOpts
    } = $table.getComputeMaps();
    const {
      treeExpandedMaps,
      treeExpandLazyLoadedMaps
    } = reactData;
    const treeOpts = computeTreeOpts.value;
    const {
      row,
      column,
      level
    } = params;
    const {
      slots
    } = column;
    const {
      indent,
      lazy,
      trigger,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose
    } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const iconSlot = slots ? slots.icon : null;
    let hasLazyChilds = false;
    let isAceived = false;
    let isLazyLoaded = false;
    const ons = {};
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!treeExpandedMaps[rowid];
      if (lazy) {
        isLazyLoaded = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
      }
    }
    if (!trigger || trigger === 'default') {
      ons.onClick = evnt => {
        evnt.stopPropagation();
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: ['vxe-cell--tree-node', {
        'is--active': isAceived
      }],
      style: {
        paddingLeft: `${level * indent}px`
      }
    }, [showIcon && (rowChilds && rowChilds.length || hasLazyChilds) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-tree--btn-wrapper',
      ...ons
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-tree--node-btn', isLazyLoaded ? iconLoaded || conf.icon.TABLE_TREE_LOADED : isAceived ? iconOpen || conf.icon.TABLE_TREE_OPEN : iconClose || conf.icon.TABLE_TREE_CLOSE]
    })])] : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-tree-cell'
    }, cellVNodes)])];
  },
  /**
   * 索引
   */
  renderSeqHeader(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : formatText(column.getTitle(), 1));
  },
  renderSeqCell(params) {
    const {
      $table,
      column
    } = params;
    const {
      props
    } = $table;
    const {
      treeConfig
    } = props;
    const {
      computeSeqOpts
    } = $table.getComputeMaps();
    const seqOpts = computeSeqOpts.value;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    const {
      seq
    } = params;
    const seqMethod = seqOpts.seqMethod;
    return [formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)];
  },
  renderTreeIndexCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderSeqCell(params));
  },
  /**
   * 单选
   */
  renderRadioHeader(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-radio--label'
    }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column.getTitle(), 1))]);
  },
  renderRadioCell(params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const {
      reactData
    } = $table;
    const {
      computeRadioOpts
    } = $table.getComputeMaps();
    const {
      selectRadioRow
    } = reactData;
    const radioOpts = computeRadioOpts.value;
    const {
      slots
    } = column;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = radioOpts;
    const {
      row
    } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = $table.eqRow(row, selectRadioRow);
    const isVisible = !visibleMethod || visibleMethod({
      row
    });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          row
        });
      }
    }
    const radioParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible
    };
    if (radioSlot) {
      return $table.callSlot(radioSlot, radioParams);
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-radio--icon', isChecked ? conf.icon.TABLE_RADIO_CHECKED : conf.icon.TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--radio', {
        'is--checked': isChecked,
        'is--disabled': isDisabled
      }],
      ...ons
    }, radioVNs)];
  },
  renderTreeRadioCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderRadioCell(params));
  },
  /**
   * 多选
   */
  renderCheckboxHeader(params) {
    const {
      $table,
      column,
      isHidden
    } = params;
    const {
      reactData
    } = $table;
    const {
      computeIsAllCheckboxDisabled,
      computeCheckboxOpts
    } = $table.getComputeMaps();
    const {
      isAllSelected: isAllCheckboxSelected,
      isIndeterminate: isAllCheckboxIndeterminate
    } = reactData;
    const isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    const {
      slots
    } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = computeCheckboxOpts.value;
    const headerTitle = column.getTitle();
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isAllCheckboxDisabled) {
            evnt.stopPropagation();
            $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
          }
        }
      };
    }
    const checkboxParams = {
      ...params,
      checked: isAllCheckboxSelected,
      disabled: isAllCheckboxDisabled,
      indeterminate: isAllCheckboxIndeterminate
    };
    if (headerSlot) {
      return renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams));
    }
    if (checkboxOpts.checkStrictly ? !checkboxOpts.showHeader : checkboxOpts.showHeader === false) {
      return renderTitleContent(checkboxParams, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)]);
    }
    return renderTitleContent(checkboxParams, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isAllCheckboxSelected,
        'is--disabled': isAllCheckboxDisabled,
        'is--indeterminate': isAllCheckboxIndeterminate
      }],
      title: conf.i18n('vxe.table.allTitle'),
      ...ons
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-checkbox--icon', isAllCheckboxIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
    })].concat(titleSlot || headerTitle ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-checkbox--label'
    }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)] : []))]);
  },
  renderCheckboxCell(params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const {
      props,
      reactData
    } = $table;
    const {
      treeConfig
    } = props;
    const {
      selectCheckboxMaps,
      treeIndeterminateMaps
    } = reactData;
    const {
      computeCheckboxOpts
    } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      labelField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({
      row
    });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!selectCheckboxMaps[rowid];
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          row
        });
      }
      if (treeConfig) {
        indeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate
    };
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
    }
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminate,
        'is--hidden': !isVisible
      }],
      ...ons
    }, checkVNs)];
  },
  renderTreeSelectionCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp(params) {
    const {
      $table,
      row,
      column,
      isHidden
    } = params;
    const {
      props,
      reactData
    } = $table;
    const {
      treeConfig
    } = props;
    const {
      treeIndeterminateMaps
    } = reactData;
    const {
      computeCheckboxOpts
    } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const {
      labelField,
      checkField,
      checkMethod,
      visibleMethod
    } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let isIndeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({
      row
    });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({
          row
        });
      }
      if (treeConfig) {
        isIndeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = {
      ...params,
      checked: isChecked,
      disabled: isDisabled,
      visible: isVisible,
      indeterminate: isIndeterminate
    };
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', isIndeterminate ? conf.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf.icon.TABLE_CHECKBOX_CHECKED : conf.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-checkbox--label'
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)));
      }
    }
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--checkbox', {
        'is--checked': isChecked,
        'is--disabled': isDisabled,
        'is--indeterminate': indeterminateField && !isChecked ? row[indeterminateField] : isIndeterminate,
        'is--hidden': !isVisible
      }],
      ...ons
    }, checkVNs)];
  },
  renderTreeSelectionCellByProp(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCellByProp(params));
  },
  /**
   * 展开行
   */
  renderExpandCell(params) {
    const {
      $table,
      isHidden,
      row,
      column
    } = params;
    const {
      reactData
    } = $table;
    const {
      rowExpandedMaps,
      rowExpandLazyLoadedMaps
    } = reactData;
    const {
      computeExpandOpts
    } = $table.getComputeMaps();
    const expandOpts = computeExpandOpts.value;
    const {
      lazy,
      labelField,
      iconLoaded,
      showIcon,
      iconOpen,
      iconClose,
      visibleMethod
    } = expandOpts;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isAceived = false;
    let isLazyLoaded = false;
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoaded = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return [showIcon && (!visibleMethod || visibleMethod(params)) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-table--expanded', {
        'is--active': isAceived
      }],
      onClick(evnt) {
        evnt.stopPropagation();
        $table.triggerRowExpandEvent(evnt, params);
      }
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-table--expand-btn', isLazyLoaded ? iconLoaded || conf.icon.TABLE_EXPAND_LOADED : isAceived ? iconOpen || conf.icon.TABLE_EXPAND_OPEN : iconClose || conf.icon.TABLE_EXPAND_CLOSE]
    })]) : null, defaultSlot || labelField ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-table--expand-label'
    }, defaultSlot ? $table.callSlot(defaultSlot, params) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, labelField)) : null];
  },
  renderExpandData(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      contentRender
    } = column;
    const contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      const compConf = VXETable.renderer.get(contentRender.name);
      if (compConf && compConf.renderExpand) {
        return getSlotVNs(compConf.renderExpand(contentRender, params));
      }
    }
    return [];
  },
  /**
   * HTML 标签
   */
  renderHTMLCell(params) {
    const {
      $table,
      column
    } = params;
    const {
      slots
    } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-cell--html',
      innerHTML: getDefaultCellLabel(params)
    })];
  },
  renderTreeHTMLCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderHTMLCell(params));
  },
  /**
   * 排序和筛选
   */
  renderSortAndFilterHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params)).concat(Cell.renderFilterIcon(params));
  },
  /**
   * 排序
   */
  renderSortHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params));
  },
  renderSortIcon(params) {
    const {
      $table,
      column
    } = params;
    const {
      computeSortOpts
    } = $table.getComputeMaps();
    const sortOpts = computeSortOpts.value;
    const {
      showIcon,
      iconLayout,
      iconAsc,
      iconDesc
    } = sortOpts;
    const {
      order
    } = column;
    if (showIcon) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-cell--sort', `vxe-cell--sort-${iconLayout}-layout`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-sort--asc-btn', iconAsc || conf.icon.TABLE_SORT_ASC, {
          'sort--active': order === 'asc'
        }],
        title: conf.i18n('vxe.table.sortAsc'),
        onClick(evnt) {
          evnt.stopPropagation();
          $table.triggerSortEvent(evnt, column, 'asc');
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-sort--desc-btn', iconDesc || conf.icon.TABLE_SORT_DESC, {
          'sort--active': order === 'desc'
        }],
        title: conf.i18n('vxe.table.sortDesc'),
        onClick(evnt) {
          evnt.stopPropagation();
          $table.triggerSortEvent(evnt, column, 'desc');
        }
      })])];
    }
    return [];
  },
  /**
   * 筛选
   */
  renderFilterHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderFilterIcon(params));
  },
  renderFilterIcon(params) {
    const {
      $table,
      column,
      hasFilter
    } = params;
    const {
      reactData
    } = $table;
    const {
      filterStore
    } = reactData;
    const {
      computeFilterOpts
    } = $table.getComputeMaps();
    const filterOpts = computeFilterOpts.value;
    const {
      showIcon,
      iconNone,
      iconMatch
    } = filterOpts;
    return showIcon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: ['vxe-cell--filter', {
        'is--active': filterStore.visible && filterStore.column === column
      }]
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-filter--btn', hasFilter ? iconMatch || conf.icon.TABLE_FILTER_MATCH : iconNone || conf.icon.TABLE_FILTER_NONE],
      title: conf.i18n('vxe.table.filter'),
      onClick(evnt) {
        if ($table.triggerFilterEvent) {
          $table.triggerFilterEvent(evnt, params.column, params);
        }
      }
    })])] : [];
  },
  /**
   * 可编辑
   */
  renderEditHeader(params) {
    const {
      $table,
      column
    } = params;
    const {
      props
    } = $table;
    const {
      computeEditOpts
    } = $table.getComputeMaps();
    const {
      editConfig,
      editRules
    } = props;
    const editOpts = computeEditOpts.value;
    const {
      sortable,
      filters,
      editRender
    } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some(rule => rule.required);
      }
    }
    return (isEnableConf(editConfig) ? [isRequired && editOpts.showAsterisk ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: 'vxe-cell--required-icon'
    }) : null, isEnableConf(editRender) && editOpts.showIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-cell--edit-icon', editOpts.icon || conf.icon.TABLE_EDIT]
    }) : null] : []).concat(Cell.renderDefaultHeader(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []);
  },
  // 行格编辑模式
  renderRowEdit(params) {
    const {
      $table,
      column
    } = params;
    const {
      reactData
    } = $table;
    const {
      editStore
    } = reactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderTreeRowEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderRowEdit(params));
  },
  // 单元格编辑模式
  renderCellEdit(params) {
    const {
      $table,
      column
    } = params;
    const {
      reactData
    } = $table;
    const {
      editStore
    } = reactData;
    const {
      actived
    } = editStore;
    const {
      editRender
    } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderTreeCellEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderCellEdit(params));
  },
  runRenderer(params, isEdit) {
    const {
      $table,
      column
    } = params;
    const {
      slots,
      editRender,
      formatter
    } = column;
    const defaultSlot = slots ? slots.default : null;
    const editSlot = slots ? slots.edit : null;
    const compConf = VXETable.renderer.get(editRender.name);
    if (isEdit) {
      if (editSlot) {
        return $table.callSlot(editSlot, params);
      }
      if (compConf && compConf.renderEdit) {
        return getSlotVNs(compConf.renderEdit(editRender, Object.assign({
          $type: 'edit'
        }, params)));
      }
      return [];
    }
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (formatter) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-cell--label'
      }, getDefaultCellLabel(params))];
    }
    return Cell.renderDefaultCell(params);
  }
};
/* harmony default export */ var cell = (Cell);
;// CONCATENATED MODULE: ./packages/table/src/column.ts



const columnProps = {
  // 列唯一主键
  colId: [String, Number],
  // 渲染类型 index,radio,checkbox,expand,html
  type: String,
  // 列字段名
  field: String,
  // 列标题
  title: String,
  // 列宽度
  width: [Number, String],
  // 列最小宽度，把剩余宽度按比例分配
  minWidth: [Number, String],
  // 列最大宽度
  maxWidth: [Number, String],
  // 是否允许拖动列宽调整大小
  resizable: {
    type: Boolean,
    default: null
  },
  // 将列固定在左侧或者右侧
  fixed: String,
  // 列对其方式
  align: String,
  // 表头对齐方式
  headerAlign: String,
  // 表尾列的对齐方式
  footerAlign: String,
  // 当内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表头内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表尾内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 给单元格附加 className
  className: [String, Function],
  // 给表头单元格附加 className
  headerClassName: [String, Function],
  // 给表尾单元格附加 className
  footerClassName: [String, Function],
  // 格式化显示内容
  formatter: [Function, Array, String],
  // 是否允许排序
  sortable: Boolean,
  // 自定义排序的属性
  sortBy: [String, Function],
  // 排序的字段类型，比如字符串转数值等
  sortType: String,
  // 配置筛选条件数组
  filters: {
    type: Array,
    default: null
  },
  // 筛选是否允许多选
  filterMultiple: {
    type: Boolean,
    default: true
  },
  // 自定义筛选方法
  filterMethod: Function,
  // 筛选重置方法
  filterResetMethod: Function,
  // 筛选复原方法
  filterRecoverMethod: Function,
  // 筛选模板配置项
  filterRender: Object,
  // 指定为树节点
  treeNode: Boolean,
  // 是否可视
  visible: {
    type: Boolean,
    default: null
  },
  // 表头单元格数据导出方法
  headerExportMethod: Function,
  // 单元格数据导出方法
  exportMethod: Function,
  // 表尾单元格数据导出方法
  footerExportMethod: Function,
  // 已废弃，被 titlePrefix 替换
  titleHelp: Object,
  // 标题前缀图标配置项
  titlePrefix: Object,
  // 标题后缀图标配置项
  titleSuffix: Object,
  // 单元格值类型
  cellType: String,
  // 单元格渲染配置项
  cellRender: Object,
  // 单元格编辑渲染配置项
  editRender: Object,
  // 内容渲染配置项
  contentRender: Object,
  // 额外的参数
  params: Object
};
/* harmony default export */ var column = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeColumn',
  props: columnProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const colgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xecolgroup', null);
    const column = cell.createColumn($xetable, props);
    column.slots = slots;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xegrid', null);
    watchColumn($xetable, props, column);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assemColumn($xetable, refElem.value, column, colgroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyColumn($xetable, column);
    });
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/column/index.ts


const VxeColumn = Object.assign(column, {
  install(app) {
    app.component(column.name, column);
    // 兼容旧用法
    app.component('VxeTableColumn', column);
  }
});
const Column = VxeColumn;
dynamicApp.component(column.name, column);
// 兼容旧用法
dynamicApp.component('VxeTableColumn', column);
/* harmony default export */ var packages_column = ((/* unused pure expression or super */ null && (VxeColumn)));
;// CONCATENATED MODULE: ./packages/table/src/group.ts




/* harmony default export */ var src_group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeColgroup',
  props: columnProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const colgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xecolgroup', null);
    const column = cell.createColumn($xetable, props);
    const columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    const xecolumn = {
      column
    };
    column.slots = columnSlots;
    column.children = [];
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xecolgroup', xecolumn);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xegrid', null);
    watchColumn($xetable, props, column);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assemColumn($xetable, refElem.value, column, colgroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyColumn($xetable, column);
    });
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/colgroup/index.ts


const VxeColgroup = Object.assign(src_group, {
  install(app) {
    app.component(src_group.name, src_group);
    // 兼容旧用法
    app.component('VxeTableColgroup', src_group);
  }
});
const Colgroup = VxeColgroup;
dynamicApp.component(src_group.name, src_group);
// 兼容旧用法
dynamicApp.component('VxeTableColgroup', src_group);
/* harmony default export */ var colgroup = ((/* unused pure expression or super */ null && (VxeColgroup)));
;// CONCATENATED MODULE: ./packages/tools/resize.ts




/**
 * 监听 resize 事件
 * 如果项目中已使用了 resize-observer-polyfill，那么只需要将方法定义全局，该组件就会自动使用
 */
let resizeTimeout;
/* eslint-disable no-use-before-define */
const resize_eventStore = [];
const defaultInterval = 500;
function eventHandle() {
  if (resize_eventStore.length) {
    resize_eventStore.forEach(item => {
      item.tarList.forEach(observer => {
        const {
          target,
          width,
          heighe
        } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    /* eslint-disable @typescript-eslint/no-use-before-define */
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, conf.resizeInterval || defaultInterval);
}
class XEResizeObserver {
  constructor(callback) {
    _defineProperty(this, "tarList", []);
    _defineProperty(this, "callback", void 0);
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const {
        tarList
      } = this;
      if (!tarList.some(observer => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!resize_eventStore.length) {
        eventListener();
      }
      if (!resize_eventStore.some(item => item === this)) {
        resize_eventStore.push(this);
      }
    }
  }
  unobserve(target) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item.tarList.some(observer => observer.target === target));
  }
  disconnect() {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item === this);
  }
}
function createResizeEvent(callback) {
  if (window.ResizeObserver) {
    return new window.ResizeObserver(callback);
  }
  return new XEResizeObserver(callback);
}
;// CONCATENATED MODULE: ./packages/table/src/body.ts









const renderType = 'body';
const lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1
};
/* harmony default export */ var body = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableBody',
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const xesize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xesize', null);
    const {
      xID,
      props: tableProps,
      context: tableContext,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xetable;
    const {
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftBody,
      refTableRightBody,
      refValidTooltip
    } = $xetable.getRefMaps();
    const {
      computeEditOpts,
      computeMouseOpts,
      computeSYOpts,
      computeEmptyOpts,
      computeKeyboardOpts,
      computeTooltipOpts,
      computeRadioOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeCheckboxOpts,
      computeValidOpts,
      computeRowOpts,
      computeColumnOpts
    } = $xetable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyTBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyYSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBodyEmptyBlock = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const getOffsetSize = () => {
      if (xesize) {
        const vSize = xesize.value;
        if (vSize) {
          return lineOffsetSizes[vSize] || 0;
        }
      }
      return 0;
    };
    // 滚动、拖动过程中不需要触发
    const isVMScrollProcess = () => {
      const {
        delayHover
      } = tableProps;
      const {
        lastScrollTime,
        _isResize
      } = tableReactData;
      return !!(_isResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const countTreeExpand = (prevRow, params) => {
      let count = 1;
      if (!prevRow) {
        return count;
      }
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rowChildren = prevRow[childrenField];
      if (rowChildren && $xetable.isTreeExpandByRow(prevRow)) {
        for (let index = 0; index < rowChildren.length; index++) {
          count += countTreeExpand(rowChildren[index], params);
        }
      }
      return count;
    };
    const calcTreeLine = (params, items, rIndex) => {
      let expandSize = 1;
      if (rIndex) {
        expandSize = countTreeExpand(items[rIndex - 1], params);
      }
      return tableReactData.rowHeight * expandSize - (rIndex ? 1 : 12 - getOffsetSize());
    };
    const renderLine = params => {
      const {
        row,
        column
      } = params;
      const {
        afterFullData
      } = tableInternalData;
      const {
        treeConfig
      } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const {
        slots,
        treeNode
      } = column;
      const {
        fullAllDataRowIdData
      } = tableInternalData;
      const rowid = getRowid($xetable, row);
      const rest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let rIndex = 0;
      let items = [];
      if (rest) {
        rLevel = rest.level;
        rIndex = rest._index;
        items = rest.items;
      }
      if (slots && slots.line) {
        return $xetable.callSlot(slots.line, params);
      }
      const isFirstRow = $xetable.eqRow(afterFullData[0], row);
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tree--line-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tree--line',
          style: {
            height: `${isFirstRow ? 1 : calcTreeLine(params, items, rIndex)}px`,
            left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize() : 0) + 16}px`
          }
        })])];
      }
      return [];
    };
    /**
     * 渲染列
     */
    const renderColumn = (seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const {
        columnKey,
        height,
        showOverflow: allColumnOverflow,
        cellClassName: allCellClassName,
        cellStyle,
        align: allAlign,
        spanMethod,
        mouseConfig,
        editConfig,
        editRules,
        tooltipConfig
      } = tableProps;
      const {
        tableData,
        overflowX,
        scrollYLoad,
        currentColumn,
        mergeList,
        editStore,
        isAllOverflow,
        validErrorMaps
      } = tableReactData;
      const {
        afterFullData
      } = tableInternalData;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const rowOpts = computeRowOpts.value;
      const sYOpts = computeSYOpts.value;
      const columnOpts = computeColumnOpts.value;
      const {
        type,
        cellRender,
        editRender,
        align,
        showOverflow,
        className,
        treeNode,
        slots
      } = column;
      const {
        actived
      } = editStore;
      const {
        rHeight: scrollYRHeight
      } = sYOpts;
      const {
        height: rowHeight
      } = rowOpts;
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? VXETable.renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.cellClassName : '';
      const compCellStyle = compConf ? compConf.cellStyle : '';
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = $xetable.getColumnIndex(column);
      const _columnIndex = $xetable.getVTColumnIndex(column);
      const isEdit = isEnableConf(editRender);
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showOverflow) ? allColumnOverflow : showOverflow;
      let showEllipsis = cellOverflow === 'ellipsis';
      const showTitle = cellOverflow === 'title';
      const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
      let hasEllipsis = showTitle || showTooltip || showEllipsis;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || allAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${column.id}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === 'default' ? height || tableData.length > 1 : validOpts.message === 'inline');
      const attrs = {
        colid: column.id
      };
      const params = {
        $table: $xetable,
        $grid: $xetable.xegrid,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        type: renderType,
        isHidden: fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      // 虚拟滚动不支持动态高度
      if (scrollYLoad && !hasEllipsis) {
        showEllipsis = hasEllipsis = true;
      }
      // hover 进入事件
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = evnt => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            // 如果配置了显示 tooltip
            $xetable.triggerBodyTooltipEvent(evnt, params);
          }
          $xetable.dispatchEvent('cell-mouseenter', Object.assign({
            cell: evnt.currentTarget
          }, params), evnt);
        };
      }
      // hover 退出事件
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = evnt => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xetable.handleTargetLeaveEvent(evnt);
          }
          $xetable.dispatchEvent('cell-mouseleave', Object.assign({
            cell: evnt.currentTarget
          }, params), evnt);
        };
      }
      // 按下事件处理
      if (checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = evnt => {
          $xetable.triggerCellMousedownEvent(evnt, params);
        };
      }
      // 点击事件处理
      tdOns.onClick = evnt => {
        $xetable.triggerCellClickEvent(evnt, params);
      };
      // 双击事件处理
      tdOns.onDblclick = evnt => {
        $xetable.triggerCellDblclickEvent(evnt, params);
      };
      // 合并行或列
      if (mergeList.length) {
        const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
        if (spanRest) {
          const {
            rowspan,
            colspan
          } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        // 自定义合并行或列的方法
        const {
          rowspan = 1,
          colspan = 1
        } = spanMethod(params) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          attrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          attrs.colspan = colspan;
        }
      }
      // 如果被合并不可隐藏
      if (fixedHiddenColumn && mergeList) {
        if (attrs.colspan > 1 || attrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      // 如果编辑列开启显示状态
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xetable.isUpdateByRow(row, column.field);
      }
      const tdVNs = [];
      if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
        tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ''
          }
        }));
      } else {
        // 渲染单元格
        tdVNs.push(...renderLine(params), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ''
          },
          title: showTitle ? $xetable.getCellLabel(row, column) : null
        }, column.renderCell(params)));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = {
            ...params,
            ...errorValidItem
          };
          tdVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-cell--valid-error-hint', getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, validSlot ? $xetable.callSlot(validSlot, validParams) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-cell--valid-error-msg'
          }, errorValidItem.content)]));
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
        class: ['vxe-body--column', column.id, {
          [`col--${cellAlign}`]: cellAlign,
          [`col--${type}`]: type,
          'col--last': $columnIndex === columns.length - 1,
          'col--tree-node': treeNode,
          'col--edit': isEdit,
          'col--ellipsis': hasEllipsis,
          'fixed--hidden': fixedHiddenColumn,
          'col--dirty': isDirty,
          'col--active': editConfig && isEdit && actived.row === row && (actived.column === column || editOpts.mode === 'row'),
          'col--valid-error': !!errorValidItem,
          'col--current': currentColumn === column
        }, getPropClass(compCellClassName, params), getPropClass(className, params), getPropClass(allCellClassName, params)],
        key: columnKey || columnOpts.useKey ? column.id : $columnIndex,
        ...attrs,
        style: Object.assign({
          height: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ''
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(compCellStyle) ? compCellStyle(params) : compCellStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(cellStyle) ? cellStyle(params) : cellStyle),
        ...tdOns
      }, tdVNs);
    };
    const renderRows = (fixedType, tableData, tableColumn) => {
      const {
        stripe,
        rowKey,
        highlightHoverRow,
        rowClassName,
        rowStyle,
        showOverflow: allColumnOverflow,
        editConfig,
        treeConfig
      } = tableProps;
      const {
        hasFixedColumn,
        treeExpandedMaps,
        scrollYLoad,
        rowExpandedMaps,
        expandColumn,
        selectRadioRow,
        pendingRowMaps,
        pendingRowList
      } = tableReactData;
      const {
        fullAllDataRowIdData
      } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const {
        transform
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      tableData.forEach((row, $rowIndex) => {
        const trOn = {};
        let rowIndex = $rowIndex;
        // 确保任何情况下 rowIndex 都精准指向真实 data 索引
        rowIndex = $xetable.getRowIndex(row);
        // 事件绑定
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = evnt => {
            if (isVMScrollProcess()) {
              return;
            }
            $xetable.triggerHoverEvent(evnt, {
              row,
              rowIndex
            });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xetable.clearHoverRow();
          };
        }
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = 0;
        if (rest) {
          rowLevel = rest.level;
          seq = rest.seq;
          _rowIndex = rest._index;
        }
        const params = {
          $table: $xetable,
          seq,
          rowid,
          fixed: fixedType,
          type: renderType,
          level: rowLevel,
          row,
          rowIndex,
          $rowIndex,
          _rowIndex
        };
        // 行是否被展开
        const isExpandRow = expandColumn && !!rowExpandedMaps[rowid];
        // 树节点是否被展开
        let isExpandTree = false;
        let rowChildren = [];
        // 处理新增状态
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xetable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = rowChildren && rowChildren.length && !!treeExpandedMaps[rowid];
        }
        rows.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          class: ['vxe-body--row', treeConfig ? `row--level-${rowLevel}` : '', {
            'row--stripe': stripe && ($xetable.getVTRowIndex(row) + 1) % 2 === 0,
            'is--new': isNewRow,
            'is--expand-row': isExpandRow,
            'is--expand-tree': isExpandTree,
            'row--new': isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            'row--radio': radioOpts.highlight && $xetable.eqRow(selectRadioRow, row),
            'row--checked': checkboxOpts.highlight && $xetable.isCheckedByCheckboxRow(row),
            'row--pending': pendingRowList.length && !!pendingRowMaps[rowid]
          }, getPropClass(rowClassName, params)],
          rowid: rowid,
          style: rowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowStyle) ? rowStyle(params) : rowStyle : null,
          key: rowKey || rowOpts.useKey || treeConfig ? rowid : $rowIndex,
          ...trOn
        }, tableColumn.map((column, $columnIndex) => {
          return renderColumn(seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        })));
        // 如果行被展开了
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const {
            height: expandHeight
          } = expandOpts;
          const cellStyle = {};
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
          }
          const {
            showOverflow
          } = expandColumn;
          const hasEllipsis = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showOverflow) ? allColumnOverflow : showOverflow;
          const expandParams = {
            $table: $xetable,
            seq,
            column: expandColumn,
            fixed: fixedType,
            type: renderType,
            level: rowLevel,
            row,
            rowIndex,
            $rowIndex,
            _rowIndex
          };
          rows.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
            class: 'vxe-body--expanded-row',
            key: `expand_${rowid}`,
            style: rowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle : null,
            ...trOn
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'vxe-body--expanded-column': 1,
              'fixed--hidden': fixedType && !hasFixedColumn,
              'col--ellipsis': hasEllipsis
            },
            colspan: tableColumn.length
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: {
              'vxe-body--expanded-cell': 1,
              'is--ellipsis': expandHeight
            },
            style: cellStyle
          }, [expandColumn.renderData(expandParams)])])]));
        }
        // 如果是树形表格
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    /**
     * 同步滚动条
     */
    let scrollProcessTimeout;
    const syncBodyScroll = (fixedType, scrollTop, elem1, elem2) => {
      if (elem1 || elem2) {
        if (elem1) {
          removeScrollListener(elem1);
          elem1.scrollTop = scrollTop;
        }
        if (elem2) {
          removeScrollListener(elem2);
          elem2.scrollTop = scrollTop;
        }
        clearTimeout(scrollProcessTimeout);
        scrollProcessTimeout = setTimeout(() => {
          // const tableBody = refTableBody.value
          // const leftBody = refTableLeftBody.value
          // const rightBody = refTableRightBody.value
          // const bodyElem = tableBody.$el as XEBodyScrollElement
          // const leftElem = leftBody ? leftBody.$el as XEBodyScrollElement : null
          // const rightElem = rightBody ? rightBody.$el as XEBodyScrollElement : null
          restoreScrollListener(elem1);
          restoreScrollListener(elem2);
          // 检查滚动条是的同步
          // let targetTop = bodyElem.scrollTop
          // if (fixedType === 'left') {
          //   if (leftElem) {
          //     targetTop = leftElem.scrollTop
          //   }
          // } else if (fixedType === 'right') {
          //   if (rightElem) {
          //     targetTop = rightElem.scrollTop
          //   }
          // }
          // setScrollTop(bodyElem, targetTop)
          // setScrollTop(leftElem, targetTop)
          // setScrollTop(rightElem, targetTop)
          tableReactData.lastScrollTime = Date.now();
        }, 300);
      }
    };
    const scrollLoadingTime = null;
    /**
     * 滚动处理
     * 如果存在列固定左侧，同步更新滚动状态
     * 如果存在列固定右侧，同步更新滚动状态
     */
    const scrollEvent = evnt => {
      const {
        fixedType
      } = props;
      const {
        highlightHoverRow
      } = tableProps;
      const {
        scrollXLoad,
        scrollYLoad
      } = tableReactData;
      const {
        elemStore,
        lastScrollTop,
        lastScrollLeft
      } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const validTip = refValidTooltip.value;
      const scrollBodyElem = refElem.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      const bodyElem = tableBody.$el;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyYRef = elemStore['main-body-ySpace'];
      const bodyYElem = bodyYRef ? bodyYRef.value : null;
      const bodyXRef = elemStore['main-body-xSpace'];
      const bodyXElem = bodyXRef ? bodyXRef.value : null;
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      let scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = bodyElem.scrollLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      tableInternalData.lastScrollTop = scrollTop;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableReactData.lastScrollTime = Date.now();
      if (rowOpts.isHover || highlightHoverRow) {
        $xetable.clearHoverRow();
      }
      if (leftElem && fixedType === 'left') {
        scrollTop = leftElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, rightElem);
      } else if (rightElem && fixedType === 'right') {
        scrollTop = rightElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, leftElem);
      } else {
        if (isRollX) {
          if (headerElem) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
          if (footerElem) {
            footerElem.scrollLeft = bodyElem.scrollLeft;
          }
        }
        if (leftElem || rightElem) {
          $xetable.checkScrolling();
          if (isRollY) {
            syncBodyScroll(fixedType, scrollTop, leftElem, rightElem);
          }
        }
      }
      // let isLoadScroll = false
      if (scrollXLoad && isRollX) {
        // isLoadScroll = true
        $xetable.triggerScrollXEvent(evnt);
      }
      if (scrollYLoad && isRollY) {
        // isLoadScroll = true
        $xetable.triggerScrollYEvent(evnt);
      }
      if (scrollLoadingTime !== null) {
        clearTimeout(scrollLoadingTime);
      }
      // if (isLoadScroll) {
      //   tableReactData.scrollVMLoading = true
      //   scrollLoadingTime = setTimeout(() => {
      //     scrollLoadingTime = null
      //     tableReactData.scrollVMLoading = false
      //   }, 20)
      // } else {
      //   tableReactData.scrollVMLoading = false
      // }
      if (isRollX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent('scroll', {
        type: renderType,
        fixed: fixedType,
        scrollTop,
        scrollLeft,
        scrollHeight: bodyElem.scrollHeight,
        scrollWidth: bodyElem.scrollWidth,
        bodyHeight,
        bodyWidth,
        isX: isRollX,
        isY: isRollY
      }, evnt);
    };
    let wheelTime;
    let wheelYSize = 0;
    let wheelYInterval = 0;
    let wheelYTotal = 0;
    let isPrevWheelTop = false;
    const handleWheel = (evnt, isTopWheel, deltaTop, isRollX, isRollY) => {
      const {
        elemStore
      } = tableInternalData;
      const {
        scrollXLoad,
        scrollYLoad
      } = tableReactData;
      const tableBody = refTableBody.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyElem = tableBody.$el;
      const bodyYRef = elemStore['main-body-ySpace'];
      const bodyYElem = bodyYRef ? bodyYRef.value : null;
      const bodyXRef = elemStore['main-body-xSpace'];
      const bodyXElem = bodyXRef ? bodyXRef.value : null;
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      const remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;
      isPrevWheelTop = isTopWheel;
      wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);
      wheelYInterval = 0;
      wheelYTotal = 0;
      clearTimeout(wheelTime);
      const handleSmooth = () => {
        if (wheelYTotal < wheelYSize) {
          const {
            fixedType
          } = props;
          wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));
          wheelYTotal = wheelYTotal + wheelYInterval;
          if (wheelYTotal > wheelYSize) {
            wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);
          }
          const {
            scrollTop,
            clientHeight,
            scrollHeight
          } = bodyElem;
          const targerTop = scrollTop + wheelYInterval * (isTopWheel ? -1 : 1);
          bodyElem.scrollTop = targerTop;
          if (leftElem) {
            leftElem.scrollTop = targerTop;
          }
          if (rightElem) {
            rightElem.scrollTop = targerTop;
          }
          if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {
            wheelTime = setTimeout(handleSmooth, 10);
          }
          $xetable.dispatchEvent('scroll', {
            type: renderType,
            fixed: fixedType,
            scrollTop: bodyElem.scrollTop,
            scrollLeft: bodyElem.scrollLeft,
            scrollHeight: bodyElem.scrollHeight,
            scrollWidth: bodyElem.scrollWidth,
            bodyHeight,
            bodyWidth,
            isX: isRollX,
            isY: isRollY
          }, evnt);
        }
      };
      handleSmooth();
    };
    /**
     * 滚轮处理
     */
    const wheelEvent = evnt => {
      const {
        deltaY,
        deltaX
      } = evnt;
      const {
        highlightHoverRow
      } = tableProps;
      const {
        scrollYLoad
      } = tableReactData;
      const {
        lastScrollTop,
        lastScrollLeft
      } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableBody = refTableBody.value;
      const scrollBodyElem = refElem.value;
      const bodyElem = tableBody.$el;
      const deltaTop = deltaY;
      const deltaLeft = deltaX;
      const isTopWheel = deltaTop < 0;
      // 如果滚动位置已经是顶部或底部，则不需要触发
      if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop + deltaTop;
      const scrollLeft = bodyElem.scrollLeft + deltaLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      // 用于鼠标纵向滚轮处理
      if (isRollY) {
        evnt.preventDefault();
        tableInternalData.lastScrollTop = scrollTop;
        tableInternalData.lastScrollLeft = scrollLeft;
        tableReactData.lastScrollTime = Date.now();
        if (rowOpts.isHover || highlightHoverRow) {
          $xetable.clearHoverRow();
        }
        handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);
        if (scrollYLoad) {
          $xetable.triggerScrollYEvent(evnt);
        }
      }
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          elemStore
        } = tableInternalData;
        const prefix = `${fixedType || 'main'}-body-`;
        const el = refElem.value;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
        if (el) {
          el.onscroll = scrollEvent;
          el._onscroll = scrollEvent;
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const el = refElem.value;
      clearTimeout(wheelTime);
      if (el) {
        el._onscroll = null;
        el.onscroll = null;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        elemStore
      } = tableInternalData;
      const prefix = `${fixedType || 'main'}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      let {
        fixedColumn,
        fixedType,
        tableColumn
      } = props;
      const {
        keyboardConfig,
        showOverflow: allColumnOverflow,
        spanMethod,
        mouseConfig
      } = tableProps;
      const {
        tableData,
        mergeList,
        scrollYLoad,
        isAllOverflow
      } = tableReactData;
      const {
        visibleColumn
      } = tableInternalData;
      const {
        slots
      } = tableContext;
      const sYOpts = computeSYOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const mouseOpts = computeMouseOpts.value;
      // const isMergeLeftFixedExceeded = computeIsMergeLeftFixedExceeded.value
      // const isMergeRightFixedExceeded = computeIsMergeRightFixedExceeded.value
      // 如果是使用优化模式
      if (fixedType) {
        // 如果存在展开行使用全量渲染
        if (!tableReactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
          if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
            // 检查固定列是否被合并，合并范围是否超出固定列
            // if (mergeList.length && !isMergeLeftFixedExceeded && fixedType === 'left') {
            //   tableColumn = fixedColumn
            // } else if (mergeList.length && !isMergeRightFixedExceeded && fixedType === 'right') {
            //   tableColumn = fixedColumn
            // } else {
            //   tableColumn = visibleColumn
            // }
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xetable.callSlot(emptySlot, {
          $table: $xetable,
          $grid: $xetable.xegrid
        });
      } else {
        const compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        const renderTableEmptyView = compConf ? compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (renderTableEmptyView) {
          emptyContent = getSlotVNs(renderTableEmptyView(emptyOpts, {
            $table: $xetable
          }));
        } else {
          emptyContent = tableProps.emptyText || conf.i18n('vxe.table.emptyText');
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--body-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID,
        ...(sYOpts.mode === 'wheel' ? {
          onWheel: wheelEvent
        } : {})
      }, [fixedType ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBodyYSpace,
        class: 'vxe-body--y-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refBodyTable,
        class: 'vxe-table--body',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [
      /**
       * 列宽
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refBodyColgroup
      }, tableColumn.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex
        });
      })),
      /**
       * 内容
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', {
        ref: refBodyTBody
      }, renderRows(fixedType, tableData, tableColumn))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--checkbox-range'
      }), mouseConfig && mouseOpts.area ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--cell-area'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area'
      }, mouseOpts.extension ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-main-area-btn',
        onMousedown(evnt) {
          $xetable.triggerCellExtendMousedownEvent(evnt, {
            $table: $xetable,
            fixed: fixedType,
            type: renderType
          });
        }
      })] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-copy-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-extend-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-multi-area'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-table--cell-active-area'
      })]) : null, !fixedType ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--empty-block',
        ref: refBodyEmptyBlock
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--empty-content'
      }, emptyContent)]) : null]);
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/table/src/header.ts




const header_renderType = 'header';
/* harmony default export */ var header = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableHeader',
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const {
      xID,
      props: tableProps,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xetable;
    const {
      refElem: tableRefElem,
      refTableBody,
      refLeftContainer,
      refRightContainer,
      refCellResizeBar
    } = $xetable.getRefMaps();
    const {
      computeColumnOpts
    } = $xetable.getComputeMaps();
    const headerColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderTHead = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderBorderRepair = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const uploadColumn = () => {
      const {
        isGroup
      } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const resizeMousedown = (evnt, params) => {
      const {
        column
      } = params;
      const {
        fixedType
      } = props;
      const tableBody = refTableBody.value;
      const leftContainerElem = refLeftContainer.value;
      const rightContainerElem = refRightContainer.value;
      const resizeBarElem = refCellResizeBar.value;
      const {
        clientX: dragClientX
      } = evnt;
      const wrapperElem = refElem.value;
      const dragBtnElem = evnt.target;
      const cell = params.cell = dragBtnElem.parentNode;
      let dragLeft = 0;
      const tableBodyElem = tableBody.$el;
      const pos = getOffsetPos(dragBtnElem, wrapperElem);
      const dragBtnWidth = dragBtnElem.clientWidth;
      const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
      const minInterval = getColReMinWidth(params) - dragBtnOffsetWidth; // 列之间的最小间距
      let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
      let dragPosLeft = pos.left + dragBtnOffsetWidth;
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const isLeftFixed = fixedType === 'left';
      const isRightFixed = fixedType === 'right';
      const tableEl = tableRefElem.value;
      // 计算左右侧固定列偏移量
      let fixedOffsetWidth = 0;
      if (isLeftFixed || isRightFixed) {
        const siblingProp = isLeftFixed ? 'nextElementSibling' : 'previousElementSibling';
        let tempCellElem = cell[siblingProp];
        while (tempCellElem) {
          if (hasClass(tempCellElem, 'fixed--hidden')) {
            break;
          } else if (!hasClass(tempCellElem, 'col--group')) {
            fixedOffsetWidth += tempCellElem.offsetWidth;
          }
          tempCellElem = tempCellElem[siblingProp];
        }
        if (isRightFixed && rightContainerElem) {
          dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
        }
      }
      // 处理拖动事件
      const updateEvent = function (evnt) {
        evnt.stopPropagation();
        evnt.preventDefault();
        const offsetX = evnt.clientX - dragClientX;
        let left = dragPosLeft + offsetX;
        const scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;
        if (isLeftFixed) {
          // 左固定列（不允许超过右侧固定列、不允许超过右边距）
          left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);
        } else if (isRightFixed) {
          // 右侧固定列（不允许超过左侧固定列、不允许超过左边距）
          dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
        } else {
          dragMinLeft = Math.max(tableBodyElem.scrollLeft, dragMinLeft);
          // left = Math.min(left, tableBodyElem.clientWidth + tableBodyElem.scrollLeft - 40)
        }
        dragLeft = Math.max(left, dragMinLeft);
        resizeBarElem.style.left = `${dragLeft - scrollLeft}px`;
      };
      tableReactData._isResize = true;
      addClass(tableEl, 'drag--resize');
      resizeBarElem.style.display = 'block';
      document.onmousemove = updateEvent;
      document.onmouseup = function (evnt) {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        const resizeWidth = column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
        column.resizeWidth = resizeWidth;
        resizeBarElem.style.display = 'none';
        tableReactData._isResize = false;
        tableInternalData._lastResizeTime = Date.now();
        $xetable.analyColumnWidth();
        $xetable.recalculate(true).then(() => {
          $xetable.saveCustomResizable();
          $xetable.updateCellAreas();
          $xetable.dispatchEvent('resizable-change', {
            ...params,
            resizeWidth
          }, evnt);
        });
        removeClass(tableEl, 'drag--resize');
      };
      updateEvent(evnt);
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.tableColumn, uploadColumn);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          internalData
        } = $xetable;
        const {
          elemStore
        } = internalData;
        const prefix = `${fixedType || 'main'}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        internalData
      } = $xetable;
      const {
        elemStore
      } = internalData;
      const prefix = `${fixedType || 'main'}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    const renderVN = () => {
      const {
        fixedType,
        fixedColumn,
        tableColumn
      } = props;
      const {
        resizable,
        border,
        columnKey,
        headerRowClassName,
        headerCellClassName,
        headerRowStyle,
        headerCellStyle,
        showHeaderOverflow: allColumnHeaderOverflow,
        headerAlign: allHeaderAlign,
        align: allAlign,
        mouseConfig
      } = tableProps;
      const {
        isGroup,
        currentColumn,
        scrollXLoad,
        overflowX,
        scrollbarWidth
      } = tableReactData;
      const {
        visibleColumn
      } = tableInternalData;
      const columnOpts = computeColumnOpts.value;
      let headerGroups = headerColumn.value;
      let renderColumnList = tableColumn;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        // 如果是使用优化模式
        if (fixedType) {
          if (scrollXLoad || allColumnHeaderOverflow) {
            renderColumnList = fixedColumn;
          }
        }
        headerGroups = [renderColumnList];
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--header-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID
      }, [fixedType ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refHeaderTable,
        class: 'vxe-table--header',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [
      /**
       * 列宽
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refHeaderColgroup
      }, renderColumnList.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex
        });
      }).concat(scrollbarWidth ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
        name: 'col_gutter'
      })] : [])),
      /**
       * 头部
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', {
        ref: refHeaderTHead
      }, headerGroups.map((cols, $rowIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          class: ['vxe-header--row', headerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowClassName) ? headerRowClassName({
            $table: $xetable,
            $rowIndex,
            fixed: fixedType,
            type: header_renderType
          }) : headerRowClassName : ''],
          style: headerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerRowStyle) ? headerRowStyle({
            $table: $xetable,
            $rowIndex,
            fixed: fixedType,
            type: header_renderType
          }) : headerRowStyle : null
        }, cols.map((column, $columnIndex) => {
          const {
            type,
            showHeaderOverflow,
            headerAlign,
            align,
            headerClassName
          } = column;
          const isColGroup = column.children && column.children.length;
          const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
          const headOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
          const headAlign = headerAlign || align || allHeaderAlign || allAlign;
          let showEllipsis = headOverflow === 'ellipsis';
          const showTitle = headOverflow === 'title';
          const showTooltip = headOverflow === true || headOverflow === 'tooltip';
          let hasEllipsis = showTitle || showTooltip || showEllipsis;
          const hasFilter = column.filters && column.filters.some(item => item.checked);
          const columnIndex = $xetable.getColumnIndex(column);
          const _columnIndex = $xetable.getVTColumnIndex(column);
          const params = {
            $table: $xetable,
            $grid: $xetable.xegrid,
            $rowIndex,
            column,
            columnIndex,
            $columnIndex,
            _columnIndex,
            fixed: fixedType,
            type: header_renderType,
            isHidden: fixedHiddenColumn,
            hasFilter
          };
          const thOns = {
            onClick: evnt => $xetable.triggerHeaderCellClickEvent(evnt, params),
            onDblclick: evnt => $xetable.triggerHeaderCellDblclickEvent(evnt, params)
          };
          // 横向虚拟滚动不支持动态行高
          if (scrollXLoad && !hasEllipsis) {
            showEllipsis = hasEllipsis = true;
          }
          // 按下事件处理
          if (mouseConfig) {
            thOns.onMousedown = evnt => $xetable.triggerHeaderCellMousedownEvent(evnt, params);
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {
            class: ['vxe-header--column', column.id, {
              [`col--${headAlign}`]: headAlign,
              [`col--${type}`]: type,
              'col--last': $columnIndex === cols.length - 1,
              'col--fixed': column.fixed,
              'col--group': isColGroup,
              'col--ellipsis': hasEllipsis,
              'fixed--hidden': fixedHiddenColumn,
              'is--sortable': column.sortable,
              'col--filter': !!column.filters,
              'is--filter-active': hasFilter,
              'col--current': currentColumn === column
            }, headerClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerClassName) ? headerClassName(params) : headerClassName : '', headerCellClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerCellClassName) ? headerCellClassName(params) : headerCellClassName : ''],
            colid: column.id,
            colspan: column.colSpan > 1 ? column.colSpan : null,
            rowspan: column.rowSpan > 1 ? column.rowSpan : null,
            style: headerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerCellStyle) ? headerCellStyle(params) : headerCellStyle : null,
            ...thOns,
            key: columnKey || columnOpts.useKey || isColGroup ? column.id : $columnIndex
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-cell', {
              'c--title': showTitle,
              'c--tooltip': showTooltip,
              'c--ellipsis': showEllipsis
            }]
          }, column.renderHeader(params)),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && !isColGroup && (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || resizable) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-resizable', {
              'is--line': !border || border === 'none'
            }],
            onMousedown: evnt => resizeMousedown(evnt, params)
          }) : null]);
        }).concat(scrollbarWidth ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {
          class: 'vxe-header--gutter col--gutter'
        })] : []));
      }))]),
      /**
       * 其他
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderBorderRepair,
        class: 'vxe-table--header-border-line'
      })]);
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/table/src/footer.ts



const footer_renderType = 'footer';
function mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeFooterList.length; mIndex++) {
    const {
      row: mergeRowIndex,
      col: mergeColIndex,
      rowspan: mergeRowspan,
      colspan: mergeColspan
    } = mergeFooterList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return {
          rowspan: mergeRowspan,
          colspan: mergeColspan
        };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return {
          rowspan: 0,
          colspan: 0
        };
      }
    }
  }
}
/* harmony default export */ var footer = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTableFooter',
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xetable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xetable', {});
    const {
      xID,
      props: tableProps,
      reactData: tableReactData,
      internalData: tableInternalData
    } = $xetable;
    const {
      refTableHeader,
      refTableBody,
      refValidTooltip
    } = $xetable.getRefMaps();
    const {
      computeTooltipOpts,
      computeColumnOpts
    } = $xetable.getComputeMaps();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterTFoot = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterXSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    /**
     * 滚动处理
     * 如果存在列固定左侧，同步更新滚动状态
     * 如果存在列固定右侧，同步更新滚动状态
     */
    const scrollEvent = evnt => {
      const {
        fixedType
      } = props;
      const {
        scrollXLoad
      } = tableReactData;
      const {
        lastScrollLeft
      } = tableInternalData;
      const validTip = refValidTooltip.value;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = refElem.value;
      const bodyElem = tableBody.$el;
      const scrollLeft = footerElem.scrollLeft;
      const isX = scrollLeft !== lastScrollLeft;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableReactData.lastScrollTime = Date.now();
      if (headerElem) {
        headerElem.scrollLeft = scrollLeft;
      }
      if (bodyElem) {
        bodyElem.scrollLeft = scrollLeft;
      }
      if (scrollXLoad && isX) {
        $xetable.triggerScrollXEvent(evnt);
      }
      if (isX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent('scroll', {
        type: footer_renderType,
        fixed: fixedType,
        scrollTop: bodyElem.scrollTop,
        scrollLeft,
        isX,
        isY: false
      }, evnt);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          fixedType
        } = props;
        const {
          elemStore
        } = tableInternalData;
        const prefix = `${fixedType || 'main'}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        fixedType
      } = props;
      const {
        elemStore
      } = tableInternalData;
      const prefix = `${fixedType || 'main'}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    const renderVN = () => {
      let {
        fixedType,
        fixedColumn,
        tableColumn,
        footerTableData
      } = props;
      const {
        footerRowClassName,
        footerCellClassName,
        footerRowStyle,
        footerCellStyle,
        footerAlign: allFooterAlign,
        footerSpanMethod,
        align: allAlign,
        columnKey,
        showFooterOverflow: allColumnFooterOverflow
      } = tableProps;
      const {
        visibleColumn
      } = tableInternalData;
      const {
        scrollXLoad,
        overflowX,
        scrollbarWidth,
        currentColumn,
        mergeFooterList
      } = tableReactData;
      const tooltipOpts = computeTooltipOpts.value;
      const columnOpts = computeColumnOpts.value;
      // 如果是使用优化模式
      if (fixedType) {
        // 如果存在展开行使用全量渲染
        if (!tableReactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
          if (!mergeFooterList.length || !footerSpanMethod) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table--footer-wrapper', fixedType ? `fixed-${fixedType}--wrapper` : 'body--wrapper'],
        xid: xID,
        onScroll: scrollEvent
      }, [fixedType ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refFooterXSpace,
        class: 'vxe-body--x-space'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        ref: refFooterTable,
        class: 'vxe-table--footer',
        xid: xID,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [
      /**
       * 列宽
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('colgroup', {
        ref: refFooterColgroup
      }, tableColumn.map((column, $columnIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
          name: column.id,
          key: $columnIndex
        });
      }).concat(scrollbarWidth ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('col', {
        name: 'col_gutter'
      })] : [])),
      /**
       * 底部
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tfoot', {
        ref: refFooterTFoot
      }, footerTableData.map((list, _rowIndex) => {
        const $rowIndex = _rowIndex;
        const rowParams = {
          $table: $xetable,
          row: list,
          _rowIndex,
          $rowIndex,
          fixed: fixedType,
          type: footer_renderType
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', {
          class: ['vxe-footer--row', footerRowClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ''],
          style: footerRowStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, tableColumn.map((column, $columnIndex) => {
          const {
            type,
            showFooterOverflow,
            footerAlign,
            align,
            footerClassName
          } = column;
          const showAllTip = tooltipOpts.showAll;
          const isColGroup = column.children && column.children.length;
          const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
          const footOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showFooterOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
          const footAlign = footerAlign || align || allFooterAlign || allAlign;
          let showEllipsis = footOverflow === 'ellipsis';
          const showTitle = footOverflow === 'title';
          const showTooltip = footOverflow === true || footOverflow === 'tooltip';
          let hasEllipsis = showTitle || showTooltip || showEllipsis;
          const attrs = {
            colid: column.id
          };
          const tfOns = {};
          const columnIndex = $xetable.getColumnIndex(column);
          const _columnIndex = $xetable.getVTColumnIndex(column);
          const itemIndex = _columnIndex;
          const cellParams = {
            $table: $xetable,
            $grid: $xetable.xegrid,
            row: list,
            rowIndex: _rowIndex,
            _rowIndex,
            $rowIndex,
            column,
            columnIndex,
            $columnIndex,
            _columnIndex,
            itemIndex,
            items: list,
            fixed: fixedType,
            type: footer_renderType,
            data: footerTableData
          };
          // 纵向虚拟滚动不支持动态行高
          if (scrollXLoad && !hasEllipsis) {
            showEllipsis = hasEllipsis = true;
          }
          if (showTitle || showTooltip || showAllTip) {
            tfOns.onMouseenter = evnt => {
              if (showTitle) {
                updateCellTitle(evnt.currentTarget, column);
              } else if (showTooltip || showAllTip) {
                $xetable.triggerFooterTooltipEvent(evnt, cellParams);
              }
            };
          }
          if (showTooltip || showAllTip) {
            tfOns.onMouseleave = evnt => {
              if (showTooltip || showAllTip) {
                $xetable.handleTargetLeaveEvent(evnt);
              }
            };
          }
          tfOns.onClick = evnt => {
            $xetable.dispatchEvent('footer-cell-click', Object.assign({
              cell: evnt.currentTarget
            }, cellParams), evnt);
          };
          tfOns.onDblclick = evnt => {
            $xetable.dispatchEvent('footer-cell-dblclick', Object.assign({
              cell: evnt.currentTarget
            }, cellParams), evnt);
          };
          // 合并行或列
          if (mergeFooterList.length) {
            const spanRest = mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex);
            if (spanRest) {
              const {
                rowspan,
                colspan
              } = spanRest;
              if (!rowspan || !colspan) {
                return null;
              }
              if (rowspan > 1) {
                attrs.rowspan = rowspan;
              }
              if (colspan > 1) {
                attrs.colspan = colspan;
              }
            }
          } else if (footerSpanMethod) {
            // 自定义合并方法
            const {
              rowspan = 1,
              colspan = 1
            } = footerSpanMethod(cellParams) || {};
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              attrs.colspan = colspan;
            }
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-footer--column', column.id, {
              [`col--${footAlign}`]: footAlign,
              [`col--${type}`]: type,
              'col--last': $columnIndex === tableColumn.length - 1,
              'fixed--hidden': fixedHiddenColumn,
              'col--ellipsis': hasEllipsis,
              'col--current': currentColumn === column
            }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)],
            ...attrs,
            style: footerCellStyle ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null,
            ...tfOns,
            key: columnKey || columnOpts.useKey ? column.id : $columnIndex
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-cell', {
              'c--title': showTitle,
              'c--tooltip': showTooltip,
              'c--ellipsis': showEllipsis
            }]
          }, column.renderFooter(cellParams))]);
        }).concat(scrollbarWidth ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
          class: 'vxe-footer--gutter col--gutter'
        })] : []));
      }))])]);
    };
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/table/src/props.ts

/* harmony default export */ var props = ({
  /** 基本属性 */
  id: String,
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => conf.table.minHeight
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => conf.table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => conf.table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => conf.table.border
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => conf.table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => conf.table.size || conf.size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => conf.table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => conf.table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => conf.table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => conf.table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => conf.table.showHeader
  },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: {
    type: Boolean,
    default: () => conf.table.highlightCurrentRow
  },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: {
    type: Boolean,
    default: () => conf.table.highlightHoverRow
  },
  // （即将废弃）是否要高亮当前选中列
  highlightCurrentColumn: {
    type: Boolean,
    default: () => conf.table.highlightCurrentColumn
  },
  // （即将废弃）鼠标移到列是否要高亮显示
  highlightHoverColumn: {
    type: Boolean,
    default: () => conf.table.highlightHoverColumn
  },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => conf.table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => conf.table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => conf.table.showFooterOverflow
  },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: {
    type: String,
    default: () => conf.table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => conf.table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => conf.table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => conf.table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置信息
  columnConfig: Object,
  // 行配置信息
  rowConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // 横向虚拟滚动配置项
  scrollX: Object,
  // 纵向虚拟滚动配置项
  scrollY: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => conf.table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => conf.table.delayHover
  },
  // 额外的参数
  params: Object
});
;// CONCATENATED MODULE: ./packages/table/src/emits.ts
/* harmony default export */ var emits = (['update:data', 'keydown-start', 'keydown', 'keydown-end', 'paste', 'copy', 'cut', 'current-change', 'radio-change', 'checkbox-change', 'checkbox-all', 'checkbox-range-start', 'checkbox-range-change', 'checkbox-range-end', 'checkbox-range-select', 'cell-click', 'cell-dblclick', 'cell-menu', 'cell-mouseenter', 'cell-mouseleave', 'cell-selected', 'cell-delete-value', 'header-cell-click', 'header-cell-dblclick', 'header-cell-menu', 'footer-cell-click', 'footer-cell-dblclick', 'footer-cell-menu', 'clear-merge', 'sort-change', 'clear-sort', 'filter-change', 'filter-visible', 'clear-filter', 'resizable-change', 'toggle-row-expand', 'toggle-tree-expand', 'menu-click', 'edit-closed', 'edit-actived', 'edit-activated', 'edit-disabled', 'valid-error', 'scroll', 'custom', 'change-fnr', 'open-fnr', 'show-fnr', 'hide-fnr', 'fnr-change', 'fnr-find', 'fnr-find-all', 'fnr-replace', 'fnr-replace-all', 'cell-area-copy', 'cell-area-cut', 'cell-area-paste', 'cell-area-merge', 'clear-cell-area-merge', 'header-cell-area-selection', 'cell-area-selection-invalid', 'cell-area-selection-start', 'cell-area-selection-drag', 'cell-area-selection-end', 'cell-area-extension-start', 'cell-area-extension-drag', 'cell-area-extension-end', 'cell-area-selection-all-start', 'cell-area-selection-all-end', 'cell-area-arrows-start', 'cell-area-arrows-end', 'active-cell-change-start', 'active-cell-change-end']);
;// CONCATENATED MODULE: ./packages/table/src/table.ts




















const isWebkit = browse['-webkit'] && !browse.edge;
const resizableStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_WIDTH';
const visibleStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_VISIBLE';
const fixedStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_FIXED';
const sortStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_SORT';
/* harmony default export */ var table = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTable',
  props: props,
  emits: emits,
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const hasUseTooltip = VXETable.tooltip;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: false,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: false,
      // 是否存在纵向滚动条
      overflowY: true,
      // 是否存在横向滚动条
      overflowX: false,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: false,
      isAllOverflow: false,
      // 复选框属性，是否全选
      isAllSelected: false,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: false,
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 展开列信息
      expandColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 树节点不确定状态的集合
      treeIndeterminateMaps: {},
      // 合并单元格的对象集
      mergeList: [],
      // 合并表尾数据的对象集
      mergeFooterList: [],
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 已标记的对象集
      pendingRowMaps: {},
      // 已标记的行
      pendingRowList: [],
      // 初始化标识
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        },
        insertMaps: {},
        removeMaps: {}
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false
      },
      // 存放数据校验相关信息
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: false,
        file: null,
        type: '',
        modeList: [],
        typeList: [],
        filename: '',
        visible: false
      },
      importParams: {
        mode: '',
        types: null,
        message: true
      },
      // 导出相关信息
      exportStore: {
        inited: false,
        name: '',
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: '',
        sheetName: '',
        mode: '',
        type: '',
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isFooter: false
      },
      scrollVMLoading: false,
      _isResize: false
    });
    const internalData = {
      tZindex: 0,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      // 当前 hover 行
      hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 总的缓存数据集
      fullAllDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCommTooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refValidTooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableMenu = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableFilter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableCustom = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableHeader = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableFooter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableLeftHeader = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableLeftBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableLeftFooter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableRightHeader = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableRightBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTableRightFooter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refLeftContainer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refRightContainer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCellResizeBar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refEmptyPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xegrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xegrid', null);
    let $xetoolbar;
    const computeValidOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.validConfig, props.validConfig);
    });
    const computeSXOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.scrollX, props.scrollX);
    });
    const computeSYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.scrollY, props.scrollY);
    });
    const computeRowHeightMaps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return {
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      };
    });
    const computeColumnOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.columnConfig, props.columnConfig);
    });
    const computeRowOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.rowConfig, props.rowConfig);
    });
    const computeResizeleOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        startIndex: 0
      }, conf.table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.checkboxConfig, props.checkboxConfig);
    });
    let computeTooltipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    computeTooltipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.tooltip, conf.table.tooltipConfig, props.tooltipConfig);
    });
    const computeTipConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return {
        ...tooltipOpts
      };
    });
    const computeValidTipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({
        isArrow: false
      }, tooltipOpts);
    });
    const computeEditOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.editConfig, props.editConfig);
    });
    const computeSortOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        orders: ['asc', 'desc', null]
      }, conf.table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.filterConfig, props.filterConfig);
    });
    const computeMouseOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.menuConfig, props.menuConfig);
    });
    const computeHeaderMenu = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        ctxMenuStore
      } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach(list => {
        list.forEach(item => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.importConfig, props.importConfig);
    });
    const computePrintOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.printConfig, props.printConfig);
    });
    const computeExpandOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.table.customConfig, props.customConfig);
    });
    const computeFixedColumnSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        collectColumn
      } = internalData;
      let fixedSize = 0;
      // 只判断第一层
      collectColumn.forEach(column => {
        if (column.fixed) {
          fixedSize++;
        }
      });
      return fixedSize;
    });
    const computeIsMaxFixedColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const {
        maxFixedSize
      } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        border
      } = props;
      if (border === true) {
        return 'full';
      }
      if (border) {
        return border;
      }
      return 'default';
    });
    const computeIsAllCheckboxDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        treeConfig
      } = props;
      const {
        tableData
      } = reactData;
      const {
        tableFullData
      } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        strict,
        checkMethod
      } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
              // 暂时不支持树形结构
            }
            // 如果所有行都被禁用
            return tableFullData.every(row => !checkMethod({
              row
            }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refCellResizeBar
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeSXOpts,
      computeSYOpts,
      computeColumnOpts,
      computeRowOpts,
      computeResizeleOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCustomOpts,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled
    };
    const $xetable = {
      xID,
      props: props,
      context,
      instance,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xegrid: $xegrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row1, field);
      const val2 = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val1) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val1)) {
        return '' + val1 === '' + val2;
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val1, val2);
    };
    const getNextSortOrder = column => {
      const sortOpts = computeSortOpts.value;
      const {
        orders
      } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = key => {
      const version = conf.version;
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(key) || '');
      return rest && rest._v === version ? rest : {
        _v: version
      };
    };
    const getRecoverRowMaps = keyMaps => {
      const {
        fullAllDataRowIdData
      } = internalData;
      const restKeys = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = reserveRowMap => {
      const {
        fullDataRowIdData
      } = internalData;
      const reserveList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xetable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const computeVirtualX = () => {
      const {
        visibleColumn
      } = internalData;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      if (tableBodyElem) {
        const {
          scrollLeft,
          clientWidth
        } = tableBodyElem;
        const endWidth = scrollLeft + clientWidth;
        let toVisibleIndex = -1;
        let cWidth = 0;
        let visibleSize = 0;
        for (let colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {
          cWidth += visibleColumn[colIndex].renderWidth;
          if (toVisibleIndex === -1 && scrollLeft < cWidth) {
            toVisibleIndex = colIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (cWidth > endWidth) {
              break;
            }
          }
        }
        return {
          toVisibleIndex: Math.max(0, toVisibleIndex),
          visibleSize: Math.max(8, visibleSize)
        };
      }
      return {
        toVisibleIndex: 0,
        visibleSize: 8
      };
    };
    const computeVirtualY = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      if (tableBodyElem) {
        const tableHeaderElem = tableHeader ? tableHeader.$el : null;
        let rowHeight = 0;
        let firstTrElem;
        firstTrElem = tableBodyElem.querySelector('tr');
        if (!firstTrElem && tableHeaderElem) {
          firstTrElem = tableHeaderElem.querySelector('tr');
        }
        if (firstTrElem) {
          rowHeight = firstTrElem.clientHeight;
        }
        if (!rowHeight) {
          rowHeight = rowHeightMaps[vSize || 'default'];
        }
        const visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);
        return {
          rowHeight,
          visibleSize
        };
      }
      return {
        rowHeight: 0,
        visibleSize: 8
      };
    };
    const calculateMergerOffserIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const {
          startIndex,
          endIndex
        } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + 'span'];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    const setMerges = (merges, mList, rowList) => {
      if (merges) {
        const {
          treeConfig
        } = props;
        const {
          visibleColumn
        } = internalData;
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog('vxe.error.noTree', ['merge-cells | merge-footer-items']);
        }
        merges.forEach(item => {
          let {
            row,
            col,
            rowspan,
            colspan
          } = item;
          if (rowList && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)) {
            row = rowList[row];
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(col)) {
            col = visibleColumn[col];
          }
          if ((rowList ? row : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)) && col && (rowspan || colspan)) {
            rowspan = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rowspan) || 1;
            colspan = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const mcIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mList, item => (item._row === row || getRowid($xetable, item._row) === getRowid($xetable, row)) && (item._col.id === col || item._col.id === col.id));
              const mergeItem = mList[mcIndex];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                const mergeRowIndex = rowList ? $xetable.findRowIndexOf(rowList, row) : row;
                const mergeColIndex = tableMethods.getVTColumnIndex(col);
                mList.push({
                  row: mergeRowIndex,
                  col: mergeColIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: col,
                  _rowspan: rowspan,
                  _colspan: colspan
                });
              }
            }
          }
        });
      }
    };
    const removeMerges = (merges, mList, rowList) => {
      const rest = [];
      if (merges) {
        const {
          treeConfig
        } = props;
        const {
          visibleColumn
        } = internalData;
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog('vxe.error.noTree', ['merge-cells | merge-footer-items']);
        }
        merges.forEach(item => {
          let {
            row,
            col
          } = item;
          if (rowList && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(row)) {
            row = rowList[row];
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(col)) {
            col = visibleColumn[col];
          }
          const mcIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(mList, item => (item._row === row || getRowid($xetable, item._row) === getRowid($xetable, row)) && (item._col.id === col || item._col.id === col.id));
          if (mcIndex > -1) {
            const rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    const clearAllSort = () => {
      const {
        tableFullColumn
      } = internalData;
      tableFullColumn.forEach(column => {
        column.order = null;
      });
    };
    const calcHeight = key => {
      const {
        parentHeight
      } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === 'auto') {
          num = parentHeight;
        } else {
          const excludeHeight = $xetable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    /**
     * 还原自定义列操作状态
     */
    const restoreCustomStorage = () => {
      const {
        id,
        customConfig
      } = props;
      const customOpts = computeCustomOpts.value;
      const {
        storage
      } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
      const isCustomResizable = isAllCustom || storageOpts.resizable;
      const isCustomVisible = isAllCustom || storageOpts.visible;
      const isCustomFixed = isAllCustom || storageOpts.fixed;
      const isCustomSort = isAllCustom || storageOpts.sort;
      if (customConfig && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
        const customMap = {};
        if (!id) {
          errLog('vxe.error.reqProp', ['id']);
          return;
        }
        // 自定义列宽
        if (isCustomResizable) {
          const columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id];
          if (columnWidthStorage) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(columnWidthStorage, (resizeWidth, colKey) => {
              customMap[colKey] = {
                resizeWidth
              };
            });
          }
        }
        // 自定义固定列
        if (isCustomFixed) {
          const columnFixedStorage = getCustomStorageMap(fixedStorageKey)[id];
          if (columnFixedStorage) {
            const colFixeds = columnFixedStorage.split(',');
            colFixeds.forEach(fixConf => {
              const [colKey, fixed] = fixConf.split('|');
              if (customMap[colKey]) {
                customMap[colKey].fixed = fixed;
              } else {
                customMap[colKey] = {
                  fixed
                };
              }
            });
          }
        }
        // 自定义顺序
        let hasCustomSort = false;
        if (isCustomSort) {
          const columnSortStorage = getCustomStorageMap(sortStorageKey)[id];
          if (columnSortStorage) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(columnSortStorage, (renderSortNumber, colKey) => {
              if (customMap[colKey]) {
                customMap[colKey].renderSortNumber = renderSortNumber;
              } else {
                customMap[colKey] = {
                  renderSortNumber
                };
              }
              if (!hasCustomSort) {
                hasCustomSort = true;
              }
            });
          }
        }
        // 自定义隐藏列
        if (isCustomVisible) {
          const columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id];
          if (columnVisibleStorage) {
            const colVisibles = columnVisibleStorage.split('|');
            const colHides = colVisibles[0] ? colVisibles[0].split(',') : [];
            const colShows = colVisibles[1] ? colVisibles[1].split(',') : [];
            colHides.forEach(colKey => {
              if (customMap[colKey]) {
                customMap[colKey].visible = false;
              } else {
                customMap[colKey] = {
                  visible: false
                };
              }
            });
            colShows.forEach(colKey => {
              if (customMap[colKey]) {
                customMap[colKey].visible = true;
              } else {
                customMap[colKey] = {
                  visible: true
                };
              }
            });
          }
        }
        let {
          collectColumn
        } = internalData;
        const keyMap = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
          const colKey = column.getKey();
          if (colKey) {
            keyMap[colKey] = column;
          }
        });
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(customMap, ({
          visible,
          resizeWidth,
          fixed,
          renderSortNumber
        }, colKey) => {
          const column = keyMap[colKey];
          if (column) {
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(resizeWidth)) {
              column.resizeWidth = resizeWidth;
            }
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(visible)) {
              column.visible = visible;
            }
            if (fixed) {
              column.fixed = fixed;
            }
            if (renderSortNumber) {
              column.renderSortNumber = Number(renderSortNumber);
            }
          }
        });
        // 如果自定义了顺序
        if (hasCustomSort) {
          collectColumn = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(collectColumn, 'renderSortNumber');
          internalData.collectColumn = collectColumn;
          internalData.tableFullColumn = getColumnList(collectColumn);
        }
      }
    };
    /**
     * 更新数据列的 Map
     * 牺牲数据组装的耗时，用来换取使用过程中的流畅
     */
    const cacheColumnMap = () => {
      const {
        tableFullColumn,
        collectColumn
      } = internalData;
      const fullColumnIdData = internalData.fullColumnIdData = {};
      const fullColumnFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!props.showOverflow;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index, items, path, parent) => {
        const {
          id: colid,
          field,
          fixed,
          type,
          treeNode
        } = column;
        const rest = {
          column,
          colid,
          index,
          items,
          parent
        };
        if (field) {
          if (true) {
            if (fullColumnFieldData[field]) {
              warnLog('vxe.error.colRepet', ['field', field]);
            }
          }
          fullColumnFieldData[field] = rest;
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === 'html') {
          htmlColumn = column;
        }
        if (treeNode) {
          if (true) {
            if (treeNodeColumn) {
              warnLog('vxe.error.colRepet', ['tree-node', treeNode]);
            }
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        } else if (type === 'expand') {
          if (true) {
            if (expandColumn) {
              warnLog('vxe.error.colRepet', ['type', type]);
            }
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (true) {
          if (type === 'checkbox') {
            if (checkboxColumn) {
              warnLog('vxe.error.colRepet', ['type', type]);
            }
            if (!checkboxColumn) {
              checkboxColumn = column;
            }
          } else if (type === 'radio') {
            if (radioColumn) {
              warnLog('vxe.error.colRepet', ['type', type]);
            }
            if (!radioColumn) {
              radioColumn = column;
            }
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog('vxe.error.colRepet', ['colId', colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parent, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index, items, path, parent);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (true) {
        if (expandColumn && mouseOpts.area) {
          errLog('vxe.error.errConflicts', ['mouse-config.area', 'column.type=expand']);
        }
      }
      if (true) {
        if (htmlColumn) {
          if (!columnOpts.useKey) {
            errLog('vxe.error.reqProp', ['column-config.useKey', 'column.type=html']);
          }
          if (!rowOpts.useKey) {
            errLog('vxe.error.reqProp', ['row-config.useKey', 'column.type=html']);
          }
        }
      }
      reactData.isGroup = isGroup;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcHeight('height');
      internalData.customMinHeight = calcHeight('minHeight');
      internalData.customMaxHeight = calcHeight('maxHeight');
    };
    /**
     * 列宽算法
     * 支持 px、%、固定 混合分配
     * 支持动态列表调整分配
     * 支持自动分配偏移量
     */
    const autoCellWidth = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const bodyElem = tableBody ? tableBody.$el : null;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      if (!bodyElem) {
        return;
      }
      let tableWidth = 0;
      const minCellWidth = 40; // 列宽最少限制 40px
      const bodyWidth = bodyElem.clientWidth - 1;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const {
        fit
      } = props;
      const {
        columnStore
      } = reactData;
      const {
        resizeList,
        pxMinList,
        pxList,
        scaleList,
        scaleMinList,
        autoList
      } = columnStore;
      // 最小宽
      pxMinList.forEach(column => {
        const minWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth);
        tableWidth += minWidth;
        column.renderWidth = minWidth;
      });
      // 最小百分比
      scaleMinList.forEach(column => {
        const scaleWidth = Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.minWidth) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      // 固定百分比
      scaleList.forEach(column => {
        const scaleWidth = Math.floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      // 固定宽
      pxList.forEach(column => {
        const width = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.width);
        tableWidth += width;
        column.renderWidth = width;
      });
      // 调整了列宽
      resizeList.forEach(column => {
        const width = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(column.resizeWidth);
        tableWidth += width;
        column.renderWidth = width;
      });
      remainWidth -= tableWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).forEach(column => {
            tableWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      // 自适应
      autoList.forEach(column => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tableWidth += width;
      });
      if (fit) {
        /**
         * 偏移量算法
         * 如果所有列足够放的情况下，从最后动态列开始分配
         */
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let odiffer = bodyWidth - tableWidth;
          if (odiffer > 0) {
            while (odiffer > 0 && dynamicSize >= 0) {
              odiffer--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tableWidth = bodyWidth;
          }
        }
      }
      const tableHeight = bodyElem.offsetHeight;
      const overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;
      let scrollbarWidth = 0;
      if (overflowY) {
        scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);
      }
      reactData.scrollbarWidth = scrollbarWidth;
      reactData.overflowY = overflowY;
      internalData.tableWidth = tableWidth;
      internalData.tableHeight = tableHeight;
      let headerHeight = 0;
      if (headerElem) {
        headerHeight = headerElem.clientHeight;
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          // 检测是否同步滚动
          if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
        });
      }
      internalData.headerHeight = headerHeight;
      let overflowX = false;
      let footerHeight = 0;
      let scrollbarHeight = 0;
      if (footerElem) {
        footerHeight = footerElem.offsetHeight;
        overflowX = tableWidth > footerElem.clientWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);
        }
      } else {
        overflowX = tableWidth > bodyWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);
        }
      }
      internalData.footerHeight = footerHeight;
      reactData.overflowX = overflowX;
      reactData.scrollbarHeight = scrollbarHeight;
      updateHeight();
      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());
      if (overflowX) {
        tablePrivateMethods.checkScrolling();
      }
    };
    const getOrderField = column => {
      const {
        sortBy,
        sortType
      } = column;
      return row => {
        let cellValue;
        if (sortBy) {
          cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(sortBy) ? sortBy({
            row,
            column
          }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, sortBy);
        } else {
          cellValue = tablePrivateMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === 'auto') {
          return isNaN(cellValue) ? cellValue : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
        } else if (sortType === 'number') {
          return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(cellValue);
        } else if (sortType === 'string') {
          return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(cellValue);
        }
        return cellValue;
      };
    };
    /**
     * 预编译
     * 对渲染中的数据提前解析序号及索引。牺牲提前编译耗时换取渲染中额外损耗，使运行时更加流畅
     */
    const updateAfterDataIndex = () => {
      const {
        treeConfig
      } = props;
      const {
        afterFullData,
        fullDataRowIdData,
        fullAllDataRowIdData
      } = internalData;
      const {
        afterTreeFullData
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeFullData, (row, index, items, path) => {
          const rowid = getRowid($xetable, row);
          const allrest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : '.').join('');
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            const rest = {
              row,
              rowid,
              seq,
              index: -1,
              $index: -1,
              _index: index,
              items: [],
              parent: null,
              level: 0
            };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        }, {
          children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField
        });
      } else {
        afterFullData.forEach((row, index) => {
          const rowid = getRowid($xetable, row);
          const allrest = fullAllDataRowIdData[rowid];
          const seq = index + 1;
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            const rest = {
              row,
              rowid,
              seq,
              index: -1,
              $index: -1,
              _index: index,
              items: [],
              parent: null,
              level: 0
            };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        });
      }
      internalData.afterFullRowMaps = fullMaps;
    };
    /**
     * 如果为虚拟树，将树结构拍平
     * @returns
     */
    const handleVirtualTreeToList = () => {
      const {
        treeConfig
      } = props;
      const {
        treeExpandedMaps
      } = reactData;
      const treeOpts = computeTreeOpts.value;
      if (treeConfig && treeOpts.transform) {
        const fullData = [];
        const expandMaps = {};
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeFullData, (row, index, items, path, parent) => {
          const rowid = getRowid($xetable, row);
          const parentRowid = getRowid($xetable, parent);
          if (!parent || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, {
          children: treeOpts.mapChildrenField
        });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    /**
     * 获取处理后全量的表格数据
     * 如果存在筛选条件，继续处理
     */
    const updateAfterFullData = () => {
      const {
        treeConfig
      } = props;
      const {
        tableFullColumn,
        tableFullData,
        tableFullTreeData
      } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const treeOpts = computeTreeOpts.value;
      const {
        transform
      } = treeOpts;
      const {
        remote: allRemoteFilter,
        filterMethod: allFilterMethod
      } = filterOpts;
      const {
        remote: allRemoteSort,
        sortMethod: allSortMethod,
        multiple: sortMultiple,
        chronological
      } = sortOpts;
      let tableData = [];
      let tableTree = [];
      // 处理列
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach(column => {
          const {
            field,
            sortable,
            order,
            filters
          } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach(item => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({
                column,
                valueList,
                itemList
              });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({
              column,
              field,
              property: field,
              order: order,
              sortTime: column.sortTime
            });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(orderColumns, 'sortTime');
        }
        // 处理筛选
        // 支持单列、多列、组合筛选
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = row => {
            return filterColumns.every(({
              column,
              valueList,
              itemList
            }) => {
              const {
                filterMethod,
                filterRender
              } = column;
              const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.filterMethod : null;
              const defaultFilterMethod = compConf ? compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some(item => filterMethod({
                  value: item.value,
                  option: item,
                  cellValue,
                  row,
                  column,
                  $table: $xetable
                }));
              } else if (compFilterMethod) {
                return itemList.some(item => compFilterMethod({
                  value: item.value,
                  option: item,
                  cellValue,
                  row,
                  column,
                  $table: $xetable
                }));
              } else if (allFilterMethod) {
                return allFilterMethod({
                  options: itemList,
                  values: valueList,
                  cellValue,
                  row,
                  column
                });
              } else if (defaultFilterMethod) {
                return itemList.some(item => defaultFilterMethod({
                  value: item.value,
                  option: item,
                  cellValue,
                  row,
                  column,
                  $table: $xetable
                }));
              }
              return valueList.indexOf(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, column.field)) > -1;
            });
          };
          if (treeConfig && transform) {
            // 筛选虚拟树
            tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData, handleFilter, {
              ...treeOpts,
              original: true
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (treeConfig && transform) {
            // 还原虚拟树
            tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData, () => true, {
              ...treeOpts,
              original: true
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        // 处理排序（不能用于树形结构）
        // 支持单列、多列、组合排序
        if (!allRemoteSort && orderColumns.length) {
          if (treeConfig && transform) {
            // 虚拟树和列表一样，只能排序根级节点
            if (allSortMethod) {
              const sortRests = allSortMethod({
                data: tableTree,
                sortList: orderColumns,
                $table: $xetable
              });
              tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests) ? sortRests : tableTree;
            } else {
              tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(tableTree, orderColumns.map(({
                column,
                order
              }) => [getOrderField(column), order]));
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({
                data: tableData,
                sortList: orderColumns,
                $table: $xetable
              });
              tableData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(tableData, orderColumns.map(({
                column,
                order
              }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (treeConfig && transform) {
          // 还原虚拟树
          tableTree = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(tableFullTreeData, () => true, {
            ...treeOpts,
            original: true
          });
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const {
        border,
        showFooter,
        showOverflow: allColumnOverflow,
        showHeaderOverflow: allColumnHeaderOverflow,
        showFooterOverflow: allColumnFooterOverflow,
        mouseConfig,
        spanMethod,
        footerSpanMethod,
        keyboardConfig
      } = props;
      const {
        isGroup,
        currentRow,
        tableColumn,
        scrollXLoad,
        scrollYLoad,
        scrollbarWidth,
        scrollbarHeight,
        columnStore,
        editStore,
        mergeList,
        mergeFooterList,
        isAllOverflow
      } = reactData;
      let {
        visibleColumn,
        fullColumnIdData,
        tableHeight,
        tableWidth,
        headerHeight,
        footerHeight,
        elemStore,
        customHeight,
        customMinHeight,
        customMaxHeight
      } = internalData;
      const containerList = ['main', 'left', 'right'];
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const bodyWrapperRef = elemStore['main-body-wrapper'];
      const bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${headerHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - scrollbarHeight}px` : '';
      }
      if (customHeight > 0) {
        if (showFooter) {
          customHeight += scrollbarHeight;
        }
      }
      containerList.forEach((name, index) => {
        const fixedType = index > 0 ? name : '';
        const layoutList = ['header', 'body', 'footer'];
        const isFixedLeft = fixedType === 'left';
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach(layout => {
          const wrapperRef = elemStore[`${name}-${layout}-wrapper`];
          const wrapperElem = wrapperRef ? wrapperRef.value : null;
          const tableRef = elemStore[`${name}-${layout}-table`];
          const tableElem = tableRef ? tableRef.value : null;
          if (layout === 'header') {
            // 表头体样式处理
            // 横向滚动渲染
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              // 如果是使用优化模式
              if (fixedType) {
                if (scrollXLoad || allColumnHeaderOverflow) {
                  renderColumnList = fixedColumn;
                }
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : '';
            }
            const repairRef = elemStore[`${name}-${layout}-repair`];
            const repairElem = repairRef ? repairRef.value : null;
            if (repairElem) {
              repairElem.style.width = `${tableWidth}px`;
            }
            const listRef = elemStore[`${name}-${layout}-list`];
            const listElem = listRef ? listRef.value : null;
            if (isGroup && listElem) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(listElem.querySelectorAll('.col--group'), thElem => {
                const colNode = tableMethods.getColumnNode(thElem);
                if (colNode) {
                  const column = colNode.item;
                  const {
                    showHeaderOverflow
                  } = column;
                  const cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;
                  const showEllipsis = cellOverflow === 'ellipsis';
                  const showTitle = cellOverflow === 'title';
                  const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
                  const hasEllipsis = showTitle || showTooltip || showEllipsis;
                  let childWidth = 0;
                  let countChild = 0;
                  if (hasEllipsis) {
                    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(column.children, item => {
                      if (!item.children || !column.children.length) {
                        countChild++;
                      }
                      childWidth += item.renderWidth;
                    }, {
                      children: 'children'
                    });
                  }
                  thElem.style.width = hasEllipsis ? `${childWidth - countChild - (border ? 2 : 0)}px` : '';
                }
              });
            }
          } else if (layout === 'body') {
            const emptyBlockRef = elemStore[`${name}-${layout}-emptyBlock`];
            const emptyBlockElem = emptyBlockRef ? emptyBlockRef.value : null;
            if (isNodeElement(wrapperElem)) {
              let bodyMaxHeight = 0;
              const bodyMinHeight = customMinHeight - headerHeight - footerHeight;
              if (customMaxHeight) {
                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;
                // 如果是固定列
                if (fixedType) {
                  bodyMaxHeight -= showFooter ? 0 : scrollbarHeight;
                }
                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);
                wrapperElem.style.maxHeight = `${bodyMaxHeight}px`;
              }
              if (customHeight) {
                let bodyHeight = customHeight - headerHeight - footerHeight;
                // 如果是固定列
                if (fixedType) {
                  bodyHeight -= showFooter ? 0 : scrollbarHeight;
                }
                if (bodyMaxHeight) {
                  bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
                }
                wrapperElem.style.height = `${Math.max(bodyMinHeight, bodyHeight)}px`;
              } else {
                wrapperElem.style.height = '';
              }
              wrapperElem.style.minHeight = `${bodyMinHeight}px`;
            }
            // 如果是固定列
            if (fixedWrapperElem) {
              if (isNodeElement(wrapperElem)) {
                wrapperElem.style.top = `${headerHeight}px`;
              }
              fixedWrapperElem.style.height = `${(customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1)}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, isFixedLeft ? 0 : scrollbarWidth)}px`;
            }
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            // 如果是使用优化模式
            if (fixedType) {
              // 如果存在展开行使用全量渲染
              if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : '';
              // 兼容性处理
              tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse['-moz'] || browse.safari) ? `${scrollbarWidth}px` : '';
            }
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : '';
            }
          } else if (layout === 'footer') {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            // 如果是使用优化模式
            if (fixedType) {
              // 如果存在展开行使用全量渲染
              if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
                if (!mergeFooterList.length || !footerSpanMethod) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (isNodeElement(wrapperElem)) {
              // 如果是固定列
              if (fixedWrapperElem) {
                wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight}px`;
              }
              wrapperElem.style.marginTop = `${-Math.max(1, scrollbarHeight)}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : '';
            }
          }
          const colgroupRef = elemStore[`${name}-${layout}-colgroup`];
          const colgroupElem = colgroupRef ? colgroupRef.value : null;
          if (colgroupElem) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(colgroupElem.children, colElem => {
              const colid = colElem.getAttribute('name');
              if (colid === 'col_gutter') {
                colElem.style.width = `${scrollbarWidth}px`;
              }
              if (fullColumnIdData[colid]) {
                const column = fullColumnIdData[colid].column;
                const {
                  showHeaderOverflow,
                  showFooterOverflow,
                  showOverflow
                } = column;
                let cellOverflow;
                colElem.style.width = `${column.renderWidth}px`;
                if (layout === 'header') {
                  cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showHeaderOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
                } else if (layout === 'footer') {
                  cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showFooterOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
                } else {
                  cellOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(showOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(showOverflow) ? allColumnOverflow : showOverflow;
                }
                const showEllipsis = cellOverflow === 'ellipsis';
                const showTitle = cellOverflow === 'title';
                const showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
                let hasEllipsis = showTitle || showTooltip || showEllipsis;
                const listRef = elemStore[`${name}-${layout}-list`];
                const listElem = listRef ? listRef.value : null;
                // 纵向虚拟滚动不支持动态行高
                if (scrollYLoad && !hasEllipsis) {
                  hasEllipsis = true;
                }
                if (listElem) {
                  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(listElem.querySelectorAll(`.${column.id}`), elem => {
                    const colspan = parseInt(elem.getAttribute('colspan') || 1);
                    const cellElem = elem.querySelector('.vxe-cell');
                    let colWidth = column.renderWidth;
                    if (cellElem) {
                      if (colspan > 1) {
                        const columnIndex = tableMethods.getColumnIndex(column);
                        for (let index = 1; index < colspan; index++) {
                          const nextColumn = tableMethods.getColumns(columnIndex + index);
                          if (nextColumn) {
                            colWidth += nextColumn.renderWidth;
                          }
                        }
                      }
                      cellElem.style.width = hasEllipsis ? `${colWidth - cellOffsetWidth * colspan}px` : '';
                    }
                  });
                }
              }
            });
          }
        });
      });
      if (currentRow) {
        tableMethods.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xetable.addCellSelectedClass();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const checkValidate = type => {
      if ($xetable.triggerValidate) {
        return $xetable.triggerValidate(type);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 当单元格发生改变时
     * 如果存在规则，则校验
     */
    const handleChangeCell = (evnt, params) => {
      checkValidate('blur').catch(e => e).then(() => {
        $xetable.handleActived(params, evnt).then(() => checkValidate('change')).catch(e => e);
      });
    };
    const handleDefaultSort = () => {
      const {
        sortConfig
      } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let {
          defaultSort
        } = sortOpts;
        if (defaultSort) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index) => {
              const {
                field,
                order
              } = item;
              if (field && order) {
                const column = tableMethods.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index;
                }
              }
            });
            if (!sortOpts.remote) {
              tablePrivateMethods.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    /**
     * 处理默认勾选
     */
    const handleDefaultSelectionChecked = () => {
      const {
        checkboxConfig
      } = props;
      if (checkboxConfig) {
        const {
          fullDataRowIdData
        } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          checkAll,
          checkRowKeys
        } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach(rowid => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    /**
     * 处理单选框默认勾选
     */
    const handleDefaultRadioChecked = () => {
      const {
        radioConfig
      } = props;
      if (radioConfig) {
        const {
          fullDataRowIdData
        } = internalData;
        const radioOpts = computeRadioOpts.value;
        const {
          checkRowKey: rowid,
          reserve
        } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xetable);
            internalData.radioReserveRow = {
              [rowkey]: rowid
            };
          }
        }
      }
    };
    /**
     * 处理默认展开行
     */
    const handleDefaultRowExpand = () => {
      const {
        expandConfig
      } = props;
      if (expandConfig) {
        const {
          fullDataRowIdData
        } = internalData;
        const expandOpts = computeExpandOpts.value;
        const {
          expandAll,
          expandRowKeys
        } = expandOpts;
        if (expandAll) {
          tableMethods.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach(rowid => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          tableMethods.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = row => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const {
        checkboxReserveRowMap
      } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const {
        checkMethod
      } = radioOpts;
      if (row && (isForce || !checkMethod || checkMethod({
        row
      }))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
        rows = [rows];
      }
      rows.forEach(row => tablePrivateMethods.handleSelectRow({
        row
      }, !!value, isForce));
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleCheckedAllCheckboxRow = (value, isForce) => {
      const {
        treeConfig
      } = props;
      const {
        selectCheckboxMaps
      } = reactData;
      const {
        afterFullData,
        afterFullRowMaps,
        checkboxReserveRowMap
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkField,
        reserve,
        checkStrictly,
        checkMethod
      } = checkboxOpts;
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      // 疑惑！
      if (!treeConfig) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps, (row, rowid) => {
          if (!afterFullRowMaps[rowid]) {
            selectRowMaps[rowid] = row;
          }
        });
      }
      // 疑惑！
      if (checkStrictly) {
        reactData.isAllSelected = value;
      } else {
        /**
         * 绑定属性方式（高性能，有污染）
         * 必须在行数据存在对应的属性，否则将不响应
         */
        if (checkField) {
          const checkValFn = row => {
            if (isForce || !checkMethod || checkMethod({
              row
            })) {
              if (value) {
                selectRowMaps[getRowid($xetable, row)] = row;
              }
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, checkField, value);
            }
            if (treeConfig && indeterminateField) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, indeterminateField, false);
            }
          };
          // 如果存在选中方法
          // 如果方法成立，则更新值，否则忽略该数据
          if (treeConfig) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData, checkValFn, {
              children: childrenField
            });
          } else {
            afterFullData.forEach(checkValFn);
          }
        } else {
          /**
           * 默认方式（低性能，无污染）
           * 无需任何属性，直接绑定
           */
          if (treeConfig) {
            if (value) {
              /**
               * 如果是树勾选
               * 如果方法成立，则添加到临时集合中
               */
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData, row => {
                if (isForce || !checkMethod || checkMethod({
                  row
                })) {
                  selectRowMaps[getRowid($xetable, row)] = row;
                }
              }, {
                children: childrenField
              });
            } else {
              /**
               * 如果是树取消
               * 如果方法成立，则不添加到临时集合中
               */
              if (!isForce && checkMethod) {
                external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData, row => {
                  const rowid = getRowid($xetable, row);
                  if (checkMethod({
                    row
                  }) ? 0 : selectCheckboxMaps[rowid]) {
                    selectRowMaps[rowid] = row;
                  }
                }, {
                  children: childrenField
                });
              }
            }
          } else {
            if (value) {
              /**
               * 如果是行勾选
               * 如果存在选中方法且成立或者本身已勾选，则添加到临时集合中
               * 如果不存在选中方法，则添加所有数据到临时集合中
               */
              if (!isForce && checkMethod) {
                afterFullData.forEach(row => {
                  const rowid = getRowid($xetable, row);
                  if (selectCheckboxMaps[rowid] || checkMethod({
                    row
                  })) {
                    selectRowMaps[rowid] = row;
                  }
                });
              } else {
                afterFullData.forEach(row => {
                  selectRowMaps[getRowid($xetable, row)] = row;
                });
              }
            } else {
              /**
               * 如果是行取消
               * 如果方法成立，则不添加到临时集合中；如果方法不成立则判断当前是否已勾选，如果已被勾选则添加到新集合中
               * 如果不存在选中方法，无需处理，临时集合默认为空
               */
              if (!isForce && checkMethod) {
                afterFullData.forEach(row => {
                  const rowid = getRowid($xetable, row);
                  if (checkMethod({
                    row
                  }) ? 0 : selectCheckboxMaps[rowid]) {
                    selectRowMaps[rowid] = row;
                  }
                });
              }
            }
          }
        }
        if (reserve) {
          if (value) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectRowMaps, (row, rowid) => {
              checkboxReserveRowMap[rowid] = row;
            });
          } else {
            afterFullData.forEach(row => handleCheckboxReserveRow(row, false));
          }
        }
        reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      }
      reactData.treeIndeterminateMaps = {};
      internalData.treeIndeterminateRowMaps = {};
      tablePrivateMethods.checkSelectionStatus();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    // 还原展开、选中等相关状态
    const handleReserveStatus = () => {
      const {
        treeConfig
      } = props;
      const {
        expandColumn,
        currentRow,
        selectCheckboxMaps,
        selectRadioRow,
        rowExpandedMaps,
        treeExpandedMaps
      } = reactData;
      const {
        fullDataRowIdData,
        fullAllDataRowIdData,
        radioReserveRow
      } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      // 单选框
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xetable, selectRadioRow)]) {
        reactData.selectRadioRow = null; // 刷新单选行状态
      }
      // 还原保留选中状态
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xetable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      // 复选框
      reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps); // 刷新多选行状态
      // 还原保留选中状态
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xetable, currentRow)]) {
        reactData.currentRow = null; // 刷新当前行状态
      }
      // 行展开
      reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {}; // 刷新行展开状态
      // 还原保留状态
      if (expandColumn && expandOpts.reserve) {
        tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      // 树展开
      reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {}; // 刷新树展开状态
      if (treeConfig && treeOpts.reserve) {
        tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    /**
     * 处理默认展开树节点
     */
    const handleDefaultTreeExpand = () => {
      const {
        treeConfig
      } = props;
      if (treeConfig) {
        const {
          tableFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const {
          expandAll,
          expandRowKeys
        } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (expandAll) {
          tableMethods.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          const rowkey = getRowkey($xetable);
          expandRowKeys.forEach(rowid => {
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData, item => rowid === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, rowkey), {
              children: childrenField
            });
            if (matchObj) {
              defExpandeds.push(matchObj.item);
            }
          });
          tableMethods.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = row => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        transform,
        loadMethod
      } = treeOpts;
      const {
        checkStrictly
      } = checkboxOpts;
      return new Promise(resolve => {
        if (loadMethod) {
          const {
            treeExpandLazyLoadedMaps
          } = reactData;
          const {
            fullAllDataRowIdData
          } = internalData;
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          loadMethod({
            $table: $xetable,
            row
          }).then(childRecords => {
            rest.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return tableMethods.loadTreeChildren(row, childRecords).then(childRows => {
                const {
                  treeExpandedMaps
                } = reactData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                // 如果当前节点已选中，则展开后子节点也被选中
                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
                  if (transform) {
                    return tablePrivateMethods.handleTableData();
                  }
                });
              });
            }
          }).catch(() => {
            const {
              treeExpandLazyLoadedMaps
            } = reactData;
            rest.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
          }).finally(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const {
        treeExpandedReserveRowMap
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = row => {
      return new Promise(resolve => {
        const expandOpts = computeExpandOpts.value;
        const {
          loadMethod
        } = expandOpts;
        if (loadMethod) {
          const {
            fullAllDataRowIdData
          } = internalData;
          const {
            rowExpandLazyLoadedMaps
          } = reactData;
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({
            $table: $xetable,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            $rowIndex: tableMethods.getVMRowIndex(row)
          }).then(() => {
            const {
              rowExpandedMaps
            } = reactData;
            rest.expandLoaded = true;
            rowExpandedMaps[rowid] = row;
          }).catch(() => {
            rest.expandLoaded = false;
          }).finally(() => {
            const {
              rowExpandLazyLoadedMaps
            } = reactData;
            if (rowExpandLazyLoadedMaps[rowid]) {
              delete rowExpandLazyLoadedMaps[rowid];
            }
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const {
        rowExpandedReserveRowMap
      } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const {
        mergeCells
      } = props;
      if (mergeCells) {
        tableMethods.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const {
        mergeFooterItems
      } = props;
      if (mergeFooterItems) {
        tableMethods.setMergeFooterItems(mergeFooterItems);
      }
    };
    // 计算可视渲染相关数据
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollXLoad,
          scrollYLoad
        } = reactData;
        const {
          scrollXStore,
          scrollYStore
        } = internalData;
        const sYOpts = computeSYOpts.value;
        const sXOpts = computeSXOpts.value;
        // 计算 X 逻辑
        if (scrollXLoad) {
          const {
            visibleSize: visibleXSize
          } = computeVirtualX();
          const offsetXSize = sXOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sXOpts.oSize) : browse.edge ? 5 : 0;
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          tablePrivateMethods.updateScrollXData();
        } else {
          tablePrivateMethods.updateScrollXSpace();
        }
        // 计算 Y 逻辑
        const {
          rowHeight,
          visibleSize: visibleYSize
        } = computeVirtualY();
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const offsetYSize = sYOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          tablePrivateMethods.updateScrollYData();
        } else {
          tablePrivateMethods.updateScrollYSpace();
        }
        reactData.rowHeight = rowHeight;
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(updateStyle);
      });
    };
    /**
     * 加载表格数据
     * @param {Array} datas 数据
     */
    const loadTableData = datas => {
      const {
        keepSource,
        treeConfig
      } = props;
      const {
        editStore,
        scrollYLoad: oldScrollYLoad
      } = reactData;
      const {
        scrollYStore,
        scrollXStore,
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        transform
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(datas ? datas.slice(0) : []); // 转为响应式
      if (treeConfig) {
        if (transform) {
          // 树结构自动转换
          if (true) {
            if (!treeOpts.rowField) {
              errLog('vxe.error.reqProp', ['tree-config.rowField']);
            }
            if (!treeOpts.parentField) {
              errLog('vxe.error.reqProp', ['tree-config.parentField']);
            }
            if (!childrenField) {
              errLog('vxe.error.reqProp', ['tree-config.childrenField']);
            }
            if (!treeOpts.mapChildrenField) {
              errLog('vxe.error.reqProp', ['tree-config.mapChildrenField']);
            }
            if (childrenField === treeOpts.mapChildrenField) {
              errLog('vxe.error.errConflicts', ['tree-config.childrenField', 'tree-config.mapChildrenField']);
            }
            // fullData.forEach(row => {
            //   if (row[treeOpts.children] && row[treeOpts.children].length) {
            //     warnLog('vxe.error.errConflicts', ['tree-config.transform', `row.${treeOpts.children}`])
            //   }
            // })
          }
          treeData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      }
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      reactData.scrollVMLoading = false;
      editStore.insertMaps = {};
      editStore.removeMaps = {};
      const sYLoad = updateScrollYStatus(fullData);
      reactData.scrollYLoad = sYLoad;
      // 全量数据
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = treeData;
      // 缓存数据
      tablePrivateMethods.cacheRowMap(true);
      // 原始数据
      internalData.tableSynchData = datas;
      // 克隆原数据，用于显示编辑状态，与编辑值做对比
      if (keepSource) {
        tablePrivateMethods.cacheSourceMap(fullData);
      }
      if (true) {
        if (sYLoad) {
          if (!(props.height || props.maxHeight)) {
            errLog('vxe.error.reqProp', ['table.height | table.max-height | table.scroll-y={enabled: false}']);
          }
          if (!props.showOverflow) {
            warnLog('vxe.error.reqProp', ['table.show-overflow']);
          }
          if (props.spanMethod) {
            warnLog('vxe.error.scrollErrProp', ['table.span-method']);
          }
        }
      }
      if ($xetable.clearCellAreas && props.mouseConfig) {
        $xetable.clearCellAreas();
        $xetable.clearCopyCellArea();
      }
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      tableMethods.updateFooter();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        // 是否启用了虚拟滚动
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        handleReserveStatus();
        tablePrivateMethods.checkSelectionStatus();
        return new Promise(resolve => {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => tableMethods.recalculate()).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const sXOpts = computeSXOpts.value;
            const sYOpts = computeSYOpts.value;
            // 是否在更新数据之后自动滚动重置滚动条
            if (sXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (sYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            // 是否变更虚拟滚动
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);
            } else {
              setTimeout(() => restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve));
            }
          });
        });
      });
    };
    /**
     * 处理数据加载默认行为
     * 默认执行一次，除非被重置
     */
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => setTimeout(() => tableMethods.recalculate()));
    };
    /**
     * 处理初始化的默认行为
     * 只会执行一次
     */
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const {
        scrollXLoad
      } = reactData;
      const {
        visibleColumn,
        scrollXStore,
        fullColumnIdData
      } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const rest = fullColumnIdData[colid];
        if (rest) {
          rest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const loadScrollXData = () => {
      const {
        mergeList,
        mergeFooterList
      } = reactData;
      const {
        scrollXStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        offsetSize
      } = scrollXStore;
      const {
        toVisibleIndex,
        visibleSize
      } = computeVirtualX();
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, 'col');
      const {
        startIndex: offsetStartIndex,
        endIndex: offsetEndIndex
      } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollXData();
        }
      }
      tableMethods.closeTooltip();
    };
    // 获取所有的列，排除分组
    const getColumnList = columns => {
      const result = [];
      columns.forEach(column => {
        result.push(...(column.children && column.children.length ? getColumnList(column.children) : [column]));
      });
      return result;
    };
    const parseColumns = () => {
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const {
        isGroup,
        columnStore
      } = reactData;
      const sXOpts = computeSXOpts.value;
      const {
        collectColumn,
        tableFullColumn,
        scrollXStore,
        fullColumnIdData
      } = internalData;
      // 如果是分组表头，如果子列全部被隐藏，则根列也隐藏
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, (column, index, items, path, parent) => {
          const isColGroup = hasChildrenList(column);
          // 如果是分组，必须按组设置固定列，不允许给子列设置固定
          if (parent && parent.fixed) {
            column.fixed = parent.fixed;
          }
          if (parent && column.fixed !== parent.fixed) {
            errLog('vxe.error.groupFixed');
          }
          if (isColGroup) {
            column.visible = !!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(column.children, subColumn => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === 'left') {
              leftList.push(column);
            } else if (column.fixed === 'right') {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach(column => {
          if (column.visible) {
            if (column.fixed === 'left') {
              leftGroupList.push(column);
            } else if (column.fixed === 'right') {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        // 重新分配列
        tableFullColumn.forEach(column => {
          if (column.visible) {
            if (column.fixed === 'left') {
              leftList.push(column);
            } else if (column.fixed === 'right') {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      // 如果gt为0，则总是启用
      const scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, {
        leftList,
        centerList,
        rightList
      });
      if (scrollXLoad) {
        if (true) {
          // if (props.showHeader && !props.showHeaderOverflow) {
          //   warnLog('vxe.error.reqProp', ['show-header-overflow'])
          // }
          // if (props.showFooter && !props.showFooterOverflow) {
          //   warnLog('vxe.error.reqProp', ['show-footer-overflow'])
          // }
          if (props.spanMethod) {
            warnLog('vxe.error.scrollErrProp', ['span-method']);
          }
          if (props.footerSpanMethod) {
            warnLog('vxe.error.scrollErrProp', ['footer-span-method']);
          }
        }
        const {
          visibleSize
        } = computeVirtualX();
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = visibleSize;
        scrollXStore.visibleSize = visibleSize;
      }
      // 如果列被显示/隐藏，则清除合并状态
      // 如果列被设置为固定，则清除合并状态
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index) => column === visibleColumn[index])) {
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach((column, index) => {
        const colid = column.id;
        const rest = fullColumnIdData[colid];
        if (rest) {
          rest._index = index;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      return tableMethods.updateFooter().then(() => {
        return tableMethods.recalculate();
      }).then(() => {
        tableMethods.updateCellAreas();
        return tableMethods.recalculate();
      });
    };
    const initColumnSort = () => {
      const {
        collectColumn
      } = internalData;
      collectColumn.forEach((column, index) => {
        const sortIndex = index + 1;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
      });
    };
    const handleColumn = collectColumn => {
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      initColumnSort();
      restoreCustomStorage();
      cacheColumnMap();
      parseColumns().then(() => {
        if (reactData.scrollXLoad) {
          loadScrollXData();
        }
      });
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      if (true) {
        if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {
          warnLog('vxe.error.scrollErrProp', ['column.type=expand']);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        if ($xetoolbar) {
          $xetoolbar.syncUpdate({
            collectColumn,
            $table: $xetable
          });
        }
        return tableMethods.recalculate();
      });
    };
    const updateScrollYStatus = fullData => {
      const {
        treeConfig
      } = props;
      const sYOpts = computeSYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const {
        transform
      } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      // 如果gt为0，则总是启用
      const scrollYLoad = (transform || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    /**
     * 展开与收起树节点
     * @param rows
     * @param expanded
     * @returns
     */
    const handleBaseTreeExpand = (rows, expanded) => {
      const {
        treeExpandedMaps,
        treeExpandLazyLoadedMaps,
        treeNodeColumn
      } = reactData;
      const treeTempExpandedMaps = {
        ...treeExpandedMaps
      };
      const {
        fullAllDataRowIdData,
        tableFullData
      } = internalData;
      const treeOpts = computeTreeOpts.value;
      const {
        reserve,
        lazy,
        accordion,
        toggleMethod
      } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = tableMethods.getColumnIndex(treeNodeColumn);
      const $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);
      let validRows = toggleMethod ? rows.filter(row => toggleMethod({
        $table: $xetable,
        expanded,
        column: treeNodeColumn,
        columnIndex,
        $columnIndex,
        row
      })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        // 同一级只能展开一个
        const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData, item => item === validRows[0], {
          children: childrenField
        });
        if (matchObj) {
          matchObj.items.forEach(item => {
            const rowid = getRowid($xetable, item);
            if (treeTempExpandedMaps[rowid]) {
              delete treeTempExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach(row => {
          const rowid = getRowid($xetable, row);
          if (!treeTempExpandedMaps[rowid]) {
            const rest = fullAllDataRowIdData[rowid];
            const isLoad = lazy && row[hasChildField] && !rest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
            // 是否使用懒加载
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(row));
            } else {
              if (row[childrenField] && row[childrenField].length) {
                treeTempExpandedMaps[rowid] = row;
              }
            }
          }
        });
      } else {
        validRows.forEach(item => {
          const rowid = getRowid($xetable, item);
          if (treeTempExpandedMaps[rowid]) {
            delete treeTempExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach(row => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedMaps = treeTempExpandedMaps;
      return Promise.all(result).then(() => {
        return tableMethods.recalculate();
      });
    };
    /**
     * 虚拟树的展开与收起
     * @param rows
     * @param expanded
     * @returns
     */
    const handleVirtualTreeExpand = (rows, expanded) => {
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        return tablePrivateMethods.handleTableData();
      }).then(() => {
        return tableMethods.recalculate();
      });
    };
    /**
     * 纵向 Y 可视渲染处理
     */
    const loadScrollYData = evnt => {
      const {
        mergeList
      } = reactData;
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = evnt.currentTarget || evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList, offsetItem, 'row');
      const {
        startIndex: offsetStartIndex,
        endIndex: offsetEndIndex
      } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = prop => {
      return function (row) {
        const {
          fullAllDataRowIdData
        } = internalData;
        if (row) {
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = prop => {
      return function (column) {
        const {
          fullColumnIdData
        } = internalData;
        if (column) {
          const rest = fullColumnIdData[column.id];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    const debounceScrollY = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(function (evnt) {
      loadScrollYData(evnt);
    }, 20, {
      leading: false,
      trailing: true
    });
    let keyCtxTimeout;
    tableMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $table: $xetable,
          $grid: $xegrid,
          $event: evnt
        }, params));
      },
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return clearTableAllStatus($xetable);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        warnLog('vxe.error.delFunc', ['syncData', 'getData']);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          reactData.tableData = [];
          emit('update:data', internalData.tableFullData);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        });
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const {
          scrollXLoad,
          scrollYLoad
        } = reactData;
        return tablePrivateMethods.handleTableData(true).then(() => {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(() => {
          tableMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(() => {
          // 存在滚动行为未结束情况
          setTimeout(() => $xetable.recalculate(), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const {
          inited,
          initStatus
        } = internalData;
        return loadTableData(datas).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        const {
          inited
        } = internalData;
        return tableMethods.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas);
        }).then(() => {
          handleLoadDefaults();
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 修改行数据
       */
      setRow(rows, record) {
        if (record) {
          let rest = rows;
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
            rest = [rows];
          }
          rest.forEach(item => Object.assign(item, record));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(row, record, field) {
        const {
          keepSource
        } = props;
        const {
          tableData
        } = reactData;
        const {
          tableSourceData
        } = internalData;
        if (keepSource) {
          const rowIndex = tableMethods.getRowIndex(row);
          const oRow = tableSourceData[rowIndex];
          if (oRow && row) {
            if (field) {
              const newValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record || row, field);
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, field, newValue);
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(oRow, field, newValue);
            } else {
              const newRecord = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone({
                ...record
              }, true);
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          if (true) {
            warnLog('vxe.error.reqProp', ['keep-source']);
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(row, childRecords) {
        const {
          keepSource
        } = props;
        const {
          tableSourceData,
          fullDataRowIdData,
          fullAllDataRowIdData,
          sourceDataRowIdData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const {
          transform,
          mapChildrenField
        } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xetable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then(rows => {
          if (keepSource) {
            const rowid = getRowid($xetable, row);
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableSourceData, item => rowid === getRowid($xetable, item), {
              children: childrenField
            });
            if (matchObj) {
              matchObj.item[childrenField] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(rows, true);
            }
            rows.forEach(childRow => {
              const rowid = getRowid($xetable, childRow);
              sourceDataRowIdData[rowid] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(childRow, true);
            });
          }
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(rows, (childRow, index, items, path, parent, nodes) => {
            const rowid = getRowid($xetable, childRow);
            const parentRow = parent || parentRest.row;
            const rest = {
              row: childRow,
              rowid,
              seq: -1,
              index,
              _index: -1,
              $index: -1,
              items,
              parent: parentRow,
              level: parentLevel + nodes.length
            };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, {
            children: childrenField
          });
          row[childrenField] = rows;
          if (transform) {
            row[mapChildrenField] = rows;
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(columns) {
        const collectColumn = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(columns, column => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(cell.createColumn($xetable, column)));
        return handleColumn(collectColumn);
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(tr) {
        if (tr) {
          const {
            fullAllDataRowIdData
          } = internalData;
          const rowid = tr.getAttribute('rowid');
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            if (rest) {
              return {
                rowid: rest.rowid,
                item: rest.row,
                index: rest.index,
                items: rest.items,
                parent: rest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(cell) {
        if (cell) {
          const {
            fullColumnIdData
          } = internalData;
          const colid = cell.getAttribute('colid');
          if (colid) {
            const rest = fullColumnIdData[colid];
            if (rest) {
              return {
                colid: rest.colid,
                item: rest.column,
                index: rest.index,
                items: rest.items,
                parent: rest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: createGetRowCacheProp('seq'),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: createGetRowCacheProp('index'),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: createGetRowCacheProp('_index'),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: createGetRowCacheProp('$index'),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: createGetColumnCacheProp('index'),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: createGetColumnCacheProp('_index'),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: createGetColumnCacheProp('$index'),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(records) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(tablePrivateMethods.defineField(records));
        });
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(records) {
        const isArr = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then(rows => isArr ? rows : rows[0]);
      },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(rows, field) {
        const {
          keepSource
        } = props;
        const {
          tableSourceData,
          sourceDataRowIdData
        } = internalData;
        if (!keepSource) {
          if (true) {
            warnLog('vxe.error.reqProp', ['keep-source']);
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        let targetRows = rows;
        if (rows) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArray($xetable.getUpdateRecords());
        }
        if (targetRows.length) {
          targetRows.forEach(row => {
            if (!tableMethods.isInsertByRow(row)) {
              const rowid = getRowid($xetable, row);
              const oRow = sourceDataRowIdData[rowid];
              if (oRow && row) {
                if (field) {
                  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, field, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(oRow, field), true));
                } else {
                  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().destructuring(row, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(oRow, true));
                }
              }
            }
          });
        }
        if (rows) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
        return tableMethods.reloadData(tableSourceData);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(rows, field) {
        const {
          tableFullData,
          visibleColumn
        } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, field, null));
        } else {
          rows.forEach(row => {
            visibleColumn.forEach(column => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow(row) {
        const {
          editStore
        } = reactData;
        const rowid = getRowid($xetable, row);
        return editStore.insertMaps[rowid];
      },
      /**
       * 删除所有新增的临时数据
       * @returns
       */
      removeInsertRow() {
        const {
          editStore
        } = reactData;
        editStore.insertMaps = {};
        return $xetable.remove($xetable.getInsertRecords());
      },
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} row 行对象
       * @param {String} field 字段名
       */
      isUpdateByRow(row, field) {
        const {
          keepSource
        } = props;
        const {
          tableFullColumn,
          fullDataRowIdData,
          sourceDataRowIdData
        } = internalData;
        if (keepSource) {
          const rowid = getRowid($xetable, row);
          // 新增的数据不需要检测
          if (!fullDataRowIdData[rowid]) {
            return false;
          }
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index = 0, len = tableFullColumn.length; index < len; index++) {
              const property = tableFullColumn[index].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(columnIndex) {
        const columns = internalData.visibleColumn;
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(colid) {
        const fullColumnIdData = internalData.fullColumnIdData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(isFull) {
        const {
          treeConfig
        } = props;
        const {
          tableFullData,
          afterFullData,
          afterTreeFullData,
          tableFullTreeData,
          fullDataRowIdData,
          afterFullRowMaps
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          transform,
          mapChildrenField
        } = treeOpts;
        const {
          checkField
        } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        const currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? afterTreeFullData : afterFullData;
        if (checkField) {
          if (treeConfig) {
            rowList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().filterTree(currTableData, row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField), {
              children: transform ? mapChildrenField : childrenField
            });
          } else {
            rowList = currTableData.filter(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField));
          }
        } else {
          const {
            selectCheckboxMaps
          } = reactData;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps, (row, rowid) => {
            if (isFull) {
              if (fullDataRowIdData[rowid]) {
                rowList.push(fullDataRowIdData[rowid].row);
              }
            } else {
              if (afterFullRowMaps[rowid]) {
                rowList.push(afterFullRowMaps[rowid]);
              }
            }
          });
        }
        return rowList;
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getParentRow(rowOrRowid) {
        const {
          treeConfig
        } = props;
        const {
          fullDataRowIdData
        } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xetable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullDataRowIdData[rowid];
            return rest ? rest.parent : null;
          }
        }
        return null;
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(cellValue) {
        const {
          fullDataRowIdData
        } = internalData;
        const rowid = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cellValue) ? '' : encodeURIComponent(cellValue || '');
        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(row) {
        return getRowid($xetable, row);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const {
          tableData,
          footerTableData
        } = reactData;
        const {
          tableFullData,
          afterFullData,
          tableFullTreeData
        } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(fieldOrColumn, fixed) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        const targetColumn = getRootColumn($xetable, column);
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        const columnOpts = computeColumnOpts.value;
        const {
          maxFixedSize
        } = columnOpts;
        if (targetColumn && targetColumn.fixed !== fixed) {
          // 是否超过最大固定列数量
          if (!targetColumn.fixed && isMaxFixedColumn) {
            if (VXETable.modal) {
              VXETable.modal.message({
                status: 'error',
                content: conf.i18n('vxe.table.maxFixedCol', [maxFixedSize])
              });
            }
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
          }
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn], column => {
            column.fixed = fixed;
          });
          tablePrivateMethods.saveCustomFixed();
          return tableMethods.refreshColumn();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        const targetColumn = getRootColumn($xetable, column);
        if (targetColumn && targetColumn.fixed) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([targetColumn], column => {
            column.fixed = null;
          });
          tablePrivateMethods.saveCustomFixed();
          return tableMethods.refreshColumn();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.visible) {
          column.visible = false;
          return tablePrivateMethods.handleCustom();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 显示指定列
       */
      showColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && !column.visible) {
          column.visible = true;
          return tablePrivateMethods.handleCustom();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setColumnWidth(fieldOrColumn, width) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          const colWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(width);
          let rdWidth = colWidth;
          if (isScale(width)) {
            const tableBody = refTableBody.value;
            const bodyElem = tableBody ? tableBody.$el : null;
            const bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;
            rdWidth = Math.floor(colWidth * bodyWidth);
          }
          column.renderWidth = rdWidth;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetColumn(options) {
        const {
          collectColumn
        } = internalData;
        const customOpts = computeCustomOpts.value;
        const {
          checkMethod
        } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true
        }, options);
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
          }
          if (!checkMethod || checkMethod({
            column
          })) {
            column.visible = column.defaultVisible;
          }
        });
        if (opts.resizable) {
          tablePrivateMethods.saveCustomResizable(true);
        }
        if (opts.sort) {
          tablePrivateMethods.saveCustomSort(true);
        }
        if (opts.fixed) {
          tablePrivateMethods.saveCustomFixed();
        }
        return tablePrivateMethods.handleCustom();
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(resiveOrder) {
        if (resiveOrder) {
          const columnList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(internalData.collectColumn, 'renderSortNumber');
          internalData.collectColumn = columnList;
          const tableFullColumn = getColumnList(columnList);
          internalData.tableFullColumn = tableFullColumn;
          cacheColumnMap();
        }
        return parseColumns().then(() => {
          return tableMethods.refreshScroll();
        }).then(() => {
          return tableMethods.recalculate();
        });
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const {
          lastScrollLeft,
          lastScrollTop
        } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        return new Promise(resolve => {
          // 还原滚动条位置
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xetable, lastScrollLeft, lastScrollTop).then().then(() => {
              // 存在滚动行为未结束情况
              setTimeout(resolve, 30);
            });
          }
          // 重置
          setScrollTop(tableBodyElem, lastScrollTop);
          setScrollTop(leftBodyElem, lastScrollTop);
          setScrollTop(rightBodyElem, lastScrollTop);
          setScrollLeft(tableFooterElem, lastScrollLeft);
          // 存在滚动行为未结束情况
          setTimeout(resolve, 30);
        });
      },
      /**
       * 计算单元格列宽，动态分配可用剩余空间
       * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%
       */
      recalculate(refull) {
        autoCellWidth();
        if (refull === true) {
          // 初始化时需要在列计算之后再执行优化运算，达到最优显示效果
          return computeScrollLoad().then(() => {
            autoCellWidth();
            return computeScrollLoad();
          });
        }
        return computeScrollLoad();
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip) {
          return $commTip.open(target, content);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const {
          tooltipStore
        } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false
          });
          if ($tooltip) {
            $tooltip.close();
          }
        }
        if ($commTip) {
          $commTip.close();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(isFull) {
        const {
          treeConfig
        } = props;
        const {
          fullDataRowIdData
        } = internalData;
        const {
          treeIndeterminateMaps
        } = reactData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeIndeterminateMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(rows, value) {
        return handleCheckedCheckboxRow(rows, value, true);
      },
      isCheckedByCheckboxRow(row) {
        const {
          selectCheckboxMaps
        } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          checkField
        } = checkboxOpts;
        if (checkField) {
          return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
        }
        return !!selectCheckboxMaps[getRowid($xetable, row)];
      },
      isIndeterminateByCheckboxRow(row) {
        const {
          treeIndeterminateMaps
        } = reactData;
        return !!treeIndeterminateMaps[getRowid($xetable, row)] && !tableMethods.isCheckedByCheckboxRow(row);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(row) {
        const {
          selectCheckboxMaps
        } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          checkField
        } = checkboxOpts;
        const value = checkField ? !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField) : !selectCheckboxMaps[getRowid($xetable, row)];
        tablePrivateMethods.handleSelectRow({
          row
        }, value, true);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(isFull) {
        const {
          treeConfig
        } = props;
        const {
          fullDataRowIdData,
          radioReserveRow,
          afterFullData
        } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xetable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xetable);
            if (treeConfig) {
              const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, row => rowid === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, rowkey), {
                children: childrenField
              });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some(row => rowid === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(isFull) {
        const {
          treeConfig
        } = props;
        const {
          afterFullData,
          fullDataRowIdData,
          checkboxReserveRowMap
        } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const afterFullIdMaps = {};
          if (treeConfig) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterFullData, row => {
              afterFullIdMaps[getRowid($xetable, row)] = 1;
            }, {
              children: childrenField
            });
          } else {
            afterFullData.forEach(row => {
              afterFullIdMaps[getRowid($xetable, row)] = 1;
            });
          }
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        tablePrivateMethods.triggerCheckAllEvent(null, !reactData.isAllSelected);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const {
          treeConfig
        } = props;
        const {
          tableFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          checkField,
          reserve
        } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = item => {
            if (treeConfig && indeterminateField) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, indeterminateField, false);
            }
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, checkField, false);
          };
          if (treeConfig) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData, handleClearChecked, {
              children: childrenField
            });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach(row => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        reactData.selectCheckboxMaps = {};
        reactData.treeIndeterminateMaps = {};
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(row) {
        const rowOpts = computeRowOpts.value;
        const el = refElem.value;
        tableMethods.clearCurrentRow();
        // tableMethods.clearCurrentColumn()
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`[rowid="${getRowid($xetable, row)}"]`), elem => addClass(elem, 'row--current'));
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      isCheckedByRadioRow(row) {
        return $xetable.eqRow(reactData.selectRadioRow, row);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const el = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll('.row--current'), elem => removeClass(elem, 'row--current'));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord() {
        const rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(isFull) {
        const {
          fullDataRowIdData,
          afterFullRowMaps
        } = internalData;
        const {
          selectRadioRow
        } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xetable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          // tableMethods.clearCurrentRow()
          tableMethods.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setPendingRow(rows, status) {
        const pendingMaps = {
          ...reactData.pendingRowMaps
        };
        const pendingList = [...reactData.pendingRowList];
        if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach(row => {
            const rowid = getRowid($xetable, row);
            if (rowid && !pendingMaps[rowid]) {
              pendingList.push(row);
              pendingMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach(row => {
            const rowid = getRowid($xetable, row);
            if (rowid && pendingMaps[rowid]) {
              const pendingIndex = $xetable.findRowIndexOf(pendingList, row);
              if (pendingIndex > -1) {
                pendingList.splice(pendingIndex, 1);
              }
              delete pendingMaps[rowid];
            }
          });
        }
        reactData.pendingRowMaps = pendingMaps;
        reactData.pendingRowList = pendingList;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      togglePendingRow(rows) {
        const pendingMaps = {
          ...reactData.pendingRowMaps
        };
        const pendingList = [...reactData.pendingRowList];
        if (rows && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
          rows = [rows];
        }
        rows.forEach(row => {
          const rowid = getRowid($xetable, row);
          if (rowid) {
            if (pendingMaps[rowid]) {
              const pendingIndex = $xetable.findRowIndexOf(pendingList, row);
              if (pendingIndex > -1) {
                pendingList.splice(pendingIndex, 1);
              }
              delete pendingMaps[rowid];
            } else {
              pendingList.push(row);
              pendingMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowMaps = pendingMaps;
        reactData.pendingRowList = pendingList;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hasPendingByRow(row) {
        const {
          pendingRowMaps
        } = reactData;
        const rowid = getRowid($xetable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const {
          pendingRowList
        } = reactData;
        return pendingRowList.slice(0);
      },
      clearPendingRow() {
        reactData.pendingRowMaps = {};
        reactData.pendingRowList = [];
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const {
          multiple,
          remote,
          orders
        } = sortOpts;
        if (sortConfs) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(sortConfs)) {
            sortConfs = [{
              field: sortConfs,
              order: sortOrder
            }];
          }
        }
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index) => {
            let {
              field,
              order
            } = confs;
            let column = field;
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          // 如果是服务端排序，则跳过本地排序处理
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xetable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          tablePrivateMethods.handleTableData(true);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(updateStyle);
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xetable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const {
          multiple,
          chronological
        } = sortOpts;
        const sortList = [];
        const {
          tableFullColumn
        } = internalData;
        tableFullColumn.forEach(column => {
          const {
            field,
            order
          } = column;
          if (column.sortable && order) {
            sortList.push({
              column,
              field,
              property: field,
              order: order,
              sortTime: column.sortTime
            });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().orderBy(sortList, 'sortTime');
        }
        return sortList;
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const {
          filterStore
        } = reactData;
        const {
          column,
          visible
        } = filterStore;
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        if (visible) {
          $xetable.dispatchEvent('filter-visible', {
            column,
            property: column.field,
            field: column.field,
            filterList: $xetable.getCheckedFilters(),
            visible: false
          }, null);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some(option => option.checked);
        }
        return $xetable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(row) {
        const {
          fullAllDataRowIdData
        } = internalData;
        const rest = fullAllDataRowIdData[getRowid($xetable, row)];
        return rest && !!rest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const {
          rowExpandLazyLoadedMaps
        } = reactData;
        const {
          fullAllDataRowIdData
        } = internalData;
        const expandOpts = computeExpandOpts.value;
        const {
          lazy
        } = expandOpts;
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        if (lazy && rest) {
          rest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(row) {
        const {
          rowExpandLazyLoadedMaps
        } = reactData;
        const expandOpts = computeExpandOpts.value;
        const {
          lazy
        } = expandOpts;
        const rowid = getRowid($xetable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      reloadExpandContent(row) {
        if (true) {
          warnLog('vxe.error.delFunc', ['reloadExpandContent', 'reloadRowExpand']);
        }
        // 即将废弃
        return tableMethods.reloadRowExpand(row);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(row) {
        return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const {
          tableFullData,
          tableFullTreeData
        } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData, row => {
            expandedRows.push(row);
          }, {
            children: childrenField
          });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(rows, expanded) {
        const {
          rowExpandedMaps,
          rowExpandLazyLoadedMaps,
          expandColumn: column
        } = reactData;
        const {
          fullAllDataRowIdData
        } = internalData;
        let rExpandedMaps = {
          ...rowExpandedMaps
        };
        const expandOpts = computeExpandOpts.value;
        const {
          reserve,
          lazy,
          accordion,
          toggleMethod
        } = expandOpts;
        const lazyRests = [];
        const columnIndex = tableMethods.getColumnIndex(column);
        const $columnIndex = tableMethods.getVMColumnIndex(column);
        if (rows) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            // 只能同时展开一个
            rExpandedMaps = {};
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter(row => toggleMethod({
            $table: $xetable,
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            $rowIndex: tableMethods.getVMRowIndex(row)
          })) : rows;
          if (expanded) {
            validRows.forEach(row => {
              const rowid = getRowid($xetable, row);
              if (!rExpandedMaps[rowid]) {
                const rest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach(item => {
              const rowid = getRowid($xetable, item);
              if (rExpandedMaps[rowid]) {
                delete rExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach(row => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedMaps = rExpandedMaps;
        return Promise.all(lazyRests).then(() => tableMethods.recalculate());
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(row) {
        const {
          rowExpandedMaps
        } = reactData;
        const rowid = getRowid($xetable, row);
        return !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        // 已废弃
        if (true) {
          warnLog('vxe.error.delFunc', ['isExpandByRow', 'isRowExpandByRow']);
        }
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const {
          tableFullData
        } = internalData;
        const expandOpts = computeExpandOpts.value;
        const {
          reserve
        } = expandOpts;
        const expList = tableMethods.getRowExpandRecords();
        reactData.rowExpandedMaps = {};
        if (reserve) {
          tableFullData.forEach(row => handleRowExpandReserve(row, false));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          if (expList.length) {
            tableMethods.recalculate();
          }
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getRowExpandRecords() {
        const rest = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(reactData.rowExpandedMaps, item => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      getTreeExpandRecords() {
        const rest = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(reactData.treeExpandedMaps, item => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(row) {
        const {
          fullAllDataRowIdData
        } = internalData;
        const rest = fullAllDataRowIdData[getRowid($xetable, row)];
        return rest && !!rest.treeLoaded;
      },
      clearTreeExpandLoaded(row) {
        const {
          treeExpandedMaps
        } = reactData;
        const {
          fullAllDataRowIdData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const {
          transform,
          lazy
        } = treeOpts;
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        if (lazy && rest) {
          rest.treeLoaded = false;
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        }
        if (transform) {
          handleVirtualTreeToList();
          return tablePrivateMethods.handleTableData();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(row) {
        const {
          treeExpandLazyLoadedMaps
        } = reactData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const {
          transform,
          lazy
        } = treeOpts;
        const rowid = getRowid($xetable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform) {
              handleVirtualTreeToList();
              return tablePrivateMethods.handleTableData();
            }
          }).then(() => {
            return tableMethods.recalculate();
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      reloadTreeChilds(row) {
        if (true) {
          warnLog('vxe.error.delFunc', ['reloadTreeChilds', 'reloadTreeExpand']);
        }
        // 即将废弃
        return tableMethods.reloadTreeExpand(row);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(row) {
        return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(expanded) {
        const {
          tableFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const {
          transform,
          lazy
        } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullData, row => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, {
          children: childrenField
        });
        return tableMethods.setTreeExpand(expandeds, expanded).then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return tableMethods.recalculate();
          }
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const {
          transform
        } = treeOpts;
        if (rows) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            // 如果为虚拟树
            if (transform) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(row) {
        const {
          treeExpandedMaps
        } = reactData;
        return !!treeExpandedMaps[getRowid($xetable, row)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const {
          tableFullTreeData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const {
          transform,
          reserve
        } = treeOpts;
        const expList = tableMethods.getTreeExpandRecords();
        reactData.treeExpandedMaps = {};
        if (reserve) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData, row => handleTreeExpandReserve(row, false), {
            children: childrenField
          });
        }
        return tablePrivateMethods.handleTableData().then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return tablePrivateMethods.handleTableData();
          }
        }).then(() => {
          if (expList.length) {
            return tableMethods.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        const {
          scrollXLoad,
          scrollYLoad
        } = reactData;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody.$el;
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: bodyElem.scrollLeft
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo(scrollLeft, scrollTop) {
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
          setScrollTop(rightBodyElem || tableBodyElem, scrollTop);
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise(resolve => {
            setTimeout(() => {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                resolve();
              });
            }, 50);
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(row, fieldOrColumn) {
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push(tablePrivateMethods.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xetable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(tableMethods.scrollToColumn(fieldOrColumn));
        }
        return Promise.all(rest);
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(fieldOrColumn) {
        const {
          fullColumnIdData
        } = internalData;
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xetable, column);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const {
          scrollXStore,
          scrollYStore
        } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (rightBodyElem) {
          restoreScrollListener(rightBodyElem);
          rightBodyElem.scrollTop = 0;
        }
        if (tableFooterElem) {
          tableFooterElem.scrollLeft = 0;
        }
        if (tableBodyElem) {
          restoreScrollListener(tableBodyElem);
          tableBodyElem.scrollTop = 0;
          tableBodyElem.scrollLeft = 0;
        }
        scrollXStore.startIndex = 0;
        scrollYStore.startIndex = 0;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const {
          showFooter,
          footerData,
          footerMethod
        } = props;
        const {
          visibleColumn,
          afterFullData
        } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({
            columns: visibleColumn,
            data: afterFullData,
            $table: $xetable,
            $grid: $xegrid
          }) : [];
        }
        reactData.footerTableData = footData;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(slotParams, cellValue) {
        const customVal = !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(cellValue);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          const {
            editRules
          } = props;
          const {
            validStore
          } = reactData;
          const tableBody = refTableBody.value;
          if (slotParams && tableBody && editRules) {
            const {
              row,
              column
            } = slotParams;
            const type = 'change';
            if ($xetable.hasCellRules) {
              if ($xetable.hasCellRules(type, row, column)) {
                const cell = tablePrivateMethods.getCell(row, column);
                if (cell) {
                  return $xetable.validCellRules(type, row, column, cellValue).then(() => {
                    if (customVal && validStore.visible) {
                      setCellValue(row, column, cellValue);
                    }
                    $xetable.clearValidate(row, column);
                  }).catch(({
                    rule
                  }) => {
                    if (customVal) {
                      setCellValue(row, column, cellValue);
                    }
                    $xetable.showValidTooltip({
                      rule,
                      row,
                      column,
                      cell
                    });
                  });
                }
              }
            }
          }
        });
      },
      /**
       * 设置合并单元格
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);
        }
        setMerges(merges, reactData.mergeList, internalData.afterFullData);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 移除单元格合并
       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);
        }
        const rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return reactData.mergeList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        reactData.mergeList = [];
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);
        }
        setMerges(merges, reactData.mergeFooterList);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      removeMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);
        }
        const rest = removeMerges(merges, reactData.mergeFooterList);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterItems() {
        return reactData.mergeFooterList.slice(0);
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterItems() {
        reactData.mergeFooterList = [];
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          return updateStyle();
        });
      },
      updateCellAreas() {
        const {
          mouseConfig
        } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xetable.handleUpdateCellAreas) {
          return $xetable.handleUpdateCellAreas();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      focus() {
        internalData.isActivated = true;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        internalData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connect($toolbar) {
        if ($toolbar) {
          $xetoolbar = $toolbar;
          $xetoolbar.syncUpdate({
            collectColumn: internalData.collectColumn,
            $table: $xetable
          });
        } else {
          errLog('vxe.error.barUnableLink');
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    /**
     * 全局按下事件处理
     */
    const handleGlobalMousedownEvent = evnt => {
      const {
        editStore,
        ctxMenuStore,
        filterStore,
        customStore
      } = reactData;
      const {
        mouseConfig,
        editRules
      } = props;
      const el = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const {
        actived
      } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      // 筛选
      if (tableFilter) {
        if (getEventTargetNode(evnt, el, 'vxe-cell--filter').flag) {
          // 如果点击了筛选按钮
        } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {
          // 如果点击筛选容器
        } else {
          if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {
            tablePrivateMethods.preventEvent(evnt, 'event.clearFilter', filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      // 自定义列
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, 'vxe-toolbar-custom-target').flag) {
          // 如果点击了自定义列按钮
        } else if (getEventTargetNode(evnt, tableCustom.$el).flag) {
          // 如果点击自定义列容器
        } else {
          if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {
            tablePrivateMethods.preventEvent(evnt, 'event.clearCustom', {}, () => {
              if ($xetable.closeCustom) {
                $xetable.closeCustom();
              }
            });
          }
        }
      }
      // 如果已激活了编辑状态
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          // 如果是激活状态，点击了单元格之外
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
              // 如果是激活状态，且点击了校验提示框
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              // 如果是激活状态，点击了单元格之外
              if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {
                // 如果手动调用了激活单元格，避免触发源被移除后导致重复关闭
                tablePrivateMethods.preventEvent(evnt, 'event.clearEdit', actived.args, () => {
                  let isClear;
                  if (editOpts.mode === 'row') {
                    const rowTargetNode = getEventTargetNode(evnt, el, 'vxe-body--row');
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    // row 方式，如果点击了不同行
                    isClear = rowNodeRest ? !$xetable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    // cell 方式，如果是非编辑列
                    isClear = !getEventTargetNode(evnt, el, 'col--edit').flag;
                  }
                  // 如果点击表头行，则清除激活状态
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, 'vxe-header--row').flag;
                  }
                  // 如果点击表尾行，则清除激活状态
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, 'vxe-footer--row').flag;
                  }
                  // 如果固定了高度且点击了行之外的空白处，则清除激活状态
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, 'vxe-table--body-wrapper')) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear ||
                  // 如果点击了当前表格之外
                  !getEventTargetNode(evnt, el).flag) {
                    setTimeout(() => $xetable.clearEdit(evnt));
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xetoolbar && getEventTargetNode(evnt, $xetoolbar.getRefMaps().refElem.value).flag)) {
          if ($xetable.clearSelected) {
            $xetable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xetable.clearCellAreas) {
              if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-areas-clear').flag) {
                tablePrivateMethods.preventEvent(evnt, 'event.clearAreas', {}, () => {
                  $xetable.clearCellAreas();
                  $xetable.clearCopyCellArea();
                });
              }
            }
          }
        }
      }
      // 如果配置了快捷菜单且，点击了其他地方则关闭
      if ($xetable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xetable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xegrid ? $xegrid.getRefMaps().refElem.value : el).flag;
      // 如果存在校验，点击了表格之外则清除
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      // 最后激活的表格
      internalData.isActivated = isActivated;
    };
    /**
     * 窗口失焦事件处理
     */
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    /**
     * 全局滚动事件
     */
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    /**
     * 表格键盘事件
     */
    const keydownEvent = evnt => {
      const {
        mouseConfig,
        keyboardConfig
      } = props;
      const {
        filterStore,
        ctxMenuStore,
        editStore
      } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const {
        actived
      } = editStore;
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, 'event.keydown', null, () => {
          tableMethods.dispatchEvent('keydown-start', {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            // 如果按下了 Esc 键，关闭快捷菜单、筛选
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              // 如果是激活编辑状态，则取消编辑
              if (actived.row) {
                const params = actived.args;
                $xetable.clearEdit(evnt);
                // 如果配置了选中功能，则为选中状态
                if (mouseOpts.selected) {
                  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => $xetable.handleSelected(params, evnt));
                }
              }
            }
          }
          tableMethods.dispatchEvent('keydown', {}, evnt);
          tableMethods.dispatchEvent('keydown-end', {}, evnt);
        });
      }
    };
    /**
     * 全局键盘事件
     */
    const handleGlobalKeydownEvent = evnt => {
      // 该行为只对当前激活的表格有效
      if (internalData.isActivated) {
        tablePrivateMethods.preventEvent(evnt, 'event.keydown', null, () => {
          const {
            mouseConfig,
            keyboardConfig,
            treeConfig,
            editConfig,
            highlightCurrentRow
          } = props;
          const {
            ctxMenuStore,
            editStore,
            currentRow
          } = reactData;
          const isMenu = computeIsMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const {
            selected,
            actived
          } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
          const isBack = hasEventKey(evnt, EVENT_KEYS.BACKSPACE);
          const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
          const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
          const isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
          const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
          const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
          const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
          const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
          const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
          const isF2 = hasEventKey(evnt, EVENT_KEYS.F2);
          const isContextMenu = hasEventKey(evnt, EVENT_KEYS.CONTEXT_MENU);
          const hasMetaKey = evnt.metaKey;
          const hasCtrlKey = evnt.ctrlKey;
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          let params;
          if (operCtxMenu) {
            // 如果配置了右键菜单; 支持方向键操作、回车
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, 'selectChild', isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, 'selected', isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (isEsc) {
            // 如果按下了 Esc 键，关闭快捷菜单、筛选
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              // 如果是激活编辑状态，则取消编辑
              if (actived.row) {
                const params = actived.args;
                $xetable.clearEdit(evnt);
                // 如果配置了选中功能，则为选中状态
                if (mouseOpts.selected) {
                  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => $xetable.handleSelected(params, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === 'checkbox' || selected.column.type === 'radio')) {
            // 空格键支持选中复选框
            evnt.preventDefault();
            if (selected.column.type === 'checkbox') {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              // 如果按下了 F2 键
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xetable.handleActived(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            // 如果按下上下文键
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(keyCtxTimeout);
            keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1000);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            // 退出选中
            if (hasCtrlKey) {
              // 如果是激活编辑状态，则取消编辑
              if (actived.row) {
                params = actived.args;
                $xetable.clearEdit(evnt);
                // 如果配置了选中功能，则为选中状态
                if (mouseOpts.selected) {
                  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => $xetable.handleSelected(params, evnt));
                }
              }
            } else {
              // 如果是激活状态，退则出到上一行/下一行
              if (selected.row || actived.row) {
                const targetArgs = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                // 如果是树形表格当前行回车移动到子节点
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  params = {
                    $table: $xetable,
                    row: targetRow,
                    rowIndex: tableMethods.getRowIndex(targetRow),
                    $rowIndex: tableMethods.getVMRowIndex(targetRow)
                  };
                  tableMethods.setTreeExpand(currentRow, true).then(() => tableMethods.scrollToRow(targetRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              // 如果按下了方向键
              if (selected.row && selected.column) {
                $xetable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                // 当前行按键上下移动
                $xetable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            // 如果按下了 Tab 键切换
            if (selected.row || selected.column) {
              $xetable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xetable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && (isDel || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {
            if (!isEditStatus) {
              const {
                delMethod,
                backMethod
              } = keyboardOpts;
              // 如果是删除键
              if (keyboardOpts.isDel && (selected.row || selected.column)) {
                const delPaqrams = {
                  row: selected.row,
                  rowIndex: tableMethods.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: tableMethods.getColumnIndex(selected.column),
                  $table: $xetable
                };
                if (delMethod) {
                  delMethod(delPaqrams);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                if (isBack) {
                  if (backMethod) {
                    backMethod({
                      row: selected.row,
                      rowIndex: tableMethods.getRowIndex(selected.row),
                      column: selected.column,
                      columnIndex: tableMethods.getColumnIndex(selected.column),
                      $table: $xetable
                    });
                  } else {
                    $xetable.handleActived(selected.args, evnt);
                  }
                } else if (isDel) {
                  // 如果按下 del 键，更新表尾数据
                  tableMethods.updateFooter();
                }
                $xetable.dispatchEvent('cell-delete-value', delPaqrams, evnt);
              } else if (isBack && keyboardOpts.isArrow && treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                // 如果树形表格回退键关闭当前行返回父节点
                const {
                  parent: parentRow
                } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(internalData.afterFullData, item => item === currentRow, {
                  children: childrenField
                });
                if (parentRow) {
                  evnt.preventDefault();
                  params = {
                    $table: $xetable,
                    row: parentRow,
                    rowIndex: tableMethods.getRowIndex(parentRow),
                    $rowIndex: tableMethods.getVMRowIndex(parentRow)
                  };
                  tableMethods.setTreeExpand(parentRow, false).then(() => tableMethods.scrollToRow(parentRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const {
              editMethod
            } = keyboardOpts;
            // 启用编辑后，空格键功能将失效
            // if (isSpacebar) {
            //   evnt.preventDefault()
            // }
            // 如果是按下非功能键之外允许直接编辑
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
              if (!beforeEditMethod || beforeEditMethod({
                ...selected.args,
                $table: $xetable,
                $grid: $xegrid
              })) {
                if (editMethod) {
                  editMethod({
                    row: selected.row,
                    rowIndex: tableMethods.getRowIndex(selected.row),
                    column: selected.column,
                    columnIndex: tableMethods.getColumnIndex(selected.column),
                    $table: $xetable,
                    $grid: $xegrid
                  });
                } else {
                  setCellValue(selected.row, selected.column, null);
                  $xetable.handleActived(selected.args, evnt);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                if (afterEditMethod) {
                  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                    afterEditMethod({
                      row: selected.row,
                      rowIndex: tableMethods.getRowIndex(selected.row),
                      column: selected.column,
                      columnIndex: tableMethods.getColumnIndex(selected.column),
                      $table: $xetable,
                      $grid: $xegrid
                    });
                  });
                }
              }
            }
          }
          tableMethods.dispatchEvent('keydown', {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = evnt => {
      const {
        keyboardConfig,
        mouseConfig
      } = props;
      const {
        editStore,
        filterStore
      } = reactData;
      const {
        isActivated
      } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const {
        actived
      } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handlePasteCellAreaEvent) {
            $xetable.handlePasteCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent('paste', {}, evnt);
      }
    };
    const handleGlobalCopyEvent = evnt => {
      const {
        keyboardConfig,
        mouseConfig
      } = props;
      const {
        editStore,
        filterStore
      } = reactData;
      const {
        isActivated
      } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const {
        actived
      } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCopyCellAreaEvent) {
            $xetable.handleCopyCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent('copy', {}, evnt);
      }
    };
    const handleGlobalCutEvent = evnt => {
      const {
        keyboardConfig,
        mouseConfig
      } = props;
      const {
        editStore,
        filterStore
      } = reactData;
      const {
        isActivated
      } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const {
        actived
      } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCutCellAreaEvent) {
            $xetable.handleCutCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent('cut', {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tableMethods.updateCellAreas();
      tableMethods.recalculate(true);
    };
    const handleTargetEnterEvent = isClear => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip) {
          $tooltip.setActived(true);
        }
      }
    };
    /**
     * 处理显示 tooltip
     * @param {Event} evnt 事件
     * @param {ColumnInfo} column 列配置
     * @param {Row} row 行对象
     */
    const handleTooltip = (evnt, cell, overflowElem, tipElem, params) => {
      params.cell = cell;
      const {
        tooltipStore
      } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      const {
        column,
        row
      } = params;
      const {
        showAll,
        contentMethod
      } = tooltipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(customContent);
      const content = useCustom ? customContent : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toString(column.type === 'html' ? overflowElem.innerText : overflowElem.textContent).trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      if (content && (showAll || useCustom || isCellOverflow)) {
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true
        });
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip) {
            $tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, formatText(content));
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 内部方法
     */
    tablePrivateMethods = {
      getSetupOptions() {
        return conf;
      },
      updateAfterDataIndex,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if ($xegrid) {
            return $xegrid.callSlot(slotFunc, params);
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const el = refElem.value;
        if ($xegrid) {
          const gridEl = $xegrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el ? el.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const {
          height
        } = props;
        const el = refElem.value;
        if (el) {
          const parentElem = el.parentNode;
          const parentPaddingSize = height === 'auto' ? getPaddingTopBottomSize(parentElem) : 0;
          return Math.floor($xegrid ? $xegrid.getParentHeight() : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return $xegrid ? $xegrid.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(records) {
        const {
          treeConfig
        } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xetable);
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(records)) {
          records = [records];
        }
        return records.map(record => {
          internalData.tableFullColumn.forEach(column => {
            const {
              field,
              editRender
            } = column;
            if (field && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const {
                  defaultValue
                } = editRender;
                if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)) {
                  cellValue = defaultValue({
                    column
                  });
                } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach(key => {
            if (key && eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record, key))) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          // 必须有行数据的唯一主键，可以自行设置；也可以默认生成一个随机数
          if (eqEmptyValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(record, rowkey))) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore,
          fullDataRowIdData
        } = internalData;
        let fullList = internalData.afterFullData;
        // 是否进行数据处理
        if (force) {
          // 更新数据，处理筛选和排序
          updateAfterFullData();
          // 如果为虚拟树，将树结构拍平
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xetable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
        });
        reactData.tableData = tableData;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      /**
       * 更新数据行的 Map
       * 牺牲数据组装的耗时，用来换取使用过程中的流畅
       */
      cacheRowMap(isSource) {
        const {
          treeConfig
        } = props;
        const treeOpts = computeTreeOpts.value;
        let {
          fullDataRowIdData,
          fullAllDataRowIdData,
          tableFullData,
          tableFullTreeData
        } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowkey = getRowkey($xetable);
        const isLazy = treeConfig && treeOpts.lazy;
        const handleRow = (row, index, items, path, parent, nodes) => {
          let rowid = getRowid($xetable, row);
          const seq = treeConfig && path ? toTreePathSeq(path) : index + 1;
          const level = nodes ? nodes.length - 1 : 0;
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, rowkey, rowid);
          }
          if (isLazy && row[hasChildField] && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(row[childrenField])) {
            row[childrenField] = null;
          }
          const rest = {
            row,
            rowid,
            seq,
            index: treeConfig && parent ? -1 : index,
            _index: -1,
            $index: -1,
            items,
            parent,
            level
          };
          if (isSource) {
            fullDataRowIdData[rowid] = rest;
          }
          fullAllDataRowIdData[rowid] = rest;
        };
        if (isSource) {
          fullDataRowIdData = internalData.fullDataRowIdData = {};
        }
        fullAllDataRowIdData = internalData.fullAllDataRowIdData = {};
        if (treeConfig) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(tableFullTreeData, handleRow, {
            children: childrenField
          });
        } else {
          tableFullData.forEach(handleRow);
        }
      },
      cacheSourceMap(fullData) {
        const {
          treeConfig
        } = props;
        const treeOpts = computeTreeOpts.value;
        let {
          sourceDataRowIdData
        } = internalData;
        const sourceData = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(fullData, true);
        const rowkey = getRowkey($xetable);
        sourceDataRowIdData = internalData.sourceDataRowIdData = {};
        const handleSourceRow = row => {
          let rowid = getRowid($xetable, row);
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, rowkey, rowid);
          }
          sourceDataRowIdData[rowid] = row;
        };
        // 源数据缓存
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(sourceData, handleSourceRow, {
            children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField
          });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.tableSourceData = sourceData;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const {
          tableFullColumn
        } = internalData;
        const columnOpts = computeColumnOpts.value;
        const {
          width: defaultWidth,
          minWidth: defaultMinWidth
        } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        tableFullColumn.forEach(column => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              autoList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, {
          resizeList,
          pxList,
          pxMinList,
          scaleList,
          scaleMinList,
          autoList
        });
      },
      saveCustomResizable(isReset) {
        const {
          id,
          customConfig
        } = props;
        const customOpts = computeCustomOpts.value;
        const {
          collectColumn
        } = internalData;
        const {
          storage
        } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isResizable = isAllStorage || storageOpts.resizable;
        if (customConfig && isResizable) {
          const columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);
          let columnWidthStorage;
          if (!id) {
            errLog('vxe.error.reqProp', ['id']);
            return;
          }
          if (!isReset) {
            columnWidthStorage = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
              if (column.resizeWidth) {
                const colKey = column.getKey();
                if (colKey) {
                  columnWidthStorage[colKey] = column.renderWidth;
                }
              }
            });
          }
          columnWidthStorageMap[id] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(columnWidthStorage) ? undefined : columnWidthStorage;
          localStorage.setItem(resizableStorageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(columnWidthStorageMap));
        }
      },
      saveCustomSort(isReset) {
        const {
          id,
          customConfig
        } = props;
        const customOpts = computeCustomOpts.value;
        const {
          collectColumn
        } = internalData;
        const {
          storage
        } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isSort = isAllStorage || storageOpts.sort;
        if (customConfig && isSort) {
          const columnSortStorageMap = getCustomStorageMap(sortStorageKey);
          let columnWidthStorage;
          if (!id) {
            errLog('vxe.error.reqProp', ['id']);
            return;
          }
          if (!isReset) {
            columnWidthStorage = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(columnSortStorageMap[id]) ? columnSortStorageMap[id] : {};
            // 排序只支持一级
            collectColumn.forEach(column => {
              if (column.sortNumber !== column.renderSortNumber) {
                const colKey = column.getKey();
                if (colKey) {
                  columnWidthStorage[colKey] = column.renderSortNumber;
                }
              }
            });
          }
          columnSortStorageMap[id] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(columnWidthStorage) ? undefined : columnWidthStorage;
          localStorage.setItem(sortStorageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(columnSortStorageMap));
        }
      },
      saveCustomFixed() {
        const {
          id,
          customConfig
        } = props;
        const {
          collectColumn
        } = internalData;
        const customOpts = computeCustomOpts.value;
        const {
          storage
        } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isCustomFixed = isAllStorage || storageOpts.fixed;
        if (customConfig && isCustomFixed) {
          const columnFixedStorageMap = getCustomStorageMap(fixedStorageKey);
          const colFixeds = [];
          if (!id) {
            errLog('vxe.error.reqProp', ['id']);
            return;
          }
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
            if (column.fixed && column.fixed !== column.defaultFixed) {
              const colKey = column.getKey();
              if (colKey) {
                colFixeds.push(`${colKey}|${column.fixed}`);
              }
            }
          });
          columnFixedStorageMap[id] = colFixeds.join(',') || undefined;
          localStorage.setItem(fixedStorageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(columnFixedStorageMap));
        }
      },
      saveCustomVisible() {
        const {
          id,
          customConfig
        } = props;
        const {
          collectColumn
        } = internalData;
        const customOpts = computeCustomOpts.value;
        const {
          checkMethod,
          storage
        } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isCustomVisible = isAllStorage || storageOpts.visible;
        if (customConfig && isCustomVisible) {
          const columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);
          const colHides = [];
          const colShows = [];
          if (!id) {
            errLog('vxe.error.reqProp', ['id']);
            return;
          }
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(collectColumn, column => {
            if (!checkMethod || checkMethod({
              column
            })) {
              if (!column.visible && column.defaultVisible) {
                const colKey = column.getKey();
                if (colKey) {
                  colHides.push(colKey);
                }
              } else if (column.visible && !column.defaultVisible) {
                const colKey = column.getKey();
                if (colKey) {
                  colShows.push(colKey);
                }
              }
            }
          });
          columnVisibleStorageMap[id] = [colHides.join(',')].concat(colShows.length ? [colShows.join(',')] : []).join('|') || undefined;
          localStorage.setItem(visibleStorageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(columnVisibleStorageMap));
        }
      },
      handleCustom() {
        const {
          mouseConfig
        } = props;
        if (mouseConfig) {
          if ($xetable.clearSelected) {
            $xetable.clearSelected();
          }
          if ($xetable.clearCellAreas) {
            $xetable.clearCellAreas();
            $xetable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.saveCustomVisible();
        tablePrivateMethods.saveCustomSort();
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = VXETable.interceptor.get(type);
        // 兼容老版本
        if (!evntList.length && type === 'event.clearEdit') {
          evntList = VXETable.interceptor.get('event.clearActived');
          if (true) {
            if (evntList.length) {
              warnLog('vxe.error.delEvent', ['event.clearActived', 'event.clearEdit']);
            }
          }
        }
        // 兼容老版本
        let rest;
        if (!evntList.some(func => func(Object.assign({
          $grid: $xegrid,
          $table: $xetable,
          $event: evnt
        }, args)) === false)) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      checkSelectionStatus() {
        const {
          treeConfig
        } = props;
        const {
          selectCheckboxMaps,
          treeIndeterminateMaps
        } = reactData;
        const {
          afterFullData
        } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          checkField,
          checkStrictly,
          checkMethod
        } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (!checkStrictly) {
          const disableRows = [];
          const checkRows = [];
          let isAllResolve = false;
          let isAllSelected = false;
          let isIndeterminate = false;
          if (checkField) {
            isAllResolve = afterFullData.every(checkMethod ? row => {
              if (!checkMethod({
                row
              })) {
                disableRows.push(row);
                return true;
              }
              if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField)) {
                checkRows.push(row);
                return true;
              }
              return false;
            } : row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField));
            isAllSelected = isAllResolve && afterFullData.length !== disableRows.length;
            if (treeConfig) {
              if (indeterminateField) {
                isIndeterminate = !isAllSelected && afterFullData.some(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, indeterminateField) || !!treeIndeterminateMaps[getRowid($xetable, row)]);
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField) || !!treeIndeterminateMaps[getRowid($xetable, row)]);
              }
            } else {
              if (indeterminateField) {
                isIndeterminate = !isAllSelected && afterFullData.some(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, indeterminateField));
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some(row => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField));
              }
            }
          } else {
            isAllResolve = afterFullData.every(checkMethod ? row => {
              if (!checkMethod({
                row
              })) {
                disableRows.push(row);
                return true;
              }
              if (selectCheckboxMaps[getRowid($xetable, row)]) {
                checkRows.push(row);
                return true;
              }
              return false;
            } : row => selectCheckboxMaps[getRowid($xetable, row)]);
            isAllSelected = isAllResolve && afterFullData.length !== disableRows.length;
            if (treeConfig) {
              isIndeterminate = !isAllSelected && afterFullData.some(row => {
                const itemRid = getRowid($xetable, row);
                return treeIndeterminateMaps[itemRid] || selectCheckboxMaps[itemRid];
              });
            } else {
              isIndeterminate = !isAllSelected && afterFullData.some(row => selectCheckboxMaps[getRowid($xetable, row)]);
            }
          }
          reactData.isAllSelected = isAllSelected;
          reactData.isIndeterminate = isIndeterminate;
        }
      },
      /**
       * 多选，行选中事件
       * value 选中true 不选false 半选-1
       */
      handleSelectRow({
        row
      }, value, isForce) {
        const {
          treeConfig
        } = props;
        const {
          selectCheckboxMaps,
          treeIndeterminateMaps
        } = reactData;
        const selectRowMaps = {
          ...selectCheckboxMaps
        };
        const {
          afterFullData
        } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          checkField,
          checkStrictly,
          checkMethod
        } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        const rowid = getRowid($xetable, row);
        if (checkField) {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if (!treeIndeterminateMaps[rowid]) {
                if (indeterminateField) {
                  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, indeterminateField, true);
                }
                treeIndeterminateMaps[rowid] = row;
              }
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, checkField, false);
            } else {
              // 更新子节点状态
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([row], item => {
                if ($xetable.eqRow(item, row) || isForce || !checkMethod || checkMethod({
                  row: item
                })) {
                  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, checkField, value);
                  if (indeterminateField) {
                    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, indeterminateField, false);
                  }
                  delete treeIndeterminateMaps[getRowid($xetable, item)];
                  handleCheckboxReserveRow(row, value);
                }
              }, {
                children: childrenField
              });
            }
            // 如果存在父节点，更新父节点状态
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, item => $xetable.eqRow(item, row), {
              children: childrenField
            });
            if (matchObj && matchObj.parent) {
              let parentStatus;
              const vItems = [];
              const vItemMaps = {};
              if (!isForce && checkMethod) {
                matchObj.items.forEach(item => {
                  if (checkMethod({
                    row: item
                  })) {
                    const itemRid = getRowid($xetable, item);
                    vItemMaps[itemRid] = item;
                    vItems.push(item);
                  }
                });
              } else {
                matchObj.items.forEach(item => {
                  const itemRid = getRowid($xetable, item);
                  vItemMaps[itemRid] = item;
                  vItems.push(item);
                });
              }
              const indeterminatesItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(matchObj.items, item => !!treeIndeterminateMaps[getRowid($xetable, item)]);
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                const selectItems = [];
                matchObj.items.forEach(item => {
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(item, checkField)) {
                    selectItems.push(item);
                  }
                });
                parentStatus = selectItems.filter(item => vItemMaps[getRowid($xetable, item)]).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              reactData.selectCheckboxMaps = selectRowMaps;
              return tablePrivateMethods.handleSelectRow({
                row: matchObj.parent
              }, parentStatus, isForce);
            }
          } else {
            if (isForce || !checkMethod || checkMethod({
              row
            })) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, checkField, value);
              handleCheckboxReserveRow(row, value);
            }
          }
        } else {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if (!treeIndeterminateMaps[rowid]) {
                if (indeterminateField) {
                  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, indeterminateField, true);
                }
                treeIndeterminateMaps[rowid] = row;
              }
              if (selectRowMaps[rowid]) {
                delete selectRowMaps[rowid];
              }
            } else {
              // 更新子节点状态
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree([row], item => {
                const itemRid = getRowid($xetable, item);
                if ($xetable.eqRow(item, row) || isForce || !checkMethod || checkMethod({
                  row: item
                })) {
                  if (value) {
                    selectRowMaps[itemRid] = item;
                  } else {
                    if (selectRowMaps[itemRid]) {
                      delete selectRowMaps[itemRid];
                    }
                  }
                  if (indeterminateField) {
                    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(row, indeterminateField, false);
                  }
                  delete treeIndeterminateMaps[getRowid($xetable, item)];
                  handleCheckboxReserveRow(row, value);
                }
              }, {
                children: childrenField
              });
            }
            // 如果存在父节点，更新父节点状态
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterFullData, item => $xetable.eqRow(item, row), {
              children: childrenField
            });
            if (matchObj && matchObj.parent) {
              let parentStatus;
              const vItems = [];
              const vItemMaps = {};
              if (!isForce && checkMethod) {
                matchObj.items.forEach(item => {
                  if (checkMethod({
                    row: item
                  })) {
                    const itemRid = getRowid($xetable, item);
                    vItemMaps[itemRid] = item;
                    vItems.push(item);
                  }
                });
              } else {
                matchObj.items.forEach(item => {
                  const itemRid = getRowid($xetable, item);
                  vItemMaps[itemRid] = item;
                  vItems.push(item);
                });
              }
              const indeterminatesItem = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(matchObj.items, item => !!treeIndeterminateMaps[getRowid($xetable, item)]);
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                const selectItems = [];
                matchObj.items.forEach(item => {
                  const itemRid = getRowid($xetable, item);
                  if (selectRowMaps[itemRid]) {
                    selectItems.push(item);
                  }
                });
                parentStatus = selectItems.filter(item => vItemMaps[getRowid($xetable, item)]).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              reactData.selectCheckboxMaps = selectRowMaps;
              return tablePrivateMethods.handleSelectRow({
                row: matchObj.parent
              }, parentStatus, isForce);
            }
          } else {
            if (isForce || !checkMethod || checkMethod({
              row
            })) {
              if (value) {
                if (!selectRowMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              } else {
                if (selectRowMaps[rowid]) {
                  delete selectRowMaps[rowid];
                }
              }
              handleCheckboxReserveRow(row, value);
            }
          }
        }
        reactData.selectCheckboxMaps = selectRowMaps;
        tablePrivateMethods.checkSelectionStatus();
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const {
            tooltipStore
          } = reactData;
          const {
            column
          } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          // tooltipStore.currOpts = { content: null }
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const {
          tooltipStore
        } = reactData;
        const {
          column
        } = params;
        const titleElem = evnt.currentTarget;
        handleTargetEnterEvent(true);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, titleElem, titleElem, null, params);
        }
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(evnt, params) {
        const {
          editConfig
        } = props;
        const {
          editStore
        } = reactData;
        const {
          tooltipStore
        } = reactData;
        const editOpts = computeEditOpts.value;
        const {
          actived
        } = editStore;
        const {
          row,
          column
        } = params;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        // 单元格处于编辑状态时不触发提示框
        if (column.editRender && isEnableConf(editConfig)) {
          // 如果是行编辑模式
          if (editOpts.mode === 'row' && actived.row === row) {
            return;
          }
          // 如果是单元格编辑模式
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          let overflowElem;
          let tipElem;
          if (column.treeNode) {
            overflowElem = cell.querySelector('.vxe-tree-cell');
            if (column.type === 'html') {
              tipElem = cell.querySelector('.vxe-cell--html');
            }
          } else {
            tipElem = cell.querySelector(column.type === 'html' ? '.vxe-cell--html' : '.vxe-cell--label');
          }
          handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(evnt, params) {
        const {
          column
        } = params;
        const {
          tooltipStore
        } = reactData;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, cell, cell.querySelector('.vxe-cell--item') || cell.children[0], null, params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && !$tooltip.isActived()) {
              tableMethods.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          tableMethods.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const {
          _lastResizeTime
        } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const {
          column
        } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, 'vxe-cell--sort').flag;
        const triggerFilter = getEventTargetNode(evnt, cell, 'vxe-cell--filter').flag;
        if (sortOpts.trigger === 'cell' && !(triggerResizable || triggerSort || triggerFilter)) {
          tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        tableMethods.dispatchEvent('header-cell-click', Object.assign({
          triggerResizable,
          triggerSort,
          triggerFilter,
          cell
        }, params), evnt);
        if (columnOpts.isCurrent || props.highlightCurrentColumn) {
          tableMethods.setCurrentColumn(column);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        tableMethods.dispatchEvent('header-cell-dblclick', Object.assign({
          cell: evnt.currentTarget
        }, params), evnt);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(evnt, params) {
        const {
          highlightCurrentRow,
          editConfig
        } = props;
        const {
          editStore
        } = reactData;
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const rowOpts = computeRowOpts.value;
        const {
          actived,
          focused
        } = editStore;
        const {
          row,
          column
        } = params;
        const {
          type,
          treeNode
        } = column;
        const isRadioType = type === 'radio';
        const isCheckboxType = type === 'checkbox';
        const isExpandType = type === 'expand';
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, 'vxe-cell--radio').flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, 'vxe-cell--checkbox').flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, 'vxe-tree--btn-wrapper').flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, 'vxe-table--expanded').flag;
        params = Object.assign({
          cell,
          triggerRadio,
          triggerCheckbox,
          triggerTreeNode,
          triggerExpandNode
        }, params);
        if (!triggerCheckbox && !triggerRadio) {
          // 如果是展开行
          if (!triggerExpandNode && (expandOpts.trigger === 'row' || isExpandType && expandOpts.trigger === 'cell')) {
            tablePrivateMethods.triggerRowExpandEvent(evnt, params);
          }
          // 如果是树形表格
          if (treeOpts.trigger === 'row' || treeNode && treeOpts.trigger === 'cell') {
            tablePrivateMethods.triggerTreeExpandEvent(evnt, params);
          }
        }
        // 如果点击了树节点
        if (!triggerTreeNode) {
          if (!triggerExpandNode) {
            // 如果是高亮行
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
              }
            }
            // 如果是单选框
            if (!triggerRadio && (radioOpts.trigger === 'row' || isRadioType && radioOpts.trigger === 'cell')) {
              tablePrivateMethods.triggerRadioRowEvent(evnt, params);
            }
            // 如果是复选框
            if (!triggerCheckbox && (checkboxOpts.trigger === 'row' || isCheckboxType && checkboxOpts.trigger === 'cell')) {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);
            }
          }
          // 如果设置了单元格选中功能，则不会使用点击事件去处理（只能支持双击模式）
          if (isEnableConf(editConfig)) {
            // 记录点击输入框聚焦状态
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === 'cell' && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === 'manual') {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === 'click') {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === 'dblclick') {
                if (editOpts.mode === 'row' && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        tableMethods.dispatchEvent('cell-click', params, evnt);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(evnt, params) {
        const {
          editConfig
        } = props;
        const {
          editStore
        } = reactData;
        const editOpts = computeEditOpts.value;
        const {
          actived
        } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({
          cell
        }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === 'dblclick') {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === 'row') {
              checkValidate('blur').catch(e => e).then(() => {
                $xetable.handleActived(params, evnt).then(() => checkValidate('change')).catch(e => e);
              });
            } else if (editOpts.mode === 'cell') {
              $xetable.handleActived(params, evnt).then(() => checkValidate('change')).catch(e => e);
            }
          }
        }
        tableMethods.dispatchEvent('cell-dblclick', params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const {
          selectCheckboxMaps
        } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          checkField
        } = checkboxOpts;
        const {
          row
        } = params;
        let value = false;
        if (checkField) {
          value = !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(row, checkField);
        } else {
          value = !selectCheckboxMaps[getRowid($xetable, row)];
        }
        if (evnt) {
          tablePrivateMethods.triggerCheckRowEvent(evnt, params, value);
        } else {
          tablePrivateMethods.handleSelectRow(params, value);
        }
      },
      triggerCheckRowEvent(evnt, params, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const {
          row
        } = params;
        const {
          afterFullData
        } = internalData;
        const {
          checkMethod
        } = checkboxOpts;
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {
          const checkboxRecords = tableMethods.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = tableMethods.getVTRowIndex(row);
            const _firstRowIndex = tableMethods.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              tableMethods.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              handleCheckedCheckboxRow(rangeRows, true, false);
              tableMethods.dispatchEvent('checkbox-range-select', Object.assign({
                rangeRecords: rangeRows
              }, params), evnt);
              return;
            }
          }
        }
        if (!checkMethod || checkMethod({
          row
        })) {
          tablePrivateMethods.handleSelectRow(params, value);
          tableMethods.dispatchEvent('checkbox-change', Object.assign({
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, params), evnt);
        }
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(evnt, value) {
        handleCheckedAllCheckboxRow(value);
        if (evnt) {
          tableMethods.dispatchEvent('checkbox-all', {
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, evnt);
        }
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(evnt, params) {
        const {
          selectRadioRow: oldValue
        } = reactData;
        const {
          row
        } = params;
        const radioOpts = computeRadioOpts.value;
        let newValue = row;
        let isChange = oldValue !== newValue;
        if (isChange) {
          handleCheckedRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            tableMethods.clearRadioRow();
          }
        }
        if (isChange) {
          tableMethods.dispatchEvent('radio-change', {
            oldValue,
            newValue,
            ...params
          }, evnt);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const {
          currentRow: oldValue
        } = reactData;
        const {
          row: newValue
        } = params;
        const isChange = oldValue !== newValue;
        tableMethods.setCurrentRow(newValue);
        if (isChange) {
          tableMethods.dispatchEvent('current-change', {
            oldValue,
            newValue,
            ...params
          }, evnt);
        }
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(evnt, params) {
        const {
          rowExpandLazyLoadedMaps,
          expandColumn: column
        } = reactData;
        const expandOpts = computeExpandOpts.value;
        const {
          row
        } = params;
        const {
          lazy
        } = expandOpts;
        const rowid = getRowid($xetable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isRowExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setRowExpand(row, expanded);
          tableMethods.dispatchEvent('toggle-row-expand', {
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            $rowIndex: tableMethods.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(evnt, params) {
        const {
          treeExpandLazyLoadedMaps
        } = reactData;
        const treeOpts = computeTreeOpts.value;
        const {
          row,
          column
        } = params;
        const {
          lazy
        } = treeOpts;
        const rowid = getRowid($xetable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isTreeExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setTreeExpand(row, expanded);
          tableMethods.dispatchEvent('toggle-tree-expand', {
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row
          }, evnt);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(evnt, column, order) {
        const {
          mouseConfig
        } = props;
        const sortOpts = computeSortOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const {
          field,
          sortable
        } = column;
        if (sortable) {
          if (!order || column.order === order) {
            tableMethods.clearSort(sortOpts.multiple ? column : null);
          } else {
            tableMethods.sort({
              field,
              order
            });
          }
          const params = {
            $table: $xetable,
            $event: evnt,
            column,
            field,
            property: field,
            order: column.order,
            sortList: tableMethods.getSortColumns(),
            sortTime: column.sortTime
          };
          if (mouseConfig && mouseOpts.area && $xetable.handleSortEvent) {
            $xetable.handleSortEvent(evnt, params);
          }
          tableMethods.dispatchEvent('sort-change', params, evnt);
        }
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        loadScrollXData();
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent(evnt) {
        const {
          scrollYStore
        } = internalData;
        const {
          adaptive,
          offsetSize,
          visibleSize
        } = scrollYStore;
        // webkit 浏览器使用最佳的渲染方式，且最高渲染量不能大于 40 条
        if (isWebkit && adaptive && offsetSize * 2 + visibleSize <= 40) {
          loadScrollYData(evnt);
        } else {
          debounceScrollY(evnt);
        }
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(row) {
        const {
          treeConfig
        } = props;
        const {
          tableFullData
        } = internalData;
        const rests = [];
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(tableFullData, item => $xetable.eqRow(item, row), {
            children: childrenField
          });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row, index) => {
              if (index < nodes.length - 1 && !tableMethods.isTreeExpandByRow(row)) {
                rests.push(tableMethods.setTreeExpand(row, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xetable, row));
      },
      updateScrollYStatus,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const {
          isGroup,
          scrollXLoad,
          scrollbarWidth
        } = reactData;
        const {
          visibleColumn,
          scrollXStore,
          elemStore,
          tableWidth
        } = internalData;
        const tableHeader = refTableHeader.value;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          const tableFooterElem = tableFooter ? tableFooter.$el : null;
          const headerElem = tableHeaderElem ? tableHeaderElem.querySelector('.vxe-table--header') : null;
          const bodyElem = tableBodyElem.querySelector('.vxe-table--body');
          const footerElem = tableFooterElem ? tableFooterElem.querySelector('.vxe-table--footer') : null;
          const leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce((previous, column) => previous + column.renderWidth, 0);
          let marginLeft = '';
          if (scrollXLoad) {
            marginLeft = `${leftSpaceWidth}px`;
          }
          if (headerElem) {
            headerElem.style.marginLeft = isGroup ? '' : marginLeft;
          }
          bodyElem.style.marginLeft = marginLeft;
          if (footerElem) {
            footerElem.style.marginLeft = marginLeft;
          }
          const containerList = ['main'];
          containerList.forEach(name => {
            const layoutList = ['header', 'body', 'footer'];
            layoutList.forEach(layout => {
              const xSpaceRef = elemStore[`${name}-${layout}-xSpace`];
              const xSpaceElem = xSpaceRef ? xSpaceRef.value : null;
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${tableWidth + (layout === 'header' ? scrollbarWidth : 0)}px` : '';
              }
            });
          });
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(updateStyle);
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore,
          elemStore,
          afterFullData
        } = internalData;
        const {
          startIndex,
          rowHeight
        } = scrollYStore;
        const bodyHeight = afterFullData.length * rowHeight;
        const topSpaceHeight = Math.max(0, startIndex * rowHeight);
        const containerList = ['main', 'left', 'right'];
        let marginTop = '';
        let ySpaceHeight = '';
        if (scrollYLoad) {
          marginTop = `${topSpaceHeight}px`;
          ySpaceHeight = `${bodyHeight}px`;
        }
        containerList.forEach(name => {
          const layoutList = ['header', 'body', 'footer'];
          const tableRef = elemStore[`${name}-body-table`];
          const tableElem = tableRef ? tableRef.value : null;
          if (tableElem) {
            tableElem.style.marginTop = marginTop;
          }
          layoutList.forEach(layout => {
            const ySpaceRef = elemStore[`${name}-${layout}-ySpace`];
            const ySpaceElem = ySpaceRef ? ySpaceRef.value : null;
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight;
            }
          });
        });
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(updateStyle);
      },
      updateScrollXData() {
        // reactData.tableColumn = []
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          handleTableColumn();
          tablePrivateMethods.updateScrollXSpace();
        });
      },
      updateScrollYData() {
        // reactData.tableData = []
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          tablePrivateMethods.handleTableData();
          tablePrivateMethods.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody ? tableBody.$el : null;
        if (bodyElem) {
          if (leftContainerElem) {
            if (bodyElem.scrollLeft > 0) {
              addClass(leftContainerElem, 'scrolling--middle');
            } else {
              removeClass(leftContainerElem, 'scrolling--middle');
            }
          }
          if (rightContainerElem) {
            if (bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft)) {
              addClass(rightContainerElem, 'scrolling--middle');
            } else {
              removeClass(rightContainerElem, 'scrolling--middle');
            }
          }
        }
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(evnt, {
        row
      }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const rowid = getRowid($xetable, row);
        const el = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`), elem => addClass(elem, 'row--hover'));
        }
        internalData.hoverRow = row;
      },
      clearHoverRow() {
        const el = refElem.value;
        if (el) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(el.querySelectorAll('.vxe-body--row.row--hover'), elem => removeClass(elem, 'row--hover'));
        }
        internalData.hoverRow = null;
      },
      getCell(row, column) {
        const rowid = getRowid($xetable, row);
        const tableBody = refTableBody.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === 'left') {
              if (leftBody) {
                bodyElem = leftBody.$el;
              }
            } else {
              if (rightBody) {
                bodyElem = rightBody.$el;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = tableBody.$el;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, column) {
        const formatter = column.formatter;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const {
            fullAllDataRowIdData
          } = internalData;
          const rowid = getRowid($xetable, row);
          const colid = column.id;
          const rest = fullAllDataRowIdData[rowid];
          if (rest) {
            formatData = rest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = {
            cellValue,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            column,
            columnIndex: tableMethods.getColumnIndex(column)
          };
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
            const gFormatOpts = VXETable.formats.get(formatter);
            cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod(formatParams) : '';
          } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
            const gFormatOpts = VXETable.formats.get(formatter[0]);
            cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod(formatParams, ...formatter.slice(1)) : '';
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = {
              value: cellValue,
              label: cellLabel
            };
          }
        }
        return cellLabel;
      },
      findRowIndexOf(list, row) {
        return row ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => $xetable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xetable, row1) === getRowid($xetable, row2);
        }
        return false;
      }
    };
    // 检测对应模块是否安装
    if (true) {
      'openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print'.split(',').forEach(name => {
        $xetable[name] = function () {
          errLog('vxe.error.reqModule', ['VxeTableExportModule']);
        };
      });
      'clearValidate,fullValidate,validate'.split(',').forEach(name => {
        $xetable[name] = function () {
          errLog('vxe.error.reqModule', ['VxeTableValidatorModule']);
        };
      });
    }
    Object.assign($xetable, tableMethods, tablePrivateMethods);
    /**
     * 渲染浮固定列
     * 分别渲染左边固定列和右边固定列
     * 如果宽度足够情况下，则不需要渲染固定列
     * @param {String} fixedType 固定列类型
     */
    const renderFixed = fixedType => {
      const {
        showHeader,
        showFooter
      } = props;
      const {
        tableData,
        tableColumn,
        tableGroupColumn,
        columnStore,
        footerTableData
      } = reactData;
      const isFixedLeft = fixedType === 'left';
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: `vxe-table--fixed-${fixedType}-wrapper`
      }, [showHeader ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(header, {
        ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
        fixedType,
        tableData,
        tableColumn,
        tableGroupColumn,
        fixedColumn
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(body, {
        ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
        fixedType,
        tableData,
        tableColumn,
        fixedColumn
      }), showFooter ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(footer, {
        ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
        footerTableData,
        tableColumn,
        fixedColumn,
        fixedType
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    const renderEmptyContenet = () => {
      const emptyOpts = computeEmptyOpts.value;
      const params = {
        $table: $xetable
      };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        const compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        const renderTableEmptyView = compConf ? compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (renderTableEmptyView) {
          return getSlotVNs(renderTableEmptyView(emptyOpts, params));
        }
      }
      return getFuncText(props.emptyText) || conf.i18n('vxe.table.emptyText');
    };
    function handleUupdateResize() {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        tableMethods.recalculate();
      }
    }
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      const {
        inited,
        initStatus
      } = internalData;
      loadTableData(props.data || []).then(() => {
        const {
          scrollXLoad,
          scrollYLoad,
          expandColumn
        } = reactData;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if (!inited) {
          handleInitDefaults();
        }
        if (true) {
          // const checkboxOpts = computeCheckboxOpts.value
          // const checkboxColumn = internalData.tableFullColumn.find(column => column.type === 'checkbox')
          // if (checkboxColumn && internalData.tableFullData.length > 300 && !checkboxOpts.checkField) {
          //   warnLog('vxe.error.checkProp', ['checkbox-config.checkField'])
          // }
          if ((scrollXLoad || scrollYLoad) && expandColumn) {
            warnLog('vxe.error.scrollErrProp', ['column.type=expand']);
          }
        }
        tableMethods.recalculate();
      });
    });
    const staticColumnFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(staticColumnFlag, () => {
      handleColumn(reactData.staticColumns);
    });
    const tableColumnFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.upDataFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        tableMethods.updateData();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.reColumnFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        tableMethods.refreshColumn();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.showHeader, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.showFooter, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    const footFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.footerData, () => {
      footFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(footFlag, () => {
      tableMethods.updateFooter();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => tableMethods.recalculate(true));
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.maxHeight, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => tableMethods.recalculate(true));
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.syncResize, value => {
      if (value) {
        handleUupdateResize();
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          handleUupdateResize();
          setTimeout(() => handleUupdateResize());
        });
      }
    });
    const mergeCellFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(mergeCellFlag, () => {
      tableMethods.clearMergeCells();
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.mergeCells) {
          tableMethods.setMergeCells(props.mergeCells);
        }
      });
    });
    const mergeFooterItemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooterItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.mergeFooterItems, () => {
      mergeFooterItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(mergeFooterItemFlag, () => {
      tableMethods.clearMergeFooterItems();
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.mergeFooterItems) {
          tableMethods.setMergeFooterItems(props.mergeFooterItems);
        }
      });
    });
    VXETable.hooks.forEach(options => {
      const {
        setupTable
      } = options;
      if (setupTable) {
        const hookRest = setupTable($xetable);
        if (hookRest && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(hookRest)) {
          Object.assign($xetable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, 'created', {
      $table: $xetable
    });
    let resizeObserver;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, 'activated', {
        $table: $xetable
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onDeactivated)(() => {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, 'deactivated', {
        $table: $xetable
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          data,
          treeConfig,
          showOverflow
        } = props;
        const {
          scrollXStore,
          scrollYStore
        } = internalData;
        const sYOpts = computeSYOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        if (true) {
          if (props.rowId) {
            warnLog('vxe.error.delProp', ['row-id', 'row-config.keyField']);
          }
          if (props.rowKey) {
            warnLog('vxe.error.delProp', ['row-key', 'row-config.useKey']);
          }
          if (props.columnKey) {
            warnLog('vxe.error.delProp', ['column-id', 'column-config.useKey']);
          }
          if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
            warnLog('vxe.error.reqProp', ['row-config.keyField']);
          }
          if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
            warnLog('vxe.error.reqProp', ['keep-source']);
          }
          if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {
            warnLog('vxe.error.reqProp', ['row-config.useKey | show-overflow']);
          }
          if (treeConfig && props.stripe) {
            warnLog('vxe.error.noTree', ['stripe']);
          }
          if (props.showFooter && !(props.footerMethod || props.footerData)) {
            warnLog('vxe.error.reqProp', ['footer-data | footer-method']);
          }
          // if (props.highlightCurrentRow) {
          //   warnLog('vxe.error.delProp', ['highlight-current-row', 'row-config.isCurrent'])
          // }
          // if (props.highlightHoverRow) {
          //   warnLog('vxe.error.delProp', ['highlight-hover-row', 'row-config.isHover'])
          // }
          // if (props.highlightCurrentColumn) {
          //   warnLog('vxe.error.delProp', ['highlight-current-column', 'column-config.isCurrent'])
          // }
          // if (props.highlightHoverColumn) {
          //   warnLog('vxe.error.delProp', ['highlight-hover-column', 'column-config.isHover'])
          // }
          // 检查导入导出类型，如果自定义导入导出方法，则不校验类型
          const {
            exportConfig,
            importConfig
          } = props;
          const exportOpts = computeExportOpts.value;
          const importOpts = computeImportOpts.value;
          if (importConfig && importOpts.types && !importOpts.importMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(VXETable.globalConfs.importTypes, importOpts.types)) {
            warnLog('vxe.error.errProp', [`export-config.types=${importOpts.types.join(',')}`, importOpts.types.filter(type => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(VXETable.globalConfs.importTypes, type)).join(',') || VXETable.globalConfs.importTypes.join(',')]);
          }
          if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includeArrays(VXETable.globalConfs.exportTypes, exportOpts.types)) {
            warnLog('vxe.error.errProp', [`export-config.types=${exportOpts.types.join(',')}`, exportOpts.types.filter(type => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(VXETable.globalConfs.exportTypes, type)).join(',') || VXETable.globalConfs.exportTypes.join(',')]);
          }
        }
        if (true) {
          const customOpts = computeCustomOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const rowOpts = computeRowOpts.value;
          if (!props.id && props.customConfig && (customOpts.storage === true || customOpts.storage && customOpts.storage.resizable || customOpts.storage && customOpts.storage.visible)) {
            errLog('vxe.error.reqProp', ['id']);
          }
          if (props.treeConfig && checkboxOpts.range) {
            errLog('vxe.error.noTree', ['checkbox-config.range']);
          }
          if (rowOpts.height && !props.showOverflow) {
            warnLog('vxe.error.notProp', ['table.show-overflow']);
          }
          if (!$xetable.handleUpdateCellAreas) {
            if (props.clipConfig) {
              warnLog('vxe.error.notProp', ['clip-config']);
            }
            if (props.fnrConfig) {
              warnLog('vxe.error.notProp', ['fnr-config']);
            }
            if (mouseOpts.area) {
              errLog('vxe.error.notProp', ['mouse-config.area']);
              return;
            }
          }
          if (props.treeConfig && treeOpts.children) {
            warnLog('vxe.error.delProp', ['tree-config.children', 'tree-config.childrenField']);
          }
          if (props.treeConfig && treeOpts.line) {
            warnLog('vxe.error.delProp', ['tree-config.line', 'tree-config.showLine']);
          }
          if (mouseOpts.area && mouseOpts.selected) {
            warnLog('vxe.error.errConflicts', ['mouse-config.area', 'mouse-config.selected']);
          }
          if (mouseOpts.area && checkboxOpts.range) {
            warnLog('vxe.error.errConflicts', ['mouse-config.area', 'checkbox-config.range']);
          }
          if (props.treeConfig && mouseOpts.area) {
            errLog('vxe.error.noTree', ['mouse-config.area']);
          }
          if (props.editConfig && editOpts.activeMethod) {
            warnLog('vxe.error.delProp', ['edit-config.activeMethod', 'edit-config.beforeEditMethod']);
          }
          if (props.treeConfig && checkboxOpts.isShiftKey) {
            errLog('vxe.error.errConflicts', ['tree-config', 'checkbox-config.isShiftKey']);
          }
          if (checkboxOpts.halfField) {
            warnLog('vxe.error.delProp', ['checkbox-config.halfField', 'checkbox-config.indeterminateField']);
          }
        }
        // 检查是否有安装需要的模块
        if (true) {
          if (props.editConfig && !$xetable.insert) {
            errLog('vxe.error.reqModule', ['Edit']);
          }
          if (props.editRules && !$xetable.validate) {
            errLog('vxe.error.reqModule', ['Validator']);
          }
          if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xetable.triggerCellMousedownEvent) {
            errLog('vxe.error.reqModule', ['Keyboard']);
          }
          if ((props.printConfig || props.importConfig || props.exportConfig) && !$xetable.exportData) {
            errLog('vxe.error.reqModule', ['Export']);
          }
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: sYOpts.adaptive !== false
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data || []).then(() => {
          if (data && data.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
            handleInitDefaults();
          }
          updateStyle();
        });
        if (props.autoResize) {
          const resizeOpts = computeResizeleOpts.value;
          const {
            refreshDelay
          } = resizeOpts;
          const el = refElem.value;
          const parentEl = tablePrivateMethods.getParentElem();
          const handleOptimizeResize = refreshDelay ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(() => tableMethods.recalculate(true), refreshDelay, {
            leading: true,
            trailing: true
          }) : null;
          resizeObserver = createResizeEvent(handleOptimizeResize ? () => {
            if (props.autoResize) {
              requestAnimationFrame(handleOptimizeResize);
            }
          } : () => {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el) {
            resizeObserver.observe(el);
          }
          if (parentEl) {
            resizeObserver.observe(parentEl);
          }
        }
      });
      GlobalEvent.on($xetable, 'paste', handleGlobalPasteEvent);
      GlobalEvent.on($xetable, 'copy', handleGlobalCopyEvent);
      GlobalEvent.on($xetable, 'cut', handleGlobalCutEvent);
      GlobalEvent.on($xetable, 'mousedown', handleGlobalMousedownEvent);
      GlobalEvent.on($xetable, 'blur', handleGlobalBlurEvent);
      GlobalEvent.on($xetable, 'mousewheel', handleGlobalMousewheelEvent);
      GlobalEvent.on($xetable, 'keydown', handleGlobalKeydownEvent);
      GlobalEvent.on($xetable, 'resize', handleGlobalResizeEvent);
      if ($xetable.handleGlobalContextmenuEvent) {
        GlobalEvent.on($xetable, 'contextmenu', $xetable.handleGlobalContextmenuEvent);
      }
      tablePrivateMethods.preventEvent(null, 'mounted', {
        $table: $xetable
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, 'beforeUnmount', {
        $table: $xetable
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      GlobalEvent.off($xetable, 'paste');
      GlobalEvent.off($xetable, 'copy');
      GlobalEvent.off($xetable, 'cut');
      GlobalEvent.off($xetable, 'mousedown');
      GlobalEvent.off($xetable, 'blur');
      GlobalEvent.off($xetable, 'mousewheel');
      GlobalEvent.off($xetable, 'keydown');
      GlobalEvent.off($xetable, 'resize');
      GlobalEvent.off($xetable, 'contextmenu');
      tablePrivateMethods.preventEvent(null, 'unmounted', {
        $table: $xetable
      });
    });
    const renderVN = () => {
      const {
        loading,
        stripe,
        showHeader,
        height,
        treeConfig,
        mouseConfig,
        showFooter,
        highlightCell,
        highlightHoverRow,
        highlightHoverColumn,
        editConfig,
        editRules
      } = props;
      const {
        isGroup,
        overflowX,
        overflowY,
        scrollXLoad,
        scrollYLoad,
        scrollbarHeight,
        tableData,
        tableColumn,
        tableGroupColumn,
        footerTableData,
        initStore,
        columnStore,
        filterStore,
        customStore
      } = reactData;
      const {
        leftList,
        rightList
      } = columnStore;
      const loadingSlot = slots.loading;
      const tipConfig = computeTipConfig.value;
      const validOpts = computeValidOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const validTipOpts = computeValidTipOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isMenu = computeIsMenu.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table', 'vxe-table--render-default', `tid_${xID}`, `border--${tableBorder}`, {
          [`size--${vSize}`]: vSize,
          [`valid-msg--${validOpts.msgMode}`]: !!editRules,
          'vxe-editable': !!editConfig,
          'old-cell-valid': editRules && conf.cellVaildMode === 'obsolete',
          'cell--highlight': highlightCell,
          'cell--selected': mouseConfig && mouseOpts.selected,
          'cell--area': mouseConfig && mouseOpts.area,
          'row--highlight': rowOpts.isHover || highlightHoverRow,
          'column--highlight': columnOpts.isHover || highlightHoverColumn,
          'is--header': showHeader,
          'is--footer': showFooter,
          'is--group': isGroup,
          'is--tree-line': treeConfig && (treeOpts.showLine || treeOpts.line),
          'is--fixed-left': leftList.length,
          'is--fixed-right': rightList.length,
          'is--animat': !!props.animat,
          'is--round': props.round,
          'is--stripe': !treeConfig && stripe,
          'is--loading': loading,
          'is--empty': !loading && !tableData.length,
          'is--scroll-y': overflowY,
          'is--scroll-x': overflowX,
          'is--virtual-x': scrollXLoad,
          'is--virtual-y': scrollYLoad
        }],
        onKeydown: keydownEvent
      }, [
      /**
       * 隐藏列
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-slots'
      }, slots.default ? slots.default({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--render-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--main-wrapper'
      }, [
      /**
       * 表头
       */
      showHeader ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(header, {
        ref: refTableHeader,
        tableData,
        tableColumn,
        tableGroupColumn
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 表体
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(body, {
        ref: refTableBody,
        tableData,
        tableColumn
      }),
      /**
       * 表尾
       */
      showFooter ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(footer, {
        ref: refTableFooter,
        footerTableData,
        tableColumn
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--fixed-wrapper'
      }, [
      /**
       * 左侧固定区域
       */
      leftList && leftList.length && overflowX ? renderFixed('left') : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 右侧固定区域
       */
      rightList && rightList.length && overflowX ? renderFixed('right') : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]),
      /**
       * 空数据
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refEmptyPlaceholder,
        class: 'vxe-table--empty-placeholder'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--empty-content'
      }, renderEmptyContenet())]),
      /**
       * 边框线
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table--border-line'
      }),
      /**
       * 列宽线
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refCellResizeBar,
        class: 'vxe-table--resizable-bar',
        style: overflowX ? {
          'padding-bottom': `${scrollbarHeight}px`
        } : null
      }),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
        class: 'vxe-table--loading',
        modelValue: loading,
        icon: loadingOpts.icon,
        text: loadingOpts.text
      }, loadingSlot ? {
        default: () => loadingSlot({
          $table: $xetable,
          $grid: $xegrid
        })
      } : {}),
      /**
       * 自定义列
       */
      initStore.custom ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-table-custom-panel'), {
        ref: refTableCustom,
        customStore
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 筛选
       */
      initStore.filter ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-table-filter-panel'), {
        ref: refTableFilter,
        filterStore
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 导入
       */
      initStore.import && props.importConfig ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-table-import-panel'), {
        defaultOptions: reactData.importParams,
        storeData: reactData.importStore
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 导出/导出
       */
      initStore.export && (props.exportConfig || props.printConfig) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-table-export-panel'), {
        defaultOptions: reactData.exportParams,
        storeData: reactData.exportStore
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 快捷菜单
       */
      isMenu ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-table-menu-panel'), {
        ref: refTableMenu
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 通用提示
       */
      hasUseTooltip ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-tooltip'), {
        ref: refCommTooltip,
        isArrow: false,
        enterable: false
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 工具提示
       */
      hasUseTooltip ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-tooltip'), {
        ref: refTooltip,
        ...tipConfig
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      /**
       * 校验提示
       */
      hasUseTooltip && props.editRules && validOpts.showMessage && (validOpts.message === 'default' ? !height : validOpts.message === 'tooltip') ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-tooltip'), {
        ref: refValidTooltip,
        class: [{
          'old-cell-valid': editRules && conf.cellVaildMode === 'obsolete'
        }, 'vxe-table--valid-error'],
        ...(validOpts.message === 'tooltip' || tableData.length === 1 ? validTipOpts : {})
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xetable.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xecolgroup', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xetable', $xetable);
    return $xetable;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/table/index.ts


const VxeTable = Object.assign(table, {
  install: function (app) {
    app.component(table.name, table);
  }
});
const Table = VxeTable;
dynamicApp.component(table.name, table);
/* harmony default export */ var packages_table = (VxeTable);
;// CONCATENATED MODULE: ./packages/select/index.ts


const VxeSelect = Object.assign(src_select, {
  install: function (app) {
    app.component(src_select.name, src_select);
  }
});
const Select = VxeSelect;
dynamicApp.component(src_select.name, src_select);
/* harmony default export */ var packages_select = (VxeSelect);
;// CONCATENATED MODULE: ./packages/pager/src/pager.ts








/* harmony default export */ var pager = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxePager',
  props: {
    size: {
      type: String,
      default: () => conf.pager.size || conf.size
    },
    // 自定义布局
    layouts: {
      type: Array,
      default: () => conf.pager.layouts || ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
    },
    // 当前页
    currentPage: {
      type: Number,
      default: 1
    },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: {
      type: Number,
      default: () => conf.pager.pageSize || 10
    },
    // 总条数
    total: {
      type: Number,
      default: 0
    },
    // 显示页码按钮的数量
    pagerCount: {
      type: Number,
      default: () => conf.pager.pagerCount || 7
    },
    // 每页大小选项列表
    pageSizes: {
      type: Array,
      default: () => conf.pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // 列对其方式
    align: {
      type: String,
      default: () => conf.pager.align
    },
    // 带边框
    border: {
      type: Boolean,
      default: () => conf.pager.border
    },
    // 带背景颜色
    background: {
      type: Boolean,
      default: () => conf.pager.background
    },
    // 配套的样式
    perfect: {
      type: Boolean,
      default: () => conf.pager.perfect
    },
    // 当只有一页时隐藏
    autoHidden: {
      type: Boolean,
      default: () => conf.pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => conf.pager.transfer
    },
    className: [String, Function],
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: ['update:pageSize', 'update:currentPage', 'page-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const $xegrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xegrid', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inpCurrPage: props.currentPage
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xepager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    let pagerMethods = {};
    let pagerPrivateMethods = {};
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const computePageCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const jumpPageEvent = (evnt, currentPage) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const changeCurrentPage = (currentPage, evnt) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const triggerJumpEvent = evnt => {
      const inputElem = evnt.target;
      const inpValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      changeCurrentPage(current, evnt);
    };
    const computeNumList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        pagerCount
      } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.pageSizes.map(item => {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(item)) {
          return {
            value: item,
            label: `${conf.i18n('vxe.pager.pagesize', [item])}`
          };
        }
        return {
          value: '',
          label: '',
          ...item
        };
      });
    });
    const handleHomePage = evnt => {
      const {
        currentPage
      } = props;
      if (currentPage > 1) {
        changeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = evnt => {
      const numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = evnt => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = params => {
      const {
        value
      } = params;
      const pageSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit('update:currentPage', pageCount);
      }
      emit('update:pageSize', pageSize);
      pagerMethods.dispatchEvent('page-change', {
        type: 'size',
        pageSize,
        currentPage
      });
    };
    const jumpInputEvent = evnt => {
      const inputElem = evnt.target;
      reactData.inpCurrPage = inputElem.value;
    };
    const jumpKeydownEvent = evnt => {
      if (hasEventKey(evnt, EVENT_KEYS.ENTER)) {
        triggerJumpEvent(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_UP)) {
        evnt.preventDefault();
        handleNextPage(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN)) {
        evnt.preventDefault();
        handlePrevPage(evnt);
      }
    };
    // 第一页
    const renderHomePage = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': props.currentPage <= 1
        }],
        type: 'button',
        title: conf.i18n('vxe.pager.homePageTitle'),
        onClick: handleHomePage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconHomePage || conf.icon.PAGER_HOME]
      })]);
    };
    // 上一页
    const renderPrevPage = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': props.currentPage <= 1
        }],
        type: 'button',
        title: conf.i18n('vxe.pager.prevPageTitle'),
        onClick: handlePrevPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconPrevPage || conf.icon.PAGER_PREV_PAGE]
      })]);
    };
    // 向上翻页
    const renderPrevJump = tagName => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-prev', {
          'is--fixed': !tagName,
          'is--disabled': props.currentPage <= 1
        }],
        type: 'button',
        title: conf.i18n('vxe.pager.prevJumpTitle'),
        onClick: handlePrevJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || conf.icon.PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpPrev || conf.icon.PAGER_JUMP_PREV]
      })]);
    };
    // 向下翻页
    const renderNextJump = tagName => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-next', {
          'is--fixed': !tagName,
          'is--disabled': props.currentPage >= pageCount
        }],
        type: 'button',
        title: conf.i18n('vxe.pager.nextJumpTitle'),
        onClick: handleNextJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || conf.icon.PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpNext || conf.icon.PAGER_JUMP_NEXT]
      })]);
    };
    // 下一页
    const renderNextPage = () => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--next-btn', {
          'is--disabled': props.currentPage >= pageCount
        }],
        type: 'button',
        title: conf.i18n('vxe.pager.nextPageTitle'),
        onClick: handleNextPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconNextPage || conf.icon.PAGER_NEXT_PAGE]
      })]);
    };
    // 最后一页
    const renderEndPage = () => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': props.currentPage >= pageCount
        }],
        type: 'button',
        title: conf.i18n('vxe.pager.endPageTitle'),
        onClick: handleEndPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconEndPage || conf.icon.PAGER_END]
      })]);
    };
    // 页数
    const renderNumber = showJump => {
      const {
        currentPage,
        pagerCount
      } = props;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => jumpPageEvent(evnt, 1)
        }, 1), renderPrevJump('span'));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
            key: number,
            class: ['vxe-pager--num-btn', {
              'is--active': currentPage === number
            }],
            type: 'button',
            onClick: evnt => jumpPageEvent(evnt, number)
          }, number));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump('button'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => jumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--btn-wrapper'
      }, nums);
    };
    // jumpNumber
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    // sizes
    const renderSizes = () => {
      const sizeList = computeSizeList.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_select, {
        class: 'vxe-pager--sizes',
        modelValue: props.pageSize,
        placement: 'top',
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    // Jump
    const renderJump = isFull => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--jump'
      }, [isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--goto-text'
      }, conf.i18n('vxe.pager.goto')) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-pager--goto',
        value: reactData.inpCurrPage,
        type: 'text',
        autocomplete: 'off',
        onInput: jumpInputEvent,
        onKeydown: jumpKeydownEvent,
        onBlur: triggerJumpEvent
      }), isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--classifier-text'
      }, conf.i18n('vxe.pager.pageClassifier')) : null]);
    };
    // FullJump
    const renderFullJump = () => {
      return renderJump(true);
    };
    // PageCount
    const renderPageCount = () => {
      const pageCount = computePageCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--count'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--separator'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', pageCount)]);
    };
    // total
    const renderTotal = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--total'
      }, conf.i18n('vxe.pager.total', [props.total]));
    };
    pagerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $pager: $xepager,
          $event: evnt
        }, params));
      },
      homePage() {
        handleHomePage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      endPage() {
        handleEndPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevPage() {
        handlePrevPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextPage() {
        handleNextPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevJump() {
        handlePrevJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextJump() {
        handleNextJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xepager, pagerMethods, pagerPrivateMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.currentPage, value => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const {
        align,
        layouts,
        className
      } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--left-wrapper'
        }, slots.left({
          $grid: $xegrid
        })));
      }
      layouts.forEach(name => {
        let renderFn;
        switch (name) {
          case 'Home':
            renderFn = renderHomePage;
            break;
          case 'PrevJump':
            renderFn = renderPrevJump;
            break;
          case 'PrevPage':
            renderFn = renderPrevPage;
            break;
          case 'Number':
            renderFn = renderNumber;
            break;
          case 'JumpNumber':
            renderFn = renderJumpNumber;
            break;
          case 'NextPage':
            renderFn = renderNextPage;
            break;
          case 'NextJump':
            renderFn = renderNextJump;
            break;
          case 'End':
            renderFn = renderEndPage;
            break;
          case 'Sizes':
            renderFn = renderSizes;
            break;
          case 'FullJump':
            renderFn = renderFullJump;
            break;
          case 'Jump':
            renderFn = renderJump;
            break;
          case 'PageCount':
            renderFn = renderPageCount;
            break;
          case 'Total':
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          if (true) {
            errLog('vxe.error.notProp', [`layouts -> ${name}`]);
          }
        }
      });
      if (slots.right) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--right-wrapper'
        }, slots.right({
          $grid: $xegrid
        })));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pager', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pager: $xepager
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          'is--border': props.border,
          'is--background': props.background,
          'is--perfect': props.perfect,
          'is--hidden': props.autoHidden && pageCount === 1,
          'is--loading': props.loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pager--wrapper'
      }, childNodes)]);
    };
    $xepager.renderVN = renderVN;
    return $xepager;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pager/index.ts


const VxePager = Object.assign(pager, {
  install: function (app) {
    app.component(pager.name, pager);
  }
});
const Pager = VxePager;
dynamicApp.component(pager.name, pager);
/* harmony default export */ var packages_pager = (VxePager);
;// CONCATENATED MODULE: ./packages/button/index.ts


const VxeButton = Object.assign(src_button, {
  install(app) {
    app.component(src_button.name, src_button);
  }
});
const Button = VxeButton;
dynamicApp.component(src_button.name, src_button);
/* harmony default export */ var packages_button = (VxeButton);
;// CONCATENATED MODULE: ./packages/toolbar/src/toolbar.ts









/* harmony default export */ var toolbar = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeToolbar',
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: {
      type: Array,
      default: () => conf.toolbar.buttons
    },
    tools: {
      type: Array,
      default: () => conf.toolbar.tools
    },
    perfect: {
      type: Boolean,
      default: () => conf.toolbar.perfect
    },
    size: {
      type: String,
      default: () => conf.toolbar.size || conf.size
    },
    className: [String, Function]
  },
  emits: ['button-click', 'tool-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isRefresh: false,
      columns: []
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xetoolbar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const $xegrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xegrid', null);
    let $xetable;
    const connectFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    const computeRefreshOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.toolbar.refresh, props.refresh);
    });
    const computeImportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.toolbar.import, props.import);
    });
    const computeExportOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.toolbar.export, props.export);
    });
    const computePrintOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.toolbar.print, props.print);
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.toolbar.zoom, props.zoom);
    });
    const computeCustomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.toolbar.custom, props.custom);
    });
    const computeTableCustomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (connectFlag.value || $xetable) {
        if ($xetable) {
          const {
            computeCustomOpts
          } = $xetable.getComputeMaps();
          return computeCustomOpts.value;
        }
      }
      return {};
    });
    const computeTrigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      if ($xetable) {
        return true;
      }
      errLog('vxe.error.barUnableLink');
    };
    const handleClickSettingEvent = ({
      $event
    }) => {
      if ($xetable) {
        if ($xetable.triggerCustomEvent) {
          $xetable.triggerCustomEvent($event);
        } else {
          errLog('vxe.error.reqModule', ['VxeTableCustomModule']);
        }
      }
    };
    const handleMouseenterSettingEvent = ({
      $event
    }) => {
      if ($xetable) {
        $xetable.customOpenEvent($event);
      } else {
        errLog('vxe.error.reqModule', ['VxeTableCustomModule']);
      }
    };
    const handleMouseleaveSettingEvent = ({
      $event
    }) => {
      const {
        customStore
      } = $xetable.reactData;
      customStore.activeBtn = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xetable.customColseEvent($event);
        }
      }, 350);
    };
    const refreshEvent = evnt => {
      const {
        isRefresh
      } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch(e => e).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e) {
            reactData.isRefresh = false;
          }
        } else if ($xegrid) {
          reactData.isRefresh = true;
          $xegrid.triggerToolbarCommitEvent({
            code: refreshOpts.code || 'reload'
          }, evnt).catch(e => e).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = evnt => {
      if ($xegrid) {
        $xegrid.triggerZoomEvent(evnt);
      }
    };
    const btnEvent = (evnt, item) => {
      const {
        code
      } = item;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = VXETable.commands.get(code);
          const params = {
            code,
            button: item,
            $table: $xetable,
            $grid: $xegrid,
            $event: evnt
          };
          if (gCommandOpts) {
            if (gCommandOpts.commandMethod) {
              gCommandOpts.commandMethod(params);
            } else {
              if (true) {
                errLog('vxe.error.notCommands', [code]);
              }
            }
          }
          $xetoolbar.dispatchEvent('button-click', params, evnt);
        }
      }
    };
    const tolEvent = (evnt, item) => {
      const {
        code
      } = item;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = VXETable.commands.get(code);
          const params = {
            code,
            tool: item,
            $table: $xetable,
            $grid: $xegrid,
            $event: evnt
          };
          if (gCommandOpts) {
            if (gCommandOpts.commandMethod) {
              gCommandOpts.commandMethod(params);
            } else {
              if (true) {
                errLog('vxe.error.notCommands', [code]);
              }
            }
          }
          $xetoolbar.dispatchEvent('tool-click', params, evnt);
        }
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        $xetable.openImport();
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        $xetable.openExport();
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        $xetable.openPrint();
      }
    };
    const renderDropdowns = (item, isBtn) => {
      const {
        dropdowns
      } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index) => {
          if (child.visible === false) {
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
          }
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
            key: index,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            onClick: evnt => isBtn ? btnEvent(evnt, child) : tolEvent(evnt, child)
          });
        });
      }
      return downVNs;
    };
    /**
     * 渲染按钮
     */
    const renderBtns = () => {
      const {
        buttons
      } = props;
      const buttonsSlot = slots.buttons;
      if (buttonsSlot) {
        return getSlotVNs(buttonsSlot({
          $grid: $xegrid,
          $table: $xetable
        }));
      }
      const btnVNs = [];
      if (buttons) {
        buttons.forEach(item => {
          const {
            dropdowns,
            buttonRender
          } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? VXETable.renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = {
                $grid: $xegrid,
                $table: $xetable,
                button: item
              };
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
                class: ['vxe-button--item', toolbarButtonClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : '']
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: evnt => btnEvent(evnt, item)
              }, dropdowns && dropdowns.length ? {
                dropdowns: () => renderDropdowns(item, true)
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    /**
     * 渲染右侧工具
     */
    const renderRightTools = () => {
      const {
        tools
      } = props;
      const toolsSlot = slots.tools;
      if (toolsSlot) {
        return getSlotVNs(toolsSlot({
          $grid: $xegrid,
          $table: $xetable
        }));
      }
      const btnVNs = [];
      if (tools) {
        tools.forEach((item, tIndex) => {
          const {
            dropdowns,
            toolRender
          } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? VXETable.renderer.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = {
                $grid: $xegrid,
                $table: $xetable,
                tool: item
              };
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
                key: rdName,
                class: ['vxe-tool--item', toolbarToolClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : '']
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
                key: tIndex,
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: evnt => tolEvent(evnt, item)
              }, dropdowns && dropdowns.length ? {
                dropdowns: () => renderDropdowns(item, false)
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
        key: 'import',
        circle: true,
        icon: importOpts.icon || conf.icon.TOOLBAR_TOOLS_IMPORT,
        title: conf.i18n('vxe.toolbar.import'),
        onClick: importEvent
      });
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
        key: 'export',
        circle: true,
        icon: exportOpts.icon || conf.icon.TOOLBAR_TOOLS_EXPORT,
        title: conf.i18n('vxe.toolbar.export'),
        onClick: exportEvent
      });
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
        key: 'print',
        circle: true,
        icon: printOpts.icon || conf.icon.TOOLBAR_TOOLS_PRINT,
        title: conf.i18n('vxe.toolbar.print'),
        onClick: printEvent
      });
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
        key: 'refresh',
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || conf.icon.TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || conf.icon.TOOLBAR_TOOLS_REFRESH,
        title: conf.i18n('vxe.toolbar.refresh'),
        onClick: refreshEvent
      });
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xegrid ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
        key: 'zoom',
        circle: true,
        icon: $xegrid.isMaximized() ? zoomOpts.iconOut || conf.icon.TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || conf.icon.TOOLBAR_TOOLS_FULLSCREEN,
        title: conf.i18n(`vxe.toolbar.zoom${$xegrid.isMaximized() ? 'Out' : 'In'}`),
        onClick: zoomEvent
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === 'manual') {
        // 手动触发
      } else if (btnTrigger === 'hover') {
        // hover 触发
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        // 点击触发
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_button, {
        key: 'custom',
        circle: true,
        icon: customOpts.icon || conf.icon.TOOLBAR_TOOLS_CUSTOM,
        title: conf.i18n('vxe.toolbar.custom'),
        className: 'vxe-toolbar-custom-target',
        ...customBtnOns
      });
    };
    toolbarMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $toolbar: $xetoolbar,
          $event: evnt
        }, params));
      },
      syncUpdate(params) {
        const {
          collectColumn
        } = params;
        $xetable = params.$table;
        reactData.columns = collectColumn;
        connectFlag.value++;
      }
    };
    Object.assign($xetoolbar, toolbarMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const {
        refresh
      } = props;
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xegrid && !queryMethod) {
        warnLog('vxe.error.notFunc', ['queryMethod']);
      }
      const customOpts = computeCustomOpts.value;
      if (true) {
        if (customOpts.isFooter) {
          warnLog('vxe.error.delProp', ['toolbar.custom.isFooter', 'table.custom-config.showFooter']);
        }
        if (customOpts.showFooter) {
          warnLog('vxe.error.delProp', ['toolbar.custom.showFooter', 'table.custom-config.showFooter']);
        }
        if (customOpts.immediate) {
          warnLog('vxe.error.delProp', ['toolbar.custom.immediate', 'table.custom-config.immediate']);
        }
        if (customOpts.trigger) {
          warnLog('vxe.error.delProp', ['toolbar.custom.trigger', 'table.custom-config.trigger']);
        }
      }
    });
    const renderVN = () => {
      const {
        perfect,
        loading,
        refresh,
        zoom,
        custom,
        className
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-toolbar', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $toolbar: $xetoolbar
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--perfect': perfect,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-buttons--wrapper'
      }, renderBtns()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tools--wrapper'
      }, renderRightTools()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tools--operate'
      }, [props.import ? renderToolImport() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), props.export ? renderToolExport() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), props.print ? renderToolPrint() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), refresh ? renderToolRefresh() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), zoom && $xegrid ? renderToolZoom() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), custom ? renderToolCustom() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])]);
    };
    $xetoolbar.renderVN = renderVN;
    return $xetoolbar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/toolbar/index.ts


const VxeToolbar = Object.assign(toolbar, {
  install: function (app) {
    app.component(toolbar.name, toolbar);
  }
});
const Toolbar = VxeToolbar;
dynamicApp.component(toolbar.name, toolbar);
/* harmony default export */ var packages_toolbar = (VxeToolbar);
;// CONCATENATED MODULE: ./packages/form/src/itemInfo.ts

class ItemInfo {
  constructor($xeform, item) {
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('item_'),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 渲染属性
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/form/src/util.ts





function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeform, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeform, _vm);
}
function handleFieldOrItem($xeform, fieldOrItem) {
  if (fieldOrItem) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrItem) ? $xeform.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeform, formItem) {
  const {
    reactData
  } = $xeform;
  const {
    collapseAll
  } = reactData;
  const {
    folding,
    visible
  } = formItem;
  return visible === false || folding && collapseAll;
}
function isActivetem($xeform, formItem) {
  let {
    visibleMethod,
    itemRender,
    visible,
    field
  } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  if (!visibleMethod && compConf && compConf.itemVisibleMethod) {
    visibleMethod = compConf.itemVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const {
    data
  } = $xeform.props;
  return visibleMethod({
    data,
    field,
    property: field,
    item: formItem,
    $form: $xeform,
    $grid: $xeform.xegrid
  });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      formItem.update(name, value);
    });
  });
}
function assemItem($xeform, el, formItem, formGather) {
  const {
    reactData
  } = $xeform;
  const {
    staticItems
  } = reactData;
  const parentElem = el.parentNode;
  const parentItem = formGather ? formGather.formItem : null;
  const parentItems = parentItem ? parentItem.children : staticItems;
  if (parentElem) {
    parentItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, formItem);
    reactData.staticItems = staticItems.slice(0);
  }
}
function destroyItem($xeform, formItem) {
  const {
    reactData
  } = $xeform;
  const {
    staticItems
  } = reactData;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/tooltip/index.ts



const VxeTooltip = Object.assign(tooltip, {
  install: function (app) {
    VXETable.tooltip = true;
    app.component(tooltip.name, tooltip);
  }
});
const Tooltip = VxeTooltip;
dynamicApp.component(tooltip.name, tooltip);
/* harmony default export */ var packages_tooltip = (VxeTooltip);
;// CONCATENATED MODULE: ./packages/form/src/render.ts







function renderPrefixIcon(titlePrefix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-prefix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: titlePrefix.icon || conf.icon.FORM_PREFIX
  })]);
}
function renderSuffixIcon(titleSuffix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-suffix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: titleSuffix.icon || conf.icon.FORM_SUFFIX
  })]);
}
function renderTitle($xeform, item) {
  const {
    data
  } = $xeform.props;
  const {
    computeTooltipOpts
  } = $xeform.getComputeMaps();
  const {
    slots,
    field,
    itemRender,
    titlePrefix,
    titleSuffix
  } = item;
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  const params = {
    data,
    field,
    property: field,
    item,
    $form: $xeform,
    $grid: $xeform.xegrid
  };
  const titleSlot = slots ? slots.title : null;
  const contVNs = [];
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_tooltip, {
      ...tooltipOpts,
      ...titlePrefix,
      content: getFuncText(titlePrefix.content || titlePrefix.message)
    }, {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-label'
  }, compConf && compConf.renderItemTitle ? getSlotVNs(compConf.renderItemTitle(itemRender, params)) : titleSlot ? $xeform.callSlot(titleSlot, params) : getFuncText(item.title)));
  contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-content'
  }, titVNs));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_tooltip, {
      ...tooltipOpts,
      ...titleSuffix,
      content: getFuncText(titleSuffix.content || titleSuffix.message)
    }, {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-postfix'
  }, fixVNs));
  return contVNs;
}
;// CONCATENATED MODULE: ./packages/form/src/form-config-item.ts









const VxeFormConfigItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormConfigItem',
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', {});
    const xeformiteminfo = {
      itemConfig: props.itemConfig
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformiteminfo', xeformiteminfo);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformgather', null);
    const renderVN = () => {
      const {
        reactData
      } = $xeform;
      const {
        data,
        rules,
        span: allSpan,
        align: allAlign,
        titleAlign: allTitleAlign,
        titleWidth: allTitleWidth,
        titleColon: allTitleColon,
        titleAsterisk: allTitleAsterisk,
        titleOverflow: allTitleOverflow,
        vertical: allVertical
      } = $xeform.props;
      const {
        computeValidOpts
      } = $xeform.getComputeMaps();
      const item = props.itemConfig;
      const {
        collapseAll
      } = reactData;
      const validOpts = computeValidOpts.value;
      const {
        slots,
        title,
        visible,
        folding,
        field,
        collapseNode,
        itemRender,
        showError,
        errRule,
        className,
        titleOverflow,
        vertical,
        children,
        showTitle,
        contentClassName,
        contentStyle,
        titleClassName,
        titleStyle
      } = item;
      const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.itemClassName : '';
      const itemStyle = compConf ? compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.itemContentClassName : '';
      const itemContentStyle = compConf ? compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.itemTitleClassName : '';
      const itemTitleStyle = compConf ? compConf.itemTitleStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const titleSlot = slots ? slots.title : null;
      const span = item.span || allSpan;
      const align = item.align || allAlign;
      const titleAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(titleOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(vertical) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(vertical) ? allVertical : vertical;
      const ovEllipsis = itemOverflow === 'ellipsis';
      const ovTitle = itemOverflow === 'title';
      const ovTooltip = itemOverflow === true || itemOverflow === 'tooltip';
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = {
        data,
        field,
        property: field,
        item,
        $form: $xeform,
        $grid: $xeform.xegrid
      };
      if (visible === false) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      let isRequired = false;
      if (rules) {
        const itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some(rule => rule.required);
        }
      }
      // 如果为项集合
      const isGather = children && children.length > 0;
      if (isGather) {
        const childVNs = children.map((childItem, index) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeFormConfigItem, {
            key: index,
            itemConfig: childItem
          });
        });
        return childVNs.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-form--gather vxe-form--item-row', item.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '']
        }, childVNs) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      let contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = [external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field))];
      }
      if (collapseNode) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-trigger-node',
          onClick: $xeform.toggleCollapseEvent
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-form--item-trigger-text'
        }, collapseAll ? conf.i18n('vxe.form.unfolding') : conf.i18n('vxe.form.folding')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-form--item-trigger-icon', collapseAll ? conf.icon.FORM_FOLDING : conf.icon.FORM_UNFOLDING]
        })]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-valid',
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.content));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeform.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform.handleTitleTipLeaveEvent
      } : {};
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item', item.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '', itemClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemClassName) ? itemClassName(params) : itemClassName : '', {
          'is--title': title,
          'is--colon': titleColon,
          'is--vertical': itemVertical,
          'is--asterisk': titleAsterisk,
          'is--required': isRequired,
          'is--hidden': folding && collapseAll,
          'is--active': isActivetem($xeform, item),
          'is--error': showError
        }],
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--item-inner'
      }, [showTitle !== false && (title || titleSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-title', titleAlign ? `align--${titleAlign}` : '', hasEllipsis ? 'is--ellipsis' : '', itemTitleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : '', titleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleClassName) ? titleClassName(params) : titleClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
          width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
        } : null),
        title: ovTitle ? getFuncText(title) : null,
        ...ons
      }, renderTitle($xeform, item)) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-content', align ? `align--${align}` : '', itemContentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : '', contentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentClassName) ? contentClassName(params) : contentClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, contentVNs)])]);
    };
    const $xeformconfigitem = {
      renderVN
    };
    return $xeformconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
/* harmony default export */ var form_config_item = (VxeFormConfigItem);
;// CONCATENATED MODULE: ./packages/form/src/form.ts














class form_Rule {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
const validErrorRuleValue = (rule, val) => {
  const {
    type,
    min,
    max,
    pattern
  } = rule;
  const isNumType = type === 'number';
  const numVal = isNumType ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(val);
  // 判断数值
  if (isNumType && isNaN(val)) {
    return true;
  }
  // 如果存在 min，判断最小值
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && numVal < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
    return true;
  }
  // 如果存在 max，判断最大值
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && numVal > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
    return true;
  }
  // 如果存在 pattern，正则校验
  if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
function getResetValue(value, resetValue) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(value)) {
    resetValue = [];
  }
  return resetValue;
}
/* harmony default export */ var src_form = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeForm',
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => conf.form.size || conf.size
    },
    span: {
      type: [String, Number],
      default: () => conf.form.span
    },
    align: {
      type: String,
      default: () => conf.form.align
    },
    titleAlign: {
      type: String,
      default: () => conf.form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => conf.form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => conf.form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => conf.form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: null
    },
    vertical: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    readonly: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => conf.form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => conf.form.customLayout
    }
  },
  emits: ['update:collapseStatus', 'collapse', 'toggle-collapse', 'submit', 'submit-invalid', 'reset'],
  setup(props, context) {
    const hasUseTooltip = VXETable.tooltip;
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      tooltipTimeout: null,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    const $xegrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xegrid', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let formMethods = {};
    const computeValidOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.tooltip, conf.form.tooltipConfig, props.tooltipConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts
    };
    const $xeform = {
      xID,
      props,
      context,
      reactData,
      xegrid: $xegrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = list => {
      if (list.length) {
        if (true) {
          list.forEach(item => {
            if (item.slots) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
                if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                  if (!slots[func]) {
                    errLog('vxe.error.notSlot', [func]);
                  }
                }
              });
            }
          });
        }
      }
      reactData.staticItems = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(list, item => createItem($xeform, item), {
        children: 'children'
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getItems = () => {
      const itemList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.formItems, item => {
        itemList.push(item);
      }, {
        children: 'children'
      });
      return itemList;
    };
    const getItemByField = field => {
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(reactData.formItems, item => item.field === field, {
        children: 'children'
      });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit('update:collapseStatus', status);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const toggleCollapseEvent = evnt => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent('toggle-collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
      formMethods.dispatchEvent('collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
    };
    const clearValidate = fieldOrItem => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach(field => {
          if (field) {
            const item = handleFieldOrItem($xeform, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach(item => {
          item.showError = false;
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const reset = () => {
      const {
        data
      } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach(item => {
          const {
            field,
            resetValue,
            itemRender
          } = item;
          if (isEnableConf(itemRender)) {
            const compConf = VXETable.renderer.get(itemRender.name);
            if (compConf && compConf.itemResetMethod) {
              compConf.itemResetMethod({
                data,
                field,
                property: field,
                item,
                $form: $xeform,
                $grid: $xeform.xegrid
              });
            } else if (field) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, resetValue === null ? getResetValue(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field), undefined) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(resetValue, true));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = evnt => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent('reset', {
        data: props.data
      }, evnt);
    };
    const handleFocus = fields => {
      const el = refElem.value;
      for (let i = 0; i < fields.length; i++) {
        const property = fields[i];
        const item = getItemByField(property);
        if (item && isEnableConf(item.itemRender)) {
          const {
            itemRender
          } = item;
          const compConf = VXETable.renderer.get(itemRender.name);
          let inputElem = null;
          // 定位到第一个
          if (!i) {
            scrollToView(el.querySelector(`.${item.id}`));
          }
          // 如果指定了聚焦 class
          if (itemRender.autofocus) {
            inputElem = el.querySelector(`.${item.id} ${itemRender.autofocus}`);
          }
          // 渲染器的聚焦处理
          if (!inputElem && compConf && compConf.autofocus) {
            inputElem = el.querySelector(`.${item.id} ${compConf.autofocus}`);
          }
          if (inputElem) {
            inputElem.focus();
            break;
          }
        }
      }
    };
    /**
     * 校验数据
     * 按表格行、列顺序依次校验（同步或异步）
     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
     * 如果校验失败则，触发回调或者 Promise<(ErrMap 校验不通过列的信息)>
     * 如果是传回调方式这返回一个 (ErrMap 校验不通过列的信息)
     *
     * rule 配置：
     *  required=Boolean 是否必填
     *  min=Number 最小长度
     *  max=Number 最大长度
     *  validator=Function({ itemValue, rule, rules, data, property }) 自定义校验，接收一个 Promise
     *  trigger=change 触发方式
     */
    const validItemRules = (validType, fields, val) => {
      const {
        data,
        rules: formRules
      } = props;
      const errorMaps = {};
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map(property => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(formRules, property);
          if (rules) {
            const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property) : val;
            rules.forEach(rule => {
              const {
                type,
                trigger,
                required,
                validator
              } = rule;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeform
                  };
                  let customValid;
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                    const gvItem = VXETable.validators.get(validator);
                    if (gvItem) {
                      if (gvItem.itemValidatorMethod) {
                        customValid = gvItem.itemValidatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog('vxe.error.notValidators', [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog('vxe.error.notValidators', [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                      errorRules.push(new form_Rule({
                        type: 'custom',
                        trigger,
                        content: customValid.message,
                        rule: new form_Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // 如果为异步校验（注：异步校验是并发无序的）
                      syncVailds.push(customValid.catch(e => {
                        errorRules.push(new form_Rule({
                          type: 'custom',
                          trigger,
                          content: e ? e.message : rule.content || rule.message,
                          rule: new form_Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === 'array';
                  const isArrVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(itemValue)) {
                    hasEmpty = eqEmptyValue(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new form_Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map(rule => {
              return {
                $form: $xeform,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    let showErrTime;
    const beginValidate = (itemList, type, callback) => {
      const {
        data,
        rules: formRules
      } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(showErrTime);
      if (data && formRules) {
        itemList.forEach(item => {
          const {
            field
          } = item;
          if (field && !isHiddenItem($xeform, item) && isActivetem($xeform, item)) {
            itemValids.push(validItemRules(type || 'all', field).then(() => {
              item.errRule = null;
            }).catch(errorMaps => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise(resolve => {
            showErrTime = window.setTimeout(() => {
              itemList.forEach(item => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = callback => {
      clearValidate();
      return beginValidate(getItems(), '', callback);
    };
    const validateField = (fieldOrItem, callback) => {
      let fields = [];
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
        fields = fieldOrItem;
      } else {
        fields = [fieldOrItem];
      }
      return beginValidate(fields.map(field => handleFieldOrItem($xeform, field)), '', callback);
    };
    const submitEvent = evnt => {
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        beginValidate(getItems()).then(errMap => {
          if (errMap) {
            formMethods.dispatchEvent('submit-invalid', {
              data: props.data,
              errMap
            }, evnt);
          } else {
            formMethods.dispatchEvent('submit', {
              data: props.data
            }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const {
        item
      } = params;
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || '').trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.tooltipTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.tooltipTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ['blur'].includes(evnt.type) ? 'blur' : 'change' : 'all', field, itemValue).then(() => {
          clearValidate(field);
        }).catch(errorMaps => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 更新项状态
     * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一项编辑状态
     * 如果单元格配置了校验规则，则会进行校验
     */
    const updateStatus = (scope, itemValue) => {
      const {
        field
      } = scope;
      return triggerItemEvent(new Event('change'), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $form: $xeform,
          $grid: $xegrid,
          $event: evnt
        }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeform, formMethods, formPrivateMethods);
    const staticItemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(itemFlag, () => {
      loadItem(props.items || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.collapseStatus, value => {
      reactData.collapseAll = !!value;
    });
    const renderVN = () => {
      const {
        loading,
        className,
        data,
        customLayout
      } = props;
      const {
        formItems
      } = reactData;
      // const formItems: any[] = []
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('form', {
        ref: refElem,
        class: ['vxe-form', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          items: formItems,
          data,
          $form: $xeform
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--wrapper vxe-form--item-row'
      }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_config_item, {
          key: index,
          itemConfig: item
        });
      })), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-slots',
        ref: 'hideItem'
      }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
        class: 'vxe-form--loading',
        modelValue: loading
      }),
      /**
       * 工具提示
       */
      hasUseTooltip ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_tooltip, {
        ref: refTooltip,
        ...tooltipOpts
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    $xeform.renderVN = renderVN;
    if (props.items) {
      loadItem(props.items);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeform', $xeform);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformgather', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformitem', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformiteminfo', null);
    return $xeform;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/index.ts


const VxeForm = Object.assign(src_form, {
  install(app) {
    app.component(src_form.name, src_form);
  }
});
const Form = VxeForm;
dynamicApp.component(src_form.name, src_form);
/* harmony default export */ var packages_form = (VxeForm);
;// CONCATENATED MODULE: ./packages/grid/src/grid.ts

















const tableComponentPropKeys = Object.keys(props);
const tableComponentMethodKeys = ['clearAll', 'syncData', 'updateData', 'loadData', 'reloadData', 'reloadRow', 'loadColumn', 'reloadColumn', 'getRowNode', 'getColumnNode', 'getRowIndex', 'getVTRowIndex', 'getVMRowIndex', 'getColumnIndex', 'getVTColumnIndex', 'getVMColumnIndex', 'createData', 'createRow', 'revertData', 'clearData', 'isInsertByRow', 'isUpdateByRow', 'getColumns', 'getColumnById', 'getColumnByField', 'getTableColumn', 'getData', 'getCheckboxRecords', 'getParentRow', 'getRowSeq', 'getRowById', 'getRowid', 'getTableData', 'setColumnFixed', 'clearColumnFixed', 'setColumnWidth', 'getColumnWidth', 'hideColumn', 'showColumn', 'resetColumn', 'refreshColumn', 'refreshScroll', 'recalculate', 'closeTooltip', 'isAllCheckboxChecked', 'isAllCheckboxIndeterminate', 'getCheckboxIndeterminateRecords', 'setCheckboxRow', 'isCheckedByCheckboxRow', 'isIndeterminateByCheckboxRow', 'toggleCheckboxRow', 'setAllCheckboxRow', 'getRadioReserveRecord', 'clearRadioReserve', 'getCheckboxReserveRecords', 'clearCheckboxReserve', 'toggleAllCheckboxRow', 'clearCheckboxRow', 'setCurrentRow', 'isCheckedByRadioRow', 'setRadioRow', 'clearCurrentRow', 'clearRadioRow', 'getCurrentRecord', 'getRadioRecord', 'getCurrentColumn', 'setCurrentColumn', 'clearCurrentColumn', 'setPendingRow', 'togglePendingRow', 'getPendingRecords', 'clearPendingRow', 'sort', 'clearSort', 'isSort', 'getSortColumns', 'closeFilter', 'isFilter', 'isActiveFilterByColumn', 'isRowExpandLoaded', 'clearRowExpandLoaded', 'reloadRowExpand', 'reloadRowExpand', 'toggleRowExpand', 'setAllRowExpand', 'setRowExpand', 'isExpandByRow', 'isRowExpandByRow', 'clearRowExpand', 'clearRowExpandReserve', 'getRowExpandRecords', 'getTreeExpandRecords', 'isTreeExpandLoaded', 'clearTreeExpandLoaded', 'reloadTreeExpand', 'reloadTreeChilds', 'toggleTreeExpand', 'setAllTreeExpand', 'setTreeExpand', 'isTreeExpandByRow', 'clearTreeExpand', 'clearTreeExpandReserve', 'getScroll', 'scrollTo', 'scrollToRow', 'scrollToColumn', 'clearScroll', 'updateFooter', 'updateStatus', 'setMergeCells', 'removeInsertRow', 'removeMergeCells', 'getMergeCells', 'clearMergeCells', 'setMergeFooterItems', 'removeMergeFooterItems', 'getMergeFooterItems', 'clearMergeFooterItems', 'openTooltip', 'focus', 'blur', 'connect'];
const gridComponentEmits = [...emits, 'page-change', 'form-submit', 'form-submit-invalid', 'form-reset', 'form-collapse', 'form-toggle-collapse', 'proxy-query', 'proxy-delete', 'proxy-save', 'toolbar-button-click', 'toolbar-tool-click', 'zoom'];
/* harmony default export */ var grid = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeGrid',
  props: {
    ...props,
    layouts: Array,
    columns: Array,
    pagerConfig: Object,
    proxyConfig: Object,
    toolbarConfig: Object,
    formConfig: Object,
    zoomConfig: Object,
    size: {
      type: String,
      default: () => conf.grid.size || conf.size
    }
  },
  emits: gridComponentEmits,
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: conf.pager.pageSize || 10,
        currentPage: 1
      }
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refToolbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPager = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFormWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refToolbarWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTopWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBottomWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPagerWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const extendTableMethods = methodKeys => {
      const funcs = {};
      methodKeys.forEach(name => {
        funcs[name] = (...args) => {
          const $xetable = refTable.value;
          if ($xetable && $xetable[name]) {
            return $xetable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach(name => {
      gridExtendTableMethods[name] = (...args) => {
        const $xetable = refTable.value;
        if ($xetable && $xetable[name]) {
          return $xetable && $xetable[name](...args);
        }
      };
    });
    const computeProxyOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.grid.proxyConfig, props.proxyConfig);
    });
    const computeIsMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.message !== false;
    });
    const computePagerOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.isZMax ? {
        zIndex: reactData.tZindex
      } : null;
    });
    const computeTableExtendProps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach(key => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xegrid = {
      xID,
      props: props,
      context,
      instance,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let gridMethods = {};
    const computeTableProps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        seqConfig,
        pagerConfig,
        loading,
        editConfig,
        proxyConfig
      } = props;
      const {
        isZMax,
        tableLoading,
        tablePage,
        tableData
      } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tableProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tableProps.maxHeight = 'auto';
        } else {
          tableProps.height = 'auto';
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tableProps.loading = loading || tableLoading;
        tableProps.data = tableData;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tableProps.seqConfig = Object.assign({}, seqConfig, {
            startIndex: (tablePage.currentPage - 1) * tablePage.pageSize
          });
        }
      }
      if (editConfig) {
        tableProps.editConfig = Object.assign({}, editConfig);
      }
      return tableProps;
    });
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const $xetable = refTable.value;
          const $xetoolbar = refToolbar.value;
          if ($xetable && $xetoolbar) {
            $xetable.connect($xetoolbar);
          }
        });
      }
    };
    const initPages = () => {
      const {
        tablePage
      } = reactData;
      const {
        pagerConfig
      } = props;
      const pagerOpts = computePagerOpts.value;
      const {
        currentPage,
        pageSize
      } = pagerOpts;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = code => {
      const isMsg = computeIsMsg.value;
      const $xetable = refTable.value;
      const selectRecords = $xetable.getCheckboxRecords();
      if (selectRecords.length) {
        $xetable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isMsg) {
          // 检测弹窗模块
          if (true) {
            if (!VXETable.modal) {
              errLog('vxe.error.reqModule', ['Modal']);
            }
          }
          VXETable.modal.message({
            id: code,
            content: conf.i18n('vxe.grid.selectOneRecord'),
            status: 'warning'
          });
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(messageProp) ? messageProp({
          data: rest,
          $grid: $xegrid
        }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, messageProp);
      }
      return msg || conf.i18n(defaultMsg);
    };
    const handleDeleteRow = (code, alertKey, callback) => {
      const isMsg = computeIsMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isMsg) {
        if (selectRecords.length) {
          return VXETable.modal.confirm({
            id: `cfm_${code}`,
            content: conf.i18n(alertKey),
            escClosable: true
          }).then(type => {
            if (type === 'confirm') {
              return callback();
            }
          });
        } else {
          // 检测弹窗模块
          if (true) {
            if (!VXETable.modal) {
              errLog('vxe.error.reqModule', ['Modal']);
            }
          }
          VXETable.modal.message({
            id: `msg_${code}`,
            content: conf.i18n('vxe.grid.selectOneRecord'),
            status: 'warning'
          });
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = params => {
      const {
        proxyConfig
      } = props;
      const {
        tablePage
      } = reactData;
      const {
        currentPage,
        pageSize
      } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      gridMethods.dispatchEvent('page-change', params);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy('query').then(rest => {
          gridMethods.dispatchEvent('proxy-query', rest, params.$event);
        });
      }
    };
    const sortChangeEvent = params => {
      const $xetable = refTable.value;
      const {
        proxyConfig
      } = props;
      const {
        computeSortOpts
      } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      // 如果是服务端排序
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy('query').then(rest => {
            gridMethods.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent('sort-change', params);
    };
    const filterChangeEvent = params => {
      const $xetable = refTable.value;
      const {
        proxyConfig
      } = props;
      const {
        computeFilterOpts
      } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      // 如果是服务端过滤
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy('query').then(rest => {
            gridMethods.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent('filter-change', params);
    };
    const submitFormEvent = params => {
      const {
        proxyConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy('reload').then(rest => {
          gridMethods.dispatchEvent('proxy-query', {
            ...rest,
            isReload: true
          }, params.$event);
        });
      }
      gridMethods.dispatchEvent('form-submit', params);
    };
    const resetFormEvent = params => {
      const {
        proxyConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy('reload').then(rest => {
          gridMethods.dispatchEvent('proxy-query', {
            ...rest,
            isReload: true
          }, params.$event);
        });
      }
      gridMethods.dispatchEvent('form-reset', params);
    };
    const submitInvalidEvent = params => {
      gridMethods.dispatchEvent('form-submit-invalid', params);
    };
    const collapseEvent = params => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => gridExtendTableMethods.recalculate(true));
      gridMethods.dispatchEvent('form-toggle-collapse', params);
      gridMethods.dispatchEvent('form-collapse', params);
    };
    const handleZoom = isMax => {
      const {
        isZMax
      } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => gridExtendTableMethods.recalculate(true)).then(() => reactData.isZMax);
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            if (true) {
              errLog('vxe.error.notSlot', [funcSlot]);
            }
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    /**
     * 渲染表单
     */
    const renderForms = () => {
      const {
        formConfig,
        proxyConfig
      } = props;
      const {
        formData
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      const restVNs = [];
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({
            $grid: $xegrid
          });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach(item => {
                  beforeItem({
                    $grid: $xegrid,
                    item
                  });
                });
              }
            }
            // 处理插槽
            formOpts.items.forEach(item => {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
                if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            slotVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_form, {
              ref: refForm,
              ...Object.assign({}, formOpts, {
                data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
              }),
              onSubmit: submitFormEvent,
              onReset: resetFormEvent,
              onSubmitInvalid: submitInvalidEvent,
              onCollapse: collapseEvent
            }, formSlots));
          }
        }
        restVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refFormWrapper,
          key: 'form',
          class: 'vxe-grid--form-wrapper'
        }, slotVNs));
      }
      return restVNs;
    };
    /**
     * 渲染工具栏
     */
    const renderToolbars = () => {
      const {
        toolbarConfig
      } = props;
      const toolbarOpts = computeToolbarOpts.value;
      const restVNs = [];
      if (toolbarConfig && isEnableConf(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({
            $grid: $xegrid
          });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, 'buttons');
            toolsSlot = getFuncSlot(toolbarOptSlots, 'tools');
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_toolbar, {
            ref: refToolbar,
            ...toolbarOpts
          }, toolbarSlots));
        }
        restVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refToolbarWrapper,
          key: 'toolbar',
          class: 'vxe-grid--toolbar-wrapper'
        }, slotVNs));
      }
      return restVNs;
    };
    /**
     * 渲染表格顶部区域
     */
    const renderTops = () => {
      if (slots.top) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refTopWrapper,
          key: 'top',
          class: 'vxe-grid--top-wrapper'
        }, slots.top({
          $grid: $xegrid
        }))];
      }
      return [];
    };
    const defaultLayouts = ['Form', 'Toolbar', 'Top', 'Table', 'Bottom', 'Pager'];
    const renderLayout = () => {
      const {
        layouts
      } = props;
      const vns = [];
      const currLayouts = layouts && layouts.length ? layouts : conf.grid.layouts || defaultLayouts;
      currLayouts.forEach(name => {
        switch (name) {
          case 'Form':
            vns.push(renderForms());
            break;
          case 'Toolbar':
            vns.push(renderToolbars());
            break;
          case 'Top':
            vns.push(renderTops());
            break;
          case 'Table':
            vns.push(renderTables());
            break;
          case 'Bottom':
            vns.push(renderBottoms());
            break;
          case 'Pager':
            vns.push(renderPagers());
            break;
          default:
            if (true) {
              errLog('vxe.error.notProp', [`layouts -> ${name}`]);
            }
            break;
        }
      });
      return vns;
    };
    const tableCompEvents = {};
    emits.forEach(name => {
      const type = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    /**
     * 渲染表格
     */
    const renderTables = () => {
      const {
        proxyConfig
      } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = () => emptySlot({});
      }
      if (loadingSlot) {
        slotObj.loading = () => loadingSlot({});
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_table, {
        ref: refTable,
        key: 'table',
        ...tableProps,
        ...tableOns
      }, slotObj)];
    };
    /**
     * 渲染表格底部区域
     */
    const renderBottoms = () => {
      if (slots.bottom) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refBottomWrapper,
          key: 'bottom',
          class: 'vxe-grid--bottom-wrapper'
        }, slots.bottom({
          $grid: $xegrid
        }))];
      }
      return [];
    };
    /**
     * 渲染分页
     */
    const renderPagers = () => {
      const {
        proxyConfig,
        pagerConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const restVNs = [];
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        let slotVNs = [];
        if (slots.pager) {
          slotVNs = slots.pager({
            $grid: $xegrid
          });
        } else {
          const pagerOptSlots = pagerOpts.slots;
          const pagerSlots = {};
          let leftSlot;
          let rightSlot;
          if (pagerOptSlots) {
            leftSlot = getFuncSlot(pagerOptSlots, 'left');
            rightSlot = getFuncSlot(pagerOptSlots, 'right');
            if (leftSlot) {
              pagerSlots.left = leftSlot;
            }
            if (rightSlot) {
              pagerSlots.right = rightSlot;
            }
          }
          slotVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_pager, {
            ref: refPager,
            ...pagerOpts,
            ...(proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}),
            onPageChange: pageChangeEvent
          }, pagerSlots));
        }
        restVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refPagerWrapper,
          key: 'pager',
          class: 'vxe-grid--pager-wrapper'
        }, slotVNs));
      }
      return restVNs;
    };
    const initProxy = () => {
      const {
        proxyConfig,
        formConfig
      } = props;
      const {
        proxyInited
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          const formData = {};
          formOpts.items.forEach(item => {
            const {
              field,
              itemRender
            } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const {
                  defaultValue
                } = itemRender;
                if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(defaultValue)) {
                  itemValue = defaultValue({
                    item
                  });
                } else if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              formData[field] = itemValue;
            }
          });
          reactData.formData = formData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => gridMethods.commitProxy('_init')).then(rest => {
              gridMethods.dispatchEvent('proxy-query', {
                ...rest,
                isInited: true
              }, new Event('init'));
            });
          }
        }
      }
    };
    gridMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $grid: $xegrid,
          $event: evnt
        }, params));
      },
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(proxyTarget, ...args) {
        const {
          toolbarConfig,
          pagerConfig,
          editRules,
          validConfig
        } = props;
        const {
          tablePage,
          formData
        } = reactData;
        const isMsg = computeIsMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const {
          beforeQuery,
          afterQuery,
          beforeDelete,
          afterDelete,
          beforeSave,
          afterSave,
          ajax = {}
        } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xetable = refTable.value;
        let button = null;
        let code = null;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(proxyTarget)) {
          const {
            buttons
          } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(buttons, item => item.code === proxyTarget, {
            children: 'dropdowns'
          }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code) {
          case 'insert':
            return $xetable.insert({});
          case 'insert_edit':
            return $xetable.insert({}).then(({
              row
            }) => $xetable.setEditRow(row));
          // 已废弃
          case 'insert_actived':
            return $xetable.insert({}).then(({
              row
            }) => $xetable.setEditRow(row));
          // 已废弃
          case 'mark_cancel':
            triggerPendingEvent(code);
            break;
          case 'remove':
            return handleDeleteRow(code, 'vxe.grid.removeSelectRecord', () => $xetable.removeCheckboxRow());
          case 'import':
            $xetable.importData(btnParams);
            break;
          case 'open_import':
            $xetable.openImport(btnParams);
            break;
          case 'export':
            $xetable.exportData(btnParams);
            break;
          case 'open_export':
            $xetable.openExport(btnParams);
            break;
          case 'reset_custom':
            return $xetable.resetColumn(true);
          case '_init':
          case 'reload':
          case 'query':
            {
              const ajaxMethods = ajax.query;
              if (ajaxMethods) {
                const isInited = code === '_init';
                const isReload = code === 'reload';
                let sortList = [];
                let filterList = [];
                let pageParams = {};
                if (pagerConfig) {
                  if (isInited || isReload) {
                    tablePage.currentPage = 1;
                  }
                  if (isEnableConf(pagerOpts)) {
                    pageParams = {
                      ...tablePage
                    };
                  }
                }
                if (isInited) {
                  const {
                    computeSortOpts
                  } = $xetable.getComputeMaps();
                  const sortOpts = computeSortOpts.value;
                  let defaultSort = sortOpts.defaultSort;
                  // 如果使用默认排序
                  if (defaultSort) {
                    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(defaultSort)) {
                      defaultSort = [defaultSort];
                    }
                    sortList = defaultSort.map(item => {
                      return {
                        field: item.field,
                        property: item.field,
                        order: item.order
                      };
                    });
                  }
                  filterList = $xetable.getCheckedFilters();
                } else {
                  if (isReload) {
                    $xetable.clearAll();
                  } else {
                    sortList = $xetable.getSortColumns();
                    filterList = $xetable.getCheckedFilters();
                  }
                }
                const commitParams = {
                  code,
                  button,
                  isInited,
                  isReload,
                  $grid: $xegrid,
                  page: pageParams,
                  sort: sortList.length ? sortList[0] : {},
                  sorts: sortList,
                  filters: filterList,
                  form: formData,
                  options: ajaxMethods
                };
                reactData.sortData = sortList;
                reactData.filterData = filterList;
                reactData.tableLoading = true;
                const applyArgs = [commitParams].concat(args);
                return Promise.resolve((beforeQuery || ajaxMethods)(...applyArgs)).then(rest => {
                  reactData.tableLoading = false;
                  if (rest) {
                    if (pagerConfig && isEnableConf(pagerOpts)) {
                      const totalProp = resConfigs.total;
                      const total = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(totalProp) ? totalProp({
                        data: rest,
                        $grid: $xegrid
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, totalProp || 'page.total')) || 0;
                      tablePage.total = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(total);
                      const resultProp = resConfigs.result;
                      reactData.tableData = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(resultProp) ? resultProp({
                        data: rest,
                        $grid: $xegrid
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, resultProp || 'result')) || [];
                      // 检验当前页码，不能超出当前最大页数
                      const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                      if (tablePage.currentPage > pageCount) {
                        tablePage.currentPage = pageCount;
                      }
                    } else {
                      const listProp = resConfigs.list;
                      reactData.tableData = (listProp ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(listProp) ? listProp({
                        data: rest,
                        $grid: $xegrid
                      }) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(rest, listProp) : rest) || [];
                    }
                  } else {
                    reactData.tableData = [];
                  }
                  if (afterQuery) {
                    afterQuery(...applyArgs);
                  }
                  return {
                    status: true
                  };
                }).catch(() => {
                  reactData.tableLoading = false;
                  return {
                    status: false
                  };
                });
              } else {
                if (true) {
                  errLog('vxe.error.notFunc', ['proxy-config.ajax.query']);
                }
              }
              break;
            }
          case 'delete':
            {
              const ajaxMethods = ajax.delete;
              if (ajaxMethods) {
                const selectRecords = gridExtendTableMethods.getCheckboxRecords();
                const removeRecords = selectRecords.filter(row => !$xetable.isInsertByRow(row));
                const body = {
                  removeRecords
                };
                const commitParams = {
                  $grid: $xegrid,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                const applyArgs = [commitParams].concat(args);
                if (selectRecords.length) {
                  return handleDeleteRow(code, 'vxe.grid.deleteSelectRecord', () => {
                    if (!removeRecords.length) {
                      return $xetable.remove(selectRecords);
                    }
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeDelete || ajaxMethods)(...applyArgs)).then(rest => {
                      reactData.tableLoading = false;
                      $xetable.setPendingRow(removeRecords, false);
                      if (isMsg) {
                        // 检测弹窗模块
                        if (true) {
                          if (!VXETable.modal) {
                            errLog('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        VXETable.modal.message({
                          content: getRespMsg(rest, 'vxe.grid.delSuccess'),
                          status: 'success'
                        });
                      }
                      if (afterDelete) {
                        afterDelete(...applyArgs);
                      } else {
                        gridMethods.commitProxy('query');
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isMsg) {
                        if (true) {
                          if (!VXETable.modal.message) {
                            errLog('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        VXETable.modal.message({
                          id: code,
                          content: getRespMsg(rest, 'vxe.grid.operError'),
                          status: 'error'
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  });
                } else {
                  if (isMsg) {
                    // 检测弹窗模块
                    if (true) {
                      if (!VXETable.modal) {
                        errLog('vxe.error.reqModule', ['Modal']);
                      }
                    }
                    VXETable.modal.message({
                      id: code,
                      content: conf.i18n('vxe.grid.selectOneRecord'),
                      status: 'warning'
                    });
                  }
                }
              } else {
                if (true) {
                  errLog('vxe.error.notFunc', ['proxy-config.ajax.delete']);
                }
              }
              break;
            }
          case 'save':
            {
              const ajaxMethods = ajax.save;
              if (ajaxMethods) {
                const body = $xetable.getRecordset();
                const {
                  insertRecords,
                  removeRecords,
                  updateRecords,
                  pendingRecords
                } = body;
                const commitParams = {
                  $grid: $xegrid,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                const applyArgs = [commitParams].concat(args);
                // 排除掉新增且标记为删除的数据
                if (insertRecords.length) {
                  body.pendingRecords = pendingRecords.filter(row => $xetable.findRowIndexOf(insertRecords, row) === -1);
                }
                // 排除已标记为删除的数据
                if (pendingRecords.length) {
                  body.insertRecords = insertRecords.filter(row => $xetable.findRowIndexOf(pendingRecords, row) === -1);
                }
                let restPromise = Promise.resolve();
                if (editRules) {
                  // 只校验新增和修改的数据
                  restPromise = $xetable[validConfig && validConfig.msgMode === 'full' ? 'fullValidate' : 'validate'](body.insertRecords.concat(updateRecords));
                }
                return restPromise.then(errMap => {
                  if (errMap) {
                    // 如果校验不通过
                    return;
                  }
                  if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeSave || ajaxMethods)(...applyArgs)).then(rest => {
                      reactData.tableLoading = false;
                      $xetable.clearPendingRow();
                      if (isMsg) {
                        // 检测弹窗模块
                        if (true) {
                          if (!VXETable.modal) {
                            errLog('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        VXETable.modal.message({
                          content: getRespMsg(rest, 'vxe.grid.saveSuccess'),
                          status: 'success'
                        });
                      }
                      if (afterSave) {
                        afterSave(...applyArgs);
                      } else {
                        gridMethods.commitProxy('query');
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isMsg) {
                        // 检测弹窗模块
                        if (true) {
                          if (!VXETable.modal) {
                            errLog('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        VXETable.modal.message({
                          id: code,
                          content: getRespMsg(rest, 'vxe.grid.operError'),
                          status: 'error'
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  } else {
                    if (isMsg) {
                      // 检测弹窗模块
                      if (true) {
                        if (!VXETable.modal) {
                          errLog('vxe.error.reqModule', ['Modal']);
                        }
                      }
                      VXETable.modal.message({
                        id: code,
                        content: conf.i18n('vxe.grid.dataUnchanged'),
                        status: 'info'
                      });
                    }
                  }
                });
              } else {
                if (true) {
                  errLog('vxe.error.notFunc', ['proxy-config.ajax.save']);
                }
              }
              break;
            }
          default:
            {
              const gCommandOpts = VXETable.commands.get(code);
              if (gCommandOpts) {
                if (gCommandOpts.commandMethod) {
                  gCommandOpts.commandMethod({
                    code,
                    button,
                    $grid: $xegrid,
                    $table: $xetable
                  }, ...args);
                } else {
                  if (true) {
                    errLog('vxe.error.notCommands', [code]);
                  }
                }
              }
            }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const {
          formConfig
        } = props;
        const {
          items
        } = formOpts;
        const itemList = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], item => {
          itemList.push(item);
        }, {
          children: 'children'
        });
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xetable = refTable.value;
        if (props.proxyConfig) {
          const {
            sortData
          } = reactData;
          return {
            data: reactData.tableData,
            filter: reactData.filterData,
            form: reactData.formData,
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xetable ? $xetable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    // 检查插槽
    if (true) {
      gridMethods.loadColumn = columns => {
        const $xetable = refTable.value;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(columns, column => {
          if (column.slots) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(column.slots, func => {
              if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                if (!slots[func]) {
                  errLog('vxe.error.notSlot', [func]);
                }
              }
            });
          }
        });
        if ($xetable) {
          return $xetable.loadColumn(columns);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      };
      gridMethods.reloadColumn = columns => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const {
          height
        } = props;
        const {
          isZMax
        } = reactData;
        const el = refElem.value;
        const formWrapper = refFormWrapper.value;
        const toolbarWrapper = refToolbarWrapper.value;
        const topWrapper = refTopWrapper.value;
        const bottomWrapper = refBottomWrapper.value;
        const pagerWrapper = refPagerWrapper.value;
        const parentPaddingSize = isZMax || height !== 'auto' ? 0 : getPaddingTopBottomSize(el.parentNode);
        return parentPaddingSize + getPaddingTopBottomSize(el) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
      },
      getParentHeight() {
        const el = refElem.value;
        if (el) {
          return (reactData.isZMax ? getDomNode().visibleHeight : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(el.parentNode).height)) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const {
          code
        } = params;
        return gridMethods.commitProxy(params, evnt).then(rest => {
          if (code && rest && rest.status && ['query', 'reload', 'delete', 'save'].includes(code)) {
            gridMethods.dispatchEvent(code === 'delete' || code === 'save' ? `proxy-${code}` : 'proxy-query', {
              ...rest,
              isReload: code === 'reload'
            }, evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent('toolbar-button-click', {
          code: button.code,
          button
        }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent('toolbar-tool-click', {
          code: tool.code,
          tool,
          $event: evnt
        });
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent('zoom', {
          type: reactData.isZMax ? 'max' : 'revert'
        }, evnt);
      }
    };
    Object.assign($xegrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns, () => {
      columnFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(columnFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => $xegrid.loadColumn(props.columns || []));
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.toolbarConfig, () => {
      initToolbar();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.pagerConfig, () => {
      initPages();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.proxyConfig, () => {
      initProxy();
    });
    const handleGlobalKeydownEvent = evnt => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    VXETable.hooks.forEach(options => {
      const {
        setupGrid
      } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xegrid);
        if (hookRest && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(hookRest)) {
          Object.assign($xegrid, hookRest);
        }
      }
    });
    initPages();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          data,
          columns,
          proxyConfig
        } = props;
        const proxyOpts = computeProxyOpts.value;
        const formOpts = computeFormOpts.value;
        if (isEnableConf(proxyConfig) && (data || proxyOpts.form && formOpts.data)) {
          errLog('vxe.error.errConflicts', ['grid.data', 'grid.proxy-config']);
        }
        // if (process.env.VUE_APP_VXE_TABLE_ENV === 'development') {
        //   if (proxyOpts.props) {
        //     warnLog('vxe.error.delProp', ['proxy-config.props', 'proxy-config.response'])
        //   }
        // }
        if (columns && columns.length) {
          $xegrid.loadColumn(columns);
        }
        initToolbar();
      });
      GlobalEvent.on($xegrid, 'keydown', handleGlobalKeydownEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      GlobalEvent.off($xegrid, 'keydown');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      initProxy();
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-grid', {
          [`size--${vSize}`]: vSize,
          'is--animat': !!props.animat,
          'is--round': props.round,
          'is--maximize': reactData.isZMax,
          'is--loading': props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xegrid.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xegrid', $xegrid);
    return $xegrid;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/grid/index.ts


const VxeGrid = Object.assign(grid, {
  install(app) {
    app.component(grid.name, grid);
  }
});
const Grid = VxeGrid;
dynamicApp.component(grid.name, grid);
/* harmony default export */ var packages_grid = ((/* unused pure expression or super */ null && (VxeGrid)));
;// CONCATENATED MODULE: ./packages/checkbox/index.ts


const VxeCheckbox = Object.assign(src_checkbox, {
  install(app) {
    app.component(src_checkbox.name, src_checkbox);
  }
});
const Checkbox = VxeCheckbox;
dynamicApp.component(src_checkbox.name, src_checkbox);
/* harmony default export */ var packages_checkbox = ((/* unused pure expression or super */ null && (VxeCheckbox)));
;// CONCATENATED MODULE: ./packages/checkbox/src/group.ts






/* harmony default export */ var checkbox_src_group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeCheckboxGroup',
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: Boolean,
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => conf.checkboxGroup.size || conf.size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        max
      } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    const computeMaps = {
      computeIsMaximize
    };
    const $xecheckboxgroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const checkboxGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $checkboxGroup: $xecheckboxgroup,
          $event: evnt
        }, params));
      }
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const {
          checked,
          label
        } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit('update:modelValue', checklist);
        $xecheckboxgroup.dispatchEvent('change', Object.assign({
          checklist
        }, params), evnt);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xecheckboxgroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const {
        options
      } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-checkbox-group'
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    $xecheckboxgroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xecheckboxgroup', $xecheckboxgroup);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox-group/index.ts


const VxeCheckboxGroup = Object.assign(checkbox_src_group, {
  install(app) {
    app.component(checkbox_src_group.name, checkbox_src_group);
  }
});
const CheckboxGroup = VxeCheckboxGroup;
dynamicApp.component(checkbox_src_group.name, checkbox_src_group);
/* harmony default export */ var checkbox_group = ((/* unused pure expression or super */ null && (VxeCheckboxGroup)));
;// CONCATENATED MODULE: ./packages/radio/index.ts


const VxeRadio = Object.assign(src_radio, {
  install: function (app) {
    app.component(src_radio.name, src_radio);
  }
});
const Radio = VxeRadio;
dynamicApp.component(src_radio.name, src_radio);
/* harmony default export */ var packages_radio = ((/* unused pure expression or super */ null && (VxeRadio)));
;// CONCATENATED MODULE: ./packages/radio-group/index.ts


const VxeRadioGroup = Object.assign(group, {
  install: function (app) {
    app.component(group.name, group);
  }
});
const RadioGroup = VxeRadioGroup;
dynamicApp.component(group.name, group);
/* harmony default export */ var radio_group = ((/* unused pure expression or super */ null && (VxeRadioGroup)));
;// CONCATENATED MODULE: ./packages/radio-button/index.ts


const VxeRadioButton = Object.assign(radio_src_button, {
  install: function (app) {
    app.component(radio_src_button.name, radio_src_button);
  }
});
const RadioButton = VxeRadioButton;
dynamicApp.component(radio_src_button.name, radio_src_button);
/* harmony default export */ var radio_button = ((/* unused pure expression or super */ null && (VxeRadioButton)));
;// CONCATENATED MODULE: ./packages/input/index.ts


const VxeInput = Object.assign(input, {
  install(app) {
    app.component(input.name, input);
  }
});
const Input = VxeInput;
dynamicApp.component(input.name, input);
/* harmony default export */ var packages_input = ((/* unused pure expression or super */ null && (VxeInput)));
;// CONCATENATED MODULE: ./packages/textarea/src/textarea.ts





let autoTxtElem;
/* harmony default export */ var src_textarea = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeTextarea',
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(conf.textarea.placeholder) ? conf.i18n('vxe.base.pleaseInput') : conf.textarea.placeholder
    },
    maxlength: [String, Number],
    rows: {
      type: [String, Number],
      default: 2
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => conf.textarea.resize
    },
    size: {
      type: String,
      default: () => conf.textarea.size || conf.size
    }
  },
  emits: ['update:modelValue', 'input', 'keydown', 'keyup', 'click', 'change', 'focus', 'blur'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTextarea = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xetextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      return props.maxlength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.maxlength);
    });
    const computeSizeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        minRows: 1,
        maxRows: 10
      }, conf.textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const {
        size,
        autosize
      } = props;
      const {
        inputValue
      } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement('div');
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ['vxe-textarea--autosize', size ? `size--${size}` : ''].join(' ');
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ('' + (inputValue || '　')).replace(/\n$/, '\n　');
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const sizeOpts = computeSizeOpts.value;
          const {
            minRows,
            maxRows
          } = sizeOpts;
          const textElem = refTextarea.value;
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.lineHeight);
          const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingTop);
          const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingBottom);
          const borderTopWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test('' + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent = evnt => {
      const value = reactData.inputValue;
      $xetextarea.dispatchEvent(evnt.type, {
        value
      }, evnt);
    };
    const emitUpdate = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = evnt => {
      const {
        immediate
      } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        emitUpdate(value, evnt);
      }
      $xetextarea.dispatchEvent('input', {
        value
      }, evnt);
      handleResize();
    };
    const changeEvent = evnt => {
      const {
        immediate
      } = props;
      if (immediate) {
        triggerEvent(evnt);
      } else {
        emitUpdate(reactData.inputValue, evnt);
      }
    };
    const blurEvent = evnt => {
      const {
        immediate
      } = props;
      const {
        inputValue
      } = reactData;
      if (!immediate) {
        emitUpdate(inputValue, evnt);
      }
      $xetextarea.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $textarea: $xetextarea,
          $event: evnt
        }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xetextarea, textareaMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const {
        autosize
      } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const {
        className,
        resize,
        placeholder,
        disabled,
        maxlength,
        autosize,
        showWordCount,
        countMethod,
        rows,
        cols
      } = props;
      const {
        inputValue
      } = reactData;
      const vSize = computeSize.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-textarea', className, {
          [`size--${vSize}`]: vSize,
          'is--autosize': autosize,
          'is--count': showWordCount,
          'is--disabled': disabled,
          'def--rows': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rows),
          'def--cols': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cols)
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('textarea', {
        ref: refTextarea,
        class: 'vxe-textarea--inner',
        value: inputValue,
        name: props.name,
        placeholder: placeholder ? getFuncText(placeholder) : null,
        maxlength,
        readonly: props.readonly,
        disabled,
        rows,
        cols,
        style: resize ? {
          resize
        } : null,
        onInput: inputEvent,
        onChange: changeEvent,
        onKeydown: triggerEvent,
        onKeyup: triggerEvent,
        onClick: triggerEvent,
        onFocus: triggerEvent,
        onBlur: blurEvent
      }), showWordCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-textarea--count', {
          'is--error': isCountError
        }]
      }, countMethod ? `${countMethod({
        value: inputValue
      })}` : `${inputCount}${maxlength ? `/${maxlength}` : ''}`) : null]);
    };
    $xetextarea.renderVN = renderVN;
    return $xetextarea;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/textarea/index.ts


const VxeTextarea = Object.assign(src_textarea, {
  install: function (app) {
    app.component(src_textarea.name, src_textarea);
  }
});
const Textarea = VxeTextarea;
dynamicApp.component(src_textarea.name, src_textarea);
/* harmony default export */ var packages_textarea = ((/* unused pure expression or super */ null && (VxeTextarea)));
;// CONCATENATED MODULE: ./packages/button/src/group.ts





/* harmony default export */ var button_src_group = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeButtonGroup',
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    size: {
      type: String,
      default: () => conf.buttonGroup.size || conf.size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeMaps = {};
    const $xebuttongroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $buttonGroup: $xebuttongroup,
          $event: evnt
        }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const {
          options
        } = props;
        const {
          name
        } = params;
        const option = options ? options.find(item => item.name === name) : null;
        buttonGroupMethods.dispatchEvent('click', {
          ...params,
          option
        }, evnt);
      }
    };
    Object.assign($xebuttongroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const {
        className,
        options
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-button-group', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $buttonGroup: $xebuttongroup
        }) : className : '']
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: index,
          ...item
        });
      }) : []);
    };
    $xebuttongroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xebuttongroup', $xebuttongroup);
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/button-group/index.ts


const VxeButtonGroup = Object.assign(button_src_group, {
  install(app) {
    app.component(button_src_group.name, button_src_group);
  }
});
const ButtonGroup = VxeButtonGroup;
dynamicApp.component(button_src_group.name, button_src_group);
/* harmony default export */ var button_group = ((/* unused pure expression or super */ null && (VxeButtonGroup)));
;// CONCATENATED MODULE: ./packages/modal/index.ts





function openModal(options) {
  // 使用动态组件渲染动态弹框
  checkDynamic();
  return new Promise(resolve => {
    if (options && options.id && allActiveModals.some(comp => comp.props.id === options.id)) {
      resolve('exist');
    } else {
      const _onHide = options.onHide;
      const modalOpts = Object.assign(options, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter(item => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveModals, $modal => $modal.props.id === id);
}
/**
 * 全局关闭动态的活动窗口（只能用于关闭动态的创建的活动窗口）
 * 如果传 id 则关闭指定的窗口
 * 如果不传则关闭所有窗口
 */
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach($modal => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(content)) {
    opts = content;
  } else {
    opts = {
      content: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content),
      title
    };
  }
  return openModal({
    ...defOpts,
    ...options,
    ...opts
  });
}
function openAlert(content, title, options) {
  return handleOpen({
    type: 'alert',
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: 'confirm',
    status: 'question',
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: 'message',
    mask: false,
    lockView: false,
    showHeader: false
  }, content, '', options);
}
const ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage
};
const modal_modal = ModalController;
const VxeModal = Object.assign(modal, {
  install: function (app) {
    app.component(modal.name, modal);
    VXETable.modal = ModalController;
  }
});
const Modal = VxeModal;
dynamicApp.component(modal.name, modal);
/* harmony default export */ var packages_modal = ((/* unused pure expression or super */ null && (VxeModal)));
;// CONCATENATED MODULE: ./packages/drawer/src/modal.ts










const allActiveDrawers = [];
/* harmony default export */ var src_modal = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeDrawer',
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: [String, Object],
    lockView: {
      type: Boolean,
      default: () => conf.drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => conf.drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => conf.drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => conf.drawer.escClosable
    },
    showHeader: {
      type: Boolean,
      default: () => conf.drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => conf.drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => conf.drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => conf.drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => conf.drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => conf.drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => conf.drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => conf.drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => conf.drawer.transfer
    },
    size: {
      type: String,
      default: () => conf.drawer.size || conf.size
    },
    beforeHideMethod: {
      type: Function,
      default: () => conf.drawer.beforeHideMethod
    },
    slots: Number
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDrawerBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      firstOpen: true
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ''}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ''}`;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        drawerZIndex
      } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {});
    };
    const closeDrawer = type => {
      const {
        beforeHideMethod
      } = props;
      const {
        visible
      } = reactData;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            reactData.contentVisible = false;
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveDrawers, item => item === $xeDrawer);
            drawerMethods.dispatchEvent('before-hide', params);
            setTimeout(() => {
              reactData.visible = false;
              emit('update:modelValue', false);
              drawerMethods.dispatchEvent('hide', params);
            }, 200);
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      drawerMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const confirmEvent = evnt => {
      const type = 'confirm';
      drawerMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const cancelEvent = evnt => {
      const type = 'cancel';
      drawerMethods.dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const openDrawer = () => {
      const {
        showFooter
      } = props;
      const {
        inited,
        visible
      } = reactData;
      if (!inited) {
        reactData.inited = true;
      }
      if (!visible) {
        recalculate();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emit('update:modelValue', true);
            drawerMethods.dispatchEvent('show', params);
          });
        }, 10);
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const {
            firstOpen
          } = reactData;
          if (firstOpen) {
            updatePosition().then(() => {
              setTimeout(() => updatePosition(), 20);
            });
          }
          if (firstOpen) {
            reactData.firstOpen = false;
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const drawerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $drawer: $xeDrawer,
          $event: evnt
        }, params));
      },
      open: openDrawer,
      close() {
        return closeDrawer('close');
      },
      getBox
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeDrawer(type);
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveDrawers, item => item.reactData.drawerZIndex);
        // 多个时，只关掉最上层的窗口
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              closeDrawer('exit');
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const {
        drawerZIndex
      } = reactData;
      if (allActiveDrawers.some(comp => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        title
      } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const titVNs = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-title'
      }, titleSlot ? getSlotVNs(titleSlot({
        $drawer: $xeDrawer
      })) : title ? getFuncText(title) : conf.i18n('vxe.alert.title'))];
      const rightVNs = [];
      if (cornerSlot) {
        rightVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-drawer--corner-wrapper'
        }, getSlotVNs(cornerSlot({
          $drawer: $xeDrawer
        }))));
      }
      if (showClose) {
        rightVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-drawer--close-btn', 'trigger--btn', conf.icon.MODAL_CLOSE],
          title: conf.i18n('vxe.drawer.close'),
          onClick: closeEvent
        }));
      }
      titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-right'
      }, rightVNs));
      return titVNs;
    };
    const renderHeader = () => {
      const {
        slots: propSlots = {},
        showTitleOverflow
      } = props;
      const headerSlot = slots.header || propSlots.header;
      const headVNs = [];
      if (props.showHeader) {
        headVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-drawer--header', {
            'is--ellipsis': showTitleOverflow
          }]
        }, headerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(headerSlot({
          $drawer: $xeDrawer
        })) : renderTitles()));
      }
      return headVNs;
    };
    const renderBody = () => {
      const {
        slots: propSlots = {},
        content
      } = props;
      const defaultSlot = slots.default || propSlots.default;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--content'
      }, defaultSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(defaultSlot({
        $drawer: $xeDrawer
      })) : getFuncText(content)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
        class: 'vxe-drawer--loading',
        modelValue: props.loading
      })])];
    };
    const renderBtns = () => {
      const {
        showCancelButton,
        showConfirmButton
      } = props;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || conf.i18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          status: 'primary',
          content: props.confirmButtonText || conf.i18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return btnVNs;
    };
    const renderFooter = () => {
      const {
        slots: propSlots = {}
      } = props;
      const footerSlot = slots.footer || propSlots.footer;
      const footVNs = [];
      if (props.showFooter) {
        footVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-drawer--footer'
        }, footerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(footerSlot({
          $drawer: $xeDrawer
        })) : renderBtns()));
      }
      return footVNs;
    };
    const renderVN = () => {
      const {
        className,
        position,
        loading,
        lockScroll,
        lockView,
        mask
      } = props;
      const {
        inited,
        contentVisible,
        visible
      } = reactData;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: props.transfer ? !inited : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-drawer--wrapper', `pos--${position}`, className || '', {
          [`size--${vSize}`]: vSize,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--mask': mask,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.drawerZIndex
        },
        onClick: selfClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDrawerBox,
        class: 'vxe-drawer--box',
        onMousedown: boxMousedownEvent
      }, renderHeader().concat(renderBody(), renderFooter()))])]);
    };
    $xeDrawer.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openDrawer();
      } else {
        closeDrawer('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.modelValue) {
          openDrawer();
        }
        recalculate();
      });
      if (props.escClosable) {
        GlobalEvent.on($xeDrawer, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      GlobalEvent.off($xeDrawer, 'keydown');
    });
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/drawer/index.ts





function openDrawer(options) {
  // 使用动态组件渲染动态弹框
  checkDynamic();
  return new Promise(resolve => {
    if (options && options.id && allActiveDrawers.some(comp => comp.props.id === options.id)) {
      resolve('exist');
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter(item => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveDrawers, $drawer => $drawer.props.id === id);
}
/**
 * 全局关闭动态的活动窗口（只能用于关闭动态的创建的活动窗口）
 * 如果传 id 则关闭指定的窗口
 * 如果不传则关闭所有窗口
 */
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach($drawer => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
const DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
const drawer = DrawerController;
const VxeDrawer = Object.assign(src_modal, {
  install: function (app) {
    app.component(src_modal.name, src_modal);
    VXETable.drawer = DrawerController;
  }
});
dynamicApp.component(src_modal.name, src_modal);
const Drawer = VxeDrawer;
/* harmony default export */ var packages_drawer = ((/* unused pure expression or super */ null && (VxeDrawer)));
;// CONCATENATED MODULE: ./packages/form/src/form-item.ts









const formItemProps = {
  title: String,
  field: String,
  span: [String, Number],
  align: String,
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: {
    default: null
  },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
/* harmony default export */ var form_item = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormItem',
  props: formItemProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', {});
    const formGather = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformgather', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeform, props));
    const xeformitem = {
      formItem
    };
    const xeformiteminfo = {
      itemConfig: formItem
    };
    formItem.slots = slots;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformiteminfo', xeformiteminfo);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformitem', xeformitem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformgather', null);
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeform, formItem);
    });
    const renderItem = ($xeform, item) => {
      const {
        props,
        reactData
      } = $xeform;
      const {
        data,
        rules,
        titleAlign: allTitleAlign,
        titleWidth: allTitleWidth,
        titleColon: allTitleColon,
        titleAsterisk: allTitleAsterisk,
        titleOverflow: allTitleOverflow,
        vertical: allVertical
      } = props;
      const {
        collapseAll
      } = reactData;
      const {
        computeValidOpts
      } = $xeform.getComputeMaps();
      const validOpts = computeValidOpts.value;
      const {
        slots,
        title,
        visible,
        folding,
        field,
        collapseNode,
        itemRender,
        showError,
        errRule,
        className,
        titleOverflow,
        vertical,
        showTitle,
        contentClassName,
        contentStyle,
        titleClassName,
        titleStyle
      } = item;
      const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.itemClassName : '';
      const itemStyle = compConf ? compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.itemContentClassName : '';
      const itemContentStyle = compConf ? compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.itemTitleClassName : '';
      const itemTitleStyle = compConf ? compConf.itemTitleStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const titleSlot = slots ? slots.title : null;
      const span = item.span || props.span;
      const align = item.align || props.align;
      const titleAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(titleOverflow) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(vertical) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNull(vertical) ? allVertical : vertical;
      const ovEllipsis = itemOverflow === 'ellipsis';
      const ovTitle = itemOverflow === 'title';
      const ovTooltip = itemOverflow === true || itemOverflow === 'tooltip';
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = {
        data,
        field,
        property: field,
        item,
        $form: $xeform,
        $grid: $xeform.xegrid
      };
      let isRequired = false;
      if (visible === false) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      if (rules) {
        const itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some(rule => rule.required);
        }
      }
      let contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = [`${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field)}`];
      }
      if (collapseNode) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-trigger-node',
          onClick: $xeform.toggleCollapseEvent
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-form--item-trigger-text'
        }, collapseAll ? conf.i18n('vxe.form.unfolding') : conf.i18n('vxe.form.folding')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-form--item-trigger-icon', collapseAll ? conf.icon.FORM_FOLDING : conf.icon.FORM_UNFOLDING]
        })]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-form--item-valid',
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.message));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeform.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform.handleTitleTipLeaveEvent
      } : {};
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-form--item', item.id, span ? `vxe-form--item-col--${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '', itemClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemClassName) ? itemClassName(params) : itemClassName : '', {
          'is--title': title,
          'is--colon': titleColon,
          'is--vertical': itemVertical,
          'is--asterisk': titleAsterisk,
          'is--required': isRequired,
          'is--hidden': folding && collapseAll,
          'is--active': isActivetem($xeform, item),
          'is--error': showError
        }],
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--item-inner'
      }, [showTitle !== false && (title || titleSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-title', titleAlign ? `align--${titleAlign}` : '', hasEllipsis ? 'is--ellipsis' : '', itemTitleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : '', titleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleClassName) ? titleClassName(params) : titleClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
          width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
        } : null),
        title: ovTitle ? getFuncText(title) : null,
        ...ons
      }, renderTitle($xeform, item)) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-form--item-content', align ? `align--${align}` : '', itemContentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : '', contentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentClassName) ? contentClassName(params) : contentClassName : ''],
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, contentVNs)])]);
    };
    const renderVN = () => {
      const formProps = $xeform ? $xeform.props : null;
      return formProps && formProps.customLayout ? renderItem($xeform, formItem) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    const $xeformitem = {
      renderVN
    };
    return $xeformitem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-item/index.ts


const VxeFormItem = Object.assign(form_item, {
  install(app) {
    app.component(form_item.name, form_item);
  }
});
const FormItem = VxeFormItem;
dynamicApp.component(form_item.name, form_item);
/* harmony default export */ var packages_form_item = ((/* unused pure expression or super */ null && (VxeFormItem)));
;// CONCATENATED MODULE: ./packages/form/src/form-gather.ts




/* harmony default export */ var form_gather = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeFormGather',
  props: formItemProps,
  setup(props, {
    slots
  }) {
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', {});
    const formGather = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformgather', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeform, props));
    const xeformitem = {
      formItem
    };
    const xeformiteminfo = {
      itemConfig: formItem
    };
    formItem.children = [];
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformiteminfo', xeformiteminfo);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformgather', xeformitem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeformitem', null);
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeform, formItem);
    });
    const renderVN = () => {
      const {
        className,
        field
      } = props;
      const span = props.span || ($xeform ? $xeform.props.span : null);
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-form--gather vxe-form--item-row', formItem.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $form: $xeform,
          data: $xeform ? $xeform.props.data : {},
          item: formItem,
          field: field,
          property: field
        }) : className : '']
      }, defaultSlot ? defaultSlot() : []);
    };
    const $xeformgather = {
      renderVN
    };
    return $xeformgather;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-gather/index.ts


const VxeFormGather = Object.assign(form_gather, {
  install(app) {
    app.component(form_gather.name, form_gather);
  }
});
const FormGather = VxeFormGather;
dynamicApp.component(form_gather.name, form_gather);
/* harmony default export */ var packages_form_gather = ((/* unused pure expression or super */ null && (VxeFormGather)));
;// CONCATENATED MODULE: ./packages/select/src/optionInfo.ts

class OptionInfo {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('option_'),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/select/src/util.ts



function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeselect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeselect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      option.update(name, value);
    });
  });
}
function assemOption($xeselect, el, option, optgroup) {
  const {
    reactData
  } = $xeselect;
  const {
    staticOptions
  } = reactData;
  const parentElem = el.parentNode;
  const parentOption = optgroup ? optgroup.option : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeselect, option) {
  const {
    reactData
  } = $xeselect;
  const {
    staticOptions
  } = reactData;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticOptions, item => item.id === option.id, {
    children: 'options'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}
;// CONCATENATED MODULE: ./packages/select/src/optgroup.ts


/* harmony default export */ var optgroup = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeOptgroup',
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeselect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeselect', {});
    const option = createOption($xeselect, props);
    const xeoption = {
      option
    };
    option.options = [];
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeoptgroup', xeoption);
    watchOption(props, option);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assemOption($xeselect, elem.value, option);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeselect, option);
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      }, slots.default ? slots.default() : []);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/optgroup/index.ts


const VxeOptgroup = Object.assign(optgroup, {
  install: function (app) {
    app.component(optgroup.name, optgroup);
  }
});
const Optgroup = VxeOptgroup;
dynamicApp.component(optgroup.name, optgroup);
/* harmony default export */ var packages_optgroup = ((/* unused pure expression or super */ null && (VxeOptgroup)));
;// CONCATENATED MODULE: ./packages/select/src/option.ts


/* harmony default export */ var src_option = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeOption',
  props: {
    value: null,
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeselect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeselect', {});
    const optgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeoptgroup', null);
    const option = createOption($xeselect, props);
    option.slots = slots;
    watchOption(props, option);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      assemOption($xeselect, elem.value, option, optgroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeselect, option);
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      });
    };
  }
}));
;// CONCATENATED MODULE: ./packages/option/index.ts


const VxeOption = Object.assign(src_option, {
  install: function (app) {
    app.component(src_option.name, src_option);
  }
});
const Option = VxeOption;
dynamicApp.component(src_option.name, src_option);
/* harmony default export */ var packages_option = ((/* unused pure expression or super */ null && (VxeOption)));
;// CONCATENATED MODULE: ./packages/switch/src/switch.ts





/* harmony default export */ var src_switch = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeSwitch',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    size: {
      type: String,
      default: () => conf.switch.size || conf.size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: ['update:modelValue', 'change', 'focus', 'blur'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeform', null);
    const $xeformiteminfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeformiteminfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const $xeswitch = {
      xID,
      props,
      context,
      reactData
    };
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let switchMethods = {};
    const computeOnShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.modelValue === props.openValue;
    });
    let _atimeout;
    const clickEvent = evnt => {
      if (!props.disabled) {
        const isChecked = computeIsChecked.value;
        clearTimeout(_atimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emit('update:modelValue', value);
        switchMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
        _atimeout = setTimeout(() => {
          reactData.hasAnimat = false;
        }, 400);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent('focus', {
        value: props.modelValue
      }, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent('blur', {
        value: props.modelValue
      }, evnt);
    };
    switchMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $switch: $xeswitch,
          $event: evnt
        }, params));
      },
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        btnElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeswitch, switchMethods);
    const renderVN = () => {
      const {
        disabled,
        openIcon,
        closeIcon,
        openActiveIcon,
        closeActiveIcon
      } = props;
      const isChecked = computeIsChecked.value;
      const vSize = computeSize.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-switch', isChecked ? 'is--on' : 'is--off', {
          [`size--${vSize}`]: vSize,
          'is--disabled': disabled,
          'is--animat': reactData.hasAnimat
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: 'vxe-switch--button',
        type: 'button',
        disabled,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-on'
      }, [openIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', openIcon]
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), onShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-off'
      }, [closeIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', closeIcon]
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), offShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--icon'
      }, openActiveIcon || closeActiveIcon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isChecked ? openActiveIcon : closeActiveIcon
      })] : [])])]);
    };
    $xeswitch.renderVN = renderVN;
    return $xeswitch;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/switch/index.ts


const VxeSwitch = Object.assign(src_switch, {
  install: function (app) {
    app.component(src_switch.name, src_switch);
  }
});
const Switch = VxeSwitch;
dynamicApp.component(src_switch.name, src_switch);
/* harmony default export */ var packages_switch = ((/* unused pure expression or super */ null && (VxeSwitch)));
;// CONCATENATED MODULE: ./packages/list/src/list.ts








/* harmony default export */ var list = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxeList',
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: {
      type: String,
      default: () => conf.list.size || conf.size
    },
    autoResize: {
      type: Boolean,
      default: () => conf.list.autoResize
    },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: ['scroll'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      scrollYLoad: false,
      bodyHeight: 0,
      rowHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const internalData = {
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refMaps = {
      refElem
    };
    const $xelist = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let listMethods = {};
    const computeSYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, conf.list.scrollY, props.scrollY);
    });
    const computeStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        maxHeight
      } = props;
      const style = {};
      if (height) {
        style.height = `${isNaN(height) ? height : `${height}px`}`;
      } else if (maxHeight) {
        style.height = 'auto';
        style.maxHeight = `${isNaN(maxHeight) ? maxHeight : `${maxHeight}px`}`;
      }
      return style;
    });
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        fullData
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        fullData,
        scrollYStore
      } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // 计算 Y 逻辑
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
        reactData.rowHeight = rowHeight;
      });
    };
    /**
     * 清除滚动条
     */
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 如果有滚动条，则滚动到对应的位置
     * @param {Number} scrollLeft 左距离
     * @param {Number} scrollTop 上距离
     */
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 刷新滚动条
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * 重新计算列表
     */
    const recalculate = () => {
      const el = refElem.value;
      if (el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = evnt => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      listMethods.dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    listMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $list: $xelist,
          $event: evnt
        }, params));
      },
      /**
       * 加载数据
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const {
          scrollYStore
        } = internalData;
        const sYOpts = computeSYOpts.value;
        const fullData = datas || [];
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 1,
          visibleSize: 0
        });
        internalData.fullData = fullData;
        // 如果gt为0，则总是启用
        reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
        handleData();
        return computeScrollLoad().then(() => {
          refreshScroll();
        });
      },
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return listMethods.loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xelist, listMethods);
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      listMethods.loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.syncResize, value => {
      if (value) {
        recalculate();
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => setTimeout(() => recalculate()));
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(() => {
      recalculate().then(() => refreshScroll());
    });
    let resizeObserver;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      GlobalEvent.on($xelist, 'resize', () => {
        recalculate();
      });
      if (props.autoResize) {
        const el = refElem.value;
        resizeObserver = createResizeEvent(() => recalculate());
        resizeObserver.observe(el);
      }
      listMethods.loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      GlobalEvent.off($xelist, 'resize');
    });
    const renderVN = () => {
      const {
        className,
        loading
      } = props;
      const {
        bodyHeight,
        topSpaceHeight,
        items
      } = reactData;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-list', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $list: $xelist
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-list--virtual-wrapper',
        style: styles,
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-list--body',
        style: {
          marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ''
        }
      }, slots.default ? slots.default({
        items,
        $list: $xelist
      }) : [])]),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(packages_loading, {
        class: 'vxe-list--loading',
        modelValue: loading
      })]);
    };
    $xelist.renderVN = renderVN;
    return $xelist;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/list/index.ts


const VxeList = Object.assign(list, {
  install(app) {
    app.component(list.name, list);
  }
});
const List = VxeList;
dynamicApp.component(list.name, list);
/* harmony default export */ var packages_list = ((/* unused pure expression or super */ null && (VxeList)));
;// CONCATENATED MODULE: ./packages/pulldown/src/pulldown.ts







/* harmony default export */ var pulldown = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: 'VxePulldown',
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    size: {
      type: String,
      default: () => conf.size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    destroyOnClose: Boolean,
    transfer: Boolean
  },
  emits: ['update:modelValue', 'hide-panel'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const computeSize = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inited: false,
      panelIndex: 0,
      panelStyle: null,
      panelPlacement: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldowContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldowPnanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xepulldown = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    /**
     * 手动更新位置
     */
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          transfer,
          placement
        } = props;
        const {
          panelIndex,
          visiblePanel
        } = reactData;
        if (visiblePanel) {
          const targetElem = refPulldowContent.value;
          const panelElem = refPulldowPnanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const {
              boundingTop,
              boundingLeft,
              visibleHeight,
              visibleWidth
            } = getAbsolutePos(targetElem);
            let panelPlacement = 'bottom';
            if (transfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === 'top') {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              } else if (!placement) {
                // 如果下面不够放，则向上
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = 'top';
                  top = boundingTop - panelHeight;
                }
                // 如果上面不够放，则向下（优先）
                if (top < marginSize) {
                  panelPlacement = 'bottom';
                  top = boundingTop + targetHeight;
                }
              }
              // 如果溢出右边
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              // 如果溢出左边
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === 'top') {
                panelPlacement = 'top';
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                // 如果下面不够放，则向上
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  // 如果上面不够放，则向下（优先）
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = 'top';
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      });
    };
    let hidePanelTimeout;
    /**
     * 显示下拉面板
     */
    const showPanel = () => {
      if (!reactData.inited) {
        reactData.inited = true;
      }
      return new Promise(resolve => {
        if (!props.disabled) {
          clearTimeout(hidePanelTimeout);
          reactData.isActivated = true;
          reactData.animatVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit('update:modelValue', true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * 隐藏下拉面板
     */
    const hidePanel = () => {
      reactData.visiblePanel = false;
      emit('update:modelValue', false);
      return new Promise(resolve => {
        if (reactData.animatVisible) {
          hidePanelTimeout = window.setTimeout(() => {
            reactData.animatVisible = false;
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 350);
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * 切换下拉面板
     */
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            pulldownMethods.dispatchEvent('hide-panel', {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const el = refElem.value;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          pulldownMethods.dispatchEvent('hide-panel', {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = evnt => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        pulldownMethods.dispatchEvent('hide-panel', {}, evnt);
      }
    };
    pulldownMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $pulldown: $xepulldown,
          $event: evnt
        }, params));
      },
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xepulldown, pulldownMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      GlobalEvent.on($xepulldown, 'mousewheel', handleGlobalMousewheelEvent);
      GlobalEvent.on($xepulldown, 'mousedown', handleGlobalMousedownEvent);
      GlobalEvent.on($xepulldown, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      GlobalEvent.off($xepulldown, 'mousewheel');
      GlobalEvent.off($xepulldown, 'mousedown');
      GlobalEvent.off($xepulldown, 'blur');
    });
    const renderVN = () => {
      const {
        className,
        popupClassName,
        destroyOnClose,
        transfer,
        disabled
      } = props;
      const {
        inited,
        isActivated,
        animatVisible,
        visiblePanel,
        panelStyle,
        panelPlacement
      } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pulldown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pulldown: $xepulldown
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visivle': visiblePanel,
          'is--disabled': disabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldowContent,
        class: 'vxe-pulldown--content'
      }, defaultSlot ? defaultSlot({
        $pulldown: $xepulldown
      }) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: transfer ? !inited : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldowPnanel,
        class: ['vxe-table--ignore-clear vxe-pulldown--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $pulldown: $xepulldown
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': transfer,
          'animat--leave': animatVisible,
          'animat--enter': visiblePanel
        }],
        placement: panelPlacement,
        style: panelStyle
      }, dropdownSlot ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-wrapper'
      }, !inited || destroyOnClose && !visiblePanel && !animatVisible ? [] : [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-header'
      }, headerSlot({
        $pulldown: $xepulldown
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-body'
      }, dropdownSlot({
        $pulldown: $xepulldown
      })), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-footer'
      }, footerSlot({
        $pulldown: $xepulldown
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])] : [])])]);
    };
    $xepulldown.renderVN = renderVN;
    return $xepulldown;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pulldown/index.ts


const VxePulldown = Object.assign(pulldown, {
  install: function (app) {
    app.component(pulldown.name, pulldown);
  }
});
const Pulldown = VxePulldown;
dynamicApp.component(pulldown.name, pulldown);
/* harmony default export */ var packages_pulldown = ((/* unused pure expression or super */ null && (VxePulldown)));
;// CONCATENATED MODULE: ./packages/locale/lang/zh-CN.ts
/* harmony default export */ var zh_CN = ({
  vxe: {
    base: {
      pleaseInput: '请输入',
      pleaseSelect: '请选择'
    },
    loading: {
      text: '加载中...'
    },
    error: {
      groupFixed: '如果使用分组表头，冻结列必须按组设置',
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: '无法插入到指定位置，请检查参数是否正确',
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: '工具栏无法关联表格',
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: '该浏览器不支持导入/导出功能',
      impFields: '导入失败，请检查字段名和数据格式是否正确',
      treeNotImp: '树表格不支持导入'
    },
    table: {
      emptyText: '暂无数据',
      allTitle: '全选/取消',
      seqTitle: '#',
      confirmFilter: '筛选',
      resetFilter: '重置',
      allFilter: '全部',
      sortAsc: '升序：最低到最高',
      sortDesc: '降序：最高到最低',
      filter: '对所选的列启用筛选',
      impSuccess: '成功导入 {0} 条记录',
      expLoading: '正在导出中',
      expSuccess: '导出成功',
      expFilename: '导出_{0}',
      expOriginFilename: '导出_源_{0}',
      customTitle: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customRestore: '重置',
      maxFixedCol: '最大冻结列的数量不能超过 {0} 个'
    },
    grid: {
      selectOneRecord: '请至少选择一条记录！',
      deleteSelectRecord: '您确定要删除所选记录吗？',
      removeSelectRecord: '您确定要移除所选记录吗？',
      dataUnchanged: '数据未改动！',
      delSuccess: '成功删除所选记录！',
      saveSuccess: '保存成功！',
      operError: '发生错误，操作失败！'
    },
    select: {
      search: '搜索',
      loadingText: '加载中',
      emptyText: '暂无数据'
    },
    pager: {
      goto: '前往',
      pagesize: '{0}条/页',
      total: '共 {0} 条记录',
      pageClassifier: '页',
      homePage: '首页',
      homePageTitle: '首页',
      prevPage: '上一页',
      prevPageTitle: '上一页',
      nextPage: '下一页',
      nextPageTitle: '下一页',
      prevJump: '向上跳页',
      prevJumpTitle: '向上跳页',
      nextJump: '向下跳页',
      nextJumpTitle: '向下跳页',
      endPage: '末页',
      endPageTitle: '末页'
    },
    alert: {
      title: '系统提示'
    },
    button: {
      confirm: '确认',
      cancel: '取消'
    },
    filter: {
      search: '搜索'
    },
    custom: {
      cstmTitle: '列设置',
      cstmRestore: '恢复默认',
      cstmCancel: '取消',
      cstmConfirm: '确定',
      cstmConfirmRestore: '请确认是否恢复成默认列配置？',
      cstmDragTarget: '移动目标：{0}',
      setting: {
        colSort: '排序',
        sortHelpTip: '点击并拖动图标可以调整列的排序',
        colTitle: '标题',
        colVisible: '是否显示',
        colFixed: '冻结列（最多 {0} 列）',
        fixedLeft: '左侧',
        fixedUnset: '不设置',
        fixedRight: '右侧'
      }
    },
    import: {
      modes: {
        covering: '覆盖',
        insert: '新增'
      },
      impTitle: '导入数据',
      impFile: '文件名',
      impSelect: '选择文件',
      impType: '文件类型',
      impOpts: '参数设置',
      impConfirm: '导入',
      impCancel: '取消'
    },
    export: {
      types: {
        csv: 'CSV (逗号分隔)(*.csv)',
        html: '网页(*.html)',
        xml: 'XML 数据(*.xml)',
        txt: '文本文件(制表符分隔)(*.txt)',
        xls: 'Excel 97-2003 工作簿(*.xls)',
        xlsx: 'Excel 工作簿(*.xlsx)',
        pdf: 'PDF (*.pdf)'
      },
      modes: {
        current: '当前数据（当前页的数据）',
        selected: '选中数据（当前页选中的数据）',
        all: '全量数据（包括所有分页的数据）'
      },
      printTitle: '打印数据',
      expTitle: '导出数据',
      expName: '文件名',
      expNamePlaceholder: '请输入文件名',
      expSheetName: '标题',
      expSheetNamePlaceholder: '请输入标题',
      expType: '保存类型',
      expMode: '选择数据',
      expCurrentColumn: '全部字段',
      expColumn: '选择字段',
      expOpts: '参数设置',
      expOptHeader: '表头',
      expHeaderTitle: '是否需要表头',
      expOptFooter: '表尾',
      expFooterTitle: '是否需要表尾',
      expOptColgroup: '分组表头',
      expColgroupTitle: '如果存在，则支持带有分组结构的表头',
      expOptMerge: '合并',
      expMergeTitle: '如果存在，则支持带有合并结构的单元格',
      expOptAllExpand: '展开层级',
      expAllExpandTitle: '如果存在，则支持将带有层级结构的数据全部展开',
      expOptUseStyle: '样式',
      expUseStyleTitle: '如果存在，则支持带样式的单元格',
      expOptOriginal: '源数据',
      expOriginalTitle: '如果为源数据，则支持导入到表格中',
      expPrint: '打印',
      expConfirm: '导出',
      expCancel: '取消'
    },
    modal: {
      zoomIn: '最大化',
      zoomOut: '还原',
      close: '关闭'
    },
    drawer: {
      close: '关闭'
    },
    form: {
      folding: '收起',
      unfolding: '展开'
    },
    toolbar: {
      import: '导入',
      export: '导出',
      print: '打印',
      refresh: '刷新',
      zoomIn: '全屏',
      zoomOut: '还原',
      custom: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customRestore: '重置',
      fixedLeft: '冻结在左侧',
      fixedRight: '冻结在右侧',
      cancelFixed: '取消冻结列'
    },
    input: {
      date: {
        m1: '01 月',
        m2: '02 月',
        m3: '03 月',
        m4: '04 月',
        m5: '05 月',
        m6: '06 月',
        m7: '07 月',
        m8: '08 月',
        m9: '09 月',
        m10: '10 月',
        m11: '11 月',
        m12: '12 月',
        quarterLabel: '{0} 年',
        monthLabel: '{0} 年',
        dayLabel: '{0} 年 {1}',
        labelFormat: {
          date: 'yyyy-MM-dd',
          time: 'HH:mm:ss',
          datetime: 'yyyy-MM-dd HH:mm:ss',
          week: 'yyyy 年第 WW 周',
          month: 'yyyy-MM',
          quarter: 'yyyy 年第 q 季度',
          year: 'yyyy'
        },
        weeks: {
          w: '周',
          w0: '周日',
          w1: '周一',
          w2: '周二',
          w3: '周三',
          w4: '周四',
          w5: '周五',
          w6: '周六'
        },
        months: {
          m0: '一月',
          m1: '二月',
          m2: '三月',
          m3: '四月',
          m4: '五月',
          m5: '六月',
          m6: '七月',
          m7: '八月',
          m8: '九月',
          m9: '十月',
          m10: '十一月',
          m11: '十二月'
        },
        quarters: {
          q1: '第一季度',
          q2: '第二季度',
          q3: '第三季度',
          q4: '第四季度'
        }
      }
    },
    formDesign: {
      widget: {
        input: '输入框',
        textarea: '文本域',
        select: '下拉框'
      }
    },
    /**
     * 扩展插件
     */
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: '无法对合并单元格进行该操作',
          multiErr: '无法对多重选择区域进行该操作',
          extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
          pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作',
          cpInvalidErr: '该操作无法进行，您选择的区域中存在被禁止的列（{0}）'
        },
        fnr: {
          title: '查找和替换',
          findLabel: '查找',
          replaceLabel: '替换',
          findTitle: '查找内容：',
          replaceTitle: '替换为：',
          tabs: {
            find: '查找',
            replace: '替换'
          },
          filter: {
            re: '正则表达式',
            whole: '全词匹配',
            sensitive: '区分大小写'
          },
          btns: {
            findNext: '查找下一个',
            findAll: '查找全部',
            replace: '替换',
            replaceAll: '替换全部',
            cancel: '取消'
          },
          header: {
            seq: '#',
            cell: '单元格',
            value: '值'
          },
          empty: '(空值)',
          reError: '无效的正则表达式',
          recordCount: '已找到 {0} 个单元格',
          notCell: '找不到匹配的单元格',
          replaceSuccess: '成功替换 {0} 个单元格'
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧'
        },
        cases: {
          equal: '等于',
          gt: '大于',
          lt: '小于',
          begin: '开头是',
          endin: '结尾是',
          include: '包含',
          isSensitive: '区分大小写'
        }
      },
      filterCombination: {
        menus: {
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        cases: {
          equal: '等于',
          unequal: '不等于',
          gt: '大于',
          ge: '大于或等于',
          lt: '小于',
          le: '小于或等于',
          begin: '开头是',
          notbegin: '开头不是',
          endin: '结尾是',
          notendin: '结尾不是',
          include: '包含',
          exclude: '不包含',
          between: '介于',
          custom: '自定义筛选',
          insensitive: '不区分大小写',
          isSensitive: '区分大小写'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    },
    /**
     * 以下废弃
     * @deprecated
     */
    pro: {
      area: {
        mergeErr: '无法对合并单元格进行该操作',
        multiErr: '无法对多重选择区域进行该操作',
        extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
        pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作'
      },
      fnr: {
        title: '查找和替换',
        findLabel: '查找',
        replaceLabel: '替换',
        findTitle: '查找内容：',
        replaceTitle: '替换为：',
        tabs: {
          find: '查找',
          replace: '替换'
        },
        filter: {
          re: '正则表达式',
          whole: '全词匹配',
          sensitive: '区分大小写'
        },
        btns: {
          findNext: '查找下一个',
          findAll: '查找全部',
          replace: '替换',
          replaceAll: '替换全部',
          cancel: '取消'
        },
        header: {
          seq: '#',
          cell: '单元格',
          value: '值'
        },
        empty: '(空值)',
        reError: '无效的正则表达式',
        recordCount: '已找到 {0} 个单元格',
        notCell: '找不到匹配的单元格',
        replaceSuccess: '成功替换 {0} 个单元格'
      }
    },
    renderer: {
      search: '搜索',
      cases: {
        equal: '等于',
        unequal: '不等于',
        gt: '大于',
        ge: '大于或等于',
        lt: '小于',
        le: '小于或等于',
        begin: '开头是',
        notbegin: '开头不是',
        endin: '结尾是',
        notendin: '结尾不是',
        include: '包含',
        exclude: '不包含',
        between: '介于',
        custom: '自定义筛选',
        insensitive: '不区分大小写',
        isSensitive: '区分大小写'
      },
      combination: {
        menus: {
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '锁定列',
          fixedGroup: '锁定组',
          cancelFixed: '取消锁定',
          fixedLeft: '锁定左侧',
          fixedRight: '锁定右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/all.ts







































// 按需加载的组件
const all_components = [
// 功能模块
VxeTableFilterModule, VxeTableMenuModule, VxeTableEditModule, VxeTableExportModule, VxeTableKeyboardModule, VxeTableValidatorModule, VxeTableCustomModule,
// 可选组件
VxeIcon, VxeColumn, VxeColgroup, VxeGrid, VxeToolbar, VxePager, VxeCheckbox, VxeCheckboxGroup, VxeRadio, VxeRadioGroup, VxeRadioButton, VxeInput, VxeTextarea, VxeButton, VxeButtonGroup, VxeModal, VxeDrawer, VxeTooltip, VxeForm, VxeFormItem, VxeFormGather, VxeSelect, VxeOptgroup, VxeOption, VxeSwitch, VxeList, VxePulldown,
// 核心
VxeTable];
// 默认中文
setConfig({
  i18n: (key, args) => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(zh_CN, key), args)
});
// 默认安装
function install(app, options) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isPlainObject(options)) {
    setConfig(options);
    if (options.theme) {
      setTheme(options.theme);
    }
  }
  all_components.forEach(component => component.install(app));
}

// Table module







// Components




























;// CONCATENATED MODULE: ./index.ts



/* harmony default export */ var index = (all_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (index);


}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});