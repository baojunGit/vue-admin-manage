"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vue = require("vue");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _utils = require("../../tools/utils");
var _dom = require("../../tools/dom");
var _log = require("../../tools/log");
var _conf = _interopRequireDefault(require("../../v-x-e-table/src/conf"));
var _vXETable = require("../../v-x-e-table");
var _table = _interopRequireDefault(require("../../table"));
var _pager = _interopRequireDefault(require("../../pager"));
var _toolbar = _interopRequireDefault(require("../../toolbar"));
var _form = _interopRequireDefault(require("../../form"));
var _props = _interopRequireDefault(require("../../table/src/props"));
var _emits = _interopRequireDefault(require("../../table/src/emits"));
var _size = require("../../hooks/size");
var _event = require("../../tools/event");
var _vn = require("../../tools/vn");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const tableComponentPropKeys = Object.keys(_props.default);
const tableComponentMethodKeys = ['clearAll', 'syncData', 'updateData', 'loadData', 'reloadData', 'reloadRow', 'loadColumn', 'reloadColumn', 'getRowNode', 'getColumnNode', 'getRowIndex', 'getVTRowIndex', 'getVMRowIndex', 'getColumnIndex', 'getVTColumnIndex', 'getVMColumnIndex', 'createData', 'createRow', 'revertData', 'clearData', 'isInsertByRow', 'isUpdateByRow', 'getColumns', 'getColumnById', 'getColumnByField', 'getTableColumn', 'getData', 'getCheckboxRecords', 'getParentRow', 'getRowSeq', 'getRowById', 'getRowid', 'getTableData', 'setColumnFixed', 'clearColumnFixed', 'setColumnWidth', 'getColumnWidth', 'hideColumn', 'showColumn', 'resetColumn', 'refreshColumn', 'refreshScroll', 'recalculate', 'closeTooltip', 'isAllCheckboxChecked', 'isAllCheckboxIndeterminate', 'getCheckboxIndeterminateRecords', 'setCheckboxRow', 'isCheckedByCheckboxRow', 'isIndeterminateByCheckboxRow', 'toggleCheckboxRow', 'setAllCheckboxRow', 'getRadioReserveRecord', 'clearRadioReserve', 'getCheckboxReserveRecords', 'clearCheckboxReserve', 'toggleAllCheckboxRow', 'clearCheckboxRow', 'setCurrentRow', 'isCheckedByRadioRow', 'setRadioRow', 'clearCurrentRow', 'clearRadioRow', 'getCurrentRecord', 'getRadioRecord', 'getCurrentColumn', 'setCurrentColumn', 'clearCurrentColumn', 'setPendingRow', 'togglePendingRow', 'getPendingRecords', 'clearPendingRow', 'sort', 'clearSort', 'isSort', 'getSortColumns', 'closeFilter', 'isFilter', 'isActiveFilterByColumn', 'isRowExpandLoaded', 'clearRowExpandLoaded', 'reloadRowExpand', 'reloadRowExpand', 'toggleRowExpand', 'setAllRowExpand', 'setRowExpand', 'isExpandByRow', 'isRowExpandByRow', 'clearRowExpand', 'clearRowExpandReserve', 'getRowExpandRecords', 'getTreeExpandRecords', 'isTreeExpandLoaded', 'clearTreeExpandLoaded', 'reloadTreeExpand', 'reloadTreeChilds', 'toggleTreeExpand', 'setAllTreeExpand', 'setTreeExpand', 'isTreeExpandByRow', 'clearTreeExpand', 'clearTreeExpandReserve', 'getScroll', 'scrollTo', 'scrollToRow', 'scrollToColumn', 'clearScroll', 'updateFooter', 'updateStatus', 'setMergeCells', 'removeInsertRow', 'removeMergeCells', 'getMergeCells', 'clearMergeCells', 'setMergeFooterItems', 'removeMergeFooterItems', 'getMergeFooterItems', 'clearMergeFooterItems', 'openTooltip', 'focus', 'blur', 'connect'];
const gridComponentEmits = [..._emits.default, 'page-change', 'form-submit', 'form-submit-invalid', 'form-reset', 'form-collapse', 'form-toggle-collapse', 'proxy-query', 'proxy-delete', 'proxy-save', 'toolbar-button-click', 'toolbar-tool-click', 'zoom'];
var _default = exports.default = (0, _vue.defineComponent)({
  name: 'VxeGrid',
  props: Object.assign(Object.assign({}, _props.default), {
    layouts: Array,
    columns: Array,
    pagerConfig: Object,
    proxyConfig: Object,
    toolbarConfig: Object,
    formConfig: Object,
    zoomConfig: Object,
    size: {
      type: String,
      default: () => _conf.default.grid.size || _conf.default.size
    }
  }),
  emits: gridComponentEmits,
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = _xeUtils.default.uniqueId();
    const instance = (0, _vue.getCurrentInstance)();
    const computeSize = (0, _size.useSize)(props);
    const reactData = (0, _vue.reactive)({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: _conf.default.pager.pageSize || 10,
        currentPage: 1
      }
    });
    const refElem = (0, _vue.ref)();
    const refTable = (0, _vue.ref)();
    const refForm = (0, _vue.ref)();
    const refToolbar = (0, _vue.ref)();
    const refPager = (0, _vue.ref)();
    const refFormWrapper = (0, _vue.ref)();
    const refToolbarWrapper = (0, _vue.ref)();
    const refTopWrapper = (0, _vue.ref)();
    const refBottomWrapper = (0, _vue.ref)();
    const refPagerWrapper = (0, _vue.ref)();
    const extendTableMethods = methodKeys => {
      const funcs = {};
      methodKeys.forEach(name => {
        funcs[name] = (...args) => {
          const $xetable = refTable.value;
          if ($xetable && $xetable[name]) {
            return $xetable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach(name => {
      gridExtendTableMethods[name] = (...args) => {
        const $xetable = refTable.value;
        if ($xetable && $xetable[name]) {
          return $xetable && $xetable[name](...args);
        }
      };
    });
    const computeProxyOpts = (0, _vue.computed)(() => {
      return Object.assign({}, _conf.default.grid.proxyConfig, props.proxyConfig);
    });
    const computeIsMsg = (0, _vue.computed)(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.message !== false;
    });
    const computePagerOpts = (0, _vue.computed)(() => {
      return Object.assign({}, _conf.default.grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = (0, _vue.computed)(() => {
      return Object.assign({}, _conf.default.grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = (0, _vue.computed)(() => {
      return Object.assign({}, _conf.default.grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = (0, _vue.computed)(() => {
      return Object.assign({}, _conf.default.grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = (0, _vue.computed)(() => {
      return reactData.isZMax ? {
        zIndex: reactData.tZindex
      } : null;
    });
    const computeTableExtendProps = (0, _vue.computed)(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach(key => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xegrid = {
      xID,
      props: props,
      context,
      instance,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let gridMethods = {};
    const computeTableProps = (0, _vue.computed)(() => {
      const {
        seqConfig,
        pagerConfig,
        loading,
        editConfig,
        proxyConfig
      } = props;
      const {
        isZMax,
        tableLoading,
        tablePage,
        tableData
      } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tableProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tableProps.maxHeight = 'auto';
        } else {
          tableProps.height = 'auto';
        }
      }
      if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
        tableProps.loading = loading || tableLoading;
        tableProps.data = tableData;
        if (pagerConfig && proxyOpts.seq && (0, _utils.isEnableConf)(pagerOpts)) {
          tableProps.seqConfig = Object.assign({}, seqConfig, {
            startIndex: (tablePage.currentPage - 1) * tablePage.pageSize
          });
        }
      }
      if (editConfig) {
        tableProps.editConfig = Object.assign({}, editConfig);
      }
      return tableProps;
    });
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && (0, _utils.isEnableConf)(toolbarOpts)) {
        (0, _vue.nextTick)(() => {
          const $xetable = refTable.value;
          const $xetoolbar = refToolbar.value;
          if ($xetable && $xetoolbar) {
            $xetable.connect($xetoolbar);
          }
        });
      }
    };
    const initPages = () => {
      const {
        tablePage
      } = reactData;
      const {
        pagerConfig
      } = props;
      const pagerOpts = computePagerOpts.value;
      const {
        currentPage,
        pageSize
      } = pagerOpts;
      if (pagerConfig && (0, _utils.isEnableConf)(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = code => {
      const isMsg = computeIsMsg.value;
      const $xetable = refTable.value;
      const selectRecords = $xetable.getCheckboxRecords();
      if (selectRecords.length) {
        $xetable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isMsg) {
          // 检测弹窗模块
          if (process.env.NODE_ENV === 'development') {
            if (!_vXETable.VXETable.modal) {
              (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
            }
          }
          _vXETable.VXETable.modal.message({
            id: code,
            content: _conf.default.i18n('vxe.grid.selectOneRecord'),
            status: 'warning'
          });
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = _xeUtils.default.isFunction(messageProp) ? messageProp({
          data: rest,
          $grid: $xegrid
        }) : _xeUtils.default.get(rest, messageProp);
      }
      return msg || _conf.default.i18n(defaultMsg);
    };
    const handleDeleteRow = (code, alertKey, callback) => {
      const isMsg = computeIsMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isMsg) {
        if (selectRecords.length) {
          return _vXETable.VXETable.modal.confirm({
            id: `cfm_${code}`,
            content: _conf.default.i18n(alertKey),
            escClosable: true
          }).then(type => {
            if (type === 'confirm') {
              return callback();
            }
          });
        } else {
          // 检测弹窗模块
          if (process.env.NODE_ENV === 'development') {
            if (!_vXETable.VXETable.modal) {
              (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
            }
          }
          _vXETable.VXETable.modal.message({
            id: `msg_${code}`,
            content: _conf.default.i18n('vxe.grid.selectOneRecord'),
            status: 'warning'
          });
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = params => {
      const {
        proxyConfig
      } = props;
      const {
        tablePage
      } = reactData;
      const {
        currentPage,
        pageSize
      } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      gridMethods.dispatchEvent('page-change', params);
      if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
        gridMethods.commitProxy('query').then(rest => {
          gridMethods.dispatchEvent('proxy-query', rest, params.$event);
        });
      }
    };
    const sortChangeEvent = params => {
      const $xetable = refTable.value;
      const {
        proxyConfig
      } = props;
      const {
        computeSortOpts
      } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      // 如果是服务端排序
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy('query').then(rest => {
            gridMethods.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent('sort-change', params);
    };
    const filterChangeEvent = params => {
      const $xetable = refTable.value;
      const {
        proxyConfig
      } = props;
      const {
        computeFilterOpts
      } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      // 如果是服务端过滤
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy('query').then(rest => {
            gridMethods.dispatchEvent('proxy-query', rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent('filter-change', params);
    };
    const submitFormEvent = params => {
      const {
        proxyConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
        gridMethods.commitProxy('reload').then(rest => {
          gridMethods.dispatchEvent('proxy-query', Object.assign(Object.assign({}, rest), {
            isReload: true
          }), params.$event);
        });
      }
      gridMethods.dispatchEvent('form-submit', params);
    };
    const resetFormEvent = params => {
      const {
        proxyConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
        gridMethods.commitProxy('reload').then(rest => {
          gridMethods.dispatchEvent('proxy-query', Object.assign(Object.assign({}, rest), {
            isReload: true
          }), params.$event);
        });
      }
      gridMethods.dispatchEvent('form-reset', params);
    };
    const submitInvalidEvent = params => {
      gridMethods.dispatchEvent('form-submit-invalid', params);
    };
    const collapseEvent = params => {
      (0, _vue.nextTick)(() => gridExtendTableMethods.recalculate(true));
      gridMethods.dispatchEvent('form-toggle-collapse', params);
      gridMethods.dispatchEvent('form-collapse', params);
    };
    const handleZoom = isMax => {
      const {
        isZMax
      } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < (0, _utils.getLastZIndex)()) {
          reactData.tZindex = (0, _utils.nextZIndex)();
        }
      }
      return (0, _vue.nextTick)().then(() => gridExtendTableMethods.recalculate(true)).then(() => reactData.isZMax);
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (_xeUtils.default.isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            if (process.env.NODE_ENV === 'development') {
              (0, _log.errLog)('vxe.error.notSlot', [funcSlot]);
            }
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    /**
     * 渲染表单
     */
    const renderForms = () => {
      const {
        formConfig,
        proxyConfig
      } = props;
      const {
        formData
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      const restVNs = [];
      if (formConfig && (0, _utils.isEnableConf)(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({
            $grid: $xegrid
          });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach(item => {
                  beforeItem({
                    $grid: $xegrid,
                    item
                  });
                });
              }
            }
            // 处理插槽
            formOpts.items.forEach(item => {
              _xeUtils.default.each(item.slots, func => {
                if (!_xeUtils.default.isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            slotVNs.push((0, _vue.h)(_form.default, Object.assign(Object.assign({
              ref: refForm
            }, Object.assign({}, formOpts, {
              data: proxyConfig && (0, _utils.isEnableConf)(proxyOpts) && proxyOpts.form ? formData : formOpts.data
            })), {
              onSubmit: submitFormEvent,
              onReset: resetFormEvent,
              onSubmitInvalid: submitInvalidEvent,
              onCollapse: collapseEvent
            }), formSlots));
          }
        }
        restVNs.push((0, _vue.h)('div', {
          ref: refFormWrapper,
          key: 'form',
          class: 'vxe-grid--form-wrapper'
        }, slotVNs));
      }
      return restVNs;
    };
    /**
     * 渲染工具栏
     */
    const renderToolbars = () => {
      const {
        toolbarConfig
      } = props;
      const toolbarOpts = computeToolbarOpts.value;
      const restVNs = [];
      if (toolbarConfig && (0, _utils.isEnableConf)(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({
            $grid: $xegrid
          });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, 'buttons');
            toolsSlot = getFuncSlot(toolbarOptSlots, 'tools');
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push((0, _vue.h)(_toolbar.default, Object.assign({
            ref: refToolbar
          }, toolbarOpts), toolbarSlots));
        }
        restVNs.push((0, _vue.h)('div', {
          ref: refToolbarWrapper,
          key: 'toolbar',
          class: 'vxe-grid--toolbar-wrapper'
        }, slotVNs));
      }
      return restVNs;
    };
    /**
     * 渲染表格顶部区域
     */
    const renderTops = () => {
      if (slots.top) {
        return [(0, _vue.h)('div', {
          ref: refTopWrapper,
          key: 'top',
          class: 'vxe-grid--top-wrapper'
        }, slots.top({
          $grid: $xegrid
        }))];
      }
      return [];
    };
    const defaultLayouts = ['Form', 'Toolbar', 'Top', 'Table', 'Bottom', 'Pager'];
    const renderLayout = () => {
      const {
        layouts
      } = props;
      const vns = [];
      const currLayouts = layouts && layouts.length ? layouts : _conf.default.grid.layouts || defaultLayouts;
      currLayouts.forEach(name => {
        switch (name) {
          case 'Form':
            vns.push(renderForms());
            break;
          case 'Toolbar':
            vns.push(renderToolbars());
            break;
          case 'Top':
            vns.push(renderTops());
            break;
          case 'Table':
            vns.push(renderTables());
            break;
          case 'Bottom':
            vns.push(renderBottoms());
            break;
          case 'Pager':
            vns.push(renderPagers());
            break;
          default:
            if (process.env.NODE_ENV === 'development') {
              (0, _log.errLog)('vxe.error.notProp', [`layouts -> ${name}`]);
            }
            break;
        }
      });
      return vns;
    };
    const tableCompEvents = {};
    _emits.default.forEach(name => {
      const type = _xeUtils.default.camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    /**
     * 渲染表格
     */
    const renderTables = () => {
      const {
        proxyConfig
      } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = () => emptySlot({});
      }
      if (loadingSlot) {
        slotObj.loading = () => loadingSlot({});
      }
      return [(0, _vue.h)(_table.default, Object.assign(Object.assign({
        ref: refTable,
        key: 'table'
      }, tableProps), tableOns), slotObj)];
    };
    /**
     * 渲染表格底部区域
     */
    const renderBottoms = () => {
      if (slots.bottom) {
        return [(0, _vue.h)('div', {
          ref: refBottomWrapper,
          key: 'bottom',
          class: 'vxe-grid--bottom-wrapper'
        }, slots.bottom({
          $grid: $xegrid
        }))];
      }
      return [];
    };
    /**
     * 渲染分页
     */
    const renderPagers = () => {
      const {
        proxyConfig,
        pagerConfig
      } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const restVNs = [];
      if (pagerConfig && (0, _utils.isEnableConf)(pagerOpts) || slots.pager) {
        let slotVNs = [];
        if (slots.pager) {
          slotVNs = slots.pager({
            $grid: $xegrid
          });
        } else {
          const pagerOptSlots = pagerOpts.slots;
          const pagerSlots = {};
          let leftSlot;
          let rightSlot;
          if (pagerOptSlots) {
            leftSlot = getFuncSlot(pagerOptSlots, 'left');
            rightSlot = getFuncSlot(pagerOptSlots, 'right');
            if (leftSlot) {
              pagerSlots.left = leftSlot;
            }
            if (rightSlot) {
              pagerSlots.right = rightSlot;
            }
          }
          slotVNs.push((0, _vue.h)(_pager.default, Object.assign(Object.assign(Object.assign({
            ref: refPager
          }, pagerOpts), proxyConfig && (0, _utils.isEnableConf)(proxyOpts) ? reactData.tablePage : {}), {
            onPageChange: pageChangeEvent
          }), pagerSlots));
        }
        restVNs.push((0, _vue.h)('div', {
          ref: refPagerWrapper,
          key: 'pager',
          class: 'vxe-grid--pager-wrapper'
        }, slotVNs));
      }
      return restVNs;
    };
    const initProxy = () => {
      const {
        proxyConfig,
        formConfig
      } = props;
      const {
        proxyInited
      } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && (0, _utils.isEnableConf)(proxyOpts)) {
        if (formConfig && (0, _utils.isEnableConf)(formOpts) && proxyOpts.form && formOpts.items) {
          const formData = {};
          formOpts.items.forEach(item => {
            const {
              field,
              itemRender
            } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const {
                  defaultValue
                } = itemRender;
                if (_xeUtils.default.isFunction(defaultValue)) {
                  itemValue = defaultValue({
                    item
                  });
                } else if (!_xeUtils.default.isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              formData[field] = itemValue;
            }
          });
          reactData.formData = formData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            (0, _vue.nextTick)().then(() => gridMethods.commitProxy('_init')).then(rest => {
              gridMethods.dispatchEvent('proxy-query', Object.assign(Object.assign({}, rest), {
                isInited: true
              }), new Event('init'));
            });
          }
        }
      }
    };
    gridMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({
          $grid: $xegrid,
          $event: evnt
        }, params));
      },
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(proxyTarget, ...args) {
        const {
          toolbarConfig,
          pagerConfig,
          editRules,
          validConfig
        } = props;
        const {
          tablePage,
          formData
        } = reactData;
        const isMsg = computeIsMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const {
          beforeQuery,
          afterQuery,
          beforeDelete,
          afterDelete,
          beforeSave,
          afterSave,
          ajax = {}
        } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xetable = refTable.value;
        let button = null;
        let code = null;
        if (_xeUtils.default.isString(proxyTarget)) {
          const {
            buttons
          } = toolbarOpts;
          const matchObj = toolbarConfig && (0, _utils.isEnableConf)(toolbarOpts) && buttons ? _xeUtils.default.findTree(buttons, item => item.code === proxyTarget, {
            children: 'dropdowns'
          }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code) {
          case 'insert':
            return $xetable.insert({});
          case 'insert_edit':
            return $xetable.insert({}).then(({
              row
            }) => $xetable.setEditRow(row));
          // 已废弃
          case 'insert_actived':
            return $xetable.insert({}).then(({
              row
            }) => $xetable.setEditRow(row));
          // 已废弃
          case 'mark_cancel':
            triggerPendingEvent(code);
            break;
          case 'remove':
            return handleDeleteRow(code, 'vxe.grid.removeSelectRecord', () => $xetable.removeCheckboxRow());
          case 'import':
            $xetable.importData(btnParams);
            break;
          case 'open_import':
            $xetable.openImport(btnParams);
            break;
          case 'export':
            $xetable.exportData(btnParams);
            break;
          case 'open_export':
            $xetable.openExport(btnParams);
            break;
          case 'reset_custom':
            return $xetable.resetColumn(true);
          case '_init':
          case 'reload':
          case 'query':
            {
              const ajaxMethods = ajax.query;
              if (ajaxMethods) {
                const isInited = code === '_init';
                const isReload = code === 'reload';
                let sortList = [];
                let filterList = [];
                let pageParams = {};
                if (pagerConfig) {
                  if (isInited || isReload) {
                    tablePage.currentPage = 1;
                  }
                  if ((0, _utils.isEnableConf)(pagerOpts)) {
                    pageParams = Object.assign({}, tablePage);
                  }
                }
                if (isInited) {
                  const {
                    computeSortOpts
                  } = $xetable.getComputeMaps();
                  const sortOpts = computeSortOpts.value;
                  let defaultSort = sortOpts.defaultSort;
                  // 如果使用默认排序
                  if (defaultSort) {
                    if (!_xeUtils.default.isArray(defaultSort)) {
                      defaultSort = [defaultSort];
                    }
                    sortList = defaultSort.map(item => {
                      return {
                        field: item.field,
                        property: item.field,
                        order: item.order
                      };
                    });
                  }
                  filterList = $xetable.getCheckedFilters();
                } else {
                  if (isReload) {
                    $xetable.clearAll();
                  } else {
                    sortList = $xetable.getSortColumns();
                    filterList = $xetable.getCheckedFilters();
                  }
                }
                const commitParams = {
                  code,
                  button,
                  isInited,
                  isReload,
                  $grid: $xegrid,
                  page: pageParams,
                  sort: sortList.length ? sortList[0] : {},
                  sorts: sortList,
                  filters: filterList,
                  form: formData,
                  options: ajaxMethods
                };
                reactData.sortData = sortList;
                reactData.filterData = filterList;
                reactData.tableLoading = true;
                const applyArgs = [commitParams].concat(args);
                return Promise.resolve((beforeQuery || ajaxMethods)(...applyArgs)).then(rest => {
                  reactData.tableLoading = false;
                  if (rest) {
                    if (pagerConfig && (0, _utils.isEnableConf)(pagerOpts)) {
                      const totalProp = resConfigs.total;
                      const total = (_xeUtils.default.isFunction(totalProp) ? totalProp({
                        data: rest,
                        $grid: $xegrid
                      }) : _xeUtils.default.get(rest, totalProp || 'page.total')) || 0;
                      tablePage.total = _xeUtils.default.toNumber(total);
                      const resultProp = resConfigs.result;
                      reactData.tableData = (_xeUtils.default.isFunction(resultProp) ? resultProp({
                        data: rest,
                        $grid: $xegrid
                      }) : _xeUtils.default.get(rest, resultProp || 'result')) || [];
                      // 检验当前页码，不能超出当前最大页数
                      const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                      if (tablePage.currentPage > pageCount) {
                        tablePage.currentPage = pageCount;
                      }
                    } else {
                      const listProp = resConfigs.list;
                      reactData.tableData = (listProp ? _xeUtils.default.isFunction(listProp) ? listProp({
                        data: rest,
                        $grid: $xegrid
                      }) : _xeUtils.default.get(rest, listProp) : rest) || [];
                    }
                  } else {
                    reactData.tableData = [];
                  }
                  if (afterQuery) {
                    afterQuery(...applyArgs);
                  }
                  return {
                    status: true
                  };
                }).catch(() => {
                  reactData.tableLoading = false;
                  return {
                    status: false
                  };
                });
              } else {
                if (process.env.NODE_ENV === 'development') {
                  (0, _log.errLog)('vxe.error.notFunc', ['proxy-config.ajax.query']);
                }
              }
              break;
            }
          case 'delete':
            {
              const ajaxMethods = ajax.delete;
              if (ajaxMethods) {
                const selectRecords = gridExtendTableMethods.getCheckboxRecords();
                const removeRecords = selectRecords.filter(row => !$xetable.isInsertByRow(row));
                const body = {
                  removeRecords
                };
                const commitParams = {
                  $grid: $xegrid,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                const applyArgs = [commitParams].concat(args);
                if (selectRecords.length) {
                  return handleDeleteRow(code, 'vxe.grid.deleteSelectRecord', () => {
                    if (!removeRecords.length) {
                      return $xetable.remove(selectRecords);
                    }
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeDelete || ajaxMethods)(...applyArgs)).then(rest => {
                      reactData.tableLoading = false;
                      $xetable.setPendingRow(removeRecords, false);
                      if (isMsg) {
                        // 检测弹窗模块
                        if (process.env.NODE_ENV === 'development') {
                          if (!_vXETable.VXETable.modal) {
                            (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        _vXETable.VXETable.modal.message({
                          content: getRespMsg(rest, 'vxe.grid.delSuccess'),
                          status: 'success'
                        });
                      }
                      if (afterDelete) {
                        afterDelete(...applyArgs);
                      } else {
                        gridMethods.commitProxy('query');
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isMsg) {
                        if (process.env.NODE_ENV === 'development') {
                          if (!_vXETable.VXETable.modal.message) {
                            (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        _vXETable.VXETable.modal.message({
                          id: code,
                          content: getRespMsg(rest, 'vxe.grid.operError'),
                          status: 'error'
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  });
                } else {
                  if (isMsg) {
                    // 检测弹窗模块
                    if (process.env.NODE_ENV === 'development') {
                      if (!_vXETable.VXETable.modal) {
                        (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
                      }
                    }
                    _vXETable.VXETable.modal.message({
                      id: code,
                      content: _conf.default.i18n('vxe.grid.selectOneRecord'),
                      status: 'warning'
                    });
                  }
                }
              } else {
                if (process.env.NODE_ENV === 'development') {
                  (0, _log.errLog)('vxe.error.notFunc', ['proxy-config.ajax.delete']);
                }
              }
              break;
            }
          case 'save':
            {
              const ajaxMethods = ajax.save;
              if (ajaxMethods) {
                const body = $xetable.getRecordset();
                const {
                  insertRecords,
                  removeRecords,
                  updateRecords,
                  pendingRecords
                } = body;
                const commitParams = {
                  $grid: $xegrid,
                  code,
                  button,
                  body,
                  form: formData,
                  options: ajaxMethods
                };
                const applyArgs = [commitParams].concat(args);
                // 排除掉新增且标记为删除的数据
                if (insertRecords.length) {
                  body.pendingRecords = pendingRecords.filter(row => $xetable.findRowIndexOf(insertRecords, row) === -1);
                }
                // 排除已标记为删除的数据
                if (pendingRecords.length) {
                  body.insertRecords = insertRecords.filter(row => $xetable.findRowIndexOf(pendingRecords, row) === -1);
                }
                let restPromise = Promise.resolve();
                if (editRules) {
                  // 只校验新增和修改的数据
                  restPromise = $xetable[validConfig && validConfig.msgMode === 'full' ? 'fullValidate' : 'validate'](body.insertRecords.concat(updateRecords));
                }
                return restPromise.then(errMap => {
                  if (errMap) {
                    // 如果校验不通过
                    return;
                  }
                  if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                    reactData.tableLoading = true;
                    return Promise.resolve((beforeSave || ajaxMethods)(...applyArgs)).then(rest => {
                      reactData.tableLoading = false;
                      $xetable.clearPendingRow();
                      if (isMsg) {
                        // 检测弹窗模块
                        if (process.env.NODE_ENV === 'development') {
                          if (!_vXETable.VXETable.modal) {
                            (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        _vXETable.VXETable.modal.message({
                          content: getRespMsg(rest, 'vxe.grid.saveSuccess'),
                          status: 'success'
                        });
                      }
                      if (afterSave) {
                        afterSave(...applyArgs);
                      } else {
                        gridMethods.commitProxy('query');
                      }
                      return {
                        status: true
                      };
                    }).catch(rest => {
                      reactData.tableLoading = false;
                      if (isMsg) {
                        // 检测弹窗模块
                        if (process.env.NODE_ENV === 'development') {
                          if (!_vXETable.VXETable.modal) {
                            (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
                          }
                        }
                        _vXETable.VXETable.modal.message({
                          id: code,
                          content: getRespMsg(rest, 'vxe.grid.operError'),
                          status: 'error'
                        });
                      }
                      return {
                        status: false
                      };
                    });
                  } else {
                    if (isMsg) {
                      // 检测弹窗模块
                      if (process.env.NODE_ENV === 'development') {
                        if (!_vXETable.VXETable.modal) {
                          (0, _log.errLog)('vxe.error.reqModule', ['Modal']);
                        }
                      }
                      _vXETable.VXETable.modal.message({
                        id: code,
                        content: _conf.default.i18n('vxe.grid.dataUnchanged'),
                        status: 'info'
                      });
                    }
                  }
                });
              } else {
                if (process.env.NODE_ENV === 'development') {
                  (0, _log.errLog)('vxe.error.notFunc', ['proxy-config.ajax.save']);
                }
              }
              break;
            }
          default:
            {
              const gCommandOpts = _vXETable.VXETable.commands.get(code);
              if (gCommandOpts) {
                if (gCommandOpts.commandMethod) {
                  gCommandOpts.commandMethod({
                    code,
                    button,
                    $grid: $xegrid,
                    $table: $xetable
                  }, ...args);
                } else {
                  if (process.env.NODE_ENV === 'development') {
                    (0, _log.errLog)('vxe.error.notCommands', [code]);
                  }
                }
              }
            }
        }
        return (0, _vue.nextTick)();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const {
          formConfig
        } = props;
        const {
          items
        } = formOpts;
        const itemList = [];
        _xeUtils.default.eachTree(formConfig && (0, _utils.isEnableConf)(formOpts) && items ? items : [], item => {
          itemList.push(item);
        }, {
          children: 'children'
        });
        return _xeUtils.default.isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xetable = refTable.value;
        if (props.proxyConfig) {
          const {
            sortData
          } = reactData;
          return {
            data: reactData.tableData,
            filter: reactData.filterData,
            form: reactData.formData,
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xetable ? $xetable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    // 检查插槽
    if (process.env.NODE_ENV === 'development') {
      gridMethods.loadColumn = columns => {
        const $xetable = refTable.value;
        _xeUtils.default.eachTree(columns, column => {
          if (column.slots) {
            _xeUtils.default.each(column.slots, func => {
              if (!_xeUtils.default.isFunction(func)) {
                if (!slots[func]) {
                  (0, _log.errLog)('vxe.error.notSlot', [func]);
                }
              }
            });
          }
        });
        if ($xetable) {
          return $xetable.loadColumn(columns);
        }
        return (0, _vue.nextTick)();
      };
      gridMethods.reloadColumn = columns => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (_xeUtils.default.isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (_xeUtils.default.isFunction(slotFunc)) {
            return (0, _vn.getSlotVNs)(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const {
          height
        } = props;
        const {
          isZMax
        } = reactData;
        const el = refElem.value;
        const formWrapper = refFormWrapper.value;
        const toolbarWrapper = refToolbarWrapper.value;
        const topWrapper = refTopWrapper.value;
        const bottomWrapper = refBottomWrapper.value;
        const pagerWrapper = refPagerWrapper.value;
        const parentPaddingSize = isZMax || height !== 'auto' ? 0 : (0, _dom.getPaddingTopBottomSize)(el.parentNode);
        return parentPaddingSize + (0, _dom.getPaddingTopBottomSize)(el) + (0, _dom.getOffsetHeight)(formWrapper) + (0, _dom.getOffsetHeight)(toolbarWrapper) + (0, _dom.getOffsetHeight)(topWrapper) + (0, _dom.getOffsetHeight)(bottomWrapper) + (0, _dom.getOffsetHeight)(pagerWrapper);
      },
      getParentHeight() {
        const el = refElem.value;
        if (el) {
          return (reactData.isZMax ? (0, _dom.getDomNode)().visibleHeight : _xeUtils.default.toNumber(getComputedStyle(el.parentNode).height)) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const {
          code
        } = params;
        return gridMethods.commitProxy(params, evnt).then(rest => {
          if (code && rest && rest.status && ['query', 'reload', 'delete', 'save'].includes(code)) {
            gridMethods.dispatchEvent(code === 'delete' || code === 'save' ? `proxy-${code}` : 'proxy-query', Object.assign(Object.assign({}, rest), {
              isReload: code === 'reload'
            }), evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent('toolbar-button-click', {
          code: button.code,
          button
        }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent('toolbar-tool-click', {
          code: tool.code,
          tool,
          $event: evnt
        });
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent('zoom', {
          type: reactData.isZMax ? 'max' : 'revert'
        }, evnt);
      }
    };
    Object.assign($xegrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = (0, _vue.ref)(0);
    (0, _vue.watch)(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    (0, _vue.watch)(() => props.columns, () => {
      columnFlag.value++;
    });
    (0, _vue.watch)(columnFlag, () => {
      (0, _vue.nextTick)(() => $xegrid.loadColumn(props.columns || []));
    });
    (0, _vue.watch)(() => props.toolbarConfig, () => {
      initToolbar();
    });
    (0, _vue.watch)(() => props.pagerConfig, () => {
      initPages();
    });
    (0, _vue.watch)(() => props.proxyConfig, () => {
      initProxy();
    });
    const handleGlobalKeydownEvent = evnt => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = (0, _event.hasEventKey)(evnt, _event.EVENT_KEYS.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    _vXETable.VXETable.hooks.forEach(options => {
      const {
        setupGrid
      } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xegrid);
        if (hookRest && _xeUtils.default.isObject(hookRest)) {
          Object.assign($xegrid, hookRest);
        }
      }
    });
    initPages();
    (0, _vue.onMounted)(() => {
      (0, _vue.nextTick)(() => {
        const {
          data,
          columns,
          proxyConfig
        } = props;
        const proxyOpts = computeProxyOpts.value;
        const formOpts = computeFormOpts.value;
        if ((0, _utils.isEnableConf)(proxyConfig) && (data || proxyOpts.form && formOpts.data)) {
          (0, _log.errLog)('vxe.error.errConflicts', ['grid.data', 'grid.proxy-config']);
        }
        // if (process.env.NODE_ENV === 'development') {
        //   if (proxyOpts.props) {
        //     warnLog('vxe.error.delProp', ['proxy-config.props', 'proxy-config.response'])
        //   }
        // }
        if (columns && columns.length) {
          $xegrid.loadColumn(columns);
        }
        initToolbar();
      });
      _event.GlobalEvent.on($xegrid, 'keydown', handleGlobalKeydownEvent);
    });
    (0, _vue.onUnmounted)(() => {
      _event.GlobalEvent.off($xegrid, 'keydown');
    });
    (0, _vue.nextTick)(() => {
      initProxy();
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return (0, _vue.h)('div', {
        ref: refElem,
        class: ['vxe-grid', {
          [`size--${vSize}`]: vSize,
          'is--animat': !!props.animat,
          'is--round': props.round,
          'is--maximize': reactData.isZMax,
          'is--loading': props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xegrid.renderVN = renderVN;
    (0, _vue.provide)('$xegrid', $xegrid);
    return $xegrid;
  },
  render() {
    return this.renderVN();
  }
});