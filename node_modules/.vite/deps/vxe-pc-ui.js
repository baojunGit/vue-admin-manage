import {
  Loading,
  LoadingController,
  VxeLoading,
  loading_default,
  loading_default2
} from "./chunk-F5B4SFP3.js";
import {
  Tooltip,
  VxeTooltip,
  addClass,
  browse,
  getAbsolutePos,
  getDomNode,
  getEventTargetNode,
  getOffsetPos,
  hasClass,
  removeClass,
  scrollToView,
  toCssUnit,
  tooltip_default,
  tooltip_default2
} from "./chunk-SAZYUJ2M.js";
import {
  getChangeEvent,
  getModelEvent,
  getOnName,
  getSlotVNs
} from "./chunk-QTR2GV55.js";
import {
  checkDynamic,
  config,
  dynamicApp,
  dynamicStore,
  eqEmptyValue,
  errLog,
  getFuncText,
  getLastZIndex,
  globalStore,
  handleBooleanDefaultValue,
  isEnableConf,
  nextZIndex,
  setup,
  version,
  warnLog
} from "./chunk-CEEPHHD6.js";
import {
  GLOBAL_EVENT_KEYS,
  VxeUI,
  clipboard,
  commands,
  component,
  coreVersion,
  createEvent,
  formats,
  getComponent,
  getConfig,
  getI18n,
  getIcon,
  getLanguage,
  getTheme,
  globalEvents,
  globalResize,
  handleCheckInfo,
  hasLanguage,
  hooks,
  interceptor,
  log,
  menus,
  permission,
  renderer,
  require_xe_utils,
  setConfig,
  setI18n,
  setIcon,
  setLanguage,
  setTheme,
  use,
  useFns,
  usePermission,
  useSize,
  validators
} from "./chunk-BNXASOE3.js";
import "./chunk-D3S72KJS.js";
import {
  Teleport,
  TransitionGroup,
  computed,
  createCommentVNode,
  defineComponent,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch
} from "./chunk-4BEKJ24D.js";
import {
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/components.js
var components_exports = {};
__export(components_exports, {
  Alert: () => Alert,
  Anchor: () => Anchor,
  AnchorLink: () => AnchorLink,
  Breadcrumb: () => Breadcrumb,
  BreadcrumbItem: () => BreadcrumbItem,
  Button: () => Button,
  ButtonGroup: () => ButtonGroup,
  Calendar: () => Calendar,
  Card: () => Card,
  Carousel: () => Carousel,
  CarouselItem: () => CarouselItem,
  Checkbox: () => Checkbox,
  CheckboxGroup: () => CheckboxGroup,
  Col: () => Col,
  Collapse: () => Collapse,
  CollapsePane: () => CollapsePane,
  DatePicker: () => DatePicker,
  Drawer: () => Drawer,
  DrawerController: () => DrawerController,
  Form: () => Form,
  FormDesign: () => FormDesign,
  FormGather: () => FormGather,
  FormItem: () => FormItem,
  FormView: () => FormView,
  GLOBAL_EVENT_KEYS: () => GLOBAL_EVENT_KEYS,
  Icon: () => Icon,
  IconPicker: () => IconPicker,
  Image: () => Image,
  ImageGroup: () => ImageGroup,
  ImagePreview: () => ImagePreview,
  Input: () => Input,
  LayoutAside: () => LayoutAside,
  LayoutBody: () => LayoutBody,
  LayoutContainer: () => LayoutContainer,
  LayoutFooter: () => LayoutFooter,
  LayoutHeader: () => LayoutHeader,
  Link: () => Link,
  List: () => List,
  ListDesign: () => ListDesign,
  ListView: () => ListView,
  Loading: () => Loading,
  LoadingController: () => LoadingController,
  Menu: () => Menu,
  Modal: () => Modal,
  ModalController: () => ModalController,
  NumberInput: () => NumberInput,
  Optgroup: () => Optgroup,
  Option: () => Option,
  Pager: () => Pager,
  PasswordInput: () => PasswordInput,
  Print: () => Print,
  PrintPageBreak: () => PrintPageBreak,
  Pulldown: () => Pulldown,
  Radio: () => Radio,
  RadioButton: () => RadioButton,
  RadioGroup: () => RadioGroup,
  Row: () => Row,
  Select: () => Select,
  Switch: () => Switch,
  TabPane: () => TabPane,
  Tabs: () => Tabs,
  Tag: () => Tag,
  Text: () => Text,
  Textarea: () => Textarea,
  Tip: () => Tip,
  Tips: () => Tips,
  Tooltip: () => Tooltip,
  Tree: () => Tree,
  TreeSelect: () => TreeSelect,
  Upload: () => Upload,
  VxeAlert: () => VxeAlert,
  VxeAnchor: () => VxeAnchor,
  VxeAnchorLink: () => VxeAnchorLink,
  VxeBreadcrumb: () => VxeBreadcrumb,
  VxeBreadcrumbItem: () => VxeBreadcrumbItem,
  VxeButton: () => VxeButton,
  VxeButtonGroup: () => VxeButtonGroup,
  VxeCalendar: () => VxeCalendar,
  VxeCard: () => VxeCard,
  VxeCarousel: () => VxeCarousel,
  VxeCarouselItem: () => VxeCarouselItem,
  VxeCheckbox: () => VxeCheckbox,
  VxeCheckboxGroup: () => VxeCheckboxGroup,
  VxeCol: () => VxeCol,
  VxeCollapse: () => VxeCollapse,
  VxeCollapsePane: () => VxeCollapsePane,
  VxeDatePicker: () => VxeDatePicker,
  VxeDrawer: () => VxeDrawer,
  VxeForm: () => VxeForm,
  VxeFormDesign: () => VxeFormDesign,
  VxeFormGather: () => VxeFormGather,
  VxeFormItem: () => VxeFormItem,
  VxeFormView: () => VxeFormView,
  VxeIcon: () => VxeIcon,
  VxeIconPicker: () => VxeIconPicker,
  VxeImage: () => VxeImage,
  VxeImageGroup: () => VxeImageGroup,
  VxeImagePreview: () => VxeImagePreview,
  VxeInput: () => VxeInput,
  VxeLayoutAside: () => VxeLayoutAside,
  VxeLayoutBody: () => VxeLayoutBody,
  VxeLayoutContainer: () => VxeLayoutContainer,
  VxeLayoutFooter: () => VxeLayoutFooter,
  VxeLayoutHeader: () => VxeLayoutHeader,
  VxeLink: () => VxeLink,
  VxeList: () => VxeList,
  VxeListDesign: () => VxeListDesign,
  VxeListView: () => VxeListView,
  VxeLoading: () => VxeLoading,
  VxeMenu: () => VxeMenu,
  VxeModal: () => VxeModal,
  VxeNumberInput: () => VxeNumberInput,
  VxeOptgroup: () => VxeOptgroup,
  VxeOption: () => VxeOption,
  VxePager: () => VxePager,
  VxePasswordInput: () => VxePasswordInput,
  VxePrint: () => VxePrint,
  VxePrintPageBreak: () => VxePrintPageBreak,
  VxePulldown: () => VxePulldown,
  VxeRadio: () => VxeRadio,
  VxeRadioButton: () => VxeRadioButton,
  VxeRadioGroup: () => VxeRadioGroup,
  VxeRow: () => VxeRow,
  VxeSelect: () => VxeSelect,
  VxeSwitch: () => VxeSwitch,
  VxeTabPane: () => VxeTabPane,
  VxeTabs: () => VxeTabs,
  VxeTag: () => VxeTag,
  VxeText: () => VxeText,
  VxeTextarea: () => VxeTextarea,
  VxeTip: () => VxeTip,
  VxeTooltip: () => VxeTooltip,
  VxeTree: () => VxeTree,
  VxeTreeSelect: () => VxeTreeSelect,
  VxeUI: () => VxeUI,
  VxeUpload: () => VxeUpload,
  clipboard: () => clipboard,
  commands: () => commands,
  component: () => component,
  config: () => config,
  coreVersion: () => coreVersion,
  createEvent: () => createEvent,
  drawer: () => drawer,
  formats: () => formats,
  getComponent: () => getComponent,
  getConfig: () => getConfig,
  getI18n: () => getI18n,
  getIcon: () => getIcon,
  getLanguage: () => getLanguage,
  getTheme: () => getTheme,
  globalEvents: () => globalEvents,
  globalResize: () => globalResize,
  globalStore: () => globalStore,
  handleCheckInfo: () => handleCheckInfo,
  hasLanguage: () => hasLanguage,
  hooks: () => hooks,
  install: () => install,
  interceptor: () => interceptor,
  loading: () => loading,
  log: () => log,
  menus: () => menus,
  modal: () => modal,
  permission: () => permission,
  print: () => print,
  readFile: () => readFile,
  renderer: () => renderer,
  saveFile: () => saveFile,
  setConfig: () => setConfig,
  setI18n: () => setI18n,
  setIcon: () => setIcon,
  setLanguage: () => setLanguage,
  setTheme: () => setTheme,
  setup: () => setup,
  use: () => use,
  useFns: () => useFns,
  usePermission: () => usePermission,
  useSize: () => useSize,
  validators: () => validators,
  version: () => version
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/language/zh-CN.js
var zh_CN_default = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入"
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动目标：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    /**
     * 扩展插件
     */
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    /**
     * 以下废弃
     * @deprecated
     */
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "锁定列",
          fixedGroup: "锁定组",
          cancelFixed: "取消锁定",
          fixedLeft: "锁定左侧",
          fixedRight: "锁定右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/alert/src/alert.js
var import_xe_utils = __toESM(require_xe_utils());
var alert_default = defineComponent({
  name: "VxeAlert",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: [
    "close"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $alert: $xeAlert }, params));
      }
    };
    const closeEvent = (evnt) => {
      alertMethods.dispatchEvent("close", {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title, showIcon, showClose } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return h("div", {
        ref: refElem,
        class: ["vxe-alert", {
          [`theme--${status}`]: status
        }]
      }, [
        iconSlot || showIcon && status || icon ? h("div", {
          class: "vxe-alert--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon || getIcon()[`ALERT_${status === null || status === void 0 ? void 0 : status.toUpperCase()}`]
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-alert--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-alert--title"
          }, titleSlot ? getSlotVNs(titleSlot({})) : import_xe_utils.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-alert--content"
          }, defaultSlot ? getSlotVNs(defaultSlot({})) : import_xe_utils.default.toValueString(content))
        ]),
        showClose ? h("div", {
          class: "vxe-alert--close-btn",
          onClick: closeEvent
        }, [
          h("i", {
            class: getIcon().ALERT_CLOSE
          })
        ]) : createCommentVNode()
      ]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/alert/index.js
var VxeAlert = Object.assign({}, alert_default, {
  install(app) {
    app.component(alert_default.name, alert_default);
  }
});
dynamicApp.component(alert_default.name, alert_default);
VxeUI.component(alert_default);
var Alert = VxeAlert;
var alert_default2 = VxeAlert;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var import_xe_utils4 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var import_xe_utils3 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/anchor/src/util.js
var import_xe_utils2 = __toESM(require_xe_utils());
function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(import_xe_utils2.default.arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = import_xe_utils2.default.findTree(staticLinks, (item) => item.id === linkConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var anchor_link_default = defineComponent({
  name: "VxeAnchorLink",
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const $xeAnchor = inject("$xeAnchor", null);
    const $xeParentAnchorLink = inject("$xeAnchorLink", null);
    const xID = import_xe_utils3.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const linkConfig = reactive({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = computed(() => {
      const { href } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (event) => {
      const { href } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    watch(() => props.href, (val) => {
      linkConfig.href = val;
    });
    onMounted(() => {
      if ($xeAnchor && refElem.value) {
        assembleAnchorLink($xeAnchor, refElem.value, linkConfig, $xeParentAnchorLink);
      }
    });
    onUnmounted(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const { href, content, title } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor-link", {
          "is--active": isActive
        }]
      }, [
        h("a", {
          class: "vxe-anchor-link--item",
          href,
          title,
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({}) : import_xe_utils3.default.toValueString(content)),
        subSlot ? h("div", {
          class: "vxe-anchor-link--sub-items"
        }, subSlot({})) : createCommentVNode()
      ]);
    };
    $xeAnchorLink.renderVN = renderVN;
    provide("$xeAnchorLink", $xeAnchorLink);
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var anchor_default = defineComponent({
  name: "VxeAnchor",
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils4.default.uniqueId();
    const refElem = ref();
    const refMarkerElem = ref();
    const reactData = reactive({
      activeHref: null,
      staticLinks: []
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = computed(() => {
      const list = [];
      import_xe_utils4.default.eachTree(reactData.staticLinks, (item) => {
        list.push(item.href || "");
      }, { children: "children" });
      return list;
    });
    const computeMaps = {};
    let containerElem = null;
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $anchor: $xeAnchor }, params));
      }
    };
    const getContainerElem = () => {
      const { container } = props;
      if (container) {
        if (import_xe_utils4.default.isElement(container)) {
          return container;
        }
        if (import_xe_utils4.default.isString(container)) {
          return document.querySelector(container);
        }
        if (import_xe_utils4.default.isFunction(container)) {
          return container({ $anchor: $xeAnchor });
        }
      }
      return null;
    };
    const emitEvent = (value) => {
      reactData.activeHref = value;
      emit("update:modelValue", value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map((href) => `${href}`).join(","));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      if (containerElem) {
        containerElem.removeEventListener("scroll", handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      containerElem = getContainerElem();
      if (containerElem) {
        containerElem.addEventListener("scroll", handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      nextTick(() => {
        const { activeHref } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const { top } = getOffsetPos(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace("#", ""));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: "smooth"
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent("click", { href }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = (options) => {
      const itemVNs = [];
      if (options) {
        options.forEach((item) => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const { options, showMarker } = props;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor", {
          "is--marker": showMarker
        }]
      }, [
        h("div", {
          class: "vxe-anchor--list"
        }, defaultSlot ? defaultSlot({}) : renderSubItems(options)),
        showMarker ? h("div", {
          ref: refMarkerElem,
          class: "vxe-anchor--marker"
        }) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeHref = val;
    });
    watch(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    watch(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    onMounted(() => {
      nextTick(() => {
        updateContainerElem();
      });
    });
    onBeforeUnmount(() => {
      removeContainerElemScroll();
    });
    $xeAnchor.renderVN = renderVN;
    provide("$xeAnchor", $xeAnchor);
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/anchor/index.js
var VxeAnchor = Object.assign({}, anchor_default, {
  install(app) {
    app.component(anchor_default.name, anchor_default);
  }
});
dynamicApp.component(anchor_default.name, anchor_default);
VxeUI.component(anchor_default);
var Anchor = VxeAnchor;
var anchor_default2 = VxeAnchor;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/anchor-link/index.js
var VxeAnchorLink = Object.assign({}, anchor_link_default, {
  install(app) {
    app.component(anchor_link_default.name, anchor_link_default);
  }
});
dynamicApp.component(anchor_link_default.name, anchor_link_default);
VxeUI.component(anchor_link_default);
var AnchorLink = VxeAnchorLink;
var anchor_link_default2 = VxeAnchorLink;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var import_xe_utils6 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb-item.js
var import_xe_utils5 = __toESM(require_xe_utils());
var breadcrumb_item_default = defineComponent({
  name: "VxeBreadcrumbItem",
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils5.default.uniqueId();
    const refElem = ref();
    const $xeBreadcrumb = inject("$xeBreadcrumb", null);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeSeparator = computed(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return "";
    });
    const clickEvent = (evnt) => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { title, routerLink } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return h("span", {
        ref: refElem,
        class: "vxe-breadcrumb-item",
        onClick: clickEvent
      }, [
        h("span", {
          class: "vxe-breadcrumb-item--content"
        }, [
          routerLink ? h(resolveComponent("router-link"), {
            class: "vxe-breadcrumb-item--content-link",
            title,
            to: routerLink
          }, {
            default() {
              return h("span", {
                class: "vxe-breadcrumb-item--content-text"
              }, defaultSlot ? defaultSlot({}) : `${title || ""}`);
            }
          }) : h("span", {
            class: "vxe-breadcrumb-item--content-text"
          }, defaultSlot ? defaultSlot({}) : `${title || ""}`)
        ]),
        separator ? h("span", {
          class: "vxe-breadcrumb-item--separator"
        }, `${separator}`) : createCommentVNode()
      ]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var breadcrumb_default = defineComponent({
  name: "VxeBreadcrumb",
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils6.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $breadcrumb: $xeBreadcrumb }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option) {
        breadcrumbMethods.dispatchEvent("click", { option }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const { options } = props;
      if (options && options.length) {
        return options.map((item) => {
          return h(breadcrumb_item_default, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: "vxe-breadcrumb"
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    $xeBreadcrumb.renderVN = renderVN;
    provide("$xeBreadcrumb", $xeBreadcrumb);
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/breadcrumb/index.js
var VxeBreadcrumb = Object.assign({}, breadcrumb_default, {
  install(app) {
    app.component(breadcrumb_default.name, breadcrumb_default);
  }
});
dynamicApp.component(breadcrumb_default.name, breadcrumb_default);
VxeUI.component(breadcrumb_default);
var Breadcrumb = VxeBreadcrumb;
var breadcrumb_default2 = VxeBreadcrumb;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/breadcrumb-item/index.js
var VxeBreadcrumbItem = Object.assign({}, breadcrumb_item_default, {
  install(app) {
    app.component(breadcrumb_item_default.name, breadcrumb_item_default);
  }
});
dynamicApp.component(breadcrumb_item_default.name, breadcrumb_item_default);
VxeUI.component(breadcrumb_item_default);
var BreadcrumbItem = VxeBreadcrumbItem;
var breadcrumb_item_default2 = VxeBreadcrumbItem;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/button/src/button.js
var import_xe_utils7 = __toESM(require_xe_utils());
var button_default = defineComponent({
  name: "VxeButton",
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: { type: String, default: () => getConfig().button.size || getConfig().size },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的图标
     */
    icon: String,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    trigger: { type: String, default: () => getConfig().button.trigger },
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().button.destroyOnClose
    },
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const $xeButtonGroup = inject("$xeButtonGroup", null);
    const xID = import_xe_utils7.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const reactData = reactive({
      inited: false,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    });
    const internalData = {
      showTime: null
    };
    const refElem = ref();
    const refButton = ref();
    const refBtnPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeButton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let buttonMethods = {};
    const computeTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().button.transfer;
        if (import_xe_utils7.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeBtnDisabled = computed(() => {
      const { disabled } = props;
      const permissionInfo = computePermissionInfo.value;
      return disabled || permissionInfo.disabled;
    });
    const computeIsFormBtn = computed(() => {
      const { type } = props;
      if (type) {
        return ["submit", "reset", "button"].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = computed(() => {
      const { type, mode } = props;
      if (mode === "text" || type === "text" || $xeButtonGroup && $xeButtonGroup.props.mode === "text") {
        return "text";
      }
      return "button";
    });
    const computeBtnStatus = computed(() => {
      const { status } = props;
      if (status) {
        return status;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.status;
      }
      return "";
    });
    const computeBtnRound = computed(() => {
      const { round } = props;
      if (round) {
        return round;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = computed(() => {
      const { circle } = props;
      if (circle) {
        return circle;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.circle;
      }
      return false;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refButton.value;
        const panelElem = refBtnPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && targetElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { top, left, boundingTop, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          if (transfer) {
            let btnLeft = left + targetWidth - panelWidth;
            let btnTop = top + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              btnTop = top - panelHeight;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                btnTop = top - panelHeight;
              }
              if (btnTop < marginSize) {
                panelPlacement = "bottom";
                btnTop = top + targetHeight;
              }
            }
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${btnLeft}px`,
              right: "auto",
              top: `${btnTop}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const clickEvent = (evnt) => {
      if ($xeButtonGroup) {
        $xeButtonGroup.handleClick({ name: props.name }, evnt);
      } else {
        buttonMethods.dispatchEvent("click", { $event: evnt }, evnt);
      }
    };
    const mousedownDropdownEvent = (evnt) => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = (evnt) => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const { flag, targetElem } = getEventTargetNode(evnt, dropdownElem, "vxe-button");
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = "N";
        }
        reactData.visiblePanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== "Y") {
            reactData.animatVisible = false;
          }
        }, 350);
        buttonMethods.dispatchEvent("dropdown-click", { name: targetElem.getAttribute("name"), $event: evnt }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        reactData.animatVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            reactData.visiblePanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.visiblePanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = (evnt) => {
      openPanel();
      mouseenterEvent(evnt);
    };
    const mouseleaveTargetEvent = (evnt) => {
      closePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = (evnt) => {
      emit("mouseenter", createEvent(evnt, {}));
    };
    const mouseleaveEvent = (evnt) => {
      emit("mouseleave", createEvent(evnt, {}));
    };
    const clickTargetEvent = (evnt) => {
      const { trigger } = props;
      if (trigger === "click") {
        if (reactData.visiblePanel) {
          closePanel();
        } else {
          openPanel();
        }
      }
      clickEvent(evnt);
    };
    const openPanel = () => {
      const { trigger } = props;
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        if (!reactData.inited) {
          reactData.inited = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            mouseenterDropdownEvent();
          } else {
            reactData.animatVisible = false;
          }
        }, trigger === "click" ? 50 : 250);
      }
      return nextTick();
    };
    const closePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = "N";
        setTimeout(() => {
          if (panelElem.dataset.active !== "Y") {
            reactData.visiblePanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== "Y") {
                reactData.animatVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.animatVisible = false;
        reactData.visiblePanel = false;
      }
      return nextTick();
    };
    const mouseleaveDropdownEvent = () => {
      closePanel();
    };
    const renderContent = () => {
      const { content, icon, loading: loading2 } = props;
      const contVNs = [];
      if (loading2) {
        contVNs.push(h("i", {
          class: ["vxe-button--loading-icon", getIcon().BUTTON_LOADING]
        }));
      } else if (slots.icon) {
        contVNs.push(h("span", {
          class: "vxe-button--custom-icon"
        }, slots.icon({})));
      } else if (icon) {
        contVNs.push(h("i", {
          class: ["vxe-button--icon", icon]
        }));
      }
      if (slots.default) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, slots.default({})));
      } else if (content) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, getFuncText(content)));
      }
      return contVNs;
    };
    buttonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $button: $xeButton }, params));
      },
      openPanel,
      closePanel,
      focus() {
        const btnElem = refButton.value;
        btnElem.focus();
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        return nextTick();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const panelElem = refBtnPanel.value;
      if (reactData.visiblePanel && !getEventTargetNode(evnt, panelElem).flag) {
        closePanel();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const btnDisabled = computeBtnDisabled.value;
      const { visiblePanel } = reactData;
      if (!btnDisabled) {
        const el = refElem.value;
        const panelElem = refBtnPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          closePanel();
        }
      }
    };
    Object.assign($xeButton, buttonMethods);
    const renderVN = () => {
      const { className, popupClassName, trigger, title, routerLink, type, destroyOnClose, name, loading: loading2 } = props;
      const { inited, visiblePanel } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnCircle = computeBtnCircle.value;
      const transfer = computeTransfer.value;
      const btnDisabled = computeBtnDisabled.value;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      if (slots.dropdowns) {
        const btnOns = {};
        const panelOns = {};
        if (trigger === "hover") {
          btnOns.onMouseenter = mouseenterTargetEvent;
          btnOns.onMouseleave = mouseleaveTargetEvent;
          panelOns.onMouseenter = mouseenterDropdownEvent;
          panelOns.onMouseleave = mouseleaveDropdownEvent;
        }
        return h("div", {
          ref: refElem,
          class: ["vxe-button--dropdown", className ? import_xe_utils7.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            "is--active": visiblePanel
          }]
        }, [
          routerLink ? h(resolveComponent("router-link"), Object.assign({
            ref: refButton,
            class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, className ? import_xe_utils7.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            to: routerLink,
            onClick: clickTargetEvent
          }, btnOns), {
            default() {
              return renderContent().concat([
                h("i", {
                  class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
                })
              ]);
            }
          }) : h("button", Object.assign({
            ref: refButton,
            class: ["vxe-button", `type--${btnMode}`, className ? import_xe_utils7.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            onClick: clickTargetEvent
          }, btnOns), renderContent().concat([
            h("i", {
              class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
            })
          ])),
          h(Teleport, {
            to: "body",
            disabled: transfer ? !inited : true
          }, [
            h("div", Object.assign({ ref: refBtnPanel, class: ["vxe-button--dropdown-panel", popupClassName ? import_xe_utils7.default.isFunction(popupClassName) ? popupClassName({ $button: $xeButton }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "animat--leave": reactData.animatVisible,
              "animat--enter": visiblePanel
            }], placement: reactData.panelPlacement, style: reactData.panelStyle }, panelOns), inited ? [
              h("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: mousedownDropdownEvent,
                onClick: clickDropdownEvent
              }, destroyOnClose && !visiblePanel ? [] : slots.dropdowns({}))
            ] : [])
          ])
        ]);
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          ref: refButton,
          class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, className ? import_xe_utils7.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            "is--round": btnRound,
            "is--circle": btnCircle,
            "is--disabled": btnDisabled || loading2,
            "is--loading": loading2
          }],
          title,
          name,
          type: isFormBtn ? type : "button",
          disabled: btnDisabled || loading2,
          to: routerLink,
          onClick: clickEvent,
          onMouseenter: mouseenterEvent,
          onMouseleave: mouseleaveEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("button", {
        ref: refButton,
        class: ["vxe-button", `type--${btnMode}`, className ? import_xe_utils7.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          "is--round": btnRound,
          "is--circle": btnCircle,
          "is--disabled": btnDisabled || loading2,
          "is--loading": loading2
        }],
        title,
        name,
        type: isFormBtn ? type : "button",
        disabled: btnDisabled || loading2,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xeButton.renderVN = renderVN;
    onMounted(() => {
      if (true) {
        if (props.type === "text") {
          warnLog("vxe.error.delProp", ["type=text", "mode=text"]);
        }
      }
      globalEvents.on($xeButton, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeButton, "mousedown", handleGlobalMousedownEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeButton, "mousewheel");
      globalEvents.off($xeButton, "mousedown");
    });
    return $xeButton;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/button/index.js
var VxeButton = Object.assign({}, button_default, {
  install(app) {
    app.component(button_default.name, button_default);
  }
});
dynamicApp.component(button_default.name, button_default);
VxeUI.component(button_default);
var Button = VxeButton;
var button_default2 = VxeButton;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/button/src/button-group.js
var import_xe_utils8 = __toESM(require_xe_utils());
var button_group_default = defineComponent({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: { type: String, default: () => getConfig().buttonGroup.size || getConfig().size }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils8.default.uniqueId();
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $buttonGroup: $xeButtonGroup }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const { options } = props;
        const { name } = params;
        const option = options ? options.find((item) => item.name === name) : null;
        buttonGroupMethods.dispatchEvent("click", Object.assign(Object.assign({}, params), { option }), evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const { className, options } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        class: ["vxe-button-group", className ? import_xe_utils8.default.isFunction(className) ? className({ $buttonGroup: $xeButtonGroup }) : className : ""]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return h(button_default, Object.assign({ key: index }, item));
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    provide("$xeButtonGroup", $xeButtonGroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/button-group/index.js
var VxeButtonGroup = Object.assign({}, button_group_default, {
  install(app) {
    app.component(button_group_default.name, button_group_default);
  }
});
dynamicApp.component(button_group_default.name, button_group_default);
VxeUI.component(button_group_default);
var ButtonGroup = VxeButtonGroup;
var button_group_default2 = VxeButtonGroup;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/calendar/src/calendar.js
var import_xe_utils9 = __toESM(require_xe_utils());
var calendar_default = defineComponent({
  name: "VxeCalendar",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils9.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-calendar"]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCalendar.renderVN = renderVN;
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/calendar/index.js
var VxeCalendar = Object.assign({}, calendar_default, {
  install(app) {
    app.component(calendar_default.name, calendar_default);
  }
});
dynamicApp.component(calendar_default.name, calendar_default);
VxeUI.component(calendar_default);
var Calendar = VxeCalendar;
var calendar_default2 = VxeCalendar;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/card/src/card.js
var import_xe_utils10 = __toESM(require_xe_utils());
var card_default = defineComponent({
  name: "VxeCard",
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    }
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils10.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { title, border, shadow, padding, loading: loading2, showTitleOverflow } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const cardStyle = computeCardStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-card", {
          "is--border": border,
          "is--shadow": shadow,
          "is--padding": padding
        }],
        style: cardStyle
      }, [
        title || titleSlot || headerSlot ? h("div", {
          class: "vxe-card--header"
        }, headerSlot ? getSlotVNs(headerSlot({})) : [
          h("div", {
            class: ["vxe-card--header-title", {
              "is--ellipsis": showTitleOverflow
            }]
          }, titleSlot ? getSlotVNs(titleSlot({})) : `${title || ""}`),
          extraSlot ? h("div", {
            class: "vxe-card--header-extra"
          }, getSlotVNs(extraSlot({}))) : createCommentVNode()
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-card--body"
        }, [
          leftSlot ? h("div", {
            class: "vxe-card--body-left"
          }, getSlotVNs(leftSlot({}))) : createCommentVNode(),
          h("div", {
            class: "vxe-card--body-content"
          }, defaultSlot ? getSlotVNs(defaultSlot({})) : []),
          rightSlot ? h("div", {
            class: "vxe-card--body-right"
          }, getSlotVNs(rightSlot({}))) : createCommentVNode()
        ]),
        footerSlot ? h("div", {
          class: "vxe-card--footer"
        }, getSlotVNs(footerSlot({}))) : createCommentVNode(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-card--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/card/index.js
var VxeCard = Object.assign({}, card_default, {
  install(app) {
    app.component(card_default.name, card_default);
  }
});
dynamicApp.component(card_default.name, card_default);
VxeUI.component(card_default);
var Card = VxeCard;
var card_default2 = VxeCard;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/carousel/src/carousel.js
var import_xe_utils11 = __toESM(require_xe_utils());
var carousel_default = defineComponent({
  name: "VxeCarousel",
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: {
      type: Boolean,
      default: () => getConfig().carousel.loading
    },
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils11.default.uniqueId();
    const refElem = ref();
    const refWrapperElem = ref();
    const reactData = reactive({
      activeName: "",
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const refMaps = {
      refElem
    };
    const computeListStyle = computed(() => {
      const { vertical, options } = props;
      const { activeName, itemWidth, itemHeight, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, import_xe_utils11.default.findIndexOf(list, (item) => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      nextTick(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit("update:modelValue", value);
      emit("change", { value }, evnt);
      updateStyle();
    };
    const initDefaultActive = (list) => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCarousel }, params));
    };
    const handlePrevNext = (isNext) => {
      const { options, loop } = props;
      const { activeName, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index = Math.max(0, import_xe_utils11.default.findIndexOf(list, (item) => item.name === activeName));
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent: dispatchEvent2,
      prev() {
        handlePrevNext(false);
        return nextTick();
      },
      next() {
        handlePrevNext(true);
        return nextTick();
      }
    };
    const prevEvent = (evnt) => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const nextEvent = (evnt) => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const carouselPrivateMethods = {};
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = (list) => {
      const { height } = props;
      const { activeName } = reactData;
      const listStyle = computeListStyle.value;
      return h("div", {
        class: "vxe-carousel--list",
        style: listStyle
      }, list.map((item) => {
        const { name, url, slots: slots2 } = item;
        const defaultSlot = slots2 ? slots2.default : null;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--item-inner", {
            "is--active": activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? getSlotVNs(defaultSlot({})) : [
          h("img", {
            class: "vxe-carousel--item-img",
            src: url
          })
        ]);
      }));
    };
    const renderIndicators = (list) => {
      const { activeName } = reactData;
      return h("div", {
        class: "vxe-carousel--indicators"
      }, list.map((item) => {
        const { name } = item;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--indicators-item", {
            "is--active": activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const { loading: loading2, height, width, vertical, options } = props;
      const { staticItems } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return h("div", {
        ref: refElem,
        class: ["vxe-carousel", `is--${vertical ? "vertical" : "horizontal"}`],
        style: width ? {
          width: toCssUnit(width)
        } : null
      }, [
        h("div", {
          class: "vxe-carousel--slots"
        }, defaultSlot ? defaultSlot({}) : []),
        h("div", {
          ref: refWrapperElem,
          class: "vxe-carousel--item-wrapper",
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, renderItemWrapper(list)),
        renderIndicators(list),
        h("div", {
          class: "vxe-carousel--btn-wrapper"
        }, [
          h("div", {
            class: "vxe-carousel--previous-btn",
            onClick: prevEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
            })
          ]),
          h("div", {
            class: "vxe-carousel--next-btn",
            onClick: nextEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
            })
          ])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-carousel--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeCarousel.renderVN = renderVN;
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    onMounted(() => {
      updateStyle();
    });
    provide("$xeCarousel", $xeCarousel);
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/carousel/index.js
var VxeCarousel = Object.assign({}, carousel_default, {
  install(app) {
    app.component(carousel_default.name, carousel_default);
  }
});
dynamicApp.component(carousel_default.name, carousel_default);
VxeUI.component(carousel_default);
var Carousel = VxeCarousel;
var carousel_default2 = VxeCarousel;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/carousel/src/util.js
var import_xe_utils12 = __toESM(require_xe_utils());
function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(import_xe_utils12.default.arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index = import_xe_utils12.default.findIndexOf(staticItems, (item) => item.id === itemConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/carousel/src/carousel-item.js
var import_xe_utils13 = __toESM(require_xe_utils());
var carousel_item_default = defineComponent({
  name: "VxeCarouselItem",
  props: {
    name: String,
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const $xeCarousel = inject("$xeCarousel", null);
    const xID = import_xe_utils13.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const itemConfig = reactive({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    watch(() => props.name, (val) => {
      itemConfig.name = val;
    });
    watch(() => props.url, (val) => {
      itemConfig.url = val;
    });
    onMounted(() => {
      if ($xeCarousel && refElem.value) {
        assembleCarouselItem($xeCarousel, refElem.value, itemConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/carousel-item/index.js
var VxeCarouselItem = Object.assign({}, carousel_item_default, {
  install(app) {
    app.component(carousel_item_default.name, carousel_item_default);
  }
});
dynamicApp.component(carousel_item_default.name, carousel_item_default);
VxeUI.component(carousel_item_default);
var CarouselItem = VxeCarouselItem;
var carousel_item_default2 = VxeCarouselItem;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/checkbox/src/checkbox.js
var import_xe_utils14 = __toESM(require_xe_utils());
var checkbox_default = defineComponent({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number], default: null },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: { type: [String, Number, Boolean], default: true },
    uncheckedValue: { type: [String, Number, Boolean], default: false },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: { type: String, default: () => getConfig().checkbox.size || getConfig().size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeCheckboxGroup = inject("$xeCheckboxGroup", null);
    const xID = import_xe_utils14.default.uniqueId();
    const $xeCheckbox = {
      xID,
      props,
      context
    };
    let checkboxMethods = {};
    const { computeSize } = useSize(props);
    const computeIsChecked = computed(() => {
      if ($xeCheckboxGroup) {
        return import_xe_utils14.default.includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const { computeIsDisabled: computeIsDisabled2, computeIsMaximize } = $xeCheckboxGroup.getComputeMaps();
          const isMaximize = computeIsMaximize.value;
          const isChecked = computeIsChecked.value;
          return computeIsDisabled2.value || isMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = (evnt) => {
      const { checkedValue, uncheckedValue } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = { checked, value, label: props.label };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          checkboxMethods.dispatchEvent("change", params, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    checkboxMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $checkbox: $xeCheckbox }, params));
      }
    };
    Object.assign($xeCheckbox, checkboxMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = props.indeterminate;
      return h("label", {
        class: ["vxe-checkbox", {
          [`size--${vSize}`]: vSize,
          "is--indeterminate": indeterminate,
          "is--disabled": isDisabled,
          "is--checked": isChecked
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h("span", {
          class: ["vxe-checkbox--icon", indeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
        }),
        h("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeCheckbox.renderVN = renderVN;
    return $xeCheckbox;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/checkbox/index.js
var VxeCheckbox = Object.assign(checkbox_default, {
  install(app) {
    app.component(checkbox_default.name, checkbox_default);
  }
});
var Checkbox = VxeCheckbox;
dynamicApp.component(checkbox_default.name, checkbox_default);
VxeUI.component(checkbox_default);
var checkbox_default2 = VxeCheckbox;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/checkbox/src/group.js
var import_xe_utils15 = __toESM(require_xe_utils());
var group_default = defineComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => getConfig().checkboxGroup.size || getConfig().size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils15.default.uniqueId();
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, max } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils15.default.toNumber(max);
      }
      return false;
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const checkboxGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $checkboxGroup: $xeCheckboxGroup }, params));
      }
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const { checked, label } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xeCheckboxGroup.dispatchEvent("change", Object.assign({ checklist }, params), evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const { options } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return h("div", {
        class: "vxe-checkbox-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(checkbox_default, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    $xeCheckboxGroup.renderVN = renderVN;
    provide("$xeCheckboxGroup", $xeCheckboxGroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/checkbox-group/index.js
var VxeCheckboxGroup = Object.assign(group_default, {
  install(app) {
    app.component(group_default.name, group_default);
  }
});
dynamicApp.component(group_default.name, group_default);
VxeUI.component(group_default);
var CheckboxGroup = VxeCheckboxGroup;
var checkbox_group_default = VxeCheckboxGroup;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/row/src/col.js
var import_xe_utils16 = __toESM(require_xe_utils());
var col_default = defineComponent({
  name: "VxeCol",
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils16.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const $xeRow = inject("$xeRow", null);
    const computeRowGutter = computed(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = computed(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = computed(() => {
      const { width } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = import_xe_utils16.default.isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const padding = import_xe_utils16.default.isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = import_xe_utils16.default.isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { span, fill, align, ellipsis } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-col", span ? `span${span}` : "", align ? `align--${align}` : "", {
          "is--span": span,
          "is--fill": fill,
          "is--ellipsis": ellipsis
        }],
        style: colStyle
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/col/index.js
var VxeCol = Object.assign({}, col_default, {
  install(app) {
    app.component(col_default.name, col_default);
  }
});
dynamicApp.component(col_default.name, col_default);
VxeUI.component(col_default);
var Col = VxeCol;
var col_default2 = VxeCol;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/collapse/src/collapse.js
var import_xe_utils17 = __toESM(require_xe_utils());
var collapse_default = defineComponent({
  name: "VxeCollapse",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils17.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-collapse"]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/collapse/index.js
var VxeCollapse = Object.assign({}, collapse_default, {
  install(app) {
    app.component(collapse_default.name, collapse_default);
  }
});
dynamicApp.component(collapse_default.name, collapse_default);
VxeUI.component(collapse_default);
var Collapse = VxeCollapse;
var collapse_default2 = VxeCollapse;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/collapse-pane/src/collapse-pane.js
var import_xe_utils18 = __toESM(require_xe_utils());
var collapse_pane_default = defineComponent({
  name: "VxeCollapsePane",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils18.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-collapse-pane"]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/collapse-pane/index.js
var VxeCollapsePane = Object.assign({}, collapse_pane_default, {
  install(app) {
    app.component(collapse_pane_default.name, collapse_pane_default);
  }
});
dynamicApp.component(collapse_pane_default.name, collapse_pane_default);
VxeUI.component(collapse_pane_default);
var CollapsePane = VxeCollapsePane;
var collapse_pane_default2 = VxeCollapsePane;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/date-picker/src/date-picker.js
var import_xe_utils19 = __toESM(require_xe_utils());
var yearSize = 12;
var monthSize = 20;
var quarterSize = 8;
function toStringTimeDate(str) {
  if (str) {
    const rest = /* @__PURE__ */ new Date();
    let h2 = 0;
    let m = 0;
    let s = 0;
    if (import_xe_utils19.default.isDate(str)) {
      h2 = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = import_xe_utils19.default.toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h2 = import_xe_utils19.default.toNumber(parses[1]);
        m = import_xe_utils19.default.toNumber(parses[3]);
        s = import_xe_utils19.default.toNumber(parses[5]);
      }
    }
    rest.setHours(h2);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return /* @__PURE__ */ new Date("");
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
var date_picker_default = defineComponent({
  name: "VxeDatePicker",
  props: {
    modelValue: [String, Number, Date],
    immediate: { type: Boolean, default: true },
    name: String,
    type: { type: String, default: "date" },
    clearable: { type: Boolean, default: () => getConfig().datePicker.clearable },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxlength: [String, Number],
    autocomplete: { type: String, default: "off" },
    align: String,
    form: String,
    className: String,
    size: { type: String, default: () => getConfig().datePicker.size || getConfig().size },
    multiple: Boolean,
    // date、week、month、quarter、year
    startDate: { type: [String, Number, Date], default: () => getConfig().datePicker.startDate },
    endDate: { type: [String, Number, Date], default: () => getConfig().datePicker.endDate },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: { type: [String, Number], default: () => getConfig().datePicker.startDay },
    labelFormat: String,
    valueFormat: String,
    editable: { type: Boolean, default: true },
    festivalMethod: { type: Function, default: () => getConfig().datePicker.festivalMethod },
    disabledMethod: { type: Function, default: () => getConfig().datePicker.disabledMethod },
    // week
    selectDay: { type: [String, Number], default: () => getConfig().datePicker.selectDay },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils19.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: null,
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let datePickerMethods = {};
    const parseDate = (value, format) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils19.default.toStringDate(value, format);
    };
    const computeTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (import_xe_utils19.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils19.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils19.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].includes(props.type);
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils19.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate(item, dateValueFormat);
          if (import_xe_utils19.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils19.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils19.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return type === "time" ? "HH:mm:ss" : type === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (import_xe_utils19.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils19.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isDatePickerType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils19.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils19.default.toNumber(import_xe_utils19.default.isNumber(startDay) || import_xe_utils19.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils19.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils19.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils19.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils19.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils19.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils19.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils19.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils19.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils19.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils19.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils19.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeDatePickerType = computed(() => {
      return "text";
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      datePickerMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      datePickerMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils19.default.toValueString(props.modelValue) !== value) {
        datePickerMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitDatePickerEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          datePickerMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitDatePickerEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        datePickerMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    let hidePanelTimeout;
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      emitModel("", evnt);
      datePickerMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        datePickerMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (import_xe_utils19.default.isValidDate(dValue)) {
        dLabel = import_xe_utils19.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils19.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        changeValue();
      }
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils19.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils19.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils19.default.toNumber(props.selectDay);
        date = import_xe_utils19.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = import_xe_utils19.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils19.default.findIndexOf(dateListValue, (val) => import_xe_utils19.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          emitModel(datetimeRest.map((date2) => import_xe_utils19.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils19.default.isEqual(val, inpVal))) {
            emitModel(dateMultipleValue.filter((val) => !import_xe_utils19.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils19.default.isEqual(modelValue, inpVal)) {
          emitModel(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (inputValue) {
          let inpDateVal = parseDate(inputValue, dateLabelFormat);
          if (import_xe_utils19.default.isValidDate(inpDateVal)) {
            if (type === "time") {
              inpDateVal = import_xe_utils19.default.toDateString(inpDateVal, dateLabelFormat);
              if (inputValue !== inpDateVal) {
                emitModel(inpDateVal, { type: "check" });
              }
              reactData.inputValue = inpDateVal;
            } else {
              let isChange = false;
              const firstDayOfWeek = computeFirstDayOfWeek.value;
              if (type === "datetime") {
                const dateValue = computeDateValue.value;
                if (inputValue !== import_xe_utils19.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils19.default.toDateString(inpDateVal, dateLabelFormat)) {
                  isChange = true;
                  datetimePanelValue.setHours(inpDateVal.getHours());
                  datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                  datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                }
              } else {
                isChange = true;
              }
              reactData.inputValue = import_xe_utils19.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
              if (isChange) {
                dateChange(inpDateVal);
              }
            }
          } else {
            dateRevert();
          }
        } else {
          emitModel("", { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      datePickerMethods.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    const keydownEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const wheelEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils19.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils19.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils19.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        datePickerMethods.dispatchEvent("date-prev", { type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      datePickerMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils19.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils19.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        datePickerMethods.dispatchEvent("date-next", { type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $datePicker: $xeDatePicker });
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils19.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils19.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils19.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils19.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            emitModel(datetimeRest.map((date) => import_xe_utils19.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils19.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils19.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils19.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils19.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils19.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils19.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils19.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils19.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils19.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils19.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils19.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils19.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils19.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils19.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils19.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils19.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils19.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils19.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils19.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils19.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils19.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils19.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils19.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), updateTimePos);
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const transfer = computeTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $datePicker: $xeDatePicker });
        const festivalItem = festivalRest ? import_xe_utils19.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils19.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-date-picker--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", label),
            h("span", {
              class: ["vxe-date-picker--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils19.default.toValueString(extraItem.label))
          ] : label)
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils19.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-date-picker--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-date-picker--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-date-picker--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils19.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils19.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils19.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils19.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils19.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils19.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils19.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils19.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils19.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils19.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils19.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils19.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils19.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils19.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils19.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-date-picker--date-picker-header"
        }, [
          h("div", {
            class: "vxe-date-picker--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-date-picker--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-date-picker--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-date-picker--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-date-picker--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-date-picker--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-date-picker--time-picker-header"
        }, [
          hasTimeMinute ? h("div", {
            class: "vxe-date-picker--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-date-picker--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-date-picker--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-date-picker--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-date-picker--time-picker-hour-list"
          }, hourList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-date-picker--time-picker-minute-list"
          }, minuteList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-date-picker--time-picker-second-list"
          }, secondList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderPanel = () => {
      const { type } = props;
      const { inited, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const transfer = computeTransfer.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-date-picker--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-date-picker--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            key: type || "default",
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-date-picker--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, renders)
        ]);
      }
      return createCommentVNode();
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-date-picker--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-date-picker--prefix-icon"
        }, prefixSlot ? getSlotVNs(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-date-picker--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils19.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-date-picker--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-date-picker--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]);
    };
    const renderExtraSuffixIcon = () => {
      return h("div", {
        class: "vxe-date-picker--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-date-picker--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    datePickerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $input: $xeDatePicker }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick(() => {
      globalEvents.on($xeDatePicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeDatePicker, "mousewheel");
      globalEvents.off($xeDatePicker, "mousedown");
      globalEvents.off($xeDatePicker, "keydown");
      globalEvents.off($xeDatePicker, "blur");
    });
    initValue();
    const renderVN = () => {
      const { className, type, align, name, autocomplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-date-picker--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const inputReadonly = computeInputReadonly.value;
      const inputType = computeDatePickerType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-date-picker", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils19.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-date-picker--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-date-picker--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onDatePicker: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 下拉面板
        renderPanel()
      ]);
    };
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/date-picker/index.js
var VxeDatePicker = Object.assign({}, date_picker_default, {
  install(app) {
    app.component(date_picker_default.name, date_picker_default);
    app.component("VxeDateInput", date_picker_default);
  }
});
dynamicApp.component(date_picker_default.name, date_picker_default);
VxeUI.component(date_picker_default);
var DatePicker = VxeDatePicker;
var date_picker_default2 = VxeDatePicker;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/drawer/index.js
var import_xe_utils21 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var import_xe_utils20 = __toESM(require_xe_utils());
var allActiveDrawers = [];
var drawer_default = defineComponent({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: { type: Boolean, default: null },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: { type: Boolean, default: () => getConfig().drawer.lockView },
    lockScroll: Boolean,
    mask: { type: Boolean, default: () => getConfig().drawer.mask },
    maskClosable: { type: Boolean, default: () => getConfig().drawer.maskClosable },
    escClosable: { type: Boolean, default: () => getConfig().drawer.escClosable },
    showHeader: { type: Boolean, default: () => getConfig().drawer.showHeader },
    showFooter: { type: Boolean, default: () => getConfig().drawer.showFooter },
    showClose: { type: Boolean, default: () => getConfig().drawer.showClose },
    content: [Number, String],
    showCancelButton: { type: Boolean, default: null },
    cancelButtonText: { type: String, default: () => getConfig().drawer.cancelButtonText },
    showConfirmButton: { type: Boolean, default: () => getConfig().drawer.showConfirmButton },
    confirmButtonText: { type: String, default: () => getConfig().drawer.confirmButtonText },
    destroyOnClose: { type: Boolean, default: () => getConfig().drawer.destroyOnClose },
    showTitleOverflow: { type: Boolean, default: () => getConfig().drawer.showTitleOverflow },
    width: [Number, String],
    height: [Number, String],
    zIndex: Number,
    transfer: { type: Boolean, default: () => getConfig().drawer.transfer },
    padding: { type: Boolean, default: () => getConfig().drawer.padding },
    size: { type: String, default: () => getConfig().drawer.size || getConfig().size },
    beforeHideMethod: { type: Function, default: () => getConfig().drawer.beforeHideMethod },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils20.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refDrawerBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      firstOpen: true
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ""}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ""}`;
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { drawerZIndex } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
      });
    };
    const closeDrawer2 = (type) => {
      const { beforeHideMethod } = props;
      const { visible } = reactData;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils20.default.isError(rest)) {
            reactData.contentVisible = false;
            import_xe_utils20.default.remove(allActiveDrawers, (item) => item === $xeDrawer);
            drawerMethods.dispatchEvent("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              drawerMethods.dispatchEvent("hide", params, null);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const confirmEvent = (evnt) => {
      const type = "confirm";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const cancelEvent = (evnt) => {
      const type = "cancel";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const openDrawer2 = () => {
      const { showFooter } = props;
      const { initialized, visible } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        recalculate();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            drawerMethods.dispatchEvent("show", params, null);
          });
        }, 10);
        nextTick(() => {
          const { firstOpen } = reactData;
          if (firstOpen) {
            updatePosition().then(() => {
              setTimeout(() => updatePosition(), 20);
            });
          }
          if (firstOpen) {
            reactData.firstOpen = false;
          }
        });
      }
      return nextTick();
    };
    const drawerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $drawer: $xeDrawer }, params));
      },
      open: openDrawer2,
      close() {
        return closeDrawer2("close");
      },
      getBox
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeDrawer2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = import_xe_utils20.default.max(allActiveDrawers, (item) => item.reactData.drawerZIndex);
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              closeDrawer2("exit");
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const { drawerZIndex } = reactData;
      if (allActiveDrawers.some((comp) => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, title } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [
        h("div", {
          class: "vxe-drawer--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({ $drawer: $xeDrawer })) : title ? getFuncText(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-drawer--header-right"
        }, [
          cornerSlot ? h("div", {
            class: "vxe-drawer--corner-wrapper"
          }, getSlotVNs(cornerSlot({ $drawer: $xeDrawer }))) : createCommentVNode(),
          showClose ? h("div", {
            class: ["vxe-drawer--close-btn", "trigger--btn"],
            title: getI18n("vxe.drawer.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().DRAWER_CLOSE
            })
          ]) : createCommentVNode()
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showTitleOverflow } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return h("div", {
          class: ["vxe-drawer--header", {
            "is--ellipsis": showTitleOverflow
          }]
        }, headerSlot ? getSlotVNs(headerSlot({ $drawer: $xeDrawer })) : renderTitles());
      }
      return createCommentVNode();
    };
    const renderBody = () => {
      const { slots: propSlots = {}, content } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return h("div", {
        class: "vxe-drawer--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-drawer--body-left"
        }, getSlotVNs(leftSlot({ $drawer: $xeDrawer }))) : createCommentVNode(),
        h("div", {
          class: "vxe-drawer--body-default"
        }, [
          h("div", {
            class: "vxe-drawer--content"
          }, defaultSlot ? getSlotVNs(defaultSlot({ $drawer: $xeDrawer })) : getFuncText(content))
        ]),
        rightSlot ? h("div", {
          class: "vxe-drawer--body-right"
        }, getSlotVNs(rightSlot({ $drawer: $xeDrawer }))) : createCommentVNode(),
        h(loading_default2, {
          class: "vxe-drawer--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-drawer--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-drawer--footer-left"
        }, lfSlot ? getSlotVNs(lfSlot({ $drawer: $xeDrawer })) : []),
        h("div", {
          class: "vxe-drawer--footer-right"
        }, rfSlot ? getSlotVNs(rfSlot({ $drawer: $xeDrawer })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-drawer--footer"
        }, footerSlot ? getSlotVNs(footerSlot({ $drawer: $xeDrawer })) : [renderDefaultFooter()]);
      }
      return createCommentVNode();
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, position, loading: loading2, lockScroll, padding, lockView, mask, destroyOnClose } = props;
      const { initialized, contentVisible, visible } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !initialized : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-drawer--wrapper", `pos--${position}`, className || "", {
            [`size--${vSize}`]: vSize,
            "is--padding": padding,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--mask": mask,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading2
          }],
          style: {
            zIndex: reactData.drawerZIndex
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refDrawerBox,
            class: "vxe-drawer--box",
            onMousedown: boxMousedownEvent
          }, [
            asideSlot ? h("div", {
              class: "vxe-drawer--aside"
            }, getSlotVNs(asideSlot({ $drawer: $xeDrawer }))) : createCommentVNode(),
            h("div", {
              class: "vxe-drawer--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter()
            ])
          ])
        ])
      ]);
    };
    $xeDrawer.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openDrawer2();
      } else {
        closeDrawer2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.modelValue) {
          openDrawer2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeDrawer, "keydown");
    });
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/drawer/index.js
function openDrawer(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveDrawers.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: import_xe_utils21.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter((item) => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return import_xe_utils21.default.find(allActiveDrawers, ($drawer) => $drawer.props.id === id);
}
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach(($drawer) => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
var DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
var VxeDrawer = Object.assign(drawer_default, {
  install: function(app) {
    app.component(drawer_default.name, drawer_default);
  }
});
dynamicApp.component(drawer_default.name, drawer_default);
VxeUI.component(drawer_default);
VxeUI.drawer = DrawerController;
var Drawer = VxeDrawer;
var drawer_default2 = VxeDrawer;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/form.js
var import_xe_utils25 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/util.js
var import_xe_utils23 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/itemInfo.js
var import_xe_utils22 = __toESM(require_xe_utils());
var ItemInfo = class {
  constructor($xeForm, item) {
    Object.assign(this, {
      id: import_xe_utils22.default.uniqueId("item_"),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 渲染属性
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/util.js
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return import_xe_utils23.default.isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { collapseAll } = reactData;
  const { folding, visible } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  let { visibleMethod, itemRender, visible, field } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const { data } = $xeForm.props;
  return visibleMethod({ data, field, property: field, item: formItem, $form: $xeForm, $grid: $xeForm.xegrid });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el, formItem, formGather) {
  const { reactData } = $xeForm;
  const { staticItems } = reactData;
  const parentElem = el.parentNode;
  const parentItem = formGather ? formGather.formItem : null;
  const parentItems = parentItem ? parentItem.children : staticItems;
  if (parentElem) {
    parentItems.splice(import_xe_utils23.default.arrayIndexOf(parentElem.children, el), 0, formItem);
    reactData.staticItems = staticItems.slice(0);
  }
}
function destroyItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { staticItems } = reactData;
  const index = import_xe_utils23.default.findIndexOf(staticItems, (item) => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/form-config-item.js
var import_xe_utils24 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/icon/src/icon.js
var icon_default = defineComponent({
  name: "VxeIcon",
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: { type: String, default: () => getConfig().icon.size || getConfig().size }
  },
  emits: [
    "click"
  ],
  setup(props, { emit }) {
    const { computeSize } = useSize(props);
    const clickEvent = (evnt) => {
      emit("click", createEvent(evnt, {}));
    };
    return () => {
      const { name, roll, status, className } = props;
      const vSize = computeSize.value;
      return h("i", {
        class: ["vxe-icon", `vxe-icon-${name}`, `${className || ""}`, {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          roll
        }],
        onClick: clickEvent
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/render.js
function renderPrefixIcon(titlePrefix) {
  return h("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    h(icon_default, {
      class: titlePrefix.icon || getIcon().FORM_PREFIX,
      status: titlePrefix.iconStatus
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    h(icon_default, {
      class: titleSuffix.icon || getIcon().FORM_SUFFIX,
      status: titleSuffix.iconStatus
    })
  ]);
}
function renderTitle($xeForm, item) {
  const { data, readonly, disabled } = $xeForm.props;
  const { computeTooltipOpts } = $xeForm.getComputeMaps();
  const { slots, field, itemRender, titlePrefix, titleSuffix } = item;
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const params = { data, readonly, disabled, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  const titleSlot = slots ? slots.title : null;
  const extraSlot = slots ? slots.extra : null;
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titlePrefix), { content: getFuncText(titlePrefix.content || titlePrefix.message) }), {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push(h("span", {
    class: "vxe-form--item-title-label"
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? getSlotVNs(rftTitle(itemRender, params)) : getFuncText(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titleSuffix), { content: getFuncText(titleSuffix.content || titleSuffix.message) }), {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  return [
    h("div", {
      class: "vxe-form--item-title-content"
    }, titVNs),
    h("div", {
      class: "vxe-form--item-title-postfix"
    }, fixVNs),
    extraSlot ? h("div", {
      class: "vxe-form--item-title-extra"
    }, $xeForm.callSlot(extraSlot, params)) : createCommentVNode()
  ];
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/form-config-item.js
var VxeFormConfigItem = defineComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = inject("$xeForm", {});
    const xeformiteminfo = { itemConfig: props.itemConfig };
    provide("xeFormItemInfo", xeformiteminfo);
    const renderVN = () => {
      const { reactData } = $xeForm;
      const { data, rules, readonly, disabled, span: allSpan, align: allAlign, titleBold: allTitleBold, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, titleOverflow: allTitleOverflow, vertical: allVertical, padding: allPadding } = $xeForm.props;
      const { computeValidOpts } = $xeForm.getComputeMaps();
      const item = props.itemConfig;
      const { collapseAll } = reactData;
      const validOpts = computeValidOpts.value;
      const { slots, title, visible, folding, field, collapseNode, itemRender, showError, errRule, className, titleOverflow, vertical, padding, children, showTitle, contentClassName, contentStyle, titleClassName, titleStyle } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : "";
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : "";
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : "";
      const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const titleSlot = slots ? slots.title : null;
      const span = item.span || allSpan;
      const align = item.align || allAlign;
      const itemPadding = import_xe_utils24.default.eqNull(padding) ? allPadding : padding;
      const itemVertical = import_xe_utils24.default.eqNull(vertical) ? allVertical : vertical;
      const titleBold = import_xe_utils24.default.eqNull(item.titleBold) ? allTitleBold : item.titleBold;
      const titleAlign = import_xe_utils24.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = itemVertical ? null : import_xe_utils24.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = import_xe_utils24.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = import_xe_utils24.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = import_xe_utils24.default.eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const ovEllipsis = itemOverflow === "ellipsis";
      const ovTitle = itemOverflow === "title";
      const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
      if (visible === false) {
        return createCommentVNode();
      }
      let isRequired = false;
      let isValid = false;
      if (!readonly && rules) {
        const itemRules = rules[field];
        if (itemRules && itemRules.length) {
          isValid = true;
          isRequired = itemRules.some((rule) => rule.required);
        }
      }
      const isGather = children && children.length > 0;
      if (isGather) {
        const childVNs = children.map((childItem, index) => {
          return h(VxeFormConfigItem, {
            key: index,
            itemConfig: childItem
          });
        });
        return childVNs.length ? h("div", {
          class: ["vxe-form--gather vxe-form--item-row", item.id, span ? `vxe-form--item-col_${span} is--span` : "", className ? import_xe_utils24.default.isFunction(className) ? className(params) : className : ""]
        }, childVNs) : createCommentVNode();
      }
      let contentVNs = [];
      const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
      if (defaultSlot) {
        contentVNs = $xeForm.callSlot(defaultSlot, params);
      } else if (rftContent) {
        contentVNs = getSlotVNs(rftContent(itemRender, params));
      } else if (field) {
        contentVNs = [import_xe_utils24.default.toValueString(import_xe_utils24.default.get(data, field))];
      }
      if (collapseNode) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeForm.toggleCollapseEvent
        }, [
          h("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? getI18n("vxe.form.unfolding") : getI18n("vxe.form.folding")),
          h("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? getIcon().FORM_FOLDING : getIcon().FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.content));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeForm.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeForm.handleTitleTipLeaveEvent
      } : {};
      return h("div", {
        class: [
          "vxe-form--item",
          item.id,
          span ? `vxe-form--item-col_${span} is--span` : "",
          className ? import_xe_utils24.default.isFunction(className) ? className(params) : className : "",
          itemClassName ? import_xe_utils24.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--colon": titleColon,
            "is--bold": titleBold,
            "is--padding": itemPadding,
            "is--vertical": itemVertical,
            "is--asterisk": titleAsterisk,
            "is--valid": isValid,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActiveItem($xeForm, item),
            "is--error": showError
          }
        ],
        style: import_xe_utils24.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        h("div", {
          class: "vxe-form--item-inner"
        }, [
          showTitle !== false && (title || titleSlot) ? h("div", Object.assign({ class: [
            "vxe-form--item-title",
            titleAlign ? `align--${titleAlign}` : "",
            hasEllipsis ? "is--ellipsis" : "",
            itemTitleClassName ? import_xe_utils24.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
            titleClassName ? import_xe_utils24.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
          ], style: Object.assign({}, import_xe_utils24.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils24.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
          } : null), title: ovTitle ? getFuncText(title) : null }, ons), renderTitle($xeForm, item)) : null,
          h("div", {
            class: [
              "vxe-form--item-content",
              align ? `align--${align}` : "",
              itemContentClassName ? import_xe_utils24.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
              contentClassName ? import_xe_utils24.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
            ],
            style: Object.assign({}, import_xe_utils24.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils24.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
          }, contentVNs)
        ])
      ]);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    provide("$xeFormGather", null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
var form_config_item_default = VxeFormConfigItem;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/form.js
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var validErrorRuleValue = (rule, val) => {
  const { type, min, max, pattern } = rule;
  const isNumType = type === "number";
  const numVal = isNumType ? import_xe_utils25.default.toNumber(val) : import_xe_utils25.default.getSize(val);
  if (isNumType && isNaN(val)) {
    return true;
  }
  if (!import_xe_utils25.default.eqNull(min) && numVal < import_xe_utils25.default.toNumber(min)) {
    return true;
  }
  if (!import_xe_utils25.default.eqNull(max) && numVal > import_xe_utils25.default.toNumber(max)) {
    return true;
  }
  if (pattern && !(import_xe_utils25.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
function getResetValue(value, resetValue) {
  if (import_xe_utils25.default.isArray(value)) {
    resetValue = [];
  }
  return resetValue;
}
var form_default = defineComponent({
  name: "VxeForm",
  props: {
    collapseStatus: { type: Boolean, default: true },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils25.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = reactive({
      tooltipTimeout: null,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    provide("xeFormItemInfo", null);
    const $xeGrid = inject("$xeGrid", null);
    const refElem = ref();
    const refTooltip = ref();
    let formMethods = {};
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      xegrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils25.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils25.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = (list) => {
      if (list.length) {
        if (true) {
          list.forEach((item) => {
            if (item.slots) {
              import_xe_utils25.default.each(item.slots, (func) => {
                if (!import_xe_utils25.default.isFunction(func)) {
                  if (!slots[func]) {
                    errLog("vxe.error.notSlot", [func]);
                  }
                }
              });
            }
          });
        }
      }
      reactData.staticItems = import_xe_utils25.default.mapTree(list, (item) => createItem($xeForm, item), { children: "children" });
      return nextTick();
    };
    const getItems = () => {
      const itemList = [];
      import_xe_utils25.default.eachTree(reactData.formItems, (item) => {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    const getItemByField = (field) => {
      const rest = import_xe_utils25.default.findTree(reactData.formItems, (item) => item.field === field, { children: "children" });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick();
    };
    const toggleCollapseEvent = (evnt) => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
    };
    const clearValidate = (fieldOrItem) => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!import_xe_utils25.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach((field) => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach((item) => {
          item.showError = false;
        });
      }
      return nextTick();
    };
    const reset = () => {
      const { data } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach((item) => {
          const { field, resetValue, itemRender } = item;
          if (isEnableConf(itemRender)) {
            const compConf = renderer.get(itemRender.name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({ data, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid });
            } else if (field) {
              import_xe_utils25.default.set(data, field, resetValue === null ? getResetValue(import_xe_utils25.default.get(data, field), void 0) : import_xe_utils25.default.clone(resetValue, true));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = (evnt) => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    const handleFocus = (fields) => {
      const el = refElem.value;
      if (el) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf(item.itemRender)) {
            const { itemRender } = item;
            const compConf = renderer.get(itemRender.name);
            if (!i) {
              scrollToView(el.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            if (import_xe_utils25.default.isFunction(autoFocus)) {
              inputElem = autoFocus({ $form: $xeForm, $grid: $xeGrid, item, data: props.data, field });
            } else if (autoFocus) {
              inputElem = el.querySelector(`.${item.id} ${autoFocus}`);
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    const validItemRules = (validType, fields, val) => {
      const { data, rules: formRules } = props;
      const errorMaps = {};
      if (!import_xe_utils25.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map((property) => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = import_xe_utils25.default.get(formRules, property);
          if (rules) {
            const itemValue = import_xe_utils25.default.isUndefined(val) ? import_xe_utils25.default.get(data, property) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (import_xe_utils25.default.isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils25.default.isError(customValid)) {
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncVailds.push(customValid.catch((e) => {
                        errorRules.push(new Rule({ type: "custom", trigger, content: e ? e.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils25.default.isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (import_xe_utils25.default.isString(itemValue)) {
                    hasEmpty = eqEmptyValue(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map((rule) => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!import_xe_utils25.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    let showErrTime;
    const beginValidate = (itemList, type, callback) => {
      const { data, rules: formRules } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(showErrTime);
      if (data && formRules) {
        itemList.forEach((item) => {
          const { field } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || "all", field).then(() => {
              item.errRule = null;
            }).catch((errorMaps) => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise((resolve) => {
            showErrTime = window.setTimeout(() => {
              itemList.forEach((item) => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = (callback) => {
      const { readonly } = props;
      clearValidate();
      if (readonly) {
        return nextTick();
      }
      return beginValidate(getItems(), "", callback);
    };
    const validateField = (fieldOrItem, callback) => {
      const { readonly } = props;
      if (readonly) {
        return nextTick();
      }
      let fields = [];
      if (fieldOrItem) {
        if (import_xe_utils25.default.isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map((field) => handleFieldOrItem($xeForm, field)), "", callback);
    };
    const submitEvent = (evnt) => {
      const { readonly } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          return;
        }
        beginValidate(getItems()).then((errMap) => {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const { item } = params;
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || "").trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.tooltipTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.tooltipTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(() => {
          clearValidate(field);
        }).catch((errorMaps) => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return nextTick();
    };
    const updateStatus = (scope, itemValue) => {
      const { field } = scope;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $form: $xeForm, $grid: $xeGrid }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, className, data, customLayout } = props;
      const { formItems } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return h("form", {
        ref: refElem,
        class: ["vxe-form", className ? import_xe_utils25.default.isFunction(className) ? className({ items: formItems, data, $form: $xeForm }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }],
        spellcheck: false,
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
          return h(form_config_item_default, {
            key: index,
            itemConfig: item
          });
        })),
        h("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-form--loading",
          modelValue: loading2
        }),
        /**
         * 工具提示
         */
        h(tooltip_default, Object.assign({ ref: refTooltip }, tooltipOpts))
      ]);
    };
    $xeForm.renderVN = renderVN;
    const staticItemFlag = ref(0);
    watch(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    watch(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => props.collapseStatus, (value) => {
      reactData.collapseAll = !!value;
    });
    watch(() => props.readonly, () => {
      clearValidate();
    });
    watch(() => props.disabled, () => {
      clearValidate();
    });
    onMounted(() => {
      nextTick(() => {
        if (true) {
          if (props.customLayout && props.items) {
            errLog("vxe.error.errConflicts", ["custom-layout", "items"]);
          }
        }
      });
    });
    if (props.items) {
      loadItem(props.items);
    }
    provide("$xeForm", $xeForm);
    provide("$xeFormGather", null);
    provide("$xeFormItem", null);
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/render/index.js
var import_xe_utils26 = __toESM(require_xe_utils());
var componentDefaultModelProp = "modelValue";
var defaultCompProps = { transfer: true };
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return resolveComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils26.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getElementOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils26.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const ons = {};
  import_xe_utils26.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils26.default.isFunction(func)) {
          errLog("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getComponentOns(renderOpts, params, (value) => {
    import_xe_utils26.default.set(data, field, value);
  }, () => {
    $form.updateStatus(params);
  });
}
function getNativeItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getElementOns(renderOpts, params, (evnt) => {
    const itemValue = evnt.target.value;
    import_xe_utils26.default.set(data, field, itemValue);
  }, () => {
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function nativeItemRender(renderOpts, params) {
  const { data, field } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = import_xe_utils26.default.get(data, field);
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, attrs), { value: attrs && name === "input" && (attrs.type === "submit" || attrs.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils26.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils26.default.get(data, field);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldButtonItemRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonItemRender(childRenderOpts, params)[0]);
}
function renderNativeFormOptions(options, renderOpts, params) {
  const { data, field } = params;
  const { optionProps = {} } = renderOpts;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = import_xe_utils26.default.get(data, field);
  return options.map((item, oIndex) => {
    return h("option", {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function defaultFormItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils26.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const { options, optionProps } = renderOpts;
  const { data, field } = params;
  const itemValue = import_xe_utils26.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({
      options,
      optionProps
    }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const { name, options, optionProps = {} } = renderOpts;
  const { data, field } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const itemValue = import_xe_utils26.default.get(data, field);
  const compName = getOldComponentName(name);
  if (options) {
    return [
      h(resolveComponent(`${compName}-group`), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: () => {
          return options.map((item, index) => {
            return h(resolveComponent(compName), {
              key: index,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h(resolveComponent(compName), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
renderer.mixin({
  input: {
    renderItemContent: nativeItemRender
  },
  textarea: {
    renderItemContent: nativeItemRender
  },
  select: {
    renderItemContent(renderOpts, params) {
      return [
        h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    }
  },
  VxeInput: {
    renderItemContent: defaultItemRender
  },
  VxeNumberInput: {
    renderItemContent: defaultItemRender
  },
  VxePasswordInput: {
    renderItemContent: defaultItemRender
  },
  VxeTextarea: {
    renderItemContent: defaultItemRender
  },
  VxeDatePicker: {
    renderItemContent: defaultItemRender
  },
  VxeButton: {
    renderItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderItemContent(renderOpts, params) {
      const { options } = renderOpts;
      const { data, field } = params;
      const itemValue = import_xe_utils26.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    renderItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils26.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTreeSelect: {
    renderItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils26.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeIconPicker: {
    renderItemContent: defaultFormItemRender
  },
  VxeRadio: {
    renderItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderItemContent: defaultItemRender
  },
  VxeImage: {
    renderItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils26.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils26.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeUpload: {
    renderItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    renderItemContent: oldItemRender
  },
  $textarea: {
    renderItemContent: oldItemRender
  },
  $button: {
    renderItemContent: oldButtonItemRender
  },
  $buttons: {
    renderItemContent: oldButtonsItemRender
  },
  $select: {
    renderItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils26.default.get(data, field);
      return [
        h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  $radio: {
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderItemContent: oldItemRender
  }
  // 以上已废弃
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/index.js
var VxeForm = Object.assign(form_default, {
  install(app) {
    app.component(form_default.name, form_default);
  }
});
dynamicApp.component(form_default.name, form_default);
VxeUI.component(form_default);
var Form = VxeForm;
var form_default2 = VxeForm;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/util.js
var import_xe_utils27 = __toESM(require_xe_utils());
var maxWidgetId = 1e5;
function getNewWidgetId(widgetObjList) {
  import_xe_utils27.default.eachTree(widgetObjList, (item) => {
    if (item) {
      maxWidgetId = Math.max(maxWidgetId, item.id);
    }
  }, { children: "children" });
  return ++maxWidgetId;
}
var hasFormDesignLayoutType = (widget) => {
  return widget && getWidgetConfigGroup(widget.name) === "layout";
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/widget-info.js
var import_xe_utils28 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps = ref({});
var createHandleGetField = (key) => {
  return function(name) {
    const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
    const configMaps = widgetReactConfigMaps[name];
    return configMaps ? configMaps[key] : null;
  };
};
function getWidgetConfigTitle(name, $xeFormDesign) {
  const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
  const configMaps = widgetReactConfigMaps[name];
  if (configMaps) {
    const configTitle = configMaps.title;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils28.default.toValueString(import_xe_utils28.default.isFunction(configTitle) ? configTitle(params) : configTitle);
  }
  return name;
}
function getWidgetConfigCustomGroup(name, $xeFormDesign) {
  const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
  const configMaps = widgetReactConfigMaps[name];
  if (configMaps) {
    const configCustomGroup = configMaps.customGroup;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils28.default.toValueString(import_xe_utils28.default.isFunction(configCustomGroup) ? configCustomGroup(params) : configCustomGroup);
  }
  return name;
}
var getWidgetConfigIcon = createHandleGetField("icon");
var getWidgetConfigGroup = createHandleGetField("group");
var getWidgetConfigUnique = createHandleGetField("unique");
var getWidgetConfigScope = createHandleGetField("scope");
var validWidgetUniqueField = (field, widgetObjList) => {
  return !import_xe_utils28.default.findTree(widgetObjList, (item) => item.field === field, { children: "children" });
};
var FormDesignWidgetInfo = class {
  constructor($xeFormDesign, name, widgetObjList) {
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "field", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "title", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "required", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "hidden", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "children", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "model", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        update: false,
        value: ""
      }
    });
    let customField = "";
    if (name) {
      const compConf = renderer.get(name) || {};
      if (compConf) {
        const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
        const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
        if (createWidgetFormConfig) {
          const params = { name, $formDesign: $xeFormDesign };
          const widgetConfig = createWidgetFormConfig(params) || {};
          const titleConf = widgetConfig.title;
          const fieldConf = widgetConfig.field;
          this.title = import_xe_utils28.default.toValueString(import_xe_utils28.default.isFunction(titleConf) ? titleConf(params) : titleConf);
          this.options = widgetConfig.options || {};
          this.children = widgetConfig.children || [];
          if (fieldConf) {
            if (import_xe_utils28.default.isFunction(fieldConf)) {
              customField = fieldConf({ name, $formDesign: $xeFormDesign });
            } else {
              customField = fieldConf;
            }
          }
          if (!widgetReactConfigMaps[name]) {
            widgetReactConfigMaps[name] = {
              title: titleConf || "",
              field: fieldConf || "",
              icon: widgetConfig.icon || "",
              group: widgetConfig.group || "",
              unique: widgetConfig.unique || false,
              scope: widgetConfig.scope || "",
              customGroup: widgetConfig.customGroup || ""
            };
            refWidgetReactConfigMaps.value = Object.assign({}, widgetReactConfigMaps);
          }
        }
      }
    }
    const widgetId = getNewWidgetId(widgetObjList);
    if (customField) {
      if (!validWidgetUniqueField(customField, widgetObjList)) {
        errLog("vxe.error.uniField", [customField]);
      }
    }
    this.id = widgetId;
    this.field = customField || `${name}${widgetId}`;
    this.name = name;
  }
};
function configToWidget(conf) {
  const widget = new FormDesignWidgetInfo(null, conf.name, []);
  widget.id = conf.id;
  widget.title = conf.title || "";
  widget.field = conf.field || "";
  widget.required = conf.required || false;
  widget.hidden = conf.hidden || false;
  widget.options = Object.assign({}, widget.options, conf.options);
  widget.children = conf.children ? conf.children.map((item) => configToWidget(item)) : [];
  return widget;
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var import_xe_utils48 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/layout-widget.js
var import_xe_utils29 = __toESM(require_xe_utils());
var layout_widget_default = defineComponent({
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragstartEvent = (evnt) => {
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetName = divEl.getAttribute("data-widget-name") || "";
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        if (dataTransfer) {
          dataTransfer.setData("text/plain", widgetName);
        }
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = dragWidget;
      } else {
        evnt.preventDefault();
      }
    };
    const dragendEvent = (evnt) => {
      if (formDesignReactData.dragWidget) {
        const newWidget = formDesignReactData.dragWidget;
        formDesignReactData.activeWidget = newWidget;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget }, evnt);
      }
      formDesignReactData.dragWidget = null;
      formDesignReactData.sortWidget = null;
    };
    const cancelDragoverItem = (evnt, group) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        if (group.children.some((widget) => widget.name === dragWidget.name)) {
          const rest = import_xe_utils29.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
          if (rest) {
            rest.items.splice(rest.index, 1);
          }
        }
      }
    };
    const addNewWidget = (evnt, widgetName) => {
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const { widgetObjList } = formDesignReactData;
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        widgetObjList.push(dragWidget);
        formDesignReactData.activeWidget = dragWidget;
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = null;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget: dragWidget }, evnt);
      }
    };
    const renderWidgetList = (group) => {
      const widgetVNs = [];
      if (group.children) {
        group.children.forEach((widget, index) => {
          const { name } = widget;
          const configTitle = getWidgetConfigTitle(name, $xeFormDesign);
          const compConf = renderer.get(name) || {};
          const renderWidgetItem = compConf.renderFormDesignWidgetItem;
          widgetVNs.push(h("div", {
            key: index,
            class: "vxe-form-design--widget-item"
          }, h("div", {
            class: "vxe-form-design--widget-box",
            "data-widget-name": name,
            title: configTitle,
            draggable: true,
            onDragstart: dragstartEvent,
            onDragend: dragendEvent
          }, renderWidgetItem ? getSlotVNs(renderWidgetItem({}, { $formDesign: $xeFormDesign })) : [
            h("i", {
              class: ["vxe-form-design--widget-item-icon", getWidgetConfigIcon(name)]
            }),
            h("span", {
              class: "vxe-form-design--widget-item-name"
            }, configTitle),
            h("span", {
              class: "vxe-form-design--widget-item-add",
              onClick(evnt) {
                addNewWidget(evnt, name);
              }
            }, [
              h("i", {
                class: getIcon().FORM_DESIGN_WIDGET_ADD
              })
            ])
          ])));
        });
      }
      return widgetVNs;
    };
    const renderWidgetGroups = () => {
      const { widgetConfigs } = formDesignReactData;
      return widgetConfigs.map((config2, gIndex) => {
        const { title, group } = config2;
        return h("div", {
          key: gIndex,
          class: "vxe-form-design--widget-group"
        }, [
          h("div", {
            class: "vxe-form-design--widget-title"
          }, group ? getI18n(`vxe.formDesign.widget.group.${group}`) : `${title || ""}`),
          h("div", {
            class: "vxe-form-design--widget-list",
            onDragover(evnt) {
              cancelDragoverItem(evnt, config2);
            }
          }, renderWidgetList(config2))
        ]);
      });
    };
    return () => {
      return h("div", {
        class: "vxe-form-design--widget"
      }, renderWidgetGroups());
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/layout-view-item.js
var import_xe_utils30 = __toESM(require_xe_utils());
var ViewItemComponent = defineComponent({
  name: "FormDesignLayoutViewItem",
  props: {
    item: {
      type: Object,
      default: () => ({})
    },
    itemIndex: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      default: () => []
    }
  },
  emits: [],
  setup(props, { slots }) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartEvent = (evnt) => {
      const { widgetObjList, sortSubWidget } = formDesignReactData;
      if (sortSubWidget) {
        evnt.preventDefault();
        return;
      }
      const divEl = evnt.currentTarget;
      const widgetId = Number(divEl.getAttribute("data-widget-id"));
      const currRest = import_xe_utils30.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
      if (currRest) {
        formDesignReactData.dragWidget = null;
        formDesignReactData.sortWidget = currRest.item;
        formDesignReactData.sortSubWidget = null;
      }
    };
    const sortDragendEvent = () => {
      formDesignReactData.activeWidget = formDesignReactData.sortWidget;
      formDesignReactData.sortWidget = null;
    };
    let isDragAnimate = false;
    const sortDragenterEvent = (evnt) => {
      const { widgetObjList, sortWidget, sortSubWidget } = formDesignReactData;
      if (isDragAnimate || sortSubWidget) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        const divEl = evnt.currentTarget;
        evnt.preventDefault();
        const widgetId = Number(divEl.getAttribute("data-widget-id"));
        if (widgetId !== sortWidget.id) {
          const targetRest = import_xe_utils30.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
          if (targetRest) {
            const currRest = import_xe_utils30.default.findTree(widgetObjList, (item) => item && item.id === sortWidget.id, { children: "children" });
            if (currRest) {
              currRest.items.splice(currRest.index, 1);
              targetRest.items.splice(targetRest.index, 0, currRest.item);
              $xeFormDesign.dispatchEvent("drag-widget", { widget: currRest.item }, evnt);
              isDragAnimate = true;
              setTimeout(() => {
                isDragAnimate = false;
              }, 150);
            }
          }
        }
      }
    };
    const dragoverItemEvent = (evnt) => {
      const { sortWidget, dragWidget, sortSubWidget } = formDesignReactData;
      if (sortWidget || dragWidget || sortSubWidget) {
        evnt.preventDefault();
      }
    };
    const handleClickEvent = (evnt, item) => {
      $xeFormDesign.handleClickWidget(evnt, item);
      formDesignReactData.sortSubWidget = null;
    };
    return () => {
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      const { item } = props;
      const { name } = item;
      const isActive = activeWidget && activeWidget.id === item.id;
      const defaultSlot = slots.default;
      return h("div", {
        key: item.id,
        "data-widget-id": item.id,
        draggable: true,
        class: ["vxe-form-design--preview-item", `widget-${import_xe_utils30.default.kebabCase(name)}`, {
          "is--active": isActive,
          "is--sort": sortWidget && sortWidget.id === item.id,
          "is--drag": dragWidget && dragWidget.id === item.id
        }],
        onDragstart: sortDragstartEvent,
        onDragend: sortDragendEvent,
        onDragenter: sortDragenterEvent,
        onDragover: dragoverItemEvent,
        onClick(evnt) {
          handleClickEvent(evnt, item);
        }
      }, [
        h("div", {
          class: "vxe-form-design--preview-item-view vxe-form--item-row"
        }, defaultSlot ? defaultSlot({}) : []),
        isActive ? h("div", {
          class: "vxe-form-design--preview-item-operate"
        }, [
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_COPY,
            status: "primary",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleCopyWidget(params.$event, item);
            }
          }),
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
            status: "danger",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleRemoveWidget(params.$event, item);
            }
          })
        ]) : createCommentVNode()
      ]);
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/layout-preview.js
var import_xe_utils31 = __toESM(require_xe_utils());
var layout_preview_default = defineComponent({
  name: "FormDesignLayoutPreview",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragoverEvent = (evnt) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        evnt.preventDefault();
        const rest = import_xe_utils31.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
        if (!rest) {
          formDesignReactData.sortWidget = dragWidget;
          widgetObjList.push(dragWidget);
          $xeFormDesign.dispatchEvent("drag-widget", { widget: dragWidget }, evnt);
        }
      }
    };
    return () => {
      const { widgetObjList } = formDesignReactData;
      return h("div", {
        class: "vxe-form-design--preview",
        onDragover: dragoverEvent
      }, [
        h("div", {
          class: "vxe-form-design--preview-wrapper"
        }, [
          h(form_default, {
            customLayout: true,
            span: 24,
            vertical: true
          }, {
            default() {
              return h(TransitionGroup, {
                class: "vxe-form-design--preview-list",
                tag: "div",
                name: "vxe-form-design--preview-list"
              }, {
                default: () => {
                  return widgetObjList.map((widget, widgetIndex) => {
                    return h(ViewItemComponent, {
                      key: widget.id,
                      item: widget,
                      itemIndex: widgetIndex,
                      items: widgetObjList
                    }, {
                      default() {
                        const { name } = widget;
                        const compConf = renderer.get(name) || {};
                        const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
                        const renderOpts = widget;
                        const isEditMode = true;
                        const params = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: null };
                        return renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : [];
                      }
                    });
                  });
                }
              });
            }
          })
        ])
      ]);
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tabs/src/tabs.js
var import_xe_utils32 = __toESM(require_xe_utils());
var tabs_default = defineComponent({
  name: "VxeTabs",
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    beforeCloseMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "tab-change-fail",
    "tab-close",
    "tab-close-fail",
    "tab-click",
    "tab-load"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils32.default.uniqueId();
    const $xeParentTabs = inject("$xeTabs", null);
    const refElem = ref();
    const refHeadWrapperElem = ref();
    const reactData = reactive({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: false,
      resizeFlag: 1
    });
    const refMaps = {
      refElem
    };
    const handleFilterTab = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const computeTabOptions = computed(() => {
      const { options } = props;
      return (options || []).filter(handleFilterTab);
    });
    const computeTabStaticOptions = computed(() => {
      const { staticTabs } = reactData;
      return staticTabs.filter(handleFilterTab);
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils32.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils32.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const updateTabStyle = () => {
      nextTick(() => {
        const { type } = props;
        const { activeName } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        let lintWidth = 0;
        let lintLeft = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index = import_xe_utils32.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === activeName);
          const { children, scrollWidth, clientWidth } = headerWrapperEl;
          isOver = scrollWidth !== clientWidth;
          if (index > -1) {
            const tabEl = children[index];
            const tabWidth = tabEl.clientWidth;
            if (type) {
              if (type === "card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft;
              } else if (type === "border-card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft - 1;
              }
            } else {
              lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
              lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
            }
          }
        }
        reactData.lintLeft = lintLeft;
        reactData.lintWidth = lintWidth;
        reactData.isTabOver = isOver;
      });
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabs: $xeTabs }, params));
    };
    const addInitName = (name, evnt) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent2("tab-load", { name }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          if (activeName === item.name) {
            validVal = true;
          }
          if (item && item.preload) {
            addInitName(item.name, null);
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const clickEvent = (evnt, item) => {
      const { trigger } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const { activeName } = reactData;
      const { name } = item;
      if (trigger === "manual") {
        dispatchEvent2("tab-click", { name }, evnt);
        return;
      }
      const value = name;
      reactData.activeName = name;
      emit("update:modelValue", value);
      dispatchEvent2("tab-click", { name }, evnt);
      addInitName(name, evnt);
      if (name !== activeName) {
        if (!beforeMethod || beforeMethod({ $tabs: $xeTabs, name, oldName: activeName, newName: name })) {
          dispatchEvent2("change", { value, name, oldName: activeName, newName: name }, evnt);
        } else {
          dispatchEvent2("tab-change-fail", { value, name, oldName: activeName, newName: name }, evnt);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index, list) => {
      evnt.stopPropagation();
      const { activeName } = reactData;
      const beforeMethod = props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const { name } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      if (!beforeMethod || beforeMethod({ $tabs: $xeTabs, value, name, nextName })) {
        dispatchEvent2("tab-close", { value, name, nextName }, evnt);
      } else {
        dispatchEvent2("tab-close-fail", { value, name, nextName }, evnt);
      }
    };
    let scrollTimeout = null;
    const startScrollAnimation = (offsetPos, offsetSize) => {
      let offsetLeft = offsetSize;
      let scrollCount = 6;
      let delayNum = 35;
      clearTimeout(scrollTimeout);
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const { clientWidth, scrollWidth, scrollLeft } = headerWrapperEl;
            offsetLeft = Math.floor(offsetLeft / 2);
            if (offsetPos > 0) {
              if (clientWidth + scrollLeft < scrollWidth) {
                headerWrapperEl.scrollLeft += offsetLeft;
                delayNum -= 4;
                scrollTimeout = setTimeout(scrollAnimate, delayNum);
              }
            } else {
              if (scrollLeft > 0) {
                headerWrapperEl.scrollLeft -= offsetLeft;
                delayNum -= 4;
                scrollTimeout = setTimeout(scrollAnimate, delayNum);
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = (offsetPos) => {
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const offsetSize = Math.floor(headerWrapperEl.clientWidth * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = (name) => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      return nextTick().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index = import_xe_utils32.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === name);
          if (index > -1) {
            const { scrollLeft, clientWidth, children } = headerWrapperEl;
            const tabEl = children[index];
            if (tabEl) {
              const tabOffsetLeft = tabEl.offsetLeft;
              const tabClientWidth = tabEl.clientWidth;
              const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
              if (overSize > 0) {
                headerWrapperEl.scrollLeft += overSize;
              }
              if (tabOffsetLeft < scrollLeft) {
                headerWrapperEl.scrollLeft = tabOffsetLeft;
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const createHandlePrevNext = (isNext) => {
      return () => {
        const { activeName } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
        const index = import_xe_utils32.default.findIndexOf(list, (item) => item.name === activeName);
        if (index > -1) {
          let item = null;
          if (isNext) {
            if (index < list.length - 1) {
              item = list[index + 1];
            }
          } else {
            if (index > 0) {
              item = list[index - 1];
            }
          }
          if (item) {
            const name = item.name;
            const value = name;
            reactData.activeName = name;
            emit("update:modelValue", value);
            addInitName(name, null);
          }
        }
        return nextTick();
      };
    };
    const tabsMethods = {
      dispatchEvent: dispatchEvent2,
      scrollToTab,
      prev: createHandlePrevNext(false),
      next: createHandlePrevNext(true),
      prevTab() {
        warnLog("vxe.error.delFunc", ["prevTab", "prev"]);
        return tabsMethods.prev();
      },
      nextTab() {
        warnLog("vxe.error.delFunc", ["nextTab", "next"]);
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = (tabList) => {
      const { type, titleWidth: allTitleWidth, titleAlign: allTitleAlign, showClose } = props;
      const { activeName, lintLeft, lintWidth, isTabOver } = reactData;
      const extraSlot = slots.extra;
      return h("div", {
        class: "vxe-tabs-header"
      }, [
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--left-bar",
          onClick: scrollLeftEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_LEFT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tabs-header--wrapper"
        }, [
          h("div", {
            ref: refHeadWrapperElem,
            class: "vxe-tabs-header--item-wrapper"
          }, tabList.map((item, index) => {
            const { title, titleWidth, titleAlign, icon, name, slots: slots2 } = item;
            const tabSlot = slots2 ? slots2.tab : null;
            const itemWidth = titleWidth || allTitleWidth;
            const itemAlign = titleAlign || allTitleAlign;
            return h("div", {
              key: `${name}`,
              class: ["vxe-tabs-header--item", itemAlign ? `align--${itemAlign}` : "", {
                "is--active": activeName === name
              }],
              style: itemWidth ? {
                width: toCssUnit(itemWidth)
              } : null,
              onClick(evnt) {
                clickEvent(evnt, item);
              }
            }, [
              h("div", {
                class: "vxe-tabs-header--item-inner"
              }, [
                h("div", {
                  class: "vxe-tabs-header--item-content"
                }, [
                  icon ? h("span", {
                    class: "vxe-tabs-header--item-icon"
                  }, [
                    h("i", {
                      class: icon
                    })
                  ]) : createCommentVNode(),
                  h("span", {
                    class: "vxe-tabs-header--item-name"
                  }, tabSlot ? callSlot(tabSlot, { name, title }) : `${title}`)
                ]),
                showClose ? h("div", {
                  class: "vxe-tabs-header--close-btn",
                  onClick(evnt) {
                    handleCloseTabEvent(evnt, item, index, tabList);
                  }
                }, [
                  h("i", {
                    class: getIcon().TABS_TAB_CLOSE
                  })
                ]) : createCommentVNode()
              ])
            ]);
          }).concat([
            h("span", {
              key: "line",
              class: `vxe-tabs-header--active-line type--${type || "default"}`,
              style: {
                left: `${lintLeft}px`,
                width: `${lintWidth}px`
              }
            })
          ]))
        ]),
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--right-bar",
          onClick: scrollRightEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_RIGHT
          })
        ]) : createCommentVNode(),
        extraSlot ? h("div", {
          class: "vxe-tabs-header--extra"
        }, getSlotVNs(extraSlot({}))) : createCommentVNode()
      ]);
    };
    const renderTabPane = (item) => {
      const { initNames, activeName } = reactData;
      const { name, slots: slots2 } = item;
      const defaultSlot = slots2 ? slots2.default : null;
      return name && initNames.includes(name) ? h("div", {
        key: name,
        class: ["vxe-tabs-pane--item", {
          "is--visible": activeName === name,
          "has--content": !!defaultSlot
        }]
      }, defaultSlot ? callSlot(defaultSlot, { name }) : []) : createCommentVNode();
    };
    const renderTabContent = (tabList) => {
      const { destroyOnClose } = props;
      const { activeName } = reactData;
      const activeDefaultTab = tabList.find((item) => item.name === activeName);
      if (destroyOnClose) {
        return activeDefaultTab ? [renderTabPane(activeDefaultTab)] : createCommentVNode();
      }
      return tabList.map(renderTabPane);
    };
    const renderVN = () => {
      const { type, height, padding, trigger } = props;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const defaultSlot = slots.default;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-tabs", `vxe-tabs--${type || "default"}`, `trigger--${trigger === "manual" ? "trigger" : "default"}`, {
          "is--padding": padding,
          "is--height": height
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-tabs-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderTabHeader(tabList),
        h("div", {
          class: "vxe-tabs-pane"
        }, renderTabContent(tabList))
      ]);
    };
    watch(() => props.modelValue, (val) => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, (val) => {
      scrollToTab(val);
      nextTick(() => {
        reactData.resizeFlag++;
      });
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
      updateTabStyle();
    });
    const stFlag = ref(0);
    watch(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      updateTabStyle();
    });
    if ($xeParentTabs) {
      watch(() => $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null, () => {
        reactData.resizeFlag++;
      });
    }
    watch(() => reactData.resizeFlag, () => {
      nextTick(updateTabStyle);
    });
    nextTick(() => {
      globalEvents.on($xeTabs, "resize", updateTabStyle);
    });
    onMounted(() => {
      updateTabStyle();
    });
    onUnmounted(() => {
      globalEvents.off($xeTabs, "resize");
    });
    $xeTabs.renderVN = renderVN;
    provide("$xeTabs", $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var import_xe_utils34 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tabs/src/util.js
var import_xe_utils33 = __toESM(require_xe_utils());
function assembleAnchorTab($xeTabs, elem, tabConfig) {
  const staticLinks = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticLinks.splice(import_xe_utils33.default.arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticLinks.slice(0);
  }
}
function destroyAnchorTab($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = import_xe_utils33.default.findTree(staticTabs, (item) => item.id === tabConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var tab_pane_default = defineComponent({
  name: "VxeTabPane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils34.default.uniqueId();
    const refElem = ref();
    const $xeTabs = inject("$xeTabs", null);
    const reactData = reactive({});
    const tabConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots: {
        default: slots.default
      }
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    watch(() => props.title, (val) => {
      tabConfig.title = val;
    });
    watch(() => props.name, (val) => {
      tabConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      tabConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      tabConfig.permissionCode = val;
    });
    onMounted(() => {
      if ($xeTabs && refElem.value) {
        assembleAnchorTab($xeTabs, refElem.value, tabConfig);
      }
    });
    onUnmounted(() => {
      if ($xeTabs) {
        destroyAnchorTab($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/form-item.js
var import_xe_utils35 = __toESM(require_xe_utils());
var formItemProps = {
  title: String,
  field: String,
  span: [String, Number],
  align: String,
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: { type: Boolean, default: null },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
var form_item_default = defineComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const formGather = inject("$xeFormGather", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    watchItem(props, formItem);
    onMounted(() => {
      assembleItem($xeForm, refElem.value, formItem, formGather);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    const renderItem = ($xeForm2, item) => {
      const { props: props2, reactData } = $xeForm2;
      const { data, rules, readonly, disabled, titleBold: allTitleBold, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, titleOverflow: allTitleOverflow, vertical: allVertical, padding: allPadding } = props2;
      const { collapseAll } = reactData;
      const { computeValidOpts } = $xeForm2.getComputeMaps();
      const validOpts = computeValidOpts.value;
      const { slots: slots2, title, visible, folding, field, collapseNode, itemRender, showError, errRule, className, titleOverflow, vertical, padding, showTitle, contentClassName, contentStyle, titleClassName, titleStyle } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : "";
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : "";
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : "";
      const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
      const defaultSlot = slots2 ? slots2.default : null;
      const titleSlot = slots2 ? slots2.title : null;
      const span = item.span || props2.span;
      const align = item.align || props2.align;
      const itemPadding = import_xe_utils35.default.eqNull(padding) ? allPadding : padding;
      const itemVertical = import_xe_utils35.default.eqNull(vertical) ? allVertical : vertical;
      const titleBold = import_xe_utils35.default.eqNull(item.titleBold) ? allTitleBold : item.titleBold;
      const titleAlign = import_xe_utils35.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = itemVertical ? null : import_xe_utils35.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = import_xe_utils35.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = import_xe_utils35.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = import_xe_utils35.default.eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const ovEllipsis = itemOverflow === "ellipsis";
      const ovTitle = itemOverflow === "title";
      const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeForm2.xegrid };
      let isRequired = false;
      let isValid = false;
      if (visible === false) {
        return createCommentVNode();
      }
      if (!readonly && rules) {
        const itemRules = rules[field];
        if (itemRules && itemRules.length) {
          isValid = true;
          isRequired = itemRules.some((rule) => rule.required);
        }
      }
      let contentVNs = [];
      const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
      if (defaultSlot) {
        contentVNs = $xeForm2.callSlot(defaultSlot, params);
      } else if (rftContent) {
        contentVNs = getSlotVNs(rftContent(itemRender, params));
      } else if (field) {
        contentVNs = [`${import_xe_utils35.default.get(data, field)}`];
      }
      if (collapseNode) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeForm2.toggleCollapseEvent
        }, [
          h("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? getI18n("vxe.form.unfolding") : getI18n("vxe.form.folding")),
          h("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? getIcon().FORM_FOLDING : getIcon().FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.message));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeForm2.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeForm2.handleTitleTipLeaveEvent
      } : {};
      return h("div", {
        ref: refElem,
        class: [
          "vxe-form--item",
          item.id,
          span ? `vxe-form--item-col_${span} is--span` : "",
          className ? import_xe_utils35.default.isFunction(className) ? className(params) : className : "",
          itemClassName ? import_xe_utils35.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--colon": titleColon,
            "is--bold": titleBold,
            "is--padding": itemPadding,
            "is--vertical": itemVertical,
            "is--asterisk": titleAsterisk,
            "is--valid": isValid,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActiveItem($xeForm2, item),
            "is--error": showError
          }
        ],
        style: import_xe_utils35.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        h("div", {
          class: "vxe-form--item-inner"
        }, [
          showTitle !== false && (title || titleSlot) ? h("div", Object.assign({ class: [
            "vxe-form--item-title",
            titleAlign ? `align--${titleAlign}` : "",
            hasEllipsis ? "is--ellipsis" : "",
            itemTitleClassName ? import_xe_utils35.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
            titleClassName ? import_xe_utils35.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
          ], style: Object.assign({}, import_xe_utils35.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils35.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
          } : null), title: ovTitle ? getFuncText(title) : null }, ons), renderTitle($xeForm2, item)) : null,
          h("div", {
            class: [
              "vxe-form--item-content",
              align ? `align--${align}` : "",
              itemContentClassName ? import_xe_utils35.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
              contentClassName ? import_xe_utils35.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
            ],
            style: Object.assign({}, import_xe_utils35.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils35.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
          }, contentVNs)
        ])
      ]);
    };
    const renderVN = () => {
      const formProps = $xeForm ? $xeForm.props : null;
      return formProps && formProps.customLayout ? renderItem($xeForm, formItem) : h("div", {
        ref: refElem
      });
    };
    const $xeFormitem = {
      formItem,
      renderVN
    };
    provide("$xeFormItem", $xeFormitem);
    provide("$xeFormGather", null);
    return $xeFormitem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/switch/src/switch.js
var import_xe_utils36 = __toESM(require_xe_utils());
var switch_default = defineComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    size: { type: String, default: () => getConfig().switch.size || getConfig().size },
    openLabel: String,
    closeLabel: String,
    openValue: { type: [String, Number, Boolean], default: true },
    closeValue: { type: [String, Number, Boolean], default: false },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils36.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData
    };
    const refButton = ref();
    let switchMethods = {};
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeOnShowLabel = computed(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = computed(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = computed(() => {
      return props.modelValue === props.openValue;
    });
    let _atimeout;
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isChecked = computeIsChecked.value;
        clearTimeout(_atimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emit("update:modelValue", value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        _atimeout = setTimeout(() => {
          reactData.hasAnimat = false;
        }, 400);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $switch: $xeSwitch }, params));
      },
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        btnElem.focus();
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const { openIcon, closeIcon, openActiveIcon, closeActiveIcon } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled,
          "is--animat": reactData.hasAnimat
        }]
      }, [
        h("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled: isDisabled,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : createCommentVNode(),
            onShowLabel
          ]),
          h("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : createCommentVNode(),
            offShowLabel
          ]),
          h("span", {
            class: ["vxe-switch--icon"]
          }, openActiveIcon || closeActiveIcon ? [
            h("i", {
              class: isChecked ? openActiveIcon : closeActiveIcon
            })
          ] : [])
        ])
      ]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/text/src/text.js
var import_xe_utils37 = __toESM(require_xe_utils());
var text_default = defineComponent({
  name: "VxeText",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    clickToCopy: Boolean,
    size: { type: String, default: () => getConfig().text.size || getConfig().size }
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils37.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const clickIconEvent = () => {
      const { content, clickToCopy } = props;
      if (clickToCopy) {
        const contentEl = refContentElem.value;
        const copyVal = (contentEl ? contentEl.textContent : "") || content;
        if (copyVal) {
          if (VxeUI.clipboard.copy(copyVal)) {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copySuccess"),
                status: "success"
              });
            }
          } else {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copyError"),
                status: "error"
              });
            }
          }
        }
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderContent = () => {
      const { icon, content, clickToCopy } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        iconSlot || icon || clickToCopy ? h("span", {
          class: "vxe-text--icon",
          onClick: clickIconEvent
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon || getIcon().TEXT_COPY
          })
        ]) : createCommentVNode(),
        h("span", {
          ref: refContentElem,
          class: "vxe-text--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils37.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { status, title, clickToCopy } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        title,
        class: ["vxe-text", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--copy": clickToCopy
        }]
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/default-setting-form.js
var DefaultSettingFormComponent = defineComponent({
  name: "DefaultSettingForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps } = $xeFormDesign;
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          const { showPc, showMobile } = formDesignProps;
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.formName"),
              field: "title",
              itemRender: { name: "VxeInput", props: { placeholder: getI18n("vxe.formDesign.defFormTitle") } }
            }),
            showPc && showMobile ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.displaySetting.name")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    h("div", {
                      class: "vxe-form-design--widget-form-item-pc"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_PC,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                      }),
                      h(switch_default, {
                        modelValue: formData.pcVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.pcVisible = val;
                        }
                      })
                    ]),
                    h("div", {
                      class: "vxe-form-design--widget-form-item-mobile"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                      }),
                      h(switch_default, {
                        modelValue: formData.mobileVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.mobileVisible = val;
                        }
                      })
                    ])
                  ])
                ];
              }
            }) : createCommentVNode()
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/layout-setting.js
var layout_setting_default = defineComponent({
  name: "FormDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const activeTab = ref(1);
    const renderSettingWidgetForm = () => {
      const { activeWidget } = formDesignReactData;
      if (activeWidget) {
        const compConf = renderer.get(activeWidget.name);
        const renderWidgetFormView = compConf ? compConf.renderFormDesignWidgetFormView : null;
        if (renderWidgetFormView) {
          return h("div", {
            class: "vxe-form-design--custom-widget-form-view"
          }, getSlotVNs(renderWidgetFormView(activeWidget, { widget: activeWidget, $formDesign: $xeFormDesign })));
        }
      }
      return createCommentVNode();
    };
    const renderSettingConfigForm = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingView = compConf ? compConf.renderFormDesignSettingFormView : null;
        if (renderSettingView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-form-view"
          }, getSlotVNs(renderSettingView({}, { $formDesign: $xeFormDesign })));
        }
      }
      return h(DefaultSettingFormComponent, {
        formData
      });
    };
    watch(() => formDesignReactData.activeWidget, () => {
      activeTab.value = 1;
    });
    return () => {
      return h("div", {
        class: "vxe-form-design--setting"
      }, [
        h("div", {
          class: "vxe-form-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-form-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetPropTab"),
                  name: 1
                }, {
                  default() {
                    return renderSettingWidgetForm();
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetFormTab"),
                  name: 2
                }, {
                  default() {
                    return renderSettingConfigForm();
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/modal/src/modal.js
var import_xe_utils38 = __toESM(require_xe_utils());
var allActiveModals = [];
var msgQueue = [];
var notifyQueue = [];
var modal_default = defineComponent({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: { type: String, default: "modal" },
    loading: { type: Boolean, default: null },
    status: String,
    iconStatus: String,
    className: String,
    top: { type: [Number, String], default: () => getConfig().modal.top },
    position: [String, Object],
    title: String,
    duration: { type: [Number, String], default: () => getConfig().modal.duration },
    message: [Number, String],
    content: [Number, String],
    showCancelButton: { type: Boolean, default: null },
    cancelButtonText: { type: String, default: () => getConfig().modal.cancelButtonText },
    showConfirmButton: { type: Boolean, default: () => getConfig().modal.showConfirmButton },
    confirmButtonText: { type: String, default: () => getConfig().modal.confirmButtonText },
    lockView: { type: Boolean, default: () => getConfig().modal.lockView },
    lockScroll: Boolean,
    mask: { type: Boolean, default: () => getConfig().modal.mask },
    maskClosable: { type: Boolean, default: () => getConfig().modal.maskClosable },
    escClosable: { type: Boolean, default: () => getConfig().modal.escClosable },
    resize: Boolean,
    showHeader: { type: Boolean, default: () => getConfig().modal.showHeader },
    showFooter: { type: Boolean, default: () => getConfig().modal.showFooter },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMinimize)
    },
    showClose: { type: Boolean, default: () => getConfig().modal.showClose },
    dblclickZoom: { type: Boolean, default: () => getConfig().modal.dblclickZoom },
    width: [Number, String],
    height: [Number, String],
    minWidth: { type: [Number, String], default: () => getConfig().modal.minWidth },
    minHeight: { type: [Number, String], default: () => getConfig().modal.minHeight },
    zIndex: Number,
    marginSize: { type: [Number, String], default: () => getConfig().modal.marginSize },
    fullscreen: Boolean,
    draggable: { type: Boolean, default: () => getConfig().modal.draggable },
    remember: { type: Boolean, default: () => getConfig().modal.remember },
    destroyOnClose: { type: Boolean, default: () => getConfig().modal.destroyOnClose },
    showTitleOverflow: { type: Boolean, default: () => getConfig().modal.showTitleOverflow },
    transfer: { type: Boolean, default: () => getConfig().modal.transfer },
    storage: { type: Boolean, default: () => getConfig().modal.storage },
    storageKey: { type: String, default: () => getConfig().modal.storageKey },
    padding: { type: Boolean, default: () => getConfig().modal.padding },
    size: { type: String, default: () => getConfig().modal.size || getConfig().size },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * 已废弃
     */
    animat: { type: Boolean, default: () => getConfig().modal.animat }
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom",
    "resize",
    "move"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils38.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: "",
      zoomStatus: "",
      revertLocat: null,
      prevLocat: null,
      firstOpen: true
    });
    const refElem = ref();
    const refModalBox = ref();
    const refHeaderElem = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const refMaps = {
      refElem
    };
    const computeIsMsg = computed(() => {
      return props.type === "message" || props.type === "notification";
    });
    const computeIsMinimizeStatus = computed(() => {
      return reactData.zoomStatus === "minimize";
    });
    const computeIsMaximizeStatus = computed(() => {
      return reactData.zoomStatus === "maximize";
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig().modal.zoomConfig, props.zoomConfig);
    });
    const computeMaps = {
      computeSize,
      computeZoomOpts
    };
    const $xeModal = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let modalMethods = {};
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ""}`;
        boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ""}`;
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { modalZindex } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else if (modalZindex < getLastZIndex()) {
        reactData.modalZindex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
        const { position } = props;
        const marginSize = import_xe_utils38.default.toNumber(props.marginSize);
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === "center";
        const { top, left } = import_xe_utils38.default.isString(position) ? { top: position, left: position } : Object.assign({}, position);
        const topCenter = isPosCenter || top === "center";
        const leftCenter = isPosCenter || left === "center";
        let posTop = "";
        let posLeft = "";
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      nextTick(() => {
        const { type } = props;
        const queueList = type === "notification" ? notifyQueue : msgQueue;
        let offsetTop = 0;
        queueList.forEach((comp) => {
          const boxElem = comp.getBox();
          if (boxElem) {
            offsetTop += import_xe_utils38.default.toNumber(comp.props.top);
            comp.reactData.modalTop = offsetTop;
            offsetTop += boxElem.clientHeight;
          }
        });
      });
    };
    const removeMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) > -1) {
        import_xe_utils38.default.remove(queueList, (comp) => comp === $xeModal);
      }
      updateStyle();
    };
    const closeModal2 = (type) => {
      const { remember } = props;
      const { visible } = reactData;
      const isMsg = computeIsMsg.value;
      const beforeHideFn = props.beforeHideMethod || getConfig().modal.beforeHideMethod;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideFn ? beforeHideFn(params) : null).then((rest) => {
          if (!import_xe_utils38.default.isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              handleRevert();
            }
            import_xe_utils38.default.remove(allActiveModals, (item) => item === $xeModal);
            modalMethods.dispatchEvent("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              modalMethods.dispatchEvent("hide", params, null);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const confirmEvent = (evnt) => {
      const type = "confirm";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const cancelEvent = (evnt) => {
      const type = "cancel";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const getStorageMap = (key) => {
      const version2 = getConfig().version;
      const rest = import_xe_utils38.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version2 ? rest : { _v: version2 };
    };
    const hasPosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      return !!(id && remember && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      if (id && remember && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(",");
          if (boxElem) {
            if (left) {
              boxElem.style.left = `${left}px`;
            }
            if (top) {
              boxElem.style.top = `${top}px`;
            }
            if (width) {
              boxElem.style.width = `${width}px`;
            }
            if (height) {
              boxElem.style.height = `${height}px`;
            }
          }
          if (zoomLeft && zoomTop) {
            reactData.revertLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) === -1) {
        queueList.push($xeModal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      const { revertLocat } = reactData;
      if (id && remember && storage) {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [
          boxElem.style.left,
          boxElem.style.top,
          boxElem.style.width,
          boxElem.style.height
        ].concat(revertLocat ? [
          revertLocat.left,
          revertLocat.top,
          revertLocat.width,
          revertLocat.height
        ] : []).map((val) => val ? import_xe_utils38.default.toNumber(val) : "").join(",");
        localStorage.setItem(storageKey, import_xe_utils38.default.toJSONString(posStorageMap));
      }
    };
    const handleMinimize = () => {
      const zoomOpts = computeZoomOpts.value;
      const { minimizeLayout, minimizeMaxSize, minimizeHorizontalOffset, minimizeVerticalOffset, minimizeOffsetMethod } = zoomOpts;
      const isHorizontalLayout = minimizeLayout === "horizontal";
      const prevZoomStatus = reactData.zoomStatus;
      const hlMList = [];
      const vlMList = [];
      allActiveModals.forEach((item) => {
        if (item.xID !== $xeModal.xID && item.props.type === "modal" && item.reactData.zoomStatus === "minimize") {
          const itemZoomOpts = item.getComputeMaps().computeZoomOpts.value;
          if (itemZoomOpts.minimizeLayout === "horizontal") {
            hlMList.push(item);
          } else {
            vlMList.push(item);
          }
        }
      });
      const mList = isHorizontalLayout ? hlMList : vlMList;
      if (minimizeMaxSize && mList.length >= minimizeMaxSize) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            status: "error",
            content: getI18n("vxe.modal.miniMaxSize", [minimizeMaxSize])
          });
        }
        return nextTick();
      }
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "minimize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const headerEl = refHeaderElem.value;
        if (!headerEl) {
          return;
        }
        const { visibleHeight } = getDomNode();
        if (!prevZoomStatus) {
          reactData.revertLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
        }
        const targetModal = import_xe_utils38.default[isHorizontalLayout ? "max" : "min"](mList, ($modal) => {
          const boxElem2 = $modal.getBox();
          return boxElem2 ? import_xe_utils38.default.toNumber(boxElem2.style[isHorizontalLayout ? "left" : "top"]) : 0;
        });
        let targetTop = visibleHeight - headerEl.offsetHeight - 16;
        let targetLeft = 16;
        if (targetModal) {
          const minBoxElem = targetModal.getBox();
          if (minBoxElem) {
            const boxLeft = import_xe_utils38.default.toNumber(minBoxElem.style.left);
            const boxTop = import_xe_utils38.default.toNumber(minBoxElem.style.top);
            let offsetObj = {};
            if (isHorizontalLayout) {
              offsetObj = Object.assign({}, minimizeHorizontalOffset);
            } else {
              offsetObj = Object.assign({}, minimizeVerticalOffset);
            }
            targetLeft = boxLeft + import_xe_utils38.default.toNumber(offsetObj.left);
            targetTop = boxTop + import_xe_utils38.default.toNumber(offsetObj.top);
            if (minimizeOffsetMethod) {
              offsetObj = minimizeOffsetMethod({
                $modal: $xeModal,
                left: targetLeft,
                top: targetTop
              });
              targetLeft = import_xe_utils38.default.toNumber(offsetObj.left);
              targetTop = import_xe_utils38.default.toNumber(offsetObj.top);
            }
          }
        }
        Object.assign(boxElem.style, {
          top: `${targetTop}px`,
          left: `${targetLeft}px`,
          width: "200px",
          height: `${headerEl.offsetHeight}px`
        });
        savePosStorage();
      });
    };
    const handleMaximize = () => {
      const prevZoomStatus = reactData.zoomStatus;
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "maximize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (boxElem) {
          if (!prevZoomStatus) {
            reactData.revertLocat = {
              top: boxElem.offsetTop,
              left: boxElem.offsetLeft,
              width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
              height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
            };
          }
          Object.assign(boxElem.style, {
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          });
        }
        savePosStorage();
      });
    };
    let msgTimeout = null;
    const handleMsgAutoClose = () => {
      const { duration } = props;
      if (duration !== -1) {
        msgTimeout = setTimeout(() => closeModal2("close"), import_xe_utils38.default.toNumber(duration));
      }
    };
    const openModal2 = () => {
      const { remember, showFooter } = props;
      const { initialized, visible } = reactData;
      const isMsg = computeIsMsg.value;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        if (!remember) {
          recalculate();
        }
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xeModal);
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            modalMethods.dispatchEvent("show", params, null);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          handleMsgAutoClose();
        } else {
          nextTick(() => {
            const { fullscreen } = props;
            const { firstOpen } = reactData;
            if (!remember || firstOpen) {
              updatePosition().then(() => {
                setTimeout(() => updatePosition(), 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                nextTick(() => handleMaximize());
              }
            } else {
              if (fullscreen) {
                nextTick(() => handleMaximize());
              }
            }
          });
        }
      }
      return nextTick();
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeModal2(type);
      }
    };
    const selfMouseoverEvent = () => {
      if (msgTimeout === null) {
        return;
      }
      const isMsg = computeIsMsg.value;
      if (isMsg) {
        clearTimeout(msgTimeout);
        msgTimeout = null;
      }
    };
    const selfMouseoutEvent = () => {
      if (msgTimeout === null) {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          handleMsgAutoClose();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = import_xe_utils38.default.max(allActiveModals, (item) => item.reactData.modalZindex);
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xeModal && lastModal.props.escClosable) {
              closeModal2("exit");
            }
          }, 10);
        }
      }
    };
    const isMinimized = () => {
      return reactData.zoomStatus === "minimize";
    };
    const isMaximized = () => {
      return reactData.zoomStatus === "maximize";
    };
    const handleRevert = () => {
      reactData.prevZoomStatus = reactData.zoomStatus;
      reactData.zoomStatus = "";
      return nextTick().then(() => {
        const { revertLocat } = reactData;
        if (revertLocat) {
          const boxElem = getBox();
          reactData.revertLocat = null;
          if (boxElem) {
            Object.assign(boxElem.style, {
              top: `${revertLocat.top}px`,
              left: `${revertLocat.left}px`,
              width: `${revertLocat.width}px`,
              height: `${revertLocat.height}px`
            });
          }
          savePosStorage();
          return nextTick();
        }
      });
    };
    const handleZoom = (type) => {
      const { zoomStatus } = reactData;
      return new Promise((resolve) => {
        if (type) {
          if (type === "maximize") {
            resolve(handleMaximize());
            return;
          }
          if (type === "minimize") {
            resolve(handleMinimize());
            return;
          }
          resolve(handleRevert());
          return;
        }
        resolve(zoomStatus ? handleRevert() : handleMaximize());
      }).then(() => {
        return reactData.zoomStatus || "revert";
      });
    };
    const toggleZoomMinEvent = (evnt) => {
      const { zoomStatus, prevZoomStatus } = reactData;
      return handleZoom(zoomStatus === "minimize" ? prevZoomStatus || "revert" : "minimize").then((type) => {
        const params = { type };
        modalMethods.dispatchEvent("zoom", params, evnt);
      });
    };
    const toggleZoomMaxEvent = (evnt) => {
      return handleZoom().then((type) => {
        const params = { type };
        modalMethods.dispatchEvent("zoom", params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          if (import_xe_utils38.default.isNumber(top)) {
            boxElem.style.top = `${top}px`;
          }
          if (import_xe_utils38.default.isNumber(left)) {
            boxElem.style.left = `${left}px`;
          }
        }
      }
      return nextTick();
    };
    const boxMousedownEvent = () => {
      const { modalZindex } = reactData;
      if (allActiveModals.some((comp) => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = (evnt) => {
      const { remember, storage } = props;
      const { zoomStatus } = reactData;
      const marginSize = import_xe_utils38.default.toNumber(props.marginSize);
      const boxElem = getBox();
      if (!boxElem) {
        return;
      }
      if (zoomStatus !== "maximize" && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, "trigger--btn").flag) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const { visibleHeight, visibleWidth } = getDomNode();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt2.clientX - disX;
          let top = evnt2.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
          emit("move", createEvent(evnt2, { type: "move" }));
        };
        document.onmouseup = () => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          if (remember && storage) {
            nextTick(() => {
              savePosStorage();
            });
          }
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { remember, storage } = props;
      const { visibleHeight, visibleWidth } = getDomNode();
      const marginSize = import_xe_utils38.default.toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = import_xe_utils38.default.toNumber(props.minWidth);
      const minHeight = import_xe_utils38.default.toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case "swst":
            dragLeft = disX - evnt2.clientX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "swlb":
            dragLeft = disX - evnt2.clientX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sest":
            dragLeft = evnt2.clientX - disX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "selb":
            dragLeft = evnt2.clientX - disX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        if (remember && storage) {
          savePosStorage();
        }
        modalMethods.dispatchEvent("resize", params, evnt2);
      };
      document.onmouseup = () => {
        reactData.revertLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    modalMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $modal: $xeModal }, params));
      },
      open: openModal2,
      close() {
        return closeModal2("close");
      },
      getBox,
      getPosition,
      setPosition,
      isMinimized,
      isMaximized,
      zoom: handleZoom,
      minimize: handleMinimize,
      maximize: handleMaximize,
      revert: handleRevert
    };
    Object.assign($xeModal, modalMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, showZoom, showMaximize, showMinimize, title } = props;
      const { zoomStatus } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const isMaximizeStatus = computeIsMaximizeStatus.value;
      return [
        h("div", {
          class: "vxe-modal--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({
          $modal: $xeModal,
          minimized: isMinimizeStatus,
          maximized: isMaximizeStatus
        })) : title ? getFuncText(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-modal--header-right"
        }, [
          cornerSlot && !isMinimizeStatus ? h("div", {
            class: "vxe-modal--corner-wrapper"
          }, getSlotVNs(cornerSlot({ $modal: $xeModal }))) : createCommentVNode(),
          (import_xe_utils38.default.isBoolean(showMinimize) ? showMinimize : showZoom) ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "minimize" ? "Out" : "Min"}`),
            onClick: toggleZoomMinEvent
          }, [
            h("i", {
              class: zoomStatus === "minimize" ? getIcon().MODAL_ZOOM_REVERT : getIcon().MODAL_ZOOM_MIN
            })
          ]) : createCommentVNode(),
          (import_xe_utils38.default.isBoolean(showMaximize) ? showMaximize : showZoom) && zoomStatus !== "minimize" ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "maximize" ? "Out" : "In"}`),
            onClick: toggleZoomMaxEvent
          }, [
            h("i", {
              class: zoomStatus === "maximize" ? getIcon().MODAL_ZOOM_OUT : getIcon().MODAL_ZOOM_IN
            })
          ]) : createCommentVNode(),
          showClose ? h("div", {
            class: ["vxe-modal--close-btn", "trigger--btn"],
            title: getI18n("vxe.modal.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().MODAL_CLOSE
            })
          ]) : createCommentVNode()
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showZoom, showMaximize, draggable } = props;
      const isMsg = computeIsMsg.value;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if ((import_xe_utils38.default.isBoolean(showMaximize) ? showMaximize : showZoom) && props.dblclickZoom && props.type === "modal") {
          headerOns.onDblclick = toggleZoomMaxEvent;
        }
        return h("div", Object.assign({ ref: refHeaderElem, class: ["vxe-modal--header", {
          "is--ellipsis": !isMsg && props.showTitleOverflow
        }] }, headerOns), headerSlot ? getSlotVNs(headerSlot({ $modal: $xeModal })) : renderTitles());
      }
      return createCommentVNode();
    };
    const renderBody = () => {
      const { slots: propSlots = {}, status, message, iconStatus } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      const contVNs = [];
      if (!isMsg && (status || iconStatus)) {
        contVNs.push(h("div", {
          class: "vxe-modal--status-wrapper"
        }, [
          h("i", {
            class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
          })
        ]));
      }
      contVNs.push(h("div", {
        class: "vxe-modal--content"
      }, defaultSlot ? getSlotVNs(defaultSlot({ $modal: $xeModal })) : getFuncText(content)));
      return h("div", {
        class: "vxe-modal--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-modal--body-left"
        }, getSlotVNs(leftSlot({ $modal: $xeModal }))) : createCommentVNode(),
        h("div", {
          class: "vxe-modal--body-default"
        }, contVNs),
        rightSlot ? h("div", {
          class: "vxe-modal--body-right"
        }, getSlotVNs(rightSlot({ $modal: $xeModal }))) : createCommentVNode(),
        isMsg ? createCommentVNode() : h(loading_default2, {
          class: "vxe-modal--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, type } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (import_xe_utils38.default.isBoolean(showCancelButton) ? showCancelButton : type === "confirm") {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (import_xe_utils38.default.isBoolean(showConfirmButton) ? showConfirmButton : type === "confirm" || type === "alert") {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-modal--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-modal--footer-left"
        }, lfSlot ? getSlotVNs(lfSlot({ $modal: $xeModal })) : []),
        h("div", {
          class: "vxe-modal--footer-right"
        }, rfSlot ? getSlotVNs(rfSlot({ $modal: $xeModal })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-modal--footer"
        }, footerSlot ? getSlotVNs(footerSlot({ $modal: $xeModal })) : [renderDefaultFooter()]);
      }
      return createCommentVNode();
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, type, animat, draggable, iconStatus, position, loading: loading2, destroyOnClose, status, lockScroll, padding, lockView, mask, resize } = props;
      const { initialized, modalTop, contentVisible, visible, zoomStatus } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const isMsg = computeIsMsg.value;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const ons = {};
      if (isMsg) {
        ons.onMouseover = selfMouseoverEvent;
        ons.onMouseout = selfMouseoutEvent;
      }
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !initialized : true
      }, [
        h("div", Object.assign({ ref: refElem, class: ["vxe-modal--wrapper", `type--${type}`, `zoom--${zoomStatus || "revert"}`, className || "", position ? `pos--${position}` : "", {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          "is--padding": padding,
          "is--animat": animat,
          "lock--scroll": lockScroll,
          "lock--view": lockView,
          "is--draggable": draggable,
          "is--resize": resize,
          "is--mask": mask,
          "is--visible": contentVisible,
          "is--active": visible,
          "is--loading": loading2
        }], style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        }, onClick: selfClickEvent }, ons), [
          h("div", {
            ref: refModalBox,
            class: "vxe-modal--box",
            onMousedown: boxMousedownEvent
          }, [
            (isMsg || asideSlot) && !isMinimizeStatus ? h("div", {
              class: "vxe-modal--aside"
            }, asideSlot ? getSlotVNs(asideSlot({ $modal: $xeModal })) : [
              status || iconStatus ? h("div", {
                class: "vxe-modal--status-wrapper"
              }, [
                h("i", {
                  class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
                })
              ]) : createCommentVNode()
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-modal--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              !isMsg && resize ? h("span", {
                class: "vxe-modal--resize"
              }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((type2) => {
                return h("span", {
                  class: `${type2}-resize`,
                  type: type2,
                  onMousedown: dragEvent
                });
              })) : createCommentVNode()
            ])
          ])
        ])
      ]);
    };
    $xeModal.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openModal2();
      } else {
        closeModal2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.storage && !props.id) {
          errLog("vxe.error.reqProp", ["modal.id"]);
        }
        if (props.modelValue) {
          openModal2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeModal, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeModal, "keydown");
      removeMsgQueue();
    });
    provide("$xeModal", $xeModal);
    return $xeModal;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var import_xe_utils40 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/default-setting-data.js
var getDefaultSettingFormData = (defOpts) => {
  return {
    title: "",
    pcVisible: defOpts ? !!defOpts.pcVisible : true,
    pcVertical: true,
    pcTitleBold: true,
    pcTitleColon: false,
    pcTitleAlign: "",
    pcTitleWidth: "",
    pcTitleWidthUnit: "",
    mobileVisible: defOpts ? !!defOpts.mobileVisible : true,
    mobileVertical: true,
    mobileTitleBold: true,
    mobileTitleColon: false,
    mobileTitleAlign: "",
    mobileTitleWidth: "",
    mobileTitleWidthUnit: ""
  };
};
var createDefaultFormViewPCFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.pcVertical,
    titleBold: formConfig.pcTitleBold,
    titleColon: formConfig.pcTitleColon,
    titleAlign: formConfig.pcTitleAlign,
    titleWidth: formConfig.pcTitleWidth
  };
};
var createDefaultFormViewMobileFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.mobileVertical,
    titleBold: formConfig.mobileTitleBold,
    titleColon: formConfig.mobileTitleColon,
    titleAlign: formConfig.mobileTitleAlign,
    titleWidth: formConfig.mobileTitleWidth
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form/src/form-gather.js
var import_xe_utils39 = __toESM(require_xe_utils());
var form_gather_default = defineComponent({
  name: "VxeFormGather",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const parentFormGather = inject("$xeFormGather", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.children = [];
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    watchItem(props, formItem);
    onMounted(() => {
      assembleItem($xeForm, refElem.value, formItem, parentFormGather);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    const renderVN = () => {
      const { className, field } = props;
      const span = props.span || ($xeForm ? $xeForm.props.span : null);
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-form--gather vxe-form--item-row", formItem.id, span ? `vxe-form--item-col_${span} is--span` : "", className ? import_xe_utils39.default.isFunction(className) ? className({ $form: $xeForm, data: $xeForm ? $xeForm.props.data : {}, item: formItem, field, property: field }) : className : ""]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    const $xeFormGather = {
      formItem,
      renderVN
    };
    provide("$xeFormGather", $xeFormGather);
    provide("$xeFormItem", null);
    return $xeFormGather;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var form_view_default = defineComponent({
  name: "VxeFormView",
  props: {
    modelValue: Object,
    config: Object,
    readonly: Boolean,
    disabled: Boolean,
    viewRender: Object,
    createFormConfig: Function
  },
  emits: [
    "update:modelValue",
    "submit",
    "reset"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils40.default.uniqueId();
    const refElem = ref();
    const formRef = ref();
    const $xeFormDesignLayoutStyle = inject("$xeFormDesignLayoutStyle", null);
    const reactData = reactive({
      formConfig: {},
      formRules: {},
      widgetObjList: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeFormView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clearConfig = () => {
      return loadConfig({
        formConfig: {},
        widgetData: []
      });
    };
    const loadConfig = (config2) => {
      if (config2) {
        const { formConfig, widgetData } = config2;
        loadFormConfig(formConfig || {});
        loadWidgetData(widgetData || []);
      }
      return nextTick();
    };
    const parseConfig = (config2) => {
      const { formConfig, widgetData } = config2 || {};
      const widgetObjList = parseWidgetData(widgetData || []);
      return Object.assign(Object.assign({}, parseForm(widgetObjList)), { formConfig: parseFormConfig(formConfig || {}), widgetData: widgetObjList });
    };
    const parseFormConfig = (formConfig) => {
      const { viewRender, createFormConfig } = props;
      const params = { viewRender, formConfig };
      if (createFormConfig) {
        return createFormConfig(params);
      }
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      return Object.assign({}, createPCFormConfig ? createPCFormConfig(params) : createDefaultFormViewPCFormConfig(params));
    };
    const loadFormConfig = (formConfig) => {
      reactData.formConfig = parseFormConfig(formConfig);
      return nextTick();
    };
    const parseForm = (widgetObjList) => {
      const formData = {};
      const formRules = {};
      import_xe_utils40.default.eachTree(widgetObjList, (widget) => {
        const { name, field, required } = widget;
        const compConf = renderer.get(name) || {};
        const createWidgetFieldValue = compConf.createFormDesignWidgetFieldValue;
        const createWidgetFieldRules = compConf.createFormDesignWidgetFieldRules;
        formData[field] = createWidgetFieldValue ? createWidgetFieldValue({ widget, $formView: $xeFormView }) : getWidgetDefaultValue(widget);
        if (createWidgetFieldRules) {
          const rules = createWidgetFieldRules({ widget, $formView: $xeFormView });
          if (rules && rules.length) {
            formRules[field] = rules;
          }
        } else if (required) {
          formRules[field] = getWidgetDefaultRule();
        }
      }, { children: "children" });
      return {
        formData,
        formRules
      };
    };
    const parseWidgetData = (widgetData) => {
      return (widgetData || []).map((item) => configToWidget(item));
    };
    const loadWidgetData = (widgetData) => {
      const widgetObjList = parseWidgetData(widgetData);
      reactData.widgetObjList = widgetObjList;
      const { formData, formRules } = parseForm(widgetObjList);
      reactData.formRules = formRules;
      emit("update:modelValue", Object.assign(formData, props.modelValue));
      return nextTick();
    };
    const getWidgetDefaultValue = (widget) => {
      switch (widget.name) {
        case "subtable":
          return [];
      }
      return null;
    };
    const getWidgetDefaultRule = () => {
      return [
        { required: true, content: "该填写该字段！" }
      ];
    };
    const updateWidgetStatus = (widget, value) => {
      const { field } = widget;
      const $form = formRef.value;
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const setItemValue = (widget, value) => {
      const { modelValue } = props;
      const { field } = widget;
      const $form = formRef.value;
      if (modelValue) {
        modelValue[field] = value;
      }
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const getItemValue = (widget) => {
      const { modelValue } = props;
      if (modelValue) {
        return modelValue[widget.field];
      }
      return null;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $formView: $xeFormView }, params));
    };
    const toWidgetFields = (widget) => {
      if (widget) {
        if (import_xe_utils40.default.isArray(widget)) {
          return widget.map((item) => item.name);
        } else {
          return [widget.name];
        }
      }
      return null;
    };
    const formViewMethods = {
      dispatchEvent: dispatchEvent2,
      clearConfig,
      loadConfig,
      parseConfig,
      loadFormConfig,
      loadWidgetData,
      updateWidgetStatus,
      setItemValue,
      getItemValue,
      validate() {
        const $form = formRef.value;
        if ($form) {
          return $form.validate();
        }
        return nextTick();
      },
      validateWidget(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.validateField(toWidgetFields(widget));
        }
        return nextTick();
      },
      clearValidate(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.clearValidate(toWidgetFields(widget));
        }
        return nextTick();
      },
      reset() {
        const $form = formRef.value;
        if ($form) {
          return $form.reset();
        }
        return nextTick();
      },
      /**
       * 已废弃
       * @deprecated
       */
      updateItemStatus(widget, value) {
        warnLog("vxe.error.delFunc", ["updateItemStatus", "updateWidgetStatus"]);
        return updateWidgetStatus(widget, value);
      }
    };
    const handleSubmit = (params) => {
      dispatchEvent2("submit", params, params.$event);
    };
    const handleReset = (params) => {
      dispatchEvent2("reset", params, params.$event);
    };
    const formViewPrivateMethods = {};
    Object.assign($xeFormView, formViewMethods, formViewPrivateMethods);
    const renderVN = () => {
      const { readonly, disabled, modelValue } = props;
      const { formConfig, formRules, widgetObjList } = reactData;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: "vxe-form-view"
      }, [
        topSlot ? h("div", {
          class: "vxe-form-view--top"
        }, getSlotVNs(topSlot({ $formView: $xeFormView }))) : createCommentVNode(),
        h(form_default, {
          ref: formRef,
          data: modelValue,
          customLayout: true,
          readonly,
          disabled,
          span: 24,
          vertical: formConfig.vertical,
          titleBold: formConfig.titleBold,
          titleColon: formConfig.titleColon,
          titleAlign: formConfig.titleAlign,
          titleWidth: formConfig.titleWidth,
          rules: formRules,
          onSubmit: handleSubmit,
          onReset: handleReset
        }, {
          default() {
            const { readonly: readonly2, disabled: disabled2 } = props;
            return [
              headerSlot ? h(form_item_default, {}, {
                default() {
                  return headerSlot({});
                }
              }) : createCommentVNode(),
              ...widgetObjList.map((widget) => {
                const { name } = widget;
                const compConf = renderer.get(name) || {};
                const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                const renderWidgetDesignPreview = compConf.renderFormDesignWidgetPreview;
                const renderWidgetDesignMobilePreview = compConf.renderFormDesignWidgetMobilePreview;
                const isEditMode = !!$xeFormDesignLayoutStyle;
                const renderOpts = widget;
                const params = { widget, readonly: !!readonly2, disabled: !!disabled2, isEditMode, isViewMode: !isEditMode, $formDesign: null, $formView: $xeFormView };
                return h(form_gather_default, {
                  key: widget.id
                }, {
                  default() {
                    if ($xeFormDesignLayoutStyle) {
                      if ($xeFormDesignLayoutStyle.reactData.activeTab === 2) {
                        if (renderWidgetDesignMobilePreview) {
                          return getSlotVNs(renderWidgetDesignMobilePreview(renderOpts, params));
                        }
                      } else {
                        if (renderWidgetDesignPreview) {
                          return getSlotVNs(renderWidgetDesignPreview(renderOpts, params));
                        }
                      }
                    }
                    return renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : [];
                  }
                });
              }),
              footerSlot ? h(form_gather_default, {
                span: 24
              }, {
                default() {
                  return footerSlot({});
                }
              }) : createCommentVNode()
            ];
          }
        }),
        bottomSlot ? h("div", {
          class: "vxe-form-view--bottom"
        }, getSlotVNs(bottomSlot({ $formView: $xeFormView }))) : createCommentVNode()
      ]);
    };
    $xeFormView.renderVN = renderVN;
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormView", $xeFormView);
    return $xeFormView;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/input/src/input.js
var import_xe_utils43 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/input/src/date.js
var import_xe_utils41 = __toESM(require_xe_utils());
function toStringTimeDate2(str) {
  if (str) {
    const rest = /* @__PURE__ */ new Date();
    let h2 = 0;
    let m = 0;
    let s = 0;
    if (import_xe_utils41.default.isDate(str)) {
      h2 = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = import_xe_utils41.default.toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h2 = import_xe_utils41.default.toNumber(parses[1]);
        m = import_xe_utils41.default.toNumber(parses[3]);
        s = import_xe_utils41.default.toNumber(parses[5]);
      }
    }
    rest.setHours(h2);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return /* @__PURE__ */ new Date("");
}
function getDateQuarter2(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/input/src/number.js
var import_xe_utils42 = __toESM(require_xe_utils());
function handleNumber(val) {
  return import_xe_utils42.default.isString(val) ? val.replace(/,/g, "") : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return import_xe_utils42.default.toFixed(import_xe_utils42.default.ceil(inputValue, digitsValue), digitsValue);
  }
  return import_xe_utils42.default.toFixed(import_xe_utils42.default.floor(inputValue, digitsValue), digitsValue);
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/input/src/input.js
var yearSize2 = 12;
var monthSize2 = 20;
var quarterSize2 = 8;
var input_default = defineComponent({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: { type: Boolean, default: true },
    name: String,
    type: { type: String, default: "text" },
    clearable: { type: Boolean, default: () => getConfig().input.clearable },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: { type: String, default: "off" },
    align: String,
    form: String,
    className: String,
    size: { type: String, default: () => getConfig().input.size || getConfig().size },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: { type: [String, Number], default: null },
    max: { type: [String, Number], default: null },
    step: [String, Number],
    exponential: { type: Boolean, default: () => getConfig().input.exponential },
    // number、integer、float、password
    controls: { type: Boolean, default: () => getConfig().input.controls },
    // float
    digits: { type: [String, Number], default: () => getConfig().input.digits },
    // date、week、month、quarter、year
    startDate: { type: [String, Number, Date], default: () => getConfig().input.startDate },
    endDate: { type: [String, Number, Date], default: () => getConfig().input.endDate },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: { type: [String, Number], default: () => getConfig().input.startDay },
    labelFormat: String,
    valueFormat: String,
    editable: { type: Boolean, default: true },
    festivalMethod: { type: Function, default: () => getConfig().input.festivalMethod },
    disabledMethod: { type: Function, default: () => getConfig().input.disabledMethod },
    // week
    selectDay: { type: [String, Number], default: () => getConfig().input.selectDay },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils43.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: null,
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate = (value, format) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate2(value);
      }
      return import_xe_utils43.default.toStringDate(value, format);
    };
    const computeTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().input.transfer;
        if (import_xe_utils43.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      if ($xeForm) {
        return $xeForm.props.readonly;
      }
      return false;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      const maxLen = maxLength || maxlength;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        if (!import_xe_utils43.default.toNumber(maxLen)) {
          return 16;
        }
      }
      return maxLen;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsNumType = computed(() => {
      return ["number", "integer", "float"].indexOf(props.type) > -1;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils43.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils43.default.toNumber(inpMaxLength);
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsPawdType = computed(() => {
      return props.type === "password";
    });
    const computeIsSearchType = computed(() => {
      return props.type === "search";
    });
    const computeDigitsValue = computed(() => {
      return import_xe_utils43.default.toInteger(props.digits) || 1;
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils43.default.toInteger(step) || 1;
      } else if (type === "float") {
        return import_xe_utils43.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils43.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === "text" || type === "search");
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils43.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils43.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].includes(props.type);
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils43.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate(item, dateValueFormat);
          if (import_xe_utils43.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils43.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils43.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return type === "time" ? "HH:mm:ss" : type === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (import_xe_utils43.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils43.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isDatePickerType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize2, 0, 1);
        for (let index = -4; index < yearSize2 + 4; index++) {
          const date = import_xe_utils43.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize2,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils43.default.toNumber(import_xe_utils43.default.isNumber(startDay) || import_xe_utils43.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils43.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter2(currentDate);
        const firstYear = import_xe_utils43.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize2 - 2; index++) {
          const date = import_xe_utils43.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter2(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils43.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils43.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize2 - 4; index++) {
          const date = import_xe_utils43.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils43.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils43.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils43.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils43.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils43.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const isReadonly = computeIsReadonly.value;
      return isReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeInputType = computed(() => {
      const { type } = props;
      const { showPwd } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === "number") {
        return "text";
      }
      return type;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().input.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxlength = computed(() => {
      const isNumType = computeIsNumType.value;
      const inpMaxLength = computeInpMaxLength.value;
      return isNumType && !import_xe_utils43.default.toNumber(inpMaxLength) ? 16 : inpMaxLength;
    });
    const computeInpImmediate = computed(() => {
      const { type, immediate } = props;
      return immediate || !(type === "text" || type === "number" || type === "integer" || type === "float");
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === "integer" ? import_xe_utils43.default.toInteger(handleNumber(inputValue)) : import_xe_utils43.default.toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= import_xe_utils43.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= import_xe_utils43.default.toNumber(max);
      }
      return false;
    });
    const getNumberValue = (val) => {
      const { type, exponential } = props;
      const inpMaxlength = computeInpMaxlength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === "float" ? toFloatValueFixed(val, digitsValue) : import_xe_utils43.default.toValueString(val);
      if (exponential && (val === restVal || import_xe_utils43.default.toValueString(val).toLowerCase() === import_xe_utils43.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxlength);
    };
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils43.default.toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          inputMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    let hidePanelTimeout;
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ["text", "search", "password"].indexOf(type) > -1) {
        focus();
      }
      emitModel("", evnt);
      inputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (import_xe_utils43.default.isValidDate(dValue)) {
        dLabel = import_xe_utils43.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils43.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const { type } = props;
      const { inputValue } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === "float") {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            emitModel(validValue, { type: "init" });
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || import_xe_utils43.default.toNumber(num) <= import_xe_utils43.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || import_xe_utils43.default.toNumber(num) >= import_xe_utils43.default.toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils43.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils43.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils43.default.toNumber(props.selectDay);
        date = import_xe_utils43.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = import_xe_utils43.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils43.default.findIndexOf(dateListValue, (val) => import_xe_utils43.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          emitModel(datetimeRest.map((date2) => import_xe_utils43.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils43.default.isEqual(val, inpVal))) {
            emitModel(dateMultipleValue.filter((val) => !import_xe_utils43.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils43.default.isEqual(modelValue, inpVal)) {
          emitModel(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (isNumType) {
          if (inputValue) {
            let inpNumVal = type === "integer" ? import_xe_utils43.default.toInteger(handleNumber(inputValue)) : import_xe_utils43.default.toNumber(handleNumber(inputValue));
            if (!validMinNum(inpNumVal)) {
              inpNumVal = min;
            } else if (!validMaxNum(inpNumVal)) {
              inpNumVal = max;
            }
            if (exponential) {
              const inpStringVal = import_xe_utils43.default.toValueString(inputValue).toLowerCase();
              if (inpStringVal === import_xe_utils43.default.toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            emitModel(getNumberValue(inpNumVal), { type: "check" });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate(inputValue, dateLabelFormat);
            if (import_xe_utils43.default.isValidDate(inpDateVal)) {
              if (type === "time") {
                inpDateVal = import_xe_utils43.default.toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  emitModel(inpDateVal, { type: "check" });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === "datetime") {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== import_xe_utils43.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils43.default.toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = import_xe_utils43.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            emitModel("", { type: "check" });
          }
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    const passwordToggleEvent = (evnt) => {
      const { showPwd } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!isDisabled && !isReadonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const searchEvent = (evnt) => {
      inputMethods.dispatchEvent("search-click", {}, evnt);
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils43.default.toInteger(handleNumber(inputValue)) : import_xe_utils43.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils43.default.add(numValue, stepValue) : import_xe_utils43.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    let downbumTimeout;
    const numberNextEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !isReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", {}, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !isReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", {}, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const numberStopDown = () => {
      clearTimeout(downbumTimeout);
    };
    const numberDownPrevEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils43.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils43.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, -yearSize2, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, -yearSize2, "first");
          } else {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, -yearSize2, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils43.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        inputMethods.dispatchEvent("date-prev", { type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, yearSize2, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, yearSize2, "first");
          } else {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, yearSize2, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils43.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils43.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        inputMethods.dispatchEvent("date-next", { type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeInput });
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils43.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils43.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils43.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils43.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            emitModel(datetimeRest.map((date) => import_xe_utils43.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils43.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils43.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils43.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils43.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils43.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils43.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils43.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils43.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils43.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils43.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils43.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils43.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils43.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils43.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils43.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils43.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils43.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils43.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils43.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils43.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils43.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils43.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils43.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), updateTimePos);
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const transfer = computeTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const isReadonly = computeIsReadonly.value;
      if (!isReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeInput });
        const festivalItem = festivalRest ? import_xe_utils43.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils43.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-input--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", label),
            h("span", {
              class: ["vxe-input--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils43.default.toValueString(extraItem.label))
          ] : label)
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils43.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-input--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-input--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils43.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils43.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils43.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils43.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils43.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils43.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils43.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils43.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils43.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils43.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils43.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils43.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils43.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils43.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils43.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-input--date-picker-header"
        }, [
          h("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-input--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-input--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-input--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-input--time-picker-header"
        }, [
          hasTimeMinute ? h("span", {
            class: "vxe-input--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-input--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-input--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-input--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, hourList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, minuteList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-input--time-picker-second-list"
          }, secondList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderPanel = () => {
      const { type } = props;
      const { inited, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const transfer = computeTransfer.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-input--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-input--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            key: type || "default",
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-input--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, renders)
        ]);
      }
      return createCommentVNode();
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("div", {
        class: "vxe-input--control-icon"
      }, [
        h("div", {
          class: "vxe-input--number-icon"
        }, [
          h("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": isDisabledAddNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_PREV_NUM
            })
          ]),
          h("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": isDisabledSubtractNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    };
    const renderDatePickerIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-input--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderSearchIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: searchEvent
      }, [
        h("i", {
          class: ["vxe-input--search-icon", getIcon().INPUT_SEARCH]
        })
      ]);
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-input--prefix-icon"
        }, prefixSlot ? getSlotVNs(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      const isClearable = computeIsClearable.value;
      const isExtraBtn = isPawdType || isNumType || isDatePickerType || isSearchType;
      return isClearable || suffixSlot || suffixIcon || isExtraBtn ? h("div", {
        class: ["vxe-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils43.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        isExtraBtn ? renderExtraSuffixIcon() : createCommentVNode(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      if (isPawdType) {
        return renderPasswordIcon();
      }
      if (isNumType) {
        if (controls) {
          return renderNumberIcon();
        }
      }
      if (isDatePickerType) {
        return renderDatePickerIcon();
      }
      if (isSearchType) {
        return renderSearchIcon();
      }
      return createCommentVNode();
    };
    inputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $input: $xeInput }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeInput, inputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick(() => {
      globalEvents.on($xeInput, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeInput, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      numberStopDown();
      globalEvents.off($xeInput, "mousewheel");
      globalEvents.off($xeInput, "mousedown");
      globalEvents.off($xeInput, "keydown");
      globalEvents.off($xeInput, "blur");
    });
    initValue();
    const renderVN = () => {
      const { className, controls, type, align, showWordCount, countMethod, name, autoComplete, autocomplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-input--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxlength = computeInpMaxlength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const isWordCount = showWordCount && ["text", "search"].includes(type);
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--count": isWordCount,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils43.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            maxlength: inpMaxlength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 下拉面板
        renderPanel(),
        // 字数统计
        isWordCount ? h("span", {
          class: ["vxe-input--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxlength ? `/${inpMaxlength}` : ""}`) : createCommentVNode()
      ]);
    };
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/radio/src/group.js
var import_xe_utils46 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/radio/src/radio.js
var import_xe_utils44 = __toESM(require_xe_utils());
var radio_default = defineComponent({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: { type: Boolean, default: () => getConfig().radio.strict },
    size: { type: String, default: () => getConfig().radio.size || getConfig().size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils44.default.uniqueId();
    const $xeRadio = {
      xID,
      props,
      context
    };
    const { computeSize } = useSize(props);
    let radioMethods = {};
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : props.name;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { modelValue, label } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioMethods.dispatchEvent("change", { label }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    radioMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $radio: $xeRadio }, params));
      }
    };
    Object.assign($xeRadio, radioMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", {
          [`size--${vSize}`]: vSize,
          "is--checked": isChecked,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeRadio.renderVN = renderVN;
    return $xeRadio;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/radio/src/button.js
var import_xe_utils45 = __toESM(require_xe_utils());
var button_default3 = defineComponent({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: { type: Boolean, default: () => getConfig().radioButton.strict },
    size: { type: String, default: () => getConfig().radioButton.size || getConfig().size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const xeFormItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils45.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeRadioButton = {
      xID,
      props,
      context
    };
    let radioButtonMethods = {};
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : null;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { modelValue, label } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : modelValue === label;
    });
    radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $radioButton: $xeRadioButton }, params));
      }
    };
    Object.assign($xeRadioButton, radioButtonMethods);
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioButtonMethods.dispatchEvent("change", { label }, evnt);
        if ($xeForm && xeFormItemInfo) {
          $xeForm.triggerItemEvent(evnt, xeFormItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const checked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", "vxe-radio-button", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    Object.assign($xeRadioButton, {
      renderVN,
      dispatchEvent
    });
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/radio/src/group.js
var group_default2 = defineComponent({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: { type: Boolean, default: () => getConfig().radioGroup.strict },
    size: { type: String, default: () => getConfig().radioGroup.size || getConfig().size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils46.default.uniqueId();
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaps = {
      computeIsDisabled
    };
    const $xeradiogroup = {
      xID,
      props,
      context,
      name: import_xe_utils46.default.uniqueId("xegroup_"),
      getComputeMaps: () => computeMaps
    };
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    let radioGroupMethods = {};
    useSize(props);
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        emit("update:modelValue", params.label);
        radioGroupMethods.dispatchEvent("change", params, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, params.label);
        }
      }
    };
    radioGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $radioGroup: $xeradiogroup }, params));
      }
    };
    const renderVN = () => {
      const { options, type } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === "button" ? button_default3 : radio_default;
      return h("div", {
        class: "vxe-radio-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(btnComp, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    Object.assign($xeradiogroup, radioGroupPrivateMethods, {
      renderVN,
      dispatchEvent
    });
    provide("$xeRadioGroup", $xeradiogroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/select/src/select.js
var import_xe_utils47 = __toESM(require_xe_utils());
function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return import_xe_utils47.default.uniqueId("opt_");
}
var select_default = defineComponent({
  name: "VxeSelect",
  props: {
    modelValue: [String, Number, Boolean, Array],
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: { type: [Number, String], default: () => getConfig().select.multiCharOverflow },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => getConfig().select.size || getConfig().size },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    // 已废弃，被 option-config.keyField 替换
    optionId: { type: String, default: () => getConfig().select.optionId },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils47.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      staticOptions: [],
      fullGroupList: [],
      fullOptionList: [],
      visibleGroupList: [],
      visibleOptionList: [],
      remoteValueList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      currentOption: null,
      currentValue: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      searchValue: "",
      searchLoading: false
    });
    const refElem = ref();
    const refInput = ref();
    const refInpSearch = ref();
    const refOptionWrapper = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let selectMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils47.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeGroupPropsOpts = computed(() => {
      return props.optionGroupProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeGroupLabelField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || "label";
    });
    const computeGroupOptionsField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || "options";
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, multiple, max } = props;
      if (multiple && max) {
        return (import_xe_utils47.default.isArray(modelValue) ? modelValue.length : import_xe_utils47.default.eqNull(modelValue) ? 0 : 1) >= import_xe_utils47.default.toNumber(max);
      }
      return false;
    });
    const computeOptionOpts = computed(() => {
      return Object.assign({}, getConfig().select.optionConfig, props.optionConfig);
    });
    const computeIsGroup = computed(() => {
      return reactData.fullGroupList.some((item) => item.options && item.options.length);
    });
    const computeMultiMaxCharNum = computed(() => {
      return import_xe_utils47.default.toNumber(props.multiCharOverflow);
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils47.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils47.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const findOption = (optionValue) => {
      const { fullOptionList, fullGroupList } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      if (isGroup) {
        for (let gIndex = 0; gIndex < fullGroupList.length; gIndex++) {
          const group = fullGroupList[gIndex];
          if (group.options) {
            for (let index = 0; index < group.options.length; index++) {
              const option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return fullOptionList.find((item) => optionValue === item[valueField]);
    };
    const findVisibleOption = (optionValue) => {
      const { visibleOptionList, visibleGroupList } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      if (isGroup) {
        for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          const group = visibleGroupList[gIndex];
          if (group.options) {
            for (let index = 0; index < group.options.length; index++) {
              const option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return visibleOptionList.find((item) => optionValue === item[valueField]);
    };
    const getRemoteSelectLabel = (value) => {
      const { remoteValueList } = reactData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValueList.find((item2) => value === item2.key);
      const item = remoteItem ? remoteItem.result : null;
      return import_xe_utils47.default.toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = (value) => {
      const labelField = computeLabelField.value;
      const item = findOption(value);
      return import_xe_utils47.default.toValueString(item ? item[labelField] : value);
    };
    const computeSelectLabel = computed(() => {
      const { modelValue, multiple, remote } = props;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (modelValue && multiple) {
        const vals = import_xe_utils47.default.isArray(modelValue) ? modelValue : [modelValue];
        if (remote) {
          return vals.map((val) => getRemoteSelectLabel(val)).join(", ");
        }
        return vals.map((val) => {
          const label = getSelectLabel(val);
          if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
            return `${label.substring(0, multiMaxCharNum)}...`;
          }
          return label;
        }).join(", ");
      }
      if (remote) {
        return getRemoteSelectLabel(modelValue);
      }
      return getSelectLabel(modelValue);
    });
    const getOptkey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || "_X_OPTION_KEY";
    };
    const getOptid = (option) => {
      const optid = option[getOptkey()];
      return optid ? encodeURIComponent(optid) : "";
    };
    const refreshOption = () => {
      const { filterable, filterMethod } = props;
      const { fullOptionList, fullGroupList, searchValue } = reactData;
      const isGroup = computeIsGroup.value;
      const groupLabelField = computeGroupLabelField.value;
      const labelField = computeLabelField.value;
      if (isGroup) {
        if (filterable && filterMethod) {
          reactData.visibleGroupList = fullGroupList.filter((group) => isOptionVisible(group) && filterMethod({ group, option: null, searchValue }));
        } else if (filterable) {
          reactData.visibleGroupList = fullGroupList.filter((group) => isOptionVisible(group) && (!searchValue || `${group[groupLabelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);
        }
      } else {
        if (filterable && filterMethod) {
          reactData.visibleOptionList = fullOptionList.filter((option) => isOptionVisible(option) && filterMethod({ group: null, option, searchValue }));
        } else if (filterable) {
          reactData.visibleOptionList = fullOptionList.filter((option) => isOptionVisible(option) && (!searchValue || `${option[labelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);
        }
      }
      return nextTick();
    };
    const cacheItemMap = () => {
      const { fullOptionList, fullGroupList } = reactData;
      const groupOptionsField = computeGroupOptionsField.value;
      const key = getOptkey();
      const handleOptis = (item) => {
        if (!getOptid(item)) {
          item[key] = getOptUniqueId();
        }
      };
      if (fullGroupList.length) {
        fullGroupList.forEach((group) => {
          handleOptis(group);
          if (group[groupOptionsField]) {
            group[groupOptionsField].forEach(handleOptis);
          }
        });
      } else if (fullOptionList.length) {
        fullOptionList.forEach(handleOptis);
      }
      refreshOption();
    };
    const setCurrentOption = (option) => {
      const valueField = computeValueField.value;
      if (option) {
        reactData.currentOption = option;
        reactData.currentValue = option[valueField];
      }
    };
    const scrollToOption = (option, isAlignBottom) => {
      return nextTick().then(() => {
        if (option) {
          const optWrapperElem = refOptionWrapper.value;
          const panelElem = refOptionPanel.value;
          const optElem = panelElem.querySelector(`[optid='${getOptid(option)}']`);
          if (optWrapperElem && optElem) {
            const wrapperHeight = optWrapperElem.offsetHeight;
            const offsetPadding = 5;
            if (isAlignBottom) {
              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
              }
            } else {
              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
              }
            }
          }
        }
      });
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const { loading: loading2, filterable } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          refreshOption();
        }
        setTimeout(() => {
          const { modelValue } = props;
          const currOption = findOption(import_xe_utils47.default.isArray(modelValue) ? modelValue[0] : modelValue);
          reactData.visiblePanel = true;
          if (currOption) {
            setCurrentOption(currOption);
            scrollToOption(currOption);
          }
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = "";
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        selectMethods.dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      reactData.remoteValueList = [];
      changeEvent(evnt, selectValue);
      selectMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, selectValue, option) => {
      const { modelValue, multiple } = props;
      const { remoteValueList } = reactData;
      if (multiple) {
        let multipleValue = [];
        const selectVals = import_xe_utils47.default.eqNull(modelValue) ? [] : import_xe_utils47.default.isArray(modelValue) ? modelValue : [modelValue];
        const index = import_xe_utils47.default.findIndexOf(selectVals, (val) => val === selectValue);
        if (index === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter((val) => val !== selectValue);
        }
        const remoteItem = remoteValueList.find((item) => item.key === selectValue);
        if (remoteItem) {
          remoteItem.result = option;
        } else {
          remoteValueList.push({ key: selectValue, result: option });
        }
        changeEvent(evnt, multipleValue);
      } else {
        reactData.remoteValueList = [{ key: selectValue, result: option }];
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const findOffsetOption = (optionValue, isUpArrow) => {
      const { visibleOptionList, visibleGroupList } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      let firstOption;
      let prevOption;
      let nextOption;
      let currOption;
      if (isGroup) {
        for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          const group = visibleGroupList[gIndex];
          const groupOptionList = group[groupOptionsField];
          const isGroupDisabled = group.disabled;
          if (groupOptionList) {
            for (let index = 0; index < groupOptionList.length; index++) {
              const option = groupOptionList[index];
              const isVisible = isOptionVisible(option);
              const isDisabled = isGroupDisabled || option.disabled;
              if (!firstOption && !isDisabled) {
                firstOption = option;
              }
              if (currOption) {
                if (isVisible && !isDisabled) {
                  nextOption = option;
                  if (!isUpArrow) {
                    return { offsetOption: nextOption };
                  }
                }
              }
              if (optionValue === option[valueField]) {
                currOption = option;
                if (isUpArrow) {
                  return { offsetOption: prevOption };
                }
              } else {
                if (isVisible && !isDisabled) {
                  prevOption = option;
                }
              }
            }
          }
        }
      } else {
        for (let index = 0; index < visibleOptionList.length; index++) {
          const option = visibleOptionList[index];
          const isDisabled = option.disabled;
          if (!firstOption && !isDisabled) {
            firstOption = option;
          }
          if (currOption) {
            if (!isDisabled) {
              nextOption = option;
              if (!isUpArrow) {
                return { offsetOption: nextOption };
              }
            }
          }
          if (optionValue === option[valueField]) {
            currOption = option;
            if (isUpArrow) {
              return { offsetOption: prevOption };
            }
          } else {
            if (!isDisabled) {
              prevOption = option;
            }
          }
        }
      }
      return { firstOption };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel, currentValue, currentOption } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentValue, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let { firstOption, offsetOption } = findOffsetOption(currentValue, isUpArrow);
            if (!offsetOption && !findVisibleOption(currentValue)) {
              offsetOption = firstOption;
            }
            setCurrentOption(offsetOption);
            scrollToOption(offsetOption, isDwArrow);
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        nextTick(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      selectMethods.dispatchEvent("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      selectMethods.dispatchEvent("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      selectMethods.dispatchEvent("blur", {}, evnt);
    };
    const modelSearchEvent = (value) => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const triggerSearchEvent = import_xe_utils47.default.debounce(function() {
      const { remote, remoteMethod } = props;
      const { searchValue } = reactData;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({ searchValue })).then(() => nextTick()).catch(() => nextTick()).finally(() => {
          reactData.searchLoading = false;
          refreshOption();
        });
      } else {
        refreshOption();
      }
    }, 350, { trailing: true });
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const checkOptionDisabled = (isSelected, option, group) => {
      if (option.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const renderOption = (list, group) => {
      const { optionKey, modelValue } = props;
      const { currentValue } = reactData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const isGroup = computeIsGroup.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const { slots: slots2, className } = option;
        const optionValue = option[valueField];
        const isSelected = import_xe_utils47.default.isArray(modelValue) ? modelValue.indexOf(optionValue) > -1 : modelValue === optionValue;
        const isVisible = !isGroup || isOptionVisible(option);
        const isDisabled = checkOptionDisabled(isSelected, option, group);
        const optid = getOptid(option);
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option, group: null, $select: $xeSelect };
        return isVisible ? h("div", {
          key: useKey || optionKey ? optid : cIndex,
          class: ["vxe-select-option", className ? import_xe_utils47.default.isFunction(className) ? className(optParams) : className : "", {
            "is--disabled": isDisabled,
            "is--selected": isSelected,
            "is--hover": currentValue === optionValue
          }],
          // attrs
          optid,
          // event
          onMousedown: (evnt) => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: (evnt) => {
            if (!isDisabled) {
              changeOptionEvent(evnt, optionValue, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled) {
              setCurrentOption(option);
            }
          }
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(option[labelField])) : createCommentVNode();
      });
    };
    const renderOptgroup = () => {
      const { optionKey } = props;
      const { visibleGroupList } = reactData;
      const optionOpts = computeOptionOpts.value;
      const groupLabelField = computeGroupLabelField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return visibleGroupList.map((group, gIndex) => {
        const { slots: slots2, className } = group;
        const optid = getOptid(group);
        const isGroupDisabled = group.disabled;
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option: group, group, $select: $xeSelect };
        return h("div", {
          key: useKey || optionKey ? optid : gIndex,
          class: ["vxe-optgroup", className ? import_xe_utils47.default.isFunction(className) ? className(optParams) : className : "", {
            "is--disabled": isGroupDisabled
          }],
          // attrs
          optid
        }, [
          h("div", {
            class: "vxe-optgroup--title"
          }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(group[groupLabelField])),
          h("div", {
            class: "vxe-optgroup--wrapper"
          }, renderOption(group[groupOptionsField] || [], group))
        ]);
      });
    };
    const renderOpts = () => {
      const { visibleGroupList, visibleOptionList, searchLoading } = reactData;
      const isGroup = computeIsGroup.value;
      if (searchLoading) {
        return [
          h("div", {
            class: "vxe-select--search-loading"
          }, [
            h("i", {
              class: ["vxe-select--search-icon", getIcon().SELECT_LOADED]
            }),
            h("span", {
              class: "vxe-select--search-text"
            }, getI18n("vxe.select.loadingText"))
          ])
        ];
      }
      if (isGroup) {
        if (visibleGroupList.length) {
          return renderOptgroup();
        }
      } else {
        if (visibleOptionList.length) {
          return renderOption(visibleOptionList);
        }
      }
      return [
        h("div", {
          class: "vxe-select--empty-placeholder"
        }, props.emptyText || getI18n("vxe.select.emptyText"))
      ];
    };
    selectMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $select: $xeSelect }, params));
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      refreshOption,
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeSelect, selectMethods);
    const renderVN = () => {
      const { className, popupClassName, loading: loading2, filterable } = props;
      const { initialized, isActivated, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const transfer = computeTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-select--readonly", className]
        }, [
          h("div", {
            class: "vxe-select-slots",
            ref: "hideOption"
          }, defaultSlot ? defaultSlot({}) : []),
          h("span", {
            class: "vxe-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-select", className ? import_xe_utils47.default.isFunction(className) ? className({ $select: $xeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--filter": filterable,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, defaultSlot ? defaultSlot({}) : []),
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: inpPlaceholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().SELECT_LOADED : visiblePanel ? getIcon().SELECT_OPEN : getIcon().SELECT_CLOSE,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-select--panel", popupClassName ? import_xe_utils47.default.isFunction(popupClassName) ? popupClassName({ $select: $xeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "ani--leave": !loading2 && reactData.isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            filterable ? h("div", {
              class: "vxe-select--panel-search"
            }, [
              h(input_default, {
                ref: refInpSearch,
                class: "vxe-select-search--input",
                modelValue: reactData.searchValue,
                clearable: true,
                placeholder: getI18n("vxe.select.search"),
                prefixIcon: getIcon().INPUT_SEARCH,
                "onUpdate:modelValue": modelSearchEvent,
                onFocus: focusSearchEvent,
                onChange: triggerSearchEvent,
                onSearch: triggerSearchEvent
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-select--panel-header"
              }, headerSlot({})) : createCommentVNode(),
              h("div", {
                class: "vxe-select--panel-body"
              }, [
                h("div", {
                  ref: refOptionWrapper,
                  class: "vxe-select-option--wrapper"
                }, renderOpts())
              ]),
              footerSlot ? h("div", {
                class: "vxe-select--panel-footer"
              }, footerSlot({})) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    $xeSelect.renderVN = renderVN;
    watch(() => reactData.staticOptions, (value) => {
      if (value.some((item) => item.options && item.options.length)) {
        reactData.fullOptionList = [];
        reactData.fullGroupList = value;
      } else {
        reactData.fullGroupList = [];
        reactData.fullOptionList = value || [];
      }
      cacheItemMap();
    });
    watch(() => props.options, (value) => {
      reactData.fullGroupList = [];
      reactData.fullOptionList = value || [];
      cacheItemMap();
    });
    watch(() => props.optionGroups, (value) => {
      reactData.fullOptionList = [];
      reactData.fullGroupList = value || [];
      cacheItemMap();
    });
    onMounted(() => {
      nextTick(() => {
        const { options, optionGroups } = props;
        if (optionGroups) {
          reactData.fullGroupList = optionGroups;
        } else if (options) {
          reactData.fullOptionList = options;
        }
        cacheItemMap();
      });
      globalEvents.on($xeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeSelect, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeSelect, "mousewheel");
      globalEvents.off($xeSelect, "mousedown");
      globalEvents.off($xeSelect, "keydown");
      globalEvents.off($xeSelect, "blur");
    });
    provide("$xeSelect", $xeSelect);
    return $xeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/default-style-form.js
var getBoldOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.styleSetting.fontBold"), value: true }
  ];
};
var getColonOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.colonVisible"), value: true },
    { label: getI18n("vxe.formDesign.styleSetting.colonHidden"), value: false }
  ];
};
var getAlignOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.alignRight"), value: "right" }
  ];
};
var getWidthUnitOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.unitPx"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.unitPct"), value: "%" }
  ];
};
var renderLayoutOption = (formData, field, type, changeEvent) => {
  const isVertical = type === "vertical";
  return h("div", {
    class: ["vxe-form-design--widget-form-item-option", `is--${type}`, {
      "is--active": isVertical ? formData[field] : !formData[field]
    }],
    onClick() {
      formData[field] = isVertical;
      changeEvent();
    }
  }, [
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {}, isVertical ? getI18n("vxe.formDesign.styleSetting.verticalLayout") : getI18n("vxe.formDesign.styleSetting.horizontalLayout"))
  ]);
};
var DefaultPCStyleFormComponent = defineComponent({
  name: "DefaultPCStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "pcVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.pcTitleWidth) {
        formData.pcTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default2, {
                      modelValue: formData.pcTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default2, {
                      modelValue: formData.pcTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleColon = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default2, {
                      modelValue: formData.pcTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleAlign = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.pcTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.pcTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultMobileStyleFormComponent = defineComponent({
  name: "DefaultMobileStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "mobileVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.mobileTitleWidth) {
        formData.mobileTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default2, {
                      modelValue: formData.mobileTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default2, {
                      modelValue: formData.mobileTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleColon = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default2, {
                      modelValue: formData.mobileTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleAlign = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.mobileTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.mobileTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/layout-style.js
var layout_style_default = defineComponent({
  name: "FormDesignLayoutStyle",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const reactData = reactive({
      activeTab: 1
    });
    const $xeFormDesignLayoutStyle = {
      reactData,
      renderVN() {
        return [];
      }
    };
    if (!$xeFormDesign) {
      return $xeFormDesignLayoutStyle;
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const settingVisible = ref(false);
    const settingConfig = ref(null);
    const settingFormData = ref({});
    const updatePreviewView = () => {
      settingConfig.value = $xeFormDesign.getConfig();
    };
    const createFormViewFormConfig = (params) => {
      const { viewRender } = params;
      const { activeTab } = reactData;
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      const createMobileFormConfig = compConf ? compConf.createFormViewMobileFormConfig : null;
      if (activeTab === 2) {
        if (createMobileFormConfig) {
          return createMobileFormConfig(params);
        }
        return createDefaultFormViewMobileFormConfig(params);
      }
      if (createPCFormConfig) {
        return createPCFormConfig(params);
      }
      return createDefaultFormViewPCFormConfig(params);
    };
    const formDesignLayoutStyleMethod = {
      updatePreviewView,
      openStylePreview() {
        const { showPc } = formDesignProps;
        updatePreviewView();
        reactData.activeTab = showPc ? 1 : 2;
        settingVisible.value = true;
      }
    };
    Object.assign($xeFormDesignLayoutStyle, formDesignLayoutStyleMethod);
    const renderStylePreview = () => {
      const { activeTab } = reactData;
      return h("div", {
        class: ["vxe-form-design--layout-style-preview", `is--${activeTab === 2 ? "mobile" : "pc"}`]
      }, [
        h(form_view_default, {
          modelValue: settingFormData.value,
          config: settingConfig.value,
          createFormConfig: createFormViewFormConfig,
          "onUpdate:modelValue"(val) {
            settingFormData.value = val;
          }
        })
      ]);
    };
    const renderMobileStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingMobileFormView = compConf ? compConf.renderFormDesignMobileStyleFormView : null;
        if (renderSettingMobileFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-mobile-form-view"
          }, getSlotVNs(renderSettingMobileFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultMobileStyleFormComponent, {
        formData
      });
    };
    const renderPCStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderStylePCFormView = compConf ? compConf.renderFormDesignStyleFormView : null;
        if (renderStylePCFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-pc-form-view"
          }, getSlotVNs(renderStylePCFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultPCStyleFormComponent, {
        formData
      });
    };
    const renderStyleSetting = () => {
      const { showPc, showMobile } = formDesignProps;
      const { activeTab } = reactData;
      return h("div", {
        class: "vxe-form-design--layout-style-setting"
      }, [
        h(tabs_default, {
          modelValue: activeTab,
          titleWidth: showPc && showMobile ? "50%" : "100%",
          titleAlign: "center",
          padding: true,
          onChange: updatePreviewView,
          "onUpdate:modelValue"(val) {
            reactData.activeTab = val;
          }
        }, {
          default() {
            const tabVNs = [];
            if (showPc) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.pc"),
                icon: getIcon().FORM_DESIGN_PROPS_PC,
                k: 1,
                name: 1
              }, {
                default() {
                  return renderPCStyle();
                }
              }));
            }
            if (showMobile) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile"),
                icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                key: 2,
                name: 2
              }, {
                default() {
                  return renderMobileStyle();
                }
              }));
            }
            return tabVNs;
          }
        })
      ]);
    };
    const renderVN = () => {
      const { showPc, showMobile } = formDesignProps;
      return h(modal_default, {
        modelValue: settingVisible.value,
        title: getI18n("vxe.formDesign.styleSetting.title"),
        height: "90vh",
        width: "90vw",
        escClosable: true,
        maskClosable: true,
        destroyOnClose: true,
        showMaximize: true,
        transfer: true,
        "onUpdate:modelValue"(val) {
          settingVisible.value = val;
        }
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--layout-style"
          }, [
            renderStylePreview(),
            showPc || showMobile ? renderStyleSetting() : createCommentVNode()
          ]);
        }
      });
    };
    $xeFormDesignLayoutStyle.renderVN = renderVN;
    provide("$xeFormDesignLayoutStyle", $xeFormDesignLayoutStyle);
    return $xeFormDesignLayoutStyle;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var form_design_default = defineComponent({
  name: "VxeFormDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().formDesign.size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().formDesign.height
    },
    widgets: {
      type: Array,
      default: () => import_xe_utils48.default.clone(getConfig().formDesign.widgets) || []
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().formDesign.showHeader
    },
    showPc: {
      type: Boolean,
      default: () => getConfig().formDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().formDesign.showMobile
    },
    formRender: Object
  },
  emits: [
    "click-widget",
    "add-widget",
    "copy-widget",
    "remove-widget",
    "drag-widget"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils48.default.uniqueId();
    const refElem = ref();
    const refLayoutStyle = ref();
    const reactData = reactive({
      formData: {},
      widgetConfigs: [],
      widgetObjList: [],
      dragWidget: null,
      sortWidget: null,
      activeWidget: null,
      sortSubWidget: null
    });
    const internalData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeFormDesign = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const createWidget = (name) => {
      return new FormDesignWidgetInfo($xeFormDesign, name, reactData.widgetObjList);
    };
    const createEmptyWidget = () => {
      return new FormDesignWidgetInfo($xeFormDesign, "", reactData.widgetObjList);
    };
    const loadConfig = (config2) => {
      if (config2) {
        const { formConfig, widgetData } = config2;
        if (formConfig) {
          loadFormConfig(formConfig);
        }
        if (widgetData) {
          loadWidgetData(widgetData);
        }
      }
      return nextTick();
    };
    const reloadConfig = (config2) => {
      clearConfig();
      return loadConfig(config2);
    };
    const getFormConfig = () => {
      return import_xe_utils48.default.clone(reactData.formData, true);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getWidgetData = () => {
      const objList = import_xe_utils48.default.clone(reactData.widgetObjList, true);
      import_xe_utils48.default.eachTree(objList, (item) => {
        item.model.value = null;
      }, { children: "children" });
      return objList;
    };
    const loadWidgetData = (widgetData) => {
      reactData.widgetObjList = (widgetData || []).map((item) => configToWidget(item));
      return nextTick();
    };
    const openStyleSetting = () => {
      const $layoutStyle = refLayoutStyle.value;
      if ($layoutStyle) {
        $layoutStyle.openStylePreview();
      }
      return nextTick();
    };
    const clearConfig = () => {
      reactData.widgetObjList = [];
      initSettingForm();
      return nextTick();
    };
    const formDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $xeFormDesign }, params));
      },
      createWidget,
      createEmptyWidget,
      getConfig() {
        return {
          formConfig: getFormConfig(),
          widgetData: getWidgetData()
        };
      },
      clearConfig,
      loadConfig,
      reloadConfig,
      getFormConfig,
      loadFormConfig,
      getFormData() {
        const { widgetObjList } = reactData;
        const formData = {};
        import_xe_utils48.default.eachTree(widgetObjList, (widget) => {
          formData[widget.field] = null;
        }, { children: "children" });
        return formData;
      },
      getWidgetData,
      loadWidgetData,
      refreshPreviewView() {
        const $layoutStyle = refLayoutStyle.value;
        if ($layoutStyle) {
          $layoutStyle.updatePreviewView();
        }
        return nextTick();
      },
      openStyleSetting
    };
    const updateWidgetConfigs = () => {
      const { widgets } = props;
      const widgetConfs = [];
      const baseWidgets = [];
      const layoutWidgets = [];
      const advancedWidgets = [];
      const customGroups = [];
      renderer.forEach((item, name) => {
        const { createFormDesignWidgetConfig } = item;
        if (createFormDesignWidgetConfig) {
          const widthItem = createWidget(name);
          const widgetGroup = getWidgetConfigGroup(name);
          const widgetCustomGroup = getWidgetConfigCustomGroup(name, $xeFormDesign);
          if (widgetCustomGroup) {
            const cusGroup = customGroups.find((item2) => item2.title === widgetCustomGroup);
            if (cusGroup) {
              cusGroup.children.push(widthItem);
            } else {
              customGroups.push({
                title: widgetCustomGroup,
                children: [widthItem]
              });
            }
          } else {
            switch (widgetGroup) {
              case "layout":
                layoutWidgets.push(widthItem);
                break;
              case "advanced":
                advancedWidgets.push(widthItem);
                break;
              default:
                if (!["title"].includes(widthItem.name)) {
                  baseWidgets.push(widthItem);
                }
                break;
            }
          }
        }
      });
      if (baseWidgets.length) {
        widgetConfs.push({
          group: "base",
          children: baseWidgets
        });
      }
      if (layoutWidgets.length) {
        widgetConfs.push({
          group: "layout",
          children: layoutWidgets
        });
      }
      if (advancedWidgets.length) {
        widgetConfs.push({
          group: "advanced",
          children: advancedWidgets
        });
      }
      if (customGroups.length) {
        widgetConfs.push(...customGroups);
      }
      if (widgets && widgets.length) {
        reactData.widgetConfigs = props.widgets.map((config2) => {
          return {
            title: config2.customGroup,
            group: config2.group,
            children: config2.children ? config2.children.map((name) => {
              const widthItem = createWidget(name);
              return widthItem;
            }) : []
          };
        });
      } else {
        reactData.widgetConfigs = widgetConfs;
      }
    };
    const validWidgetUnique = (widgetName) => {
      const { widgetObjList } = reactData;
      const uniqueConf = getWidgetConfigUnique(widgetName);
      if (uniqueConf) {
        const existWidgetList = [];
        import_xe_utils48.default.eachTree(widgetObjList, (obj) => {
          if (obj.name === widgetName) {
            existWidgetList.push(obj);
          }
        }, { children: "children" });
        const status = existWidgetList.length < 1;
        if (!status) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.formDesign.error.wdFormUni"),
              status: "error",
              id: "wdFormUni"
            });
          }
        }
        return status;
      }
      return true;
    };
    const formDesignPrivateMethods = {
      validWidgetUnique,
      handleClickWidget(evnt, item) {
        if (item && item.name) {
          evnt.stopPropagation();
          reactData.activeWidget = item;
          formDesignMethods.dispatchEvent("click-widget", { widget: item }, evnt);
        }
      },
      handleCopyWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils48.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          evnt.stopPropagation();
          if (validWidgetUnique(widget.name)) {
            const { path } = rest;
            const rootIndex = Number(path[0]);
            const newWidget = createWidget(widget.name);
            if (newWidget.title) {
              newWidget.title = getI18n("vxe.formDesign.widget.copyTitle", [`${widget.title}`.replace(getI18n("vxe.formDesign.widget.copyTitle", [""]), "")]);
            }
            if (rootIndex >= widgetObjList.length - 1) {
              widgetObjList.push(newWidget);
            } else {
              widgetObjList.splice(rootIndex + 1, 0, newWidget);
            }
            reactData.activeWidget = newWidget;
            reactData.widgetObjList = [...widgetObjList];
            formDesignMethods.dispatchEvent("copy-widget", { widget, newWidget }, evnt);
          }
        }
      },
      handleRemoveWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils48.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          const { index, parent, items } = rest;
          evnt.stopPropagation();
          if (index >= items.length - 1) {
            reactData.activeWidget = items[index - 1];
          } else {
            reactData.activeWidget = items[index + 1] || null;
          }
          if (parent && parent.name === "row") {
            items[index] = createEmptyWidget();
          } else {
            items.splice(index, 1);
          }
          reactData.widgetObjList = [...widgetObjList];
          formDesignMethods.dispatchEvent("remove-widget", { widget }, evnt);
        }
      }
    };
    const createSettingForm = () => {
      const { formRender, showPc, showMobile } = props;
      let conf = getDefaultSettingFormData({
        pcVisible: showPc,
        mobileVisible: showMobile
      });
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createFormDesignSettingFormConfig : null;
        conf = (createFormConfig ? createFormConfig({}) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const openStylePreviewEvent = () => {
      openStyleSetting();
    };
    Object.assign($xeFormDesign, formDesignMethods, formDesignPrivateMethods);
    const renderLayoutHeader = () => {
      return h("div", {
        class: "vxe-form-design--header-wrapper"
      }, [
        h("div", {
          class: "vxe-form-design--header-left"
        }),
        h("div", {
          class: "vxe-form-design--header-middle"
        }),
        h("div", {
          class: "vxe-form-design--header-right"
        }, [
          h(button_default, {
            mode: "text",
            status: "primary",
            icon: getIcon().FORM_DESIGN_STYLE_SETTING,
            content: getI18n("vxe.formDesign.styleSetting.btn"),
            onClick: openStylePreviewEvent
          })
        ])
      ]);
    };
    const renderVN = () => {
      const { height, showHeader } = props;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: "vxe-form-design",
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        showHeader || headerSlot ? h("div", {
          class: "vxe-form-design--header"
        }, headerSlot ? headerSlot({}) : renderLayoutHeader()) : createCommentVNode(),
        h("div", {
          class: "vxe-form-design--body"
        }, [
          h(layout_widget_default),
          h(layout_preview_default),
          h(layout_setting_default),
          h(layout_style_default, {
            ref: refLayoutStyle
          })
        ]),
        footerSlot ? h("div", {
          class: "vxe-form-design--footer"
        }, footerSlot ? footerSlot({}) : []) : createCommentVNode()
      ]);
    };
    $xeFormDesign.renderVN = renderVN;
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    updateWidgetConfigs();
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormDesign", $xeFormDesign);
    return $xeFormDesign;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/use/widget-name.js
var import_xe_utils49 = __toESM(require_xe_utils());
function useWidgetName(props) {
  const computeKebabCaseName = computed(() => {
    const { renderOpts } = props;
    return renderOpts ? import_xe_utils49.default.kebabCase(renderOpts.name) : "";
  });
  return {
    computeKebabCaseName
  };
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/use/widget-view.js
function useWidgetView(props) {
  const currWidget = computed(() => {
    const { renderParams } = props;
    return renderParams.widget;
  });
  const isEditMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isEditMode || false;
  });
  const isViewMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isViewMode || false;
  });
  const widgetOptions = computed(() => {
    const { renderParams } = props;
    const { widget } = renderParams;
    return widget ? widget.options : {};
  });
  const widgetModel = computed({
    get() {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      return $formView ? $formView.getItemValue(widget) : null;
    },
    set(value) {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      if ($formView) {
        $formView.setItemValue(widget, value);
      }
    }
  });
  return {
    currWidget,
    widgetOptions,
    widgetModel,
    isEditMode,
    isViewMode
  };
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/textarea/src/textarea.js
var import_xe_utils50 = __toESM(require_xe_utils());
var autoTxtElem;
var textarea_default = defineComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: { type: Boolean, default: true },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: { type: Boolean, default: true },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: { type: [String, Number], default: 2 },
    cols: { type: [String, Number], default: null },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: { type: String, default: () => getConfig().textarea.resize },
    size: { type: String, default: () => getConfig().textarea.size || getConfig().size },
    // 已废弃
    maxlength: [String, Number]
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils50.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refTextarea = ref();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = computed(() => {
      const { editable } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils50.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils50.default.toNumber(inpMaxLength);
    });
    const computeSizeOpts = computed(() => {
      return Object.assign({ minRows: 1, maxRows: 10 }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const { size, autosize } = props;
      const { inputValue } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? `size--${size}` : ""].join(" ");
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ("" + (inputValue || "　")).replace(/\n$/, "\n　");
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        nextTick(() => {
          const sizeOpts = computeSizeOpts.value;
          const { minRows, maxRows } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = import_xe_utils50.default.toNumber(textStyle.lineHeight);
          const paddingTop = import_xe_utils50.default.toNumber(textStyle.paddingTop);
          const paddingBottom = import_xe_utils50.default.toNumber(textStyle.paddingBottom);
          const borderTopWidth = import_xe_utils50.default.toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = import_xe_utils50.default.toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent = (evnt) => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    const emitUpdate = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils50.default.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const { immediate } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        emitUpdate(value, evnt);
      }
      $xeTextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    const changeEvent = (evnt) => {
      const { immediate } = props;
      if (immediate) {
        triggerEvent(evnt);
      } else {
        emitUpdate(reactData.inputValue, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { immediate } = props;
      const { inputValue } = reactData;
      if (!immediate) {
        emitUpdate(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $textarea: $xeTextarea }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return nextTick();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return nextTick();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    watch(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    nextTick(() => {
      const { autosize } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const { className, resize, autosize, showWordCount, countMethod, rows, cols } = props;
      const { inputValue } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-textarea--readonly", className]
        }, inputValue);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-textarea", className, {
          [`size--${vSize}`]: vSize,
          "is--autosize": autosize,
          "is--count": showWordCount,
          "is--disabled": isDisabled,
          "def--rows": !import_xe_utils50.default.eqNull(rows),
          "def--cols": !import_xe_utils50.default.eqNull(cols)
        }],
        spellcheck: false
      }, [
        h("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: inpPlaceholder,
          maxlength: inpMaxLength,
          readonly: inputReadonly,
          disabled: isDisabled,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent,
          onKeyup: triggerEvent,
          onClick: triggerEvent,
          onFocus: triggerEvent,
          onBlur: blurEvent
        }),
        showWordCount ? h("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : null
      ]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tip/src/tip.js
var import_xe_utils51 = __toESM(require_xe_utils());
var tip_default = defineComponent({
  name: "VxeTip",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: { type: String, default: () => getConfig().tip.size || getConfig().size }
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils51.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { status, content, icon, title } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tip", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "has--title": !!(titleSlot || title)
        }]
      }, [
        iconSlot || icon ? h("div", {
          class: "vxe-tip--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tip--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-tip--title"
          }, titleSlot ? getSlotVNs(titleSlot({})) : import_xe_utils51.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-tip--content"
          }, defaultSlot ? getSlotVNs(defaultSlot({})) : import_xe_utils51.default.toValueString(content))
        ])
      ]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/src/use/widget-prop-data-source.js
function useWidgetPropDataSource(props, renderConfig) {
  const renConf = Object.assign({}, renderConfig);
  const isSubOption = renConf.isSubOption;
  const optionsContent = ref("");
  const expandIndexList = ref([]);
  const addOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    options.push({
      value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [options.length + 1])
    });
    widget.options.options = [...options];
  };
  const subRE = /^(\s|\t)+/;
  const hasSubOption = (str) => {
    return subRE.test(str);
  };
  const expandAllOption = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    const indexList = [];
    options.forEach((group, gIndex) => {
      const { options: options2 } = group;
      if (options2 && options2.length) {
        indexList.push(gIndex);
      }
    });
    expandIndexList.value = indexList;
  };
  const toggleExpandOption = (item, gIndex) => {
    if (expandIndexList.value.includes(gIndex)) {
      expandIndexList.value = expandIndexList.value.filter((num) => num !== gIndex);
    } else {
      expandIndexList.value.push(gIndex);
    }
  };
  const removeOptionEvent = (item, group) => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    if (group) {
      if (group.options) {
        group.options = group.options.filter((obj) => obj !== item);
      }
    } else {
      options.options = options.options.filter((obj) => obj !== item);
    }
  };
  const confirmBatchAddOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const optList = [];
    const rowList = optionsContent.value.split("\n");
    let prevGroup = null;
    if (isSubOption) {
      rowList.forEach((str, index) => {
        const nextStr = rowList[index + 1];
        const value = str.trim();
        if (!value) {
          return;
        }
        const item = {
          value
        };
        if (prevGroup) {
          if (hasSubOption(str)) {
            prevGroup.options.push(item);
            return;
          }
          prevGroup = null;
          optList.push(item);
        } else {
          optList.push(item);
        }
        if (nextStr) {
          if (hasSubOption(nextStr)) {
            prevGroup = Object.assign(item, { options: [] });
          }
        }
      });
    } else {
      rowList.forEach((str) => {
        optList.push({
          value: str.trim()
        });
      });
    }
    widget.options.options = optList;
    expandAllOption();
  };
  const openPopupEditEvent = () => {
    var _a;
    const { renderParams } = props;
    const { widget } = renderParams;
    const contList = [];
    (_a = widget.options.options) === null || _a === void 0 ? void 0 : _a.forEach((group) => {
      var _a2;
      contList.push(group.value);
      (_a2 = group.options) === null || _a2 === void 0 ? void 0 : _a2.forEach((item) => {
        contList.push(`	${item.value}`);
      });
    });
    optionsContent.value = contList.join("\n");
    VxeUI.modal.open({
      title: `${widget.title} - ${getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption")}`,
      width: 500,
      height: "50vh ",
      resize: true,
      showFooter: true,
      showCancelButton: true,
      showConfirmButton: true,
      confirmButtonText: getI18n("vxe.formDesign.widgetProp.dataSource.buildOption"),
      onConfirm: confirmBatchAddOptionEvent,
      slots: {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-form-item-data-source-popup"
          }, [
            h(tip_default, {
              status: "primary",
              title: "",
              content: getI18n(`vxe.formDesign.widgetProp.dataSource.${isSubOption ? "batchEditSubTip" : "batchEditTip"}`)
            }),
            h(textarea_default, {
              resize: "none",
              modelValue: optionsContent.value,
              "onUpdate:modelValue"(val) {
                optionsContent.value = val;
              }
            })
          ]);
        }
      }
    });
  };
  const renderOption = (item, group, isExpand, gIndex, hasSub, isFirst, isLast) => {
    const hasFirstLevel = !group;
    return h("div", {
      class: ["vxe-form-design--widget-form-item-data-source-option", {
        "is--first": isFirst,
        "is--last": isLast
      }]
    }, [
      h("div", {
        class: "vxe-form-design--widget-expand-btn"
      }, hasFirstLevel && hasSub ? [
        h("i", {
          class: isExpand ? getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE : getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN,
          onClick() {
            toggleExpandOption(item, gIndex);
          }
        })
      ] : []),
      h("input", {
        class: "vxe-default-input",
        value: item.value,
        onInput(evnt) {
          item.value = evnt.target.value;
        }
      }),
      h(button_default, {
        status: "danger",
        mode: "text",
        icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
        onClick() {
          removeOptionEvent(item, group);
        }
      })
    ]);
  };
  const renderOptions = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    const groups = options.options;
    const optVNs = [];
    if (groups) {
      groups.forEach((group, gIndex) => {
        const { options: options2 } = group;
        const isExpand = expandIndexList.value.includes(gIndex);
        if (options2 && options2.length) {
          optVNs.push(renderOption(group, null, isExpand, gIndex, true, gIndex === 0, gIndex === groups.length - 1));
          if (isExpand) {
            optVNs.push(h("div", {
              class: "vxe-form-design--widget-form-item-data-source-sub-option"
            }, options2.map((item) => renderOption(item, group, isExpand, 0, false, false, false))));
          }
        } else {
          optVNs.push(renderOption(group, null, isExpand, gIndex, false, gIndex === 0, gIndex === groups.length - 1));
        }
      });
    }
    return optVNs;
  };
  watch(() => props.renderParams.widget, () => {
    expandAllOption();
  });
  onMounted(() => {
    expandAllOption();
  });
  const renderDataSourceFormItemContent = () => {
    return [
      h("div", {}, [
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.addOption"),
          onClick: addOptionEvent
        }),
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption"),
          onClick: openPopupEditEvent
        })
      ]),
      h("div", {
        class: "vxe-form-design--widget-form-item-data-source-wrapper"
      }, renderOptions())
    ];
  };
  return {
    renderDataSourceFormItem() {
      return h(form_item_default, {
        title: getI18n("vxe.formDesign.widgetProp.dataSource.name"),
        field: "options"
      }, {
        default() {
          return renderDataSourceFormItemContent();
        }
      });
    },
    renderDataSourceFormItemContent
  };
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/render/util.js
var getFormDesignWidgetName = (name) => {
  return getI18n(`vxe.formDesign.widget.component.${name}`);
};
var handleGetFormDesignWidgetName = (params) => {
  return getFormDesignWidgetName(params.name);
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-text/text-data.js
var getWidgetTextConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-text",
    group: "layout",
    options: {
      color: "",
      align: "",
      bold: false,
      fontSize: ""
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-text/text-form.js
var import_xe_utils52 = __toESM(require_xe_utils());
var getFontSizeOptions = () => {
  return import_xe_utils52.default.range(12, 27).map((num) => {
    return { label: `${num}px`, value: `${num}px` };
  });
};
var getAlignOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignCenter"), value: "center" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignRight"), value: "right" }
  ];
};
var getBoldOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontBold"), value: true }
  ];
};
var WidgetTextFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const alignOpts = ref(getAlignOptions2());
    const boldOpts = ref(getBoldOptions2());
    const fontSizeOpts = ref(getFontSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.boldTitle"),
              field: "bold",
              itemRender: { name: "VxeRadioGroup", options: boldOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.alignTitle"),
              field: "align",
              itemRender: { name: "VxeRadioGroup", options: alignOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.sizeTitle"),
              field: "fontSize",
              itemRender: { name: "VxeSelect", options: fontSizeOpts.value }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-text/text-view.js
var WidgetTextViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        align: options.align
      }, {
        default() {
          return h("div", {
            style: {
              fontSize: options.fontSize,
              fontWeight: options.bold ? "bold" : ""
            }
          }, widget.title);
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-row/row-data.js
var import_xe_utils53 = __toESM(require_xe_utils());
var getWidgetRowConfig = (params) => {
  const { $formDesign } = params;
  const defaultColSize = 2;
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-row-col",
    options: {
      colSize: defaultColSize,
      colSpan: "12,12"
    },
    children: $formDesign ? import_xe_utils53.default.range(0, defaultColSize).map(() => {
      return $formDesign.createEmptyWidget();
    }) : []
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/row/src/row.js
var import_xe_utils54 = __toESM(require_xe_utils());
var row_default = defineComponent({
  name: "VxeRow",
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils54.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = computed(() => {
      const { gutter, vertical } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = import_xe_utils54.default.isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const offsetSize = import_xe_utils54.default.isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = import_xe_utils54.default.isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleDefaultEvent = (evnt) => {
      emit(evnt.type, createEvent(evnt, { $row: $xeRow }));
    };
    const renderVN = () => {
      const { vertical, wrap } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-row", {
          "is--vertical": vertical,
          "is--wrap": wrap
        }],
        style: rowStyle,
        onClick: handleDefaultEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeRow.renderVN = renderVN;
    provide("$xeRow", $xeRow);
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-row/row-form.js
var import_xe_utils55 = __toESM(require_xe_utils());
var WidgetRowFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    const spanOptions = ref([
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col3"),
        value: 2,
        list: [
          { value: "12,12", spans: [12, 12] },
          { value: "8,16", spans: [8, 16] },
          { value: "16,8", spans: [16, 8] },
          { value: "6,18", spans: [6, 18] },
          { value: "18,6", spans: [18, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col3"),
        value: 3,
        list: [
          { value: "8,8,8", spans: [8, 8, 8] },
          { value: "6,6,12", spans: [6, 6, 12] },
          { value: "12,6,6", spans: [12, 6, 6] },
          { value: "6,12,6", spans: [6, 12, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col4"),
        value: 4,
        list: [
          { value: "6,6,6,6", spans: [6, 6, 6, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col6"),
        value: 6,
        list: [
          { value: "4,4,4,4,4,4", spans: [4, 4, 4, 4, 4, 4] }
        ]
      }
    ]);
    const labelMaps = {
      18: "3/4",
      16: "2/3",
      12: "1/2",
      8: "1/3",
      6: "1/4",
      4: "1/6"
    };
    const computeSelectSpanItem = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      return spanOptions.value.find((item) => item.value === options.colSize);
    });
    const changeColSpan = (item) => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      options.colSpan = item.value;
      widget.children = import_xe_utils55.default.range(0, options.colSize).map(() => {
        return $xeFormDesign.createEmptyWidget();
      });
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.colSize"),
              field: "colSize",
              itemRender: { name: "VxeRadioGroup", options: spanOptions.value, props: { type: "button" } }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.layout")
            }, {
              default() {
                const selectSpanItem = computeSelectSpanItem.value;
                if (selectSpanItem) {
                  return selectSpanItem.list.map((item, rIndex) => {
                    return h(row_default, {
                      key: rIndex,
                      class: [`vxe-form-design--widget-${kebabCaseName}-form-row`, {
                        "is--active": item.value === widget.options.colSpan
                      }],
                      onClick() {
                        changeColSpan(item);
                      }
                    }, {
                      default() {
                        return item.spans.map((span, sIndex) => {
                          return h(col_default, {
                            key: `${rIndex}${sIndex}`,
                            class: `vxe-form-design--widget-${kebabCaseName}-form-col`,
                            span
                          }, {
                            default() {
                              return h("div", {}, `${labelMaps[span]}`);
                            }
                          });
                        });
                      }
                    });
                  });
                }
                return [];
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-row/row-view.js
var import_xe_utils56 = __toESM(require_xe_utils());
var ViewColItemComponent = defineComponent({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    span: Number,
    colItemIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const handleDragoverColItem = (evnt) => {
      const { parentWidget, colItemIndex } = props;
      const { widgetObjList, sortWidget } = formDesignReactData;
      const currWidget = parentWidget.children[colItemIndex];
      evnt.stopPropagation();
      if (sortWidget && parentWidget && sortWidget.id !== parentWidget.id) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if ((!currWidget || !currWidget.name) && !hasFormDesignLayoutType(currWidget)) {
          const rest = import_xe_utils56.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
          if (rest) {
            const { item, index, items } = rest;
            if (!parentWidget.children.length) {
              parentWidget.children = import_xe_utils56.default.range(0, parentWidget.options.colSize).map(() => {
                return $xeFormDesign.createEmptyWidget();
              });
            }
            parentWidget.children[colItemIndex] = item;
            items.splice(index, 1);
            $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
          }
        }
      }
    };
    return () => {
      const { widget, span } = props;
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      return h(form_item_default, {
        span,
        padding: false
      }, {
        default() {
          const name = widget ? widget.name : "";
          const compConf = renderer.get(name) || {};
          const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
          const renderOpts = widget || { name };
          const params = { widget, readonly: false, disabled: false, isEditMode: true, isViewMode: false, $formDesign: $xeFormDesign, $formView: null };
          const isActive = activeWidget && widget && activeWidget.id === widget.id;
          return h("div", {
            class: ["vxe-form-design--widget-row-view", {
              "is--active": isActive,
              "is--sort": sortWidget && widget && sortWidget.id === widget.id,
              "is--drag": dragWidget && widget && dragWidget.id === widget.id
            }],
            "data-widget-id": widget.id,
            onDragover: handleDragoverColItem,
            onClick(evnt) {
              if (widget) {
                $xeFormDesign.handleClickWidget(evnt, widget);
              }
            }
          }, [
            renderWidgetDesignView ? h("div", {
              class: "vxe-form-design--widget-row-view-item-wrapper"
            }, [
              h("div", {
                class: "vxe-form-design--widget-row-view-item-box vxe-form--item-row"
              }, getSlotVNs(renderWidgetDesignView(renderOpts, params))),
              isActive ? h("div", {
                class: "vxe-form-design--preview-item-operate"
              }, [
                h(button_default, {
                  icon: getIcon().FORM_DESIGN_WIDGET_COPY,
                  status: "primary",
                  size: "mini",
                  circle: true,
                  onClick(params2) {
                    $xeFormDesign.handleCopyWidget(params2.$event, widget);
                  }
                }),
                h(button_default, {
                  icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
                  status: "danger",
                  size: "mini",
                  circle: true,
                  onClick(params2) {
                    $xeFormDesign.handleRemoveWidget(params2.$event, widget);
                  }
                })
              ]) : createCommentVNode()
            ]) : h("div", {
              class: "vxe-form-design--widget-row-view-empty"
            }, "控件位置")
          ]);
        }
      });
    };
  }
});
var WidgetRowEditComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      return h(form_gather_default, {}, {
        default() {
          const colObjList = computedColObjList.value;
          return colObjList.map((span, colItemIndex) => {
            return h(ViewColItemComponent, {
              key: colItemIndex,
              parentWidget: widget,
              widget: widget.children[colItemIndex],
              span,
              colItemIndex
            });
          });
        }
      });
    };
  }
});
var WidgetRowViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const colObjList = computedColObjList.value;
      return h(row_default, {}, {
        default() {
          return colObjList.map((span, colItemIndex) => {
            return h(col_default, {
              key: colItemIndex,
              class: "vxe-form--item-row",
              span
            }, {
              default() {
                const subWidget = widget.children[colItemIndex];
                if (subWidget) {
                  const { name } = subWidget;
                  const compConf = renderer.get(name) || {};
                  const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                  const renderOpts = subWidget;
                  const isEditMode = !!$xeFormDesign;
                  const params = { widget: subWidget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
                  if (renderWidgetDesignView) {
                    return getSlotVNs(renderWidgetDesignView(renderOpts, params));
                  }
                }
                return createCommentVNode();
              }
            });
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-data.js
var getWidgetSubtableConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-subtable",
    options: {
      showCheckbox: false
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-form.js
var WidgetSubtableFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.subtableProp.showCheckbox"),
              field: "showCheckbox"
            }, {
              default() {
                return h(switch_default, {
                  modelValue: options.showCheckbox,
                  "onUpdate:modelValue"(val) {
                    options.showCheckbox = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-view.js
var import_xe_utils57 = __toESM(require_xe_utils());
var ViewSubItemComponent = defineComponent({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartEvent = (evnt) => {
      evnt.stopPropagation();
      const { widgetObjList } = formDesignReactData;
      const divEl = evnt.currentTarget;
      const widgetId = Number(divEl.getAttribute("data-widget-id"));
      const currRest = import_xe_utils57.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
      if (currRest) {
        formDesignReactData.dragWidget = null;
        formDesignReactData.sortSubWidget = currRest.item;
        formDesignReactData.sortSubWidget = currRest.item;
      }
    };
    const sortDragendEvent = (evnt) => {
      evnt.stopPropagation();
      formDesignReactData.activeWidget = formDesignReactData.sortSubWidget;
      formDesignReactData.sortWidget = null;
    };
    let isDragAnimate = false;
    const sortDragenterEvent = (evnt) => {
      const { sortSubWidget } = formDesignReactData;
      if (sortSubWidget) {
        evnt.stopPropagation();
      }
      if (isDragAnimate) {
        evnt.preventDefault();
        return;
      }
      const { widget, parentWidget } = props;
      if (parentWidget && widget && sortSubWidget && widget.id !== sortSubWidget.id) {
        evnt.preventDefault();
        const subList = parentWidget.children.map((item) => item);
        if (!subList.length) {
          parentWidget.children.push(sortSubWidget);
          isDragAnimate = false;
          return;
        }
        const targetIndex = import_xe_utils57.default.findIndexOf(subList, (item) => item.id === widget.id);
        if (targetIndex > -1) {
          const sortIndex = import_xe_utils57.default.findIndexOf(subList, (item) => item.id === sortSubWidget.id);
          if (sortIndex > -1) {
            subList[sortIndex] = widget;
            subList[targetIndex] = sortSubWidget;
            parentWidget.children = subList;
            isDragAnimate = true;
            $xeFormDesign.dispatchEvent("drag-widget", { widget: sortSubWidget }, evnt);
            setTimeout(() => {
              isDragAnimate = false;
            }, 150);
          }
        }
      }
    };
    const handleDragoverSubItem = (evnt) => {
      const { sortSubWidget } = formDesignReactData;
      if (sortSubWidget) {
        evnt.preventDefault();
      }
    };
    const handleClickEvent = (evnt) => {
      const { widget } = props;
      if (widget) {
        formDesignReactData.sortSubWidget = widget;
        $xeFormDesign.handleClickWidget(evnt, widget);
      }
    };
    return () => {
      const { widget } = props;
      const { dragWidget, activeWidget, sortSubWidget } = formDesignReactData;
      const name = widget ? widget.name : "";
      const compConf = renderer.get(name) || {};
      const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
      const renderOpts = widget || { name };
      const isEditMode = !!$xeFormDesign;
      const params = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
      const isActive = activeWidget && widget && activeWidget.id === widget.id;
      return h("div", {
        class: ["vxe-form-design--widget-subtable-view-item", {
          "is--active": isActive,
          "is--sort": sortSubWidget && widget && sortSubWidget.id === widget.id,
          "is--drag": dragWidget && widget && dragWidget.id === widget.id
        }],
        draggable: true,
        "data-widget-id": widget.id,
        onDragstart: sortDragstartEvent,
        onDragend: sortDragendEvent,
        onDragenter: sortDragenterEvent,
        onDragover: handleDragoverSubItem,
        onClick: handleClickEvent
      }, [
        h("div", {
          class: "vxe-form-design--widget-subtable-view-item-wrapper"
        }, [
          h("div", {
            class: "vxe-form-design--widget-subtable-view-item-box vxe-form--item-row"
          }, renderWidgetDesignView ? getSlotVNs(renderWidgetDesignView(renderOpts, params)) : []),
          isActive ? h("div", {
            class: "vxe-form-design--preview-item-operate"
          }, [
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_COPY,
              status: "primary",
              size: "mini",
              circle: true,
              onClick(params2) {
                $xeFormDesign.handleCopyWidget(params2.$event, widget);
              }
            }),
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
              status: "danger",
              size: "mini",
              circle: true,
              onClick(params2) {
                $xeFormDesign.handleRemoveWidget(params2.$event, widget);
              }
            })
          ]) : createCommentVNode()
        ])
      ]);
    };
  }
});
var WidgetSubtableEditComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const onDragoverEmptyWrapper = (evnt) => {
      const { sortWidget, widgetObjList } = formDesignReactData;
      const { renderParams } = props;
      const { widget } = renderParams;
      evnt.stopPropagation();
      if (!sortWidget || !widget || widget.id === sortWidget.id) {
        return;
      }
      if (hasFormDesignLayoutType(sortWidget)) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            content: getI18n("vxe.formDesign.widgetProp.subtableProp.errSubDrag"),
            status: "error",
            id: "errSubDrag"
          });
        }
        return;
      }
      if (widget.name && !widget.children.some((item) => item.id === sortWidget.id)) {
        const rest = import_xe_utils57.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (rest) {
          const { item, index, items } = rest;
          formDesignReactData.sortWidget = null;
          formDesignReactData.sortSubWidget = item;
          formDesignReactData.activeWidget = item;
          widget.children.push(item);
          items.splice(index, 1);
        }
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { title, children, options } = widget;
      const { showCheckbox } = options;
      return h(form_item_default, {
        title,
        className: "vxe-form-design--widget-subtable-form-item"
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-subtable-view"
          }, [
            h("div", {
              class: "vxe-form-design--widget-subtable-view-left"
            }, [
              showCheckbox ? h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, [
                  h(checkbox_default)
                ]),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, [
                  h(checkbox_default)
                ])
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, getI18n("vxe.formDesign.widgetProp.subtableProp.seqTitle")),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, "1")
              ])
            ]),
            h("div", {
              class: "vxe-form-design--widget-subtable-view-right"
            }, [
              h("div", {
                class: "vxe-form-design--widget-subtable-view-wrapper"
              }, [
                h(TransitionGroup, {
                  class: "vxe-form-design--widget-subtable-view-list",
                  tag: "div",
                  name: "vxe-form-design--widget-subtable-view-list"
                }, {
                  default: () => {
                    return children.map((childWidget) => {
                      return h(ViewSubItemComponent, {
                        key: childWidget.id,
                        parentWidget: widget,
                        widget: childWidget
                      });
                    });
                  }
                }),
                h("div", {
                  key: "empty",
                  class: "vxe-form-design--widget-subtable-view-empty",
                  onDragover: onDragoverEmptyWrapper
                }, "将控件拖拽进来")
              ])
            ])
          ]);
        }
      });
    };
  }
});
var WidgetSubtableViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const computeSubtableColumns = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { children, options } = widget;
      const columns = [];
      if (options.showCheckbox) {
        columns.push({
          type: "checkbox",
          width: 60
        });
      }
      columns.push({
        type: "seq",
        width: 60
      });
      if (children) {
        children.forEach((childWidget) => {
          columns.push({
            field: childWidget.field,
            title: childWidget.title
          });
        });
      }
      return columns;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      const subtableColumns = computeSubtableColumns.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        span: 24,
        padding: false
      }, {
        default() {
          return VxeTableGridComponent ? h(VxeTableGridComponent, {
            border: true,
            columnConfig: {
              resizable: true
            },
            data: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            columns: subtableColumns
          }) : createCommentVNode();
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-input/input-data.js
var getWidgetInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-input/input-form.js
var WidgetInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-input/input-view.js
var WidgetInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("input", {
            class: "vxe-default-input",
            type: "text",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-data.js
var getWidgetTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-form.js
var WidgetTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-view.js
var WidgetTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h("textarea", {
            class: "vxe-default-textarea",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-select/select-data.js
var import_xe_utils58 = __toESM(require_xe_utils());
var getWidgetSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      options: import_xe_utils58.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-select/select-form.js
var WidgetSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: true
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-select/select-view.js
var WidgetSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    const renderOptions = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget.options;
      return options ? options.map((group) => {
        if (group.options) {
          return h("optgroup", {
            label: group.value
          }, group.options.map((item) => {
            return h("option", {
              value: item.value
            }, item.value);
          }));
        }
        return h("option", {}, group.value);
      }) : [];
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("select", {
            class: "vxe-default-select",
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent
          }, isViewMode ? renderOptions() : []);
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-data.js
var getWidgetVxeInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-form.js
var WidgetVxeInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-view.js
var WidgetVxeInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-data.js
var getWidgetVxeNumberInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-number",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-form.js
var WidgetVxeNumberInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/number-input/src/number-input.js
var import_xe_utils59 = __toESM(require_xe_utils());
function handleNumber2(val) {
  return import_xe_utils59.default.isString(val) ? val.replace(/,/g, "") : val;
}
function toFloatValueFixed2(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return import_xe_utils59.default.toFixed(import_xe_utils59.default.ceil(inputValue, digitsValue), digitsValue);
  }
  return import_xe_utils59.default.toFixed(import_xe_utils59.default.floor(inputValue, digitsValue), digitsValue);
}
var number_input_default = defineComponent({
  name: "VxeNumberInput",
  props: {
    modelValue: [String, Number],
    immediate: { type: Boolean, default: true },
    name: String,
    type: { type: String, default: "number" },
    clearable: { type: Boolean, default: () => getConfig().numberInput.clearable },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: { type: String, default: () => getConfig().numberInput.size || getConfig().size },
    multiple: Boolean,
    // number、integer、float
    min: { type: [String, Number], default: null },
    max: { type: [String, Number], default: null },
    step: [String, Number],
    exponential: { type: Boolean, default: () => getConfig().numberInput.exponential },
    // number、integer、float
    controls: { type: Boolean, default: () => getConfig().numberInput.controls },
    // float
    digits: { type: [String, Number], default: () => getConfig().numberInput.digits },
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils59.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsNumType = computed(() => {
      return true;
    });
    const computeDigitsValue = computed(() => {
      return import_xe_utils59.default.toInteger(props.digits) || 1;
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils59.default.toInteger(step) || 1;
      } else if (type === "float") {
        return import_xe_utils59.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils59.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInputReadonly = computed(() => {
      const { multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().numberInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxlength = computed(() => {
      const { maxLength, maxlength } = props;
      return import_xe_utils59.default.toNumber(maxLength || maxlength) || 16;
    });
    const computeInpImmediate = computed(() => {
      const { type, immediate } = props;
      return immediate || !(type === "number" || type === "integer" || type === "float");
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === "integer" ? import_xe_utils59.default.toInteger(handleNumber2(inputValue)) : import_xe_utils59.default.toNumber(handleNumber2(inputValue));
      }
      return 0;
    });
    const computeNumLabel = computed(() => {
      const { inputValue } = reactData;
      return import_xe_utils59.default.toString(inputValue);
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= import_xe_utils59.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= import_xe_utils59.default.toNumber(max);
      }
      return false;
    });
    const getNumberValue = (val) => {
      const { type, exponential } = props;
      const inpMaxlength = computeInpMaxlength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === "float" ? toFloatValueFixed2(val, digitsValue) : import_xe_utils59.default.toValueString(val);
      if (exponential && (val === restVal || import_xe_utils59.default.toValueString(val).toLowerCase() === import_xe_utils59.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxlength);
    };
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitModel = (value, inputValue, evnt) => {
      const isChange = Number(value) !== props.modelValue;
      if (isChange) {
        reactData.inputValue = inputValue || "";
        emit("update:modelValue", value ? Number(value) : null);
      }
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (isChange) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (inputValue, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? import_xe_utils59.default.toNumber(inputValue) : null;
      reactData.inputValue = inputValue;
      if (inpImmediate) {
        emitModel(value, inputValue, evnt);
      } else {
        inputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      emitModel(null, "", evnt);
      inputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const initValue = () => {
      const { type } = props;
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      if (type === "float") {
        if (inputValue) {
          let textValue = "";
          let validValue = null;
          if (inputValue) {
            textValue = toFloatValueFixed2(inputValue, digitsValue);
            validValue = Number(textValue);
          }
          if (inputValue !== validValue) {
            emitModel(validValue, textValue, { type: "init" });
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || import_xe_utils59.default.toNumber(num) <= import_xe_utils59.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || import_xe_utils59.default.toNumber(num) >= import_xe_utils59.default.toNumber(props.min);
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue } = reactData;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (inputValue) {
          let inpNumVal = type === "integer" ? import_xe_utils59.default.toInteger(handleNumber2(inputValue)) : import_xe_utils59.default.toNumber(handleNumber2(inputValue));
          if (!validMinNum(inpNumVal)) {
            inpNumVal = min;
          } else if (!validMaxNum(inpNumVal)) {
            inpNumVal = max;
          }
          if (exponential) {
            const inpStringVal = import_xe_utils59.default.toValueString(inputValue).toLowerCase();
            if (inpStringVal === import_xe_utils59.default.toNumber(inpNumVal).toExponential()) {
              inpNumVal = inpStringVal;
            }
          }
          const inpValue = getNumberValue(inpNumVal);
          emitModel(inpValue === null ? null : Number(inpValue), inpValue, { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? Number(inputValue) : null;
      if (!inpImmediate) {
        emitModel(value, `${inputValue || ""}`, evnt);
      }
      afterCheckValue();
      reactData.isActivated = false;
      inputMethods.dispatchEvent("blur", { value }, evnt);
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils59.default.toInteger(handleNumber2(inputValue)) : import_xe_utils59.default.toNumber(handleNumber2(inputValue));
      const newValue = isPlus ? import_xe_utils59.default.add(numValue, stepValue) : import_xe_utils59.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    let downbumTimeout;
    const numberNextEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !formReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", {}, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!isDisabled && !formReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", {}, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const numberStopDown = () => {
      clearTimeout(downbumTimeout);
    };
    const numberDownPrevEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { isActivated } = reactData;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          afterCheckValue();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        }
        if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated } = reactData;
      if (isActivated) {
        afterCheckValue();
      }
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("div", {
        class: "vxe-input--control-icon"
      }, [
        h("div", {
          class: "vxe-input--number-icon"
        }, [
          h("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": isDisabledAddNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_PREV_NUM
            })
          ]),
          h("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": isDisabledSubtractNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-number-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-number-input--prefix-icon"
        }, prefixSlot ? getSlotVNs(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-number-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils59.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-number-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-number-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]);
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      if (controls) {
        return renderNumberIcon();
      }
      return createCommentVNode();
    };
    inputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $input: $xeInput }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeInput, inputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue
      });
      initValue();
    });
    nextTick(() => {
      globalEvents.on($xeInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeInput, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      numberStopDown();
      globalEvents.off($xeInput, "mousedown");
      globalEvents.off($xeInput, "keydown");
      globalEvents.off($xeInput, "blur");
    });
    initValue();
    const renderVN = () => {
      const { className, controls, type, align, name, autocomplete, autoComplete } = props;
      const { inputValue, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const numLabel = computeNumLabel.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-number-input--readonly", `type--${type}`, className]
        }, numLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const inpMaxlength = computeInpMaxlength.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-number-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils59.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-number-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-number-input--inner",
            value: inputValue,
            name,
            type: "text",
            placeholder: inpPlaceholder,
            maxlength: inpMaxlength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode()
      ]);
    };
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-view.js
var WidgetVxeNumberInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(number_input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-data.js
var getWidgetVxeDatePickerConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-calendar",
    options: {
      placeholder: "",
      defaultValue: {
        type: "",
        value: ""
      }
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-form.js
var WidgetVxeDatePickerFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            // renderDefaultValueFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-view.js
var WidgetVxeDatePickerViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(date_picker_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-data.js
var getWidgetVxeTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    options: {
      placeholder: ""
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-form.js
var WidgetVxeTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-view.js
var WidgetVxeTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(textarea_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            resize: "node",
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-data.js
var getWidgetVxeSwitchConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-switch",
    query: true,
    options: {}
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-form.js
var WidgetVxeSwitchFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-view.js
var WidgetVxeSwitchViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(switch_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-data.js
var import_xe_utils60 = __toESM(require_xe_utils());
var getWidgetVxeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils60.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-form.js
var WidgetVxeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            renderDataSourceFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-view.js
var WidgetVxeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: isViewMode ? options.options : [],
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-data.js
var import_xe_utils61 = __toESM(require_xe_utils());
var getWidgetVxeTreeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-tree-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils61.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-form.js
var WidgetVxeTreeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
var import_xe_utils63 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tree/src/tree.js
var import_xe_utils62 = __toESM(require_xe_utils());
function getNodeUniqueId() {
  return import_xe_utils62.default.uniqueId("node_");
}
var tree_default = defineComponent({
  name: "VxeTree",
  props: {
    data: Array,
    height: [String, Number],
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    // mapChildrenField: {
    //   type: String as PropType<VxeTreePropTypes.MapChildrenField>,
    //   default: () => getConfig().tree.mapChildrenField
    // },
    transform: Boolean,
    // 已废弃
    isCurrent: Boolean,
    // 已废弃
    isHover: Boolean,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    size: { type: String, default: () => getConfig().tree.size || getConfig().size }
  },
  emits: [
    "update:modelValue",
    "update:checkNodeKey",
    "update:checkNodeKeys",
    "node-click",
    "node-dblclick",
    "current-change",
    "radio-change",
    "checkbox-change",
    "load-success",
    "load-error"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils62.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      currentNode: null,
      nodeMaps: {},
      selectRadioKey: props.checkNodeKey,
      treeList: [],
      treeExpandedMaps: {},
      treeExpandLazyLoadedMaps: {},
      selectCheckboxMaps: {},
      indeterminateCheckboxMaps: {}
    });
    const internalData = {};
    const refMaps = {
      refElem
    };
    const computeTitleField = computed(() => {
      return props.titleField || "title";
    });
    const computeKeyField = computed(() => {
      return props.keyField || "id";
    });
    const computeValueField = computed(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = computed(() => {
      return props.parentField || "parentId";
    });
    const computeChildrenField = computed(() => {
      return props.childrenField || "children";
    });
    const computeHasChildField = computed(() => {
      return props.hasChildField || "hasChild";
    });
    const computeIsRowCurrent = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isCurrent } = nodeOpts;
      if (import_xe_utils62.default.isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isHover } = nodeOpts;
      if (import_xe_utils62.default.isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = computed(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = computed(() => {
      const { height, minHeight } = props;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (minHeight) {
        stys.minHeight = toCssUnit(minHeight);
      }
      return stys;
    });
    const computeMaps = {
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = (node) => {
      const valueField = computeValueField.value;
      const nodeid = import_xe_utils62.default.get(node, valueField);
      return import_xe_utils62.default.eqNull(nodeid) ? "" : encodeURIComponent(nodeid);
    };
    const isExpandByNode = (node) => {
      const { treeExpandedMaps } = reactData;
      const nodeid = getNodeId(node);
      return !!treeExpandedMaps[nodeid];
    };
    const isCheckedByRadioNodeId = (nodeid) => {
      const { selectRadioKey } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = (node) => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = (nodeid) => {
      const { selectCheckboxMaps } = reactData;
      return !!selectCheckboxMaps[nodeid];
    };
    const isCheckedByCheckboxNode = (node) => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = (nodeid) => {
      const { indeterminateCheckboxMaps } = reactData;
      return !!indeterminateCheckboxMaps[nodeid];
    };
    const isIndeterminateByCheckboxNode = (node) => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = (value) => {
      emit("update:checkNodeKeys", value);
    };
    const emitRadioMode = (value) => {
      emit("update:checkNodeKey", value);
    };
    const setRadioNode = (node, checked) => {
      if (node) {
        reactData.selectRadioKey = checked ? getNodeId(node) : null;
      }
      return nextTick();
    };
    const setCheckboxNode = (nodeList, checked) => {
      if (nodeList) {
        if (!import_xe_utils62.default.isArray(nodeList)) {
          nodeList = [nodeList];
        }
        handleCheckedCheckboxNode(nodeList.map((item) => getNodeId(item)), checked);
      }
      return nextTick();
    };
    const setCheckboxByNodeId = (nodeIds, checked) => {
      if (nodeIds) {
        if (!import_xe_utils62.default.isArray(nodeIds)) {
          nodeIds = [nodeIds];
        }
        handleCheckedCheckboxNode(nodeIds, checked);
      }
      return nextTick();
    };
    const handleCheckedCheckboxNode = (nodeIds, checked) => {
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      nodeIds.forEach((key) => {
        if (checked) {
          selectKeyMaps[key] = true;
        } else if (selectKeyMaps[key]) {
          delete selectKeyMaps[key];
        }
      });
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const updateCheckboxChecked = (nodeIds) => {
      const selectKeyMaps = {};
      if (nodeIds) {
        nodeIds.forEach((key) => {
          selectKeyMaps[key] = true;
        });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tree: $xeTree }, params));
    };
    const createNode = (records) => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map((obj) => {
        const item = Object.assign({}, obj);
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils62.default.set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const treeMethods = {
      dispatchEvent: dispatchEvent2,
      clearRadioNode() {
        reactData.selectRadioKey = null;
        return nextTick();
      },
      setRadioNode,
      setCheckboxNode,
      setCheckboxByNodeId,
      clearCheckboxNode() {
        reactData.selectCheckboxMaps = {};
        return nextTick();
      },
      setAllCheckboxNode(checked) {
        const selectMaps = Object.assign(reactData.selectCheckboxMaps);
        const childrenField = computeChildrenField.value;
        if (checked) {
          import_xe_utils62.default.eachTree(reactData.treeList, (node) => {
            const nodeid = getNodeId(node);
            selectMaps[nodeid] = true;
          }, { children: childrenField });
        }
        reactData.selectCheckboxMaps = selectMaps;
        return nextTick();
      },
      clearExpandNode() {
        import_xe_utils62.default.each(reactData.nodeMaps, (nodeItem) => {
          nodeItem.treeLoaded = false;
        });
        reactData.treeExpandedMaps = {};
        return nextTick();
      },
      setExpandByNodeId(nodeids, expanded) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils62.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      setExpandNode(nodes, expanded) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils62.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandByNodeId(nodeids) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils62.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandNode(nodes) {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils62.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      setAllExpandNode() {
        const expandedMaps = Object.assign(reactData.treeExpandedMaps);
        const childrenField = computeChildrenField.value;
        import_xe_utils62.default.eachTree(reactData.treeList, (node) => {
          const nodeid = getNodeId(node);
          expandedMaps[nodeid] = true;
        }, { children: childrenField });
        reactData.treeExpandedMaps = expandedMaps;
        return nextTick();
      },
      reloadExpandNode(node) {
        const { lazy } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return nextTick();
      },
      clearExpandLoaded(node) {
        const { lazy } = props;
        const { nodeMaps } = reactData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return nextTick();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadChildrenNode(node, childRecords) {
        const { lazy, transform } = props;
        const { nodeMaps } = reactData;
        if (!lazy) {
          return nextTick();
        }
        const childrenField = computeChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then((nodeList) => {
          import_xe_utils62.default.eachTree(nodeList, (childRow, index, items, path, parent, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: node,
              itemIndex: -1,
              items,
              parent: parent || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              lineCount: 0,
              treeLoaded: false
            };
          }, { children: childrenField });
          node[childrenField] = nodeList;
          if (transform) {
            node[childrenField] = nodeList;
          }
          updateNodeLine(node);
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode
    };
    const cacheNodeMap = () => {
      const { treeList } = reactData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      import_xe_utils62.default.eachTree(treeList, (item, itemIndex, items, path, parent, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils62.default.set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          itemIndex,
          items,
          parent,
          nodes,
          level: nodes.length,
          lineCount: 0,
          treeLoaded: false
        };
      }, { children: childrenField });
      reactData.nodeMaps = keyMaps;
    };
    const updateData = (list) => {
      const { transform } = props;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      if (transform) {
        reactData.treeList = import_xe_utils62.default.toArrayTree(list, { key: keyField, parentKey: parentField, mapChildren: childrenField });
      } else {
        reactData.treeList = list ? list.slice(0) : [];
      }
      cacheNodeMap();
    };
    const handleCountLine = (item, isRoot, nodeItem) => {
      const { treeExpandedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(item);
      nodeItem.lineCount++;
      if (treeExpandedMaps[nodeid]) {
        import_xe_utils62.default.arrayEach(item[childrenField], (childItem, childIndex, childList) => {
          if (!isRoot || childIndex < childList.length - 1) {
            handleCountLine(childItem, false, nodeItem);
          }
        });
      }
    };
    const updateNodeLine = (node) => {
      const { nodeMaps } = reactData;
      if (node) {
        const nodeid = getNodeId(node);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          import_xe_utils62.default.lastArrayEach(nodeItem.nodes, (childItem) => {
            const nodeid2 = getNodeId(childItem);
            const nodeItem2 = nodeMaps[nodeid2];
            if (nodeItem2) {
              nodeItem2.lineCount = 0;
              handleCountLine(childItem, true, nodeItem2);
            }
          });
        }
      }
    };
    const handleNodeClickEvent = (evnt, node) => {
      const { showRadio, showCheckbox, trigger } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === "node") {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === "node") {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === "node") {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent2("node-click", { node, triggerCurrent, triggerRadio, triggerCheckbox, triggerExpand }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent2("node-dblclick", { node }, evnt);
    };
    const handleAsyncTreeExpandChilds = (node) => {
      const checkboxOpts = computeCheckboxOpts.value;
      const { loadMethod } = props;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { treeExpandLazyLoadedMaps } = reactData;
          const { nodeMaps } = reactData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          treeExpandLazyLoadedMaps[nodeid] = true;
          Promise.resolve(loadMethod({ $tree: $xeTree, node })).then((childRecords) => {
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              delete treeExpandLazyLoadedMaps[nodeid];
            }
            if (!import_xe_utils62.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return treeMethods.loadChildrenNode(node, childRecords).then((childRows) => {
                const { treeExpandedMaps } = reactData;
                if (childRows.length && !treeExpandedMaps[nodeid]) {
                  treeExpandedMaps[nodeid] = true;
                }
                if (!checkStrictly && treeMethods.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows.map((item) => getNodeId(item)), true);
                }
                updateNodeLine(node);
                dispatchEvent2("load-success", { node, data: childRecords }, new Event("load-success"));
                return nextTick();
              });
            } else {
              updateNodeLine(node);
              dispatchEvent2("load-success", { node, data: childRecords }, new Event("load-success"));
            }
          }).catch((e) => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = reactData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps2[nodeid]) {
              delete treeExpandLazyLoadedMaps2[nodeid];
            }
            updateNodeLine(node);
            dispatchEvent2("load-error", { node, data: e }, new Event("load-error"));
          }).finally(() => {
            return nextTick();
          });
        } else {
          resolve();
        }
      });
    };
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const { lazy, accordion, toggleMethod } = props;
      const { nodeMaps, treeExpandLazyLoadedMaps } = reactData;
      const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter((node) => toggleMethod({ $tree: $xeTree, expanded, node })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach((item) => {
            const itemNodeId = getNodeId(item);
            if (tempExpandedMaps[itemNodeId]) {
              delete tempExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (!tempExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                tempExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (tempExpandedMaps[itemNodeId]) {
            delete tempExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.treeExpandedMaps = tempExpandedMaps;
      expandNodes.forEach(updateNodeLine);
      return Promise.all(result);
    };
    const toggleExpandEvent = (evnt, node) => {
      const { lazy } = props;
      const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const handleNodeCheckboxStatus = (node, selectKeyMaps, indeterminateMaps) => {
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils62.default.get(node, childrenField);
      const nodeid = getNodeId(node);
      if (childList && childList.length) {
        let checkSome = false;
        let checkSize = 0;
        childList.forEach((childNode) => {
          const childNodeid = getNodeId(childNode);
          const isChecked = selectKeyMaps[childNodeid];
          if (isChecked || indeterminateMaps[childNodeid]) {
            if (isChecked) {
              checkSize++;
            }
            checkSome = true;
          }
        });
        const checkAll = checkSize === childList.length;
        if (checkAll) {
          if (!selectKeyMaps[nodeid]) {
            selectKeyMaps[nodeid] = true;
          }
          if (indeterminateMaps[nodeid]) {
            delete indeterminateMaps[nodeid];
          }
        } else {
          if (selectKeyMaps[nodeid]) {
            delete selectKeyMaps[nodeid];
          }
          indeterminateMaps[nodeid] = checkSome;
        }
      } else {
        if (indeterminateMaps[nodeid]) {
          delete indeterminateMaps[nodeid];
        }
      }
    };
    const updateCheckboxStatus = () => {
      const { treeList } = reactData;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly } = checkboxOpts;
      if (!checkStrictly) {
        const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
        const indeterminateMaps = {};
        import_xe_utils62.default.eachTree(treeList, (node, index, items, path, parent, nodes) => {
          const childList = import_xe_utils62.default.get(node, childrenField);
          if (!childList || !childList.length) {
            handleNodeCheckboxStatus(node, selectKeyMaps, indeterminateMaps);
          }
          if (index === items.length - 1) {
            for (let len = nodes.length - 2; len >= 0; len--) {
              const parentItem = nodes[len];
              handleNodeCheckboxStatus(parentItem, selectKeyMaps, indeterminateMaps);
            }
          }
        });
        reactData.selectCheckboxMaps = selectKeyMaps;
        reactData.indeterminateCheckboxMaps = indeterminateMaps;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly, checkMethod } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectKeyMaps[nodeid]) {
        delete selectKeyMaps[nodeid];
      } else {
        isChecked = true;
        selectKeyMaps[nodeid] = isChecked;
      }
      if (!checkStrictly) {
        import_xe_utils62.default.eachTree(import_xe_utils62.default.get(node, childrenField), (childNode) => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectKeyMaps[childNodeid]) {
              selectKeyMaps[childNodeid] = true;
            }
          } else {
            if (selectKeyMaps[childNodeid]) {
              delete selectKeyMaps[childNodeid];
            }
          }
        }, { children: childrenField });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
      updateCheckboxStatus();
      const value = Object.keys(reactData.selectCheckboxMaps);
      emitCheckboxMode(value);
      dispatchEvent2("checkbox-change", { node, value, checked: isChecked }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const { currentMethod, trigger } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils62.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === "child") {
        if (hasChild) {
          return;
        }
      } else if (trigger === "parent") {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent2("current-change", { node, checked: isChecked }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const value = getNodeId(node);
      reactData.selectRadioKey = value;
      emitRadioMode(value);
      dispatchEvent2("radio-change", { node, value, checked: isChecked }, evnt);
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const { showRadio } = props;
      const radioOpts = computeRadioOpts.value;
      const { showIcon, checkMethod, visibleMethod } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--radio-option", {
            "is--checked": isChecked,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const { showCheckbox } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const { showIcon, checkMethod, visibleMethod } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--checkbox-option", {
            "is--checked": isChecked,
            "is--indeterminate": isIndeterminate,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderNode = (node) => {
      const { lazy, showRadio, showCheckbox, showLine, indent, iconOpen, iconClose, iconLoaded, showIcon } = props;
      const { nodeMaps, treeExpandedMaps, currentNode, selectRadioKey, treeExpandLazyLoadedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = import_xe_utils62.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const nodeid = getNodeId(node);
      const isExpand = treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = import_xe_utils62.default.get(node, titleField);
      const childVns = [];
      if (hasChild && treeExpandedMaps[nodeid]) {
        if (showLine) {
          childVns.push(h("div", {
            key: "line",
            class: "vxe-tree--node-child-line",
            style: {
              height: `calc(${nodeItem.lineCount} * var(--vxe-ui-tree-node-height) - var(--vxe-ui-tree-node-height) / 2)`,
              left: `${(nodeItem.level + 1) * (indent || 1)}px`
            }
          }));
        }
        childList.forEach((childItem) => {
          childVns.push(renderNode(childItem));
        });
      }
      let isRadioChecked = false;
      if (showRadio) {
        isRadioChecked = nodeid == selectRadioKey;
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      return h("div", {
        class: ["vxe-tree--node-wrapper", `node--level-${nodeItem.level}`],
        nodeid
      }, [
        h("div", {
          class: ["vxe-tree--node-item", {
            "is--current": currentNode && nodeid === getNodeId(currentNode),
            "is-radio--checked": isRadioChecked,
            "is-checkbox--checked": isCheckboxChecked
          }],
          style: {
            paddingLeft: `${(nodeItem.level - 1) * (indent || 1)}px`
          },
          onClick(evnt) {
            handleNodeClickEvent(evnt, node);
          },
          onDblclick(evnt) {
            handleNodeDblclickEvent(evnt, node);
          }
        }, [
          showIcon || showLine ? h("div", {
            class: "vxe-tree--node-item-switcher"
          }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [
            h("div", {
              class: "vxe-tree--node-item-icon",
              onClick(evnt) {
                toggleExpandEvent(evnt, node);
              }
            }, [
              h("i", {
                class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
              })
            ])
          ] : []) : createCommentVNode(),
          renderRadio(node, nodeid, isRadioChecked),
          renderCheckbox(node, nodeid, isCheckboxChecked),
          h("div", {
            class: "vxe-tree--node-item-inner"
          }, [
            h("div", {
              class: "vxe-tree--node-item-title"
            }, titleSlot ? getSlotVNs(titleSlot({ node })) : `${nodeValue}`),
            extraSlot ? h("div", {
              class: "vxe-tree--node-item-extra"
            }, getSlotVNs(extraSlot({ node }))) : createCommentVNode()
          ])
        ]),
        hasChild && treeExpandedMaps[nodeid] ? h("div", {
          class: "vxe-tree--node-child-wrapper"
        }, childVns) : createCommentVNode()
      ]);
    };
    const renderNodeList = () => {
      const { treeList } = reactData;
      return h("div", {
        class: "vxe-tree--node-list-wrapper"
      }, treeList.map((node) => renderNode(node)));
    };
    const renderVN = () => {
      const { loading: loading2, trigger, showLine } = props;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeStyle = computeTreeStyle.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const loadingSlot = slots.loading;
      return h("div", {
        ref: refElem,
        class: ["vxe-tree", {
          [`size--${vSize}`]: vSize,
          "show--line": showLine,
          "checkbox--highlight": checkboxOpts.highlight,
          "radio--highlight": radioOpts.highlight,
          "node--hover": isRowHover,
          "node--trigger": trigger === "node",
          "is--loading": loading2
        }],
        style: treeStyle
      }, [
        renderNodeList(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-tree--loading",
          modelValue: loading2,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => loadingSlot({ $tree: $xeTree })
        } : {})
      ]);
    };
    $xeTree.renderVN = renderVN;
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateData(props.data || []);
    });
    watch(() => props.checkNodeKey, (val) => {
      reactData.selectRadioKey = val;
    });
    const checkboxFlag = ref(0);
    watch(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    watch(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    watch(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    onUnmounted(() => {
      reactData.treeList = [];
      reactData.treeExpandedMaps = {};
      reactData.nodeMaps = {};
    });
    updateData(props.data || []);
    updateCheckboxChecked(props.checkNodeKeys || []);
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
function getOptUniqueId2() {
  return import_xe_utils63.default.uniqueId("node_");
}
var tree_select_default = defineComponent({
  name: "VxeTreeSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils63.default.eqNull(getConfig().select.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().select.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    size: { type: String, default: () => getConfig().select.size || getConfig().size },
    remote: Boolean,
    remoteMethod: Function,
    treeConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "node-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils63.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refOptionWrapper = ref();
    const refOptionPanel = ref();
    const reactData = reactive({
      initialized: false,
      fullOptionList: [],
      fullNodeMaps: {},
      visibleOptionList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils63.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig);
    });
    const computeTreeNodeOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({ isHover: true }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: "node"
      });
    });
    const computeTreeRadioOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: "node"
      });
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeChildrenField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || "children";
    });
    const computeParentField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || "parentField";
    });
    const computeHasChildField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || "hasChild";
    });
    const computeSelectLabel = computed(() => {
      const { modelValue } = props;
      const { fullNodeMaps } = reactData;
      return (import_xe_utils63.default.isArray(modelValue) ? modelValue : [modelValue]).map((value) => {
        const cacheItem = fullNodeMaps[value];
        const labelField = computeLabelField.value;
        return cacheItem ? cacheItem.item[labelField] : value;
      }).join(", ");
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const treeSelectMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $treeSelect: $xeTreeSelect }, params));
      }
    };
    const getOptid = (option) => {
      const valueField = computeValueField.value;
      const optid = option[valueField];
      return optid ? encodeURIComponent(optid) : "";
    };
    const refreshOption = () => {
      return nextTick();
    };
    const cacheItemMap = () => {
      const { options } = props;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const nodeMaps = {};
      import_xe_utils63.default.eachTree(options, (item, index, items, parent, nodes) => {
        let nodeid = getOptid(item);
        if (!nodeid) {
          nodeid = getOptUniqueId2();
          item[valueField] = nodeid;
        }
        nodeMaps[nodeid] = { item, index, items, parent, nodes };
      }, { children: childrenField });
      reactData.fullOptionList = options || [];
      reactData.fullNodeMaps = nodeMaps;
      refreshOption();
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.animatVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.animatVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const { fullNodeMaps } = reactData;
      if (selectValue !== props.modelValue) {
        const cacheItem = fullNodeMaps[selectValue];
        emit("update:modelValue", selectValue);
        treeSelectMethods.dispatchEvent("change", { value: selectValue, option: cacheItem ? cacheItem.item : null }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      treeSelectMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      treeSelectMethods.dispatchEvent("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      treeSelectMethods.dispatchEvent("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      treeSelectMethods.dispatchEvent("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = (params) => {
      const { $event } = params;
      treeSelectMethods.dispatchEvent("node-click", params, $event);
    };
    const radioChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const { className, modelValue, multiple, options, popupClassName, loading: loading2 } = props;
      const { initialized, isActivated, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const transfer = computeTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-tree-select--readonly", className]
        }, [
          h("div", {
            class: "vxe-tree-select-slots",
            ref: "hideOption"
          }, defaultSlot ? defaultSlot({}) : []),
          h("span", {
            class: "vxe-tree-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tree-select", className ? import_xe_utils63.default.isFunction(className) ? className({ $treeSelect: $xeTreeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-tree-select--panel", popupClassName ? import_xe_utils63.default.isFunction(popupClassName) ? popupClassName({ $treeSelect: $xeTreeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "animat--leave": !loading2 && reactData.animatVisible,
              "animat--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-tree-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-tree-select--panel-header"
              }, headerSlot({})) : createCommentVNode(),
              h("div", {
                class: "vxe-tree-select--panel-body"
              }, [
                h("div", {
                  ref: refOptionWrapper,
                  class: "vxe-tree-select-option--wrapper"
                }, [
                  h(tree_default, {
                    class: "vxe-tree-select--tree",
                    data: options,
                    indent: treeOpts.indent,
                    showRadio: !multiple,
                    radioConfig: treeRadioOpts,
                    checkNodeKey: multiple ? null : modelValue,
                    showCheckbox: !!multiple,
                    checkNodeKeys: multiple ? modelValue : null,
                    checkboxConfig: treeCheckboxOpts,
                    titleField: labelField,
                    valueField,
                    keyField: treeOpts.keyField,
                    childrenField: treeOpts.childrenField || childrenField,
                    parentField: treeOpts.parentField || parentField,
                    hasChildField: treeOpts.hasChildField || hasChildField,
                    accordion: treeOpts.accordion,
                    nodeConfig: treeNodeOpts,
                    lazy: treeOpts.lazy,
                    loadMethod: treeOpts.loadMethod,
                    toggleMethod: treeOpts.toggleMethod,
                    transform: treeOpts.transform,
                    trigger: treeOpts.trigger,
                    showIcon: treeOpts.showIcon,
                    showLine: treeOpts.showLine,
                    iconOpen: treeOpts.iconOpen,
                    iconLoaded: treeOpts.iconLoaded,
                    iconClose: treeOpts.iconClose,
                    onNodeClick: nodeClickEvent,
                    onRadioChange: radioChangeEvent,
                    onCheckboxChange: checkboxChangeEvent
                  })
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-tree-select--panel-footer"
              }, footerSlot({})) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    $xeTreeSelect.renderVN = renderVN;
    watch(() => props.options, () => {
      cacheItemMap();
    });
    cacheItemMap();
    onMounted(() => {
      globalEvents.on($xeTreeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTreeSelect, "mousewheel");
      globalEvents.off($xeTreeSelect, "mousedown");
      globalEvents.off($xeTreeSelect, "blur");
    });
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-view.js
var WidgetVxeTreeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(tree_select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-data.js
var import_xe_utils64 = __toESM(require_xe_utils());
var getWidgetVxeRadioGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-radio-checked",
    options: {
      options: import_xe_utils64.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-form.js
var WidgetVxeRadioGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-view.js
var WidgetVxeRadioGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default2, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-data.js
var import_xe_utils65 = __toESM(require_xe_utils());
var getWidgetVxeCheckboxGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-checkbox-checked",
    options: {
      options: import_xe_utils65.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-form.js
var WidgetVxeCheckboxGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-view.js
var WidgetVxeCheckboxGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-data.js
function getLimitSizeOptions() {
  const sizeOpts = [
    { label: "无限制", value: "" }
  ];
  const sizeList = [1, 2, 5, 10, 20, 50, 100, 200, 500];
  sizeList.forEach((num) => {
    sizeOpts.push({ label: `${num}M`, value: num });
  });
  return sizeOpts;
}
var getWidgetVxeUploadFileConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file",
    options: {
      limitCount: "",
      limitSize: 100,
      multiple: false
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-form.js
var WidgetVxeUploadFileFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiFile"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/upload/src/upload.js
var import_xe_utils67 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/upload/src/util.js
var import_xe_utils66 = __toESM(require_xe_utils());
var fileForm = null;
var fileInput = null;
function parseFile(file) {
  const name = file.name;
  const tIndex = import_xe_utils66.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
var readLocalFile = (options) => {
  const opts = Object.assign({}, options);
  return new Promise((resolve, reject) => {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.name = "file";
      fileInput.type = "file";
    }
    if (!fileForm) {
      fileForm = document.createElement("form");
      fileForm.className = "vxe-table--file-form";
      fileForm.appendChild(fileInput);
      document.body.appendChild(fileForm);
    }
    const types = opts.types || [];
    const isAllType = !types.length || types.some((type) => type === "*");
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? "" : `.${types.join(", .")}`;
    fileInput.onchange = (evnt) => {
      const eventTarget = evnt.target;
      const files = Array.from(eventTarget.files || []);
      const file = files[0];
      let errType = "";
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const { type } = parseFile(files[fIndex]);
          if (!import_xe_utils66.default.includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({ status: true, files, file });
      } else {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.notType", [errType]),
              status: "error"
            });
          }
        }
        const params = { status: false, files, file };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
var saveLocalFile = (options) => {
  const opts = Object.assign({ type: "" }, options);
  const { filename, type, content } = opts;
  const name = type ? `${filename}.${type}` : `${filename}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(import_xe_utils66.default.toValueString(content), opts);
    const winNavigator = window.navigator;
    if (winNavigator.msSaveBlob) {
      winNavigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement("a");
      linkElem.target = "_blank";
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getI18n("vxe.error.notExp")));
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/upload/src/upload.js
var upload_default = defineComponent({
  name: "VxeUpload",
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => getConfig().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    mode: {
      type: String,
      default: () => getConfig().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => import_xe_utils67.default.clone(getConfig().upload.imageTypes, true)
    },
    imageStyle: {
      type: Object,
      default: () => import_xe_utils67.default.clone(getConfig().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => import_xe_utils67.default.clone(getConfig().upload.fileTypes, true)
    },
    singleMode: Boolean,
    urlMode: Boolean,
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => getConfig().upload.limitSize
    },
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    nameField: {
      type: String,
      default: () => getConfig().upload.nameField
    },
    typeField: {
      type: String,
      default: () => getConfig().upload.typeField
    },
    urlField: {
      type: String,
      default: () => getConfig().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => getConfig().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => getConfig().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => getConfig().upload.showProgress
    },
    autoHiddenButton: {
      type: Boolean,
      default: () => getConfig().upload.autoHiddenButton
    },
    buttonText: {
      type: String,
      default: () => getConfig().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => getConfig().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => getConfig().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => getConfig().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => getConfig().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().upload.showPreview
    },
    tipText: String,
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    removeMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: { type: String, default: () => getConfig().upload.size || getConfig().size }
  },
  emits: [
    "update:modelValue",
    "add",
    "remove",
    "download",
    "upload-success",
    "upload-error"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils67.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      isDrag: false,
      fileList: []
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsImage = computed(() => {
      return props.mode === "image";
    });
    const computeNameProp = computed(() => {
      return props.nameField || "name";
    });
    const computeTypeProp = computed(() => {
      return props.typeField || "type";
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeSizeProp = computed(() => {
      return props.sizeField || "size";
    });
    const computeLimitMaxSizeB = computed(() => {
      return import_xe_utils67.default.toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = computed(() => {
      return props.multiple ? import_xe_utils67.default.toNumber(props.limitCount) : 1;
    });
    const computeOverCount = computed(() => {
      const { multiple } = props;
      const { fileList } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = computed(() => {
      const limitSize = import_xe_utils67.default.toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return "";
    });
    const computedDefHintText = computed(() => {
      const { limitSize, fileTypes, multiple, limitCount } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (import_xe_utils67.default.isString(tipText)) {
        return tipText;
      }
      const defHints = [];
      if (isImage) {
        if (multiple && limitCount) {
          defHints.push(getI18n("vxe.upload.imgCountHint", [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(getI18n("vxe.upload.imgSizeHint", [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defHints.push(getI18n("vxe.upload.fileTypeHint", [fileTypes.join("/")]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(getI18n("vxe.upload.fileSizeHint", [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defHints.push(getI18n("vxe.upload.fileCountHint", [limitCount]));
        }
      }
      return defHints.join(getI18n("vxe.base.comma"));
    });
    const computeImageStyleOpts = computed(() => {
      return Object.assign({}, props.imageStyle);
    });
    const computeImgStyle = computed(() => {
      const { width, height } = computeImageStyleOpts.value;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMoreOpts = computed(() => {
      return Object.assign({ showMoreButton: true }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateFileList = () => {
      const { modelValue, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? import_xe_utils67.default.isArray(modelValue) ? modelValue : [modelValue] : []).map((item) => {
        if (!item || import_xe_utils67.default.isString(item)) {
          const url = `${item || ""}`;
          const name2 = parseFileName(url);
          return {
            [nameProp]: name2,
            [typeProp]: parseFileType(name2),
            [urlProp]: url,
            [sizeProp]: 0
          };
        }
        const name = item[nameProp] || "";
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || "";
        item[sizeProp] = item[sizeProp] || 0;
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = (url) => {
      return decodeURIComponent(`${url || ""}`).split("/").pop() || "";
    };
    const parseFileType = (name) => {
      const index = name ? name.indexOf(".") : -1;
      if (index > -1) {
        return name.substring(index + 1, name.length).toLowerCase();
      }
      return "";
    };
    const uploadMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $upload: $xeUpload }, params));
      }
    };
    const emitModel = (value) => {
      const { singleMode, urlMode } = props;
      const urlProp = computeUrlProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlMode) {
        restList = restList.map((item) => item[urlProp]);
      }
      emit("update:modelValue", singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = (item) => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = (item) => {
      const getUrlFn = props.getUrlMethod || getConfig().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const imagePreviewTypes = ["jpg", "jpeg", "png", "gif"];
    const handleDefaultFilePreview = (item) => {
      const { imageTypes, showDownloadButton } = props;
      const typeProp = computeTypeProp.value;
      if (imagePreviewTypes.concat(imageTypes || []).some((type) => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || getConfig().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index) => {
      const { showDownloadButton } = props;
      const { fileList } = reactData;
      if (props.showPreview) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: fileList.map((item2) => getFileUrl(item2)),
            activeIndex: index,
            showDownloadButton
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const { showErrorStatus } = props;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && item._X_DATA) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            Object.assign(item._X_DATA || {}, { p: Math.max(0, Math.min(99, import_xe_utils67.default.toNumber(percentNum))) });
          }
        })).then((res) => {
          Object.assign(item._X_DATA || {}, { l: false, p: 100 });
          Object.assign(item, res);
          uploadMethods.dispatchEvent("upload-success", { option: item, data: res }, null);
        }).catch((res) => {
          Object.assign(item._X_DATA || {}, { l: false, s: "error" });
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter((obj) => obj._X_DATA !== item._X_DATA);
          }
          uploadMethods.dispatchEvent("upload-error", { option: item, data: res }, null);
        });
      }
      return Promise.resolve();
    };
    const handleReUpload = (item) => {
      const { uploadMethod, urlMode } = props;
      const uploadFn = uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && item._X_DATA) {
        const file = item._X_DATA.f;
        Object.assign(item._X_DATA, {
          l: true,
          s: "",
          p: 0
        });
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            emitModel(reactData.fileList);
          }
        });
      }
    };
    const uploadFile = (files, evnt) => {
      const { multiple, urlMode } = props;
      const { fileList } = reactData;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSizeB = computeLimitMaxSizeB.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        if (fileList.length >= limitMaxCount) {
          if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              content: getI18n("vxe.upload.overCountErr", [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              slots: {
                default() {
                  return h("div", {
                    class: "vxe-upload--file-message-over-error"
                  }, [
                    h("div", {}, getI18n("vxe.upload.overCountExtraErr", [limitMaxCount, overNum])),
                    h("div", {
                      class: "vxe-upload--file-message-over-extra"
                    }, overExtraList.map((file, index) => {
                      return h("div", {
                        key: index,
                        class: "vxe-upload--file-message-over-extra-item"
                      }, file.name);
                    }))
                  ]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      if (limitMaxSizeB) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSizeB) {
            if (VxeUI.modal) {
              VxeUI.modal.notification({
                title: getI18n("vxe.modal.errTitle"),
                status: "error",
                content: getI18n("vxe.upload.overSizeErr", [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach((file) => {
        const { name } = file;
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: ""
        };
        if (uploadFn) {
          fileObj._X_DATA = {
            k: import_xe_utils67.default.uniqueId(),
            f: file,
            l: true,
            s: "",
            p: 0
          };
        }
        const item = reactive(fileObj);
        if (uploadFn) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
        uploadMethods.dispatchEvent("add", { option: item }, evnt);
      });
      reactData.fileList = newFileList;
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        emitModel(newFileList);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const clickEvent = (evnt) => {
      const { multiple, imageTypes, fileTypes } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return;
      }
      readLocalFile({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then(({ files }) => {
        uploadFile(files, evnt);
      }).catch(() => {
      });
    };
    const handleRemoveEvent = (evnt, item, index) => {
      const { fileList } = reactData;
      fileList.splice(index, 1);
      emitModel(fileList);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      uploadMethods.dispatchEvent("remove", { option: item }, evnt);
    };
    const removeFileEvent = (evnt, item, index) => {
      const removeFn = props.removeMethod || getConfig().upload.removeMethod;
      if (removeFn) {
        Promise.resolve(removeFn({
          $upload: $xeUpload,
          option: item
        })).then(() => {
          handleRemoveEvent(evnt, item, index);
        }).catch((e) => e);
      } else {
        handleRemoveEvent(evnt, item, index);
      }
    };
    const handleDownloadEvent = (evnt, item) => {
      uploadMethods.dispatchEvent("download", { option: item }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const downloadFn = props.downloadMethod || getConfig().upload.downloadMethod;
      if (downloadFn) {
        Promise.resolve(downloadFn({
          $upload: $xeUpload,
          option: item
        })).then(() => {
          handleDownloadEvent(evnt, item);
        }).catch((e) => e);
      } else {
        handleDownloadEvent(evnt, item);
      }
    };
    const handleDragleaveEvent = (evnt) => {
      const elem = refElem.value;
      const { clientX, clientY } = evnt;
      if (elem) {
        const { x: targetX, y: targetY, height: targetHeight, width: targetWidth } = elem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDrag = false;
        }
      }
    };
    const handleDragoverEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDrag = true;
        }
      }
    };
    const handleDropEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          const files = [];
          Array.from(items).forEach((item) => {
            const file = item.getAsFile();
            if (file) {
              files.push(file);
            }
          });
          uploadFile(files, evnt);
          evnt.preventDefault();
        }
      }
      reactData.isDrag = false;
    };
    const handleMoreEvent = () => {
      const isImage = computeIsImage.value;
      VxeUI.modal.open({
        title: "查看列表",
        width: 660,
        height: 500,
        escClosable: true,
        showMaximize: true,
        resize: true,
        maskClosable: true,
        slots: {
          default() {
            const { fileList } = reactData;
            if (isImage) {
              return h("div", {
                class: "vxe-upload--image-more-list"
              }, renderImageItemList(fileList, true));
            }
            return h("div", {
              class: "vxe-upload--file-more-list"
            }, renderFileItemList(fileList));
          }
        }
      });
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = (currList) => {
      const { showRemoveButton, showDownloadButton, showProgress, showPreview, showErrorStatus } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      return currList.map((item, index) => {
        const isLoading = item._X_DATA && item._X_DATA.l;
        const isError = item._X_DATA && item._X_DATA.s === "error";
        return h("div", {
          key: index,
          class: ["vxe-upload--file-item", {
            "is--preview": showPreview,
            "is--loading": isLoading,
            "is--error": isError
          }]
        }, [
          h("div", {
            class: "vxe-upload--file-item-icon"
          }, [
            h("i", {
              class: getIcon()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || getIcon().UPLOAD_FILE_TYPE_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-upload--file-item-name",
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewFileEvent(evnt, item);
              }
            }
          }, `${item[nameProp] || ""}`),
          isLoading ? h("div", {
            class: "vxe-upload--file-item-loading-icon"
          }, [
            h("i", {
              class: getIcon().UPLOAD_LOADING
            })
          ]) : createCommentVNode(),
          showProgress && isLoading && item._X_DATA ? h("div", {
            class: "vxe-upload--file-item-loading-text"
          }, getI18n("vxe.upload.uploadProgress", [item._X_DATA.p])) : createCommentVNode(),
          showErrorStatus && isError ? h("div", {
            class: "vxe-upload--image-item-error"
          }, [
            h(button_default, {
              icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
              mode: "text",
              status: "primary",
              content: getI18n("vxe.upload.reUpload"),
              onClick() {
                handleReUpload(item);
              }
            })
          ]) : createCommentVNode(),
          showDownloadButton && !isLoading ? h("div", {
            class: "vxe-upload--file-item-download-icon",
            onClick(evnt) {
              downloadFileEvent(evnt, item);
            }
          }, [
            h("i", {
              class: getIcon().UPLOAD_FILE_DOWNLOAD
            })
          ]) : createCommentVNode(),
          showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
            class: "vxe-upload--file-item-remove-icon",
            onClick(evnt) {
              removeFileEvent(evnt, item, index);
            }
          }, [
            h("i", {
              class: getIcon().UPLOAD_FILE_REMOVE
            })
          ]) : createCommentVNode()
        ]);
      });
    };
    const renderAllMode = () => {
      const { buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const { fileList } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const moreOpts = computeMoreOpts.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      const { maxCount, showMoreButton, layout } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (formReadonly && maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "all",
        class: "vxe-upload--file-wrapper"
      }, [
        formReadonly ? createCommentVNode() : h("div", {
          class: "vxe-upload--file-action"
        }, [
          autoHiddenButton && overCount ? createCommentVNode() : h("div", {
            class: "vxe-upload--file-action-btn",
            onClick: clickEvent
          }, defaultSlot ? getSlotVNs(defaultSlot({ $upload: $xeUpload })) : [
            h(button_default, {
              content: showButtonText ? buttonText ? `${buttonText}` : getI18n("vxe.upload.fileBtnText") : "",
              icon: showButtonIcon ? buttonIcon || getIcon().UPLOAD_FILE_ADD : "",
              disabled: isDisabled
            })
          ]),
          defHintText || tipSlot ? h("div", {
            class: "vxe-upload--file-action-tip"
          }, tipSlot ? getSlotVNs(tipSlot({ $upload: $xeUpload })) : defHintText) : createCommentVNode()
        ]),
        currList.length ? h("div", {
          class: ["vxe-upload--file-list-wrapper", {
            "is--horizontal": layout === "horizontal"
          }]
        }, [
          h("div", {
            class: "vxe-upload--file-list"
          }, renderFileItemList(currList)),
          formReadonly && showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--file-over-more"
          }, [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : createCommentVNode()
        ]) : createCommentVNode()
      ]);
    };
    const renderImageItemList = (currList, isPreview) => {
      const { showRemoveButton, showProgress, showPreview, showErrorStatus } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imgStyle = computeImgStyle.value;
      return currList.map((item, index) => {
        const isLoading = item._X_DATA && item._X_DATA.l;
        const isError = item._X_DATA && item._X_DATA.s === "error";
        return h("div", {
          key: index,
          class: ["vxe-upload--image-item", {
            "is--preview": showPreview,
            "is--loading": isLoading,
            "is--error": isError
          }]
        }, [
          h("div", {
            class: "vxe-upload--image-item-box",
            style: isPreview ? null : imgStyle,
            title: getI18n("vxe.upload.viewItemTitle"),
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewImageEvent(evnt, item, index);
              }
            }
          }, [
            isLoading && item._X_DATA ? h("div", {
              class: "vxe-upload--image-item-loading"
            }, [
              h("div", {
                class: "vxe-upload--image-item-loading-icon"
              }, [
                h("i", {
                  class: getIcon().UPLOAD_LOADING
                })
              ]),
              showProgress ? h("div", {
                class: "vxe-upload--image-item-loading-text"
              }, getI18n("vxe.upload.uploadProgress", [item._X_DATA.p])) : createCommentVNode()
            ]) : createCommentVNode(),
            !isLoading ? isError && showErrorStatus ? h("div", {
              class: "vxe-upload--image-item-error"
            }, [
              h(button_default, {
                icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
                mode: "text",
                status: "primary",
                content: getI18n("vxe.upload.reUpload"),
                onClick() {
                  handleReUpload(item);
                }
              })
            ]) : h("img", {
              class: "vxe-upload--image-item-img",
              src: getThumbnailFileUrl(item)
            }) : createCommentVNode(),
            showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
              class: "vxe-upload--image-item-remove-icon",
              onClick(evnt) {
                evnt.stopPropagation();
                removeFileEvent(evnt, item, index);
              }
            }, [
              h("i", {
                class: getIcon().UPLOAD_IMAGE_REMOVE
              })
            ]) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderImageMode = () => {
      const { buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const { fileList } = reactData;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const moreOpts = computeMoreOpts.value;
      const defaultSlot = slots.default;
      const hintSlot = slots.hint;
      const { maxCount, showMoreButton } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (formReadonly && maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "image",
        class: "vxe-upload--image-wrapper"
      }, [
        h("div", {
          class: "vxe-upload--image-list"
        }, renderImageItemList(currList, false).concat([
          formReadonly && showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--image-over-more"
          }, [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : createCommentVNode(),
          formReadonly || autoHiddenButton && overCount ? createCommentVNode() : h("div", {
            class: "vxe-upload--image-action"
          }, [
            h("div", {
              class: "vxe-upload--image-action-btn",
              onClick: clickEvent
            }, defaultSlot ? defaultSlot({ $upload: $xeUpload }) : [
              h("div", {
                class: "vxe-upload--image-action-box",
                style: imgStyle
              }, [
                showButtonIcon ? h("div", {
                  class: "vxe-upload--image-action-icon"
                }, [
                  h("i", {
                    class: buttonIcon || getIcon().UPLOAD_IMAGE_ADD
                  })
                ]) : createCommentVNode(),
                showButtonText ? h("div", {
                  class: "vxe-upload--image-action-content"
                }, buttonText ? `${buttonText}` : getI18n("vxe.upload.imgBtnText")) : createCommentVNode(),
                defHintText || hintSlot ? h("div", {
                  class: "vxe-upload--image-action-hint"
                }, hintSlot ? getSlotVNs(hintSlot({ $upload: $xeUpload })) : defHintText) : createCommentVNode()
              ])
            ])
          ])
        ]))
      ]);
    };
    const renderVN = () => {
      const { showErrorStatus } = props;
      const { isDrag } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-upload", {
          [`size--${vSize}`]: vSize,
          "is--readonly": formReadonly,
          "is--disabled": isDisabled,
          "show--error": showErrorStatus,
          "is--drag": isDrag
        }],
        onDragover: handleDragoverEvent,
        onDragleave: handleDragleaveEvent,
        onDrop: handleDropEvent
      }, [
        isImage ? renderImageMode() : renderAllMode(),
        isDrag ? h("div", {
          class: "vxe-upload--drag-placeholder"
        }, getI18n("vxe.upload.dragPlaceholder")) : createCommentVNode()
      ]);
    };
    $xeUpload.renderVN = renderVN;
    const listFlag = ref(0);
    watch(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    watch(() => props.modelValue, () => {
      listFlag.value++;
    });
    watch(listFlag, () => {
      updateFileList();
    });
    onMounted(() => {
      if (true) {
        if (props.multiple && props.singleMode) {
          errLog("vxe.error.errConflicts", ["multiple", "single-mode"]);
        }
      }
    });
    onUnmounted(() => {
      reactData.isDrag = false;
    });
    updateFileList();
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-view.js
var WidgetVxeUploadFileViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "all",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-data.js
var getWidgetVxeUploadImageConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file-image",
    options: {
      limitCount: 9,
      limitSize: 10,
      multiple: false
    }
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-form.js
var WidgetVxeUploadImageFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiImg"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-view.js
var WidgetVxeUploadImageViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "image",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/render/index.js
renderer.mixin({
  text: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  /**
   * 已废弃
   */
  title: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  row: {
    createFormDesignWidgetConfig: getWidgetRowConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetRowEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetRowViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetRowFormComponent, { renderOpts, renderParams });
    }
  },
  subtable: {
    createFormDesignWidgetConfig: getWidgetSubtableConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetSubtableEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSubtableViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSubtableFormComponent, { renderOpts, renderParams });
    }
  },
  input: {
    createFormDesignWidgetConfig: getWidgetInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetInputFormComponent, { renderOpts, renderParams });
    }
  },
  textarea: {
    createFormDesignWidgetConfig: getWidgetTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  select: {
    createFormDesignWidgetConfig: getWidgetSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeInput: {
    createFormDesignWidgetConfig: getWidgetVxeInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeNumberInput: {
    createFormDesignWidgetConfig: getWidgetVxeNumberInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeDatePicker: {
    createFormDesignWidgetConfig: getWidgetVxeDatePickerConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTextarea: {
    createFormDesignWidgetConfig: getWidgetVxeTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSwitch: {
    createFormDesignWidgetConfig: getWidgetVxeSwitchConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTreeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeTreeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeRadioGroup: {
    createFormDesignWidgetConfig: getWidgetVxeRadioGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeCheckboxGroup: {
    createFormDesignWidgetConfig: getWidgetVxeCheckboxGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadFile: {
    createFormDesignWidgetConfig: getWidgetVxeUploadFileConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadImage: {
    createFormDesignWidgetConfig: getWidgetVxeUploadImageConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageFormComponent, { renderOpts, renderParams });
    }
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-design/index.js
var VxeFormDesign = Object.assign({}, form_design_default, {
  install(app) {
    app.component(form_design_default.name, form_design_default);
  }
});
var formDesign = {
  useWidgetName,
  useWidgetView,
  useWidgetPropDataSource
};
dynamicApp.component(form_design_default.name, form_design_default);
VxeUI.component(form_design_default);
VxeUI.formDesign = formDesign;
var FormDesign = VxeFormDesign;
var form_design_default2 = VxeFormDesign;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-gather/index.js
var VxeFormGather = Object.assign(form_gather_default, {
  install(app) {
    app.component(form_gather_default.name, form_gather_default);
  }
});
dynamicApp.component(form_gather_default.name, form_gather_default);
VxeUI.component(form_gather_default);
var FormGather = VxeFormGather;
var form_gather_default2 = VxeFormGather;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-item/index.js
var VxeFormItem = Object.assign(form_item_default, {
  install(app) {
    app.component(form_item_default.name, form_item_default);
  }
});
dynamicApp.component(form_item_default.name, form_item_default);
VxeUI.component(form_item_default);
var FormItem = VxeFormItem;
var form_item_default2 = VxeFormItem;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/form-view/index.js
var VxeFormView = Object.assign(form_view_default, {
  install: function(app) {
    app.component(form_view_default.name, form_view_default);
  }
});
dynamicApp.component(form_view_default.name, form_view_default);
VxeUI.component(form_view_default);
var FormView = VxeFormView;
var form_view_default2 = VxeFormView;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/icon/index.js
var VxeIcon = Object.assign({}, icon_default, {
  install(app) {
    app.component(icon_default.name, icon_default);
  }
});
dynamicApp.component(icon_default.name, icon_default);
VxeUI.component(icon_default);
var Icon = VxeIcon;
var icon_default2 = VxeIcon;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/icon-picker/src/icon-picker.js
var import_xe_utils68 = __toESM(require_xe_utils());
var icon_picker_default = defineComponent({
  name: "VxeIconPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: { type: String, default: () => getConfig().iconPicker.size || getConfig().size },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils68.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      selectIcon: "",
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const refElem = ref();
    const refInput = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (import_xe_utils68.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeIconList = computed(() => {
      let { icons } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map((name) => {
        return {
          title: name,
          icon: `vxe-icon-${name}`
        };
      });
    });
    const computeIconGroupList = computed(() => {
      const iconList = computeIconList.value;
      return import_xe_utils68.default.chunk(iconList, 4);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const transfer = computeTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        iconPickerMethods.dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      iconPickerMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = (evnt) => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      iconPickerMethods.dispatchEvent("click", {}, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    iconPickerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $iconPicker: $xeIconPicker }, params));
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const { showIconTitle } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        class: "vxe-ico-picker--list-wrapper"
      }, iconGroupList.map((list) => {
        return h("div", {
          class: "vxe-ico-picker--list"
        }, list.map((item) => {
          return h("div", {
            class: "vxe-ico-picker--item",
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [
            h("div", {
              class: "vxe-ico-picker--item-icon"
            }, [
              h("i", {
                class: item.icon || ""
              })
            ]),
            showIconTitle ? h("div", {
              class: "vxe-ico-picker--item-title"
            }, `${item.title || ""}`) : createCommentVNode()
          ]);
        }));
      }));
    };
    const renderVN = () => {
      const { className, popupClassName, clearable } = props;
      const { initialized, isActivated, visiblePanel, selectIcon } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const transfer = computeTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-ico-picker--readonly", className]
        }, [
          h("i", {
            class: selectIcon
          })
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-ico-picker", className ? import_xe_utils68.default.isFunction(className) ? className({ $iconPicker: $xeIconPicker }) : className : "", {
          [`size--${vSize}`]: vSize,
          "show--clear": clearable && !isDisabled && !!selectIcon,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-ico-picker--inner",
          onClick: clickEvent
        }, [
          h("input", {
            ref: refInput,
            class: "vxe-ico-picker--input",
            onFocus: focusEvent,
            onBlur: blurEvent
          }),
          selectIcon ? h("div", {
            class: "vxe-ico-picker--icon"
          }, [
            h("i", {
              class: selectIcon
            })
          ]) : h("div", {
            class: "vxe-ico-picker--placeholder"
          }, inpPlaceholder),
          h("div", {
            class: "vxe-ico-picker--suffix"
          }, [
            h("div", {
              class: "vxe-ico-picker--clear-icon",
              onClick: clearEvent
            }, [
              h("i", {
                class: getIcon().INPUT_CLEAR
              })
            ]),
            h("div", {
              class: "vxe-ico-picker--suffix-icon"
            }, [
              h("i", {
                class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
              })
            ])
          ])
        ]),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-ico-picker--panel", popupClassName ? import_xe_utils68.default.isFunction(popupClassName) ? popupClassName({ $iconPicker: $xeIconPicker }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "ani--leave": reactData.isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, [
            initialized ? h("div", {
              class: "vxe-ico-picker--panel-wrapper"
            }, renderIconWrapper()) : createCommentVNode()
          ])
        ])
      ]);
    };
    $xeIconPicker.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      reactData.selectIcon = `${val || ""}`;
    });
    onMounted(() => {
      globalEvents.on($xeIconPicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeIconPicker, "mousewheel");
      globalEvents.off($xeIconPicker, "mousedown");
      globalEvents.off($xeIconPicker, "keydown");
      globalEvents.off($xeIconPicker, "blur");
    });
    provide("$xeIconPicker", $xeIconPicker);
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/icon-picker/index.js
var VxeIconPicker = Object.assign(icon_picker_default, {
  install: function(app) {
    app.component(icon_picker_default.name, icon_picker_default);
  }
});
dynamicApp.component(icon_picker_default.name, icon_picker_default);
VxeUI.component(icon_picker_default);
var IconPicker = VxeIconPicker;
var icon_picker_default2 = VxeIconPicker;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image/src/image.js
var import_xe_utils71 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image/src/preview.js
var import_xe_utils69 = __toESM(require_xe_utils());
var preview_default = defineComponent({
  name: "VxeImagePreview",
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "close"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils69.default.uniqueId();
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const reactData = reactive({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeMarginSize = computed(() => {
      return import_xe_utils69.default.toNumber(props.marginSize || 0) || 16;
    });
    const computeRotateText = computed(() => {
      const { offsetRotate } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}°`;
      }
      return "0°";
    });
    const computeScaleText = computed(() => {
      const { offsetScale } = reactData;
      if (offsetScale) {
        return `${import_xe_utils69.default.ceil((1 + offsetScale) * 100)}%`;
      }
      return "100%";
    });
    const computeImgList = computed(() => {
      const { urlList } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map((item) => {
          if (import_xe_utils69.default.isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return "";
        });
      }
      return [];
    });
    const computeImgTransform = computed(() => {
      let { offsetScale, offsetRotate, offsetLeft, offsetTop } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(" ") : "";
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imagePreviewMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $imagePreview: $xeImagePreview }, params));
      }
    };
    const emitModel = (value) => {
      reactData.activeIndex = value;
      emit("update:modelValue", value);
    };
    const handleCloseEvent = (evnt) => {
      imagePreviewMethods.dispatchEvent("close", {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass(elem, "is--move");
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const { offsetScale } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = (isAdd) => {
      const { offsetScale } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChange = (isNext) => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      resetStyle();
      reactData.activeIndex = activeIndex;
      emitModel(activeIndex);
    };
    const handleRotateImg = (isRight) => {
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (VxeUI.print) {
        VxeUI.print({
          align: "center",
          pageBreaks: [
            {
              bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
            }
          ]
        });
      }
    };
    const handleDownloadImg = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (VxeUI.saveFile) {
        fetch(imgUrl).then((res) => {
          res.blob().then((blob) => {
            VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
          });
        });
      }
    };
    const handleOperationBtn = (code) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code) {
          case "zoomOut":
            handleZoom(false);
            break;
          case "zoomIn":
            handleZoom(true);
            break;
          case "pctFull":
            resetStyle();
            break;
          case "pct11":
            handlePct11();
            break;
          case "rotateLeft":
            handleRotateImg(false);
            break;
          case "rotateRight":
            handleRotateImg(true);
            break;
          case "print":
            handlePrintImg();
            break;
          case "download":
            handleDownloadImg();
            break;
        }
      }
    };
    const wheelEvent = (evnt) => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        handleZoom(false);
      } else if (delta < 0) {
        handleZoom(true);
      }
    };
    const moveEvent = (evnt) => {
      const { offsetTop, offsetLeft } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = (et) => {
        const { pageX, pageY } = et;
        const { visibleHeight, visibleWidth } = getDomNode();
        et.preventDefault();
        addClass(elem, "is--move");
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass(elem, "is--move");
      };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const hasCtrlKey = evnt.ctrlKey;
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChange(false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChange(true);
        }
      } else if (isR && hasCtrlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImg(false);
        } else {
          handleRotateImg(true);
        }
      } else if (isP && hasCtrlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = (evnt) => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          imagePreviewMethods.dispatchEvent("close", {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return h("div", {
        class: "vxe-image-preview--img-list",
        onClick: handleClickMaskEvent
      }, imgList.map((url, index) => {
        const isActive = activeIndex === index;
        return h("img", {
          class: ["vxe-image-preview--img-item", {
            "is--active": isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code, icon) => {
      return h("div", {
        class: "vxe-image-preview--operation-btn",
        title: getI18n(`vxe.imagePreview.operBtn.${code}`),
        onClick() {
          handleOperationBtn(code);
        }
      }, [
        h("i", {
          class: getIcon()[icon]
        })
      ]);
    };
    const renderBtnWrapper = () => {
      const { showPrintButton, showDownloadButton } = props;
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      return h("div", {
        class: "vxe-image-preview--btn-wrapper"
      }, [
        h("div", {
          class: "vxe-image-preview--close-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--close-btn",
            onClick: handleCloseEvent
          }, [
            h("i", {
              class: getIcon().IMAGE_PREVIEW_CLOSE
            })
          ]),
          h("div", {
            class: "vxe-image-preview--close-bg"
          })
        ]),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--previous-btn",
          onClick() {
            handleChange(false);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_PREVIOUS
          })
        ]) : createCommentVNode(),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--next-btn",
          onClick() {
            handleChange(true);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_NEXT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-image-preview--operation-info"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-deg"
          }, rotateText),
          h("div", {
            class: "vxe-image-preview--operation-pct"
          }, scaleText)
        ]),
        h("div", {
          class: "vxe-image-preview--operation-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-active-count"
          }, [
            h("span", {
              class: "vxe-image-preview--operation-active-current"
            }, `${(activeIndex || 0) + 1}`),
            h("span", {
              class: "vxe-image-preview--operation-active-total"
            }, `/${imgList.length}`)
          ]),
          renderOperationBtn("zoomOut", "IMAGE_PREVIEW_ZOOM_OUT"),
          renderOperationBtn("zoomIn", "IMAGE_PREVIEW_ZOOM_IN"),
          renderOperationBtn("pctFull", "IMAGE_PREVIEW_PCT_FULL"),
          renderOperationBtn("pct11", "IMAGE_PREVIEW_PCT_1_1"),
          renderOperationBtn("rotateLeft", "IMAGE_PREVIEW_ROTATE_LEFT"),
          renderOperationBtn("rotateRight", "IMAGE_PREVIEW_ROTATE_RIGHT"),
          showPrintButton ? renderOperationBtn("print", "IMAGE_PREVIEW_PRINT") : createCommentVNode(),
          showDownloadButton ? renderOperationBtn("download", "IMAGE_PREVIEW_DOWNLOAD") : createCommentVNode()
        ])
      ]);
    };
    const renderVN = () => {
      const { offsetPct11 } = reactData;
      return h("div", {
        ref: refElem,
        class: ["vxe-image-preview", {
          "is--pct11": offsetPct11
        }],
        onWheel: wheelEvent
      }, [
        renderImgWrapper(),
        renderBtnWrapper()
      ]);
    };
    $xeImagePreview.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      reactData.activeIndex = val;
      resetStyle();
    });
    onMounted(() => {
      globalEvents.on($xeImagePreview, "keydown", handleGlobalKeydownEvent);
    });
    onBeforeUnmount(() => {
      const elem = refElem.value;
      removeClass(elem, "is--move");
    });
    onUnmounted(() => {
      globalEvents.off($xeImagePreview, "keydown");
    });
    provide("$xeImagePreview", $xeImagePreview);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image/src/util.js
var import_xe_utils70 = __toESM(require_xe_utils());
var openPreviewImage = (options) => {
  if (VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const { urlList, activeIndex } = opts;
    const modalId = import_xe_utils70.default.uniqueId("image-preview");
    VxeUI.modal.open({
      id: modalId,
      title: "预览",
      width: "100%",
      height: "100%",
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      className: "vxe-image-preview-popup-wrapper",
      slots: {
        default() {
          return h(preview_default, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            onClose() {
              VxeUI.modal.close(modalId);
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image/src/image.js
var image_default = defineComponent({
  name: "VxeImage",
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils71.default.uniqueId();
    const $xeImageGroup = inject("$xeImageGroup", null);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = computed(() => {
      const { width, height } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = computed(() => {
      const { src } = props;
      if (src) {
        return (import_xe_utils71.default.isArray(src) ? src : [src]).map((item) => {
          if (import_xe_utils71.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = computed(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = computed(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ""}` : "";
    });
    const computeMaps = {};
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $image: $xeImage }, params));
      }
    };
    const clickEvent = (evnt) => {
      const { showPreview } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, { url: imgUrl });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList
          });
        }
        imageMethods.dispatchEvent("click", { url: imgUrl }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const { alt, loading: loading2 } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      return h("img", {
        ref: refElem,
        class: "vxe-image",
        src: imgUrl,
        alt,
        loading: loading2,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image/index.js
var VxeImage = Object.assign({}, image_default, {
  install(app) {
    app.component(image_default.name, image_default);
  }
});
dynamicApp.component(image_default.name, image_default);
VxeUI.component(image_default);
var Image = VxeImage;
var image_default2 = VxeImage;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image/src/group.js
var import_xe_utils72 = __toESM(require_xe_utils());
var group_default3 = defineComponent({
  name: "VxeImageGroup",
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    size: { type: String, default: () => getConfig().imageGroup.size || getConfig().size }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils72.default.uniqueId();
    const computeImgList = computed(() => {
      const { urlList } = props;
      if (urlList) {
        return (import_xe_utils72.default.isArray(urlList) ? urlList : [urlList]).map((item) => {
          if (import_xe_utils72.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = computed(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeMaps = {};
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $imageGroup: $xeImageGroup }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const { showPreview } = props;
        const { url } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, import_xe_utils72.default.findIndexOf(imgList, (item) => item.url === url)),
            urlList: imgList
          });
        }
        imageGroupMethods.dispatchEvent("click", { url, urlList: imgList }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      return h("div", {
        class: "vxe-image-group"
      }, imgList ? imgList.map((item, index) => {
        return h(image_default, {
          key: index,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    provide("$xeImageGroup", $xeImageGroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image-group/index.js
var VxeImageGroup = Object.assign({}, group_default3, {
  install(app) {
    app.component(group_default3.name, group_default3);
  }
});
dynamicApp.component(group_default3.name, group_default3);
VxeUI.component(group_default3);
var ImageGroup = VxeImageGroup;
var image_group_default = VxeImageGroup;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/image-preview/index.js
var VxeImagePreview = Object.assign(preview_default, {
  install(app) {
    app.component(preview_default.name, preview_default);
    VxeUI.previewImage = openPreviewImage;
  }
});
dynamicApp.component(preview_default.name, preview_default);
VxeUI.component(preview_default);
var ImagePreview = VxeImagePreview;
var image_preview_default = VxeImagePreview;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/input/index.js
var VxeInput = Object.assign(input_default, {
  install(app) {
    app.component(input_default.name, input_default);
  }
});
dynamicApp.component(input_default.name, input_default);
VxeUI.component(input_default);
var Input = VxeInput;
var input_default2 = VxeInput;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-aside/src/layout-aside.js
var import_xe_utils73 = __toESM(require_xe_utils());
var layout_aside_default = defineComponent({
  name: "VxeLayoutAside",
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils73.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = computed(() => {
      const { width, collapsed, collapseWidth } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return "";
    });
    const computeMaps = {};
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { width, collapsed, loading: loading2, padding } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const defaultSlot = slots.default;
      return h("aside", {
        ref: refElem,
        class: ["vxe-layout-aside", {
          "is--padding": padding,
          "is--default-width": !width,
          "is--collapse": collapsed,
          "is--loading": loading2
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [
        h("div", {
          class: "vxe-layout-aside--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    onMounted(() => {
    });
    $xeLayoutAside.renderVN = renderVN;
    provide("$xeLayoutAside", $xeLayoutAside);
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-aside/index.js
var VxeLayoutAside = Object.assign({}, layout_aside_default, {
  install(app) {
    app.component(layout_aside_default.name, layout_aside_default);
  }
});
dynamicApp.component(layout_aside_default.name, layout_aside_default);
VxeUI.component(layout_aside_default);
var LayoutAside = VxeLayoutAside;
var layout_aside_default2 = VxeLayoutAside;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-body/src/layout-body.js
var import_xe_utils74 = __toESM(require_xe_utils());
var layout_body_default = defineComponent({
  name: "VxeLayoutBody",
  props: {
    loading: Boolean,
    padding: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils74.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { loading: loading2, padding } = props;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-body", {
          "is--loading": loading2,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-layout-body--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-body/index.js
var VxeLayoutBody = Object.assign({}, layout_body_default, {
  install(app) {
    app.component(layout_body_default.name, layout_body_default);
  }
});
dynamicApp.component(layout_body_default.name, layout_body_default);
VxeUI.component(layout_body_default);
var LayoutBody = VxeLayoutBody;
var layout_body_default2 = VxeLayoutBody;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-container/src/layout-container.js
var import_xe_utils75 = __toESM(require_xe_utils());
var layout_container_default = defineComponent({
  name: "VxeLayoutContainer",
  props: {
    vertical: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils75.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { vertical } = props;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-container", {
          "is--vertical": vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-container/index.js
var VxeLayoutContainer = Object.assign({}, layout_container_default, {
  install(app) {
    app.component(layout_container_default.name, layout_container_default);
  }
});
dynamicApp.component(layout_container_default.name, layout_container_default);
VxeUI.component(layout_container_default);
var LayoutContainer = VxeLayoutContainer;
var layout_container_default2 = VxeLayoutContainer;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-footer/src/layout-footer.js
var import_xe_utils76 = __toESM(require_xe_utils());
var layout_footer_default = defineComponent({
  name: "VxeLayoutFooter",
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils76.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { fixed, align } = props;
      const defaultSlot = slots.default;
      return h("footer", {
        ref: refElem,
        class: ["vxe-layout-footer", align ? `align--${align}` : "", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-footer/index.js
var VxeLayoutFooter = Object.assign({}, layout_footer_default, {
  install(app) {
    app.component(layout_footer_default.name, layout_footer_default);
  }
});
dynamicApp.component(layout_footer_default.name, layout_footer_default);
VxeUI.component(layout_footer_default);
var LayoutFooter = VxeLayoutFooter;
var layout_footer_default2 = VxeLayoutFooter;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-header/src/layout-header.js
var import_xe_utils77 = __toESM(require_xe_utils());
var layout_header_default = defineComponent({
  name: "VxeLayoutHeader",
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils77.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("header", {
        ref: refElem,
        class: ["vxe-layout-header", {
          "is--fixed": props.fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/layout-header/index.js
var VxeLayoutHeader = Object.assign({}, layout_header_default, {
  install(app) {
    app.component(layout_header_default.name, layout_header_default);
  }
});
dynamicApp.component(layout_header_default.name, layout_header_default);
VxeUI.component(layout_header_default);
var LayoutHeader = VxeLayoutHeader;
var layout_header_default2 = VxeLayoutHeader;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/link/src/link.js
var import_xe_utils78 = __toESM(require_xe_utils());
var link_default = defineComponent({
  name: "VxeLink",
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: { type: String, default: () => getConfig().link.size || getConfig().size }
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils78.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = import_xe_utils78.default.toValueString(content);
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-link--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        defaultSlot || textContent ? h("span", {
          class: "vxe-link--content"
        }, defaultSlot ? defaultSlot({}) : textContent) : createCommentVNode()
      ];
    };
    const renderVN = () => {
      const { status, target, href, title, underline, routerLink } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          class: ["vxe-link", {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            "is--underline": underline
          }],
          title,
          target,
          to: routerLink
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("a", {
        ref: refElem,
        href,
        target,
        title,
        class: ["vxe-link", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--underline": underline
        }]
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/link/index.js
var VxeLink = Object.assign({}, link_default, {
  install(app) {
    app.component(link_default.name, link_default);
  }
});
dynamicApp.component(link_default.name, link_default);
VxeUI.component(link_default);
var Link = VxeLink;
var link_default2 = VxeLink;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var import_xe_utils81 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/render/util.js
var createListDesignActionButton = (btnObj) => {
  return Object.assign({
    name: "",
    icon: "",
    type: "",
    classify: "",
    code: "",
    status: "",
    permissionCode: ""
  }, btnObj);
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/src/default-setting-data.js
var getDefaultSettingFormData2 = () => {
  return {
    listView: {
      enabled: true
    },
    ganttView: {
      enabled: false
    },
    chartView: {
      enabled: false
    },
    autoFoldFilter: true,
    showCheckbox: "auto",
    showSeq: true,
    showSummary: true,
    mobileDefaultView: "list",
    pcDefaultView: "list",
    actionButtonList: []
  };
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/src/layout-preview.js
var import_xe_utils79 = __toESM(require_xe_utils());
var layout_preview_default2 = defineComponent({
  name: "ListDesignLayoutView",
  props: {},
  emits: [],
  setup() {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refGrid = ref();
    const tableData = ref([]);
    const computeFormItems = computed(() => {
      const { searchFormItems } = listDesignReactData;
      if (searchFormItems.length) {
        return searchFormItems.concat([
          {
            field: "active",
            title: "",
            folding: false,
            collapseNode: searchFormItems.some((item) => item.folding),
            itemRender: {
              name: "VxeButtonGroup",
              options: [
                { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
                { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
              ]
            }
          }
        ]);
      }
      return searchFormItems;
    });
    const computeTableColumn = computed(() => {
      const { formData, listTableColumns } = listDesignReactData;
      const { showSeq, actionButtonList } = formData;
      const columns = [];
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          width: 70
        });
      }
      listTableColumns.forEach((item) => {
        columns.push({
          field: item.field,
          title: item.title,
          visible: item.visible,
          width: item.width
        });
      });
      if (actionButtonList && actionButtonList.length) {
        columns.push({
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto",
          cellRender: {
            name: "VxeButtonGroup",
            options: []
          }
        });
      }
      return columns;
    });
    const updateColumnWidthEvent = ({ column, resizeWidth }) => {
      const { listTableColumns } = listDesignReactData;
      const rest = import_xe_utils79.default.findTree(listTableColumns, (item) => item.field === column.field, { children: "children" });
      if (rest) {
        const { item } = rest;
        item.width = resizeWidth;
      }
    };
    const updateTableData = () => {
      const { listTableColumns } = listDesignReactData;
      const data = [{}, {}];
      data.forEach((row) => {
        listTableColumns.forEach((column) => {
          row[column.field] = "-";
        });
      });
      tableData.value = data;
    };
    const dataFlag = ref(0);
    watch(() => listDesignReactData.listTableColumns ? listDesignReactData.listTableColumns.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => listDesignReactData.listTableColumns, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateTableData();
    });
    onMounted(() => {
      updateTableData();
    });
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    return () => {
      const { searchFormData, searchFormItems } = listDesignReactData;
      const formItems = computeFormItems.value;
      const tableColumn = computeTableColumn.value;
      return h("div", {
        class: "vxe-list-design--preview"
      }, [
        h("div", {
          class: "vxe-list-design--preview-wrapper"
        }, [
          h("div", {
            class: "vxe-list-design--preview-search"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.searchTitle")),
            searchFormItems.length ? h(form_default, {
              data: searchFormData,
              items: formItems
            }) : h("div", {
              class: "vxe-list-design--field-configs-empty-data"
            }, [
              h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
            ])
          ]),
          h("div", {
            class: "vxe-list-design--preview-table"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.listTitle")),
            VxeTableGridComponent ? h(VxeTableGridComponent, {
              ref: refGrid,
              columns: tableColumn,
              data: tableData.value,
              showOverflow: true,
              border: true,
              columnConfig: {
                minWidth: "auto",
                resizable: true
              },
              rowConfig: {
                isHover: true
              },
              scrollX: {
                enabled: false
              },
              scrollY: {
                enabled: false
              },
              onResizableChange: updateColumnWidthEvent
            }) : createCommentVNode()
          ])
        ])
      ]);
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/src/default-setting-form.js
var import_xe_utils80 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps2 = ref({});
var DefaultFieldSettingFormComponent = defineComponent({
  name: "DefaultFieldSettingForm",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refIsAllChecked = ref(false);
    const refIsAllIndeterminate = ref(false);
    const changeVisible = (item) => {
      item.visible = !item.visible;
      listDesignReactData.listTableColumns = listDesignReactData.listTableColumns.slice(0);
    };
    const addSearchEvent = () => {
      const { listTableColumns, searchFormItems } = listDesignReactData;
      const widgetReactConfigMaps = refWidgetReactConfigMaps2.value;
      const allFormItemList = [];
      listTableColumns.forEach((item) => {
        const { cellRender } = item;
        if (cellRender) {
          const conf = searchFormItems.find((conf2) => conf2.field === item.field);
          const name = cellRender.name || "";
          let widgetConfig = widgetReactConfigMaps[name];
          if (!widgetConfig) {
            const compConf = renderer.get(name);
            if (compConf) {
              const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
              if (createWidgetFormConfig) {
                const params = { name, $formDesign: null };
                widgetConfig = createWidgetFormConfig(params) || {};
                widgetReactConfigMaps[name] = widgetConfig;
              }
            }
          }
          if (widgetConfig.query) {
            allFormItemList.push(Object.assign(Object.assign({}, item), { checked: !!conf, isHalf: false, folding: conf ? !!conf.folding : false }));
          }
        }
      });
      refWidgetReactConfigMaps2.value = Object.assign({}, widgetReactConfigMaps);
      const refAllFormItemList = ref(allFormItemList);
      const checkOptionStatus = () => {
        const allFormItemList2 = refAllFormItemList.value;
        refIsAllChecked.value = allFormItemList2.every((item) => item.checked);
        refIsAllIndeterminate.value = !refIsAllChecked.value && allFormItemList2.some((item) => item.checked || item.isHalf);
      };
      const handleOptionCheck = (item) => {
        const allFormItemList2 = refAllFormItemList.value;
        const matchObj = import_xe_utils80.default.findTree(allFormItemList2, (obj) => obj === item);
        if (matchObj && matchObj.parent) {
          const { parent } = matchObj;
          if (parent.children && parent.children.length) {
            parent.checked = parent.children.every((obj) => obj.checked);
            parent.isHalf = !parent.checked && parent.children.some((obj) => obj.checked || obj.isHalf);
            handleOptionCheck(parent);
          }
        }
      };
      const changeCheckboxOption = (item) => {
        const isChecked = !item.checked;
        import_xe_utils80.default.eachTree([item], (obj) => {
          obj.checked = isChecked;
          obj.isHalf = false;
        });
        handleOptionCheck(item);
        checkOptionStatus();
      };
      const allOptionEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const isAll = !refIsAllChecked.value;
        import_xe_utils80.default.eachTree(allFormItemList2, (item) => {
          item.checked = isAll;
          item.isHalf = false;
        });
        refIsAllChecked.value = isAll;
        checkOptionStatus();
      };
      const confirmEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const searchItems = [];
        allFormItemList2.forEach((item) => {
          if (item.checked) {
            searchItems.push({
              field: item.field,
              title: item.title,
              folding: item.folding,
              itemRender: Object.assign({}, item.cellRender)
            });
          }
        });
        $xeListDesign.setSearchItems(searchItems);
      };
      VxeUI.modal.open({
        title: "编辑查询字段",
        width: 680,
        height: 500,
        showFooter: true,
        escClosable: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: "保存",
        showZoom: true,
        resize: true,
        onConfirm: confirmEvent,
        slots: {
          default() {
            const isAllChecked = refIsAllChecked.value;
            const isAllIndeterminate = refIsAllIndeterminate.value;
            const allFormItemList2 = refAllFormItemList.value;
            return h("div", {
              class: "vxe-list-design--field-search-popup"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col")
                  // h('col', {
                  //   style: {
                  //     width: '140px'
                  //   }
                  // })
                ]),
                h("thead", {}, [
                  h("th", {}, [
                    h("div", {
                      class: ["vxe-list-design--field-search-checkbox-option", {
                        "is--checked": isAllChecked,
                        "is--indeterminate": isAllIndeterminate
                      }],
                      title: getI18n("vxe.table.allTitle"),
                      onClick: allOptionEvent
                    }, [
                      h("span", {
                        class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                      }),
                      h("span", {
                        class: "vxe-checkbox--label"
                      }, getI18n("vxe.toolbar.customAll"))
                    ])
                  ]),
                  h("th", {}, "标题")
                  // h('th', {}, '展开/折叠')
                ]),
                h("tbody", {}, allFormItemList2.map((item) => {
                  const isChecked = item.checked;
                  const isIndeterminate = item.isHalf;
                  return h("tr", {}, [
                    h("td", {
                      class: "vxe-list-design--field-search-option-item col--visible"
                    }, [
                      h("div", {
                        class: ["vxe-list-design--field-search-checkbox-option", {
                          "is--checked": isChecked,
                          "is--indeterminate": isIndeterminate
                        }],
                        title: getI18n("vxe.custom.setting.colVisible"),
                        onClick: () => {
                          changeCheckboxOption(item);
                        }
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                        })
                      ])
                    ]),
                    h("td", {
                      class: "vxe-list-design--field-search-option-item"
                    }, `${item.title || ""}`)
                    // h('td', {}, [
                    //   h(VxeRadioGroupComponent, {
                    //     modelValue: item.folding,
                    //     type: 'button',
                    //     options: foldOptions.value,
                    //     size: 'mini',
                    //     'onUpdate:modelValue' (val) {
                    //       item.folding = val
                    //     }
                    //   })
                    // ])
                  ]);
                }))
              ])
            ]);
          }
        }
      });
    };
    const renderChildOptions = (item) => {
      const { children } = item;
      if (children && children.length) {
        return h("div", {
          class: "vxe-list-design--field-option-item"
        }, [
          h("div", {
            class: "vxe-list-design--field-sub-option",
            onClick() {
              changeVisible(item);
            }
          }, children.map((child) => {
            const { title, visible: isChecked } = child;
            return h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(child);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ]);
          }))
        ]);
      }
      return createCommentVNode();
    };
    const renderFieldOptions = () => {
      const { listTableColumns } = listDesignReactData;
      return listTableColumns.map((item) => {
        const { title, visible: isChecked } = item;
        return h("div", {
          class: "vxe-list-design--field-options"
        }, [
          h("div", {
            class: "vxe-list-design--field-option-item"
          }, [
            h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(item);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ])
          ]),
          renderChildOptions(item)
        ]);
      });
    };
    return () => {
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.listDesign.searchField")
            }, {
              extra() {
                return h(button_default, {
                  mode: "text",
                  status: "primary",
                  icon: getIcon().FORM_DESIGN_PROPS_EDIT,
                  content: getI18n("vxe.listDesign.search.addBtn"),
                  onClick: addSearchEvent
                });
              },
              default() {
                const { searchFormItems } = listDesignReactData;
                return [
                  searchFormItems.length ? h("div", {
                    class: ""
                  }, [
                    h("div", {}, searchFormItems.map((item) => {
                      return h("div", {
                        class: ""
                      }, `${item.title || ""}`);
                    }))
                  ]) : h("div", {
                    class: "vxe-list-design--field-configs-empty-data"
                  }, [
                    h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.listDesign.listField")
            }, {
              default() {
                return renderFieldOptions();
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultParameterSettingFormComponent = defineComponent({
  name: "DefaultListSettingTabComponent",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { props: listDesignProps, reactData: listDesignReactData } = $xeListDesign;
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const renderViewList = ref([
      { label: "列表视图", value: "list", isExpand: false }
    ]);
    const refSeqOpts = ref([
      { label: "显示", value: true },
      { label: "隐藏", value: false }
    ]);
    const refCheckboxOpts = ref([
      { label: "默认", value: "auto" },
      { label: "允许", value: true },
      { label: "不允许", value: false }
    ]);
    const disableView = computed(() => {
      const { formData } = listDesignReactData;
      return [formData.listView.enabled, formData.ganttView.enabled, formData.chartView.enabled].filter((enabled) => enabled).length <= 1;
    });
    const openActiveBtnPopup = (activeBtnObj) => {
      const { formData } = listDesignReactData;
      const { actionCodes } = listDesignProps;
      let btnList = formData.actionButtonList;
      if (!btnList) {
        btnList = [];
      }
      const activeBtnItem = reactive(createListDesignActionButton(activeBtnObj));
      const systemBtnList = systemConfigList.filter((item) => {
        if (actionCodes && actionCodes.length) {
          if (!actionCodes.some((conf) => import_xe_utils80.default.isString(conf) ? item.code === conf : conf.code === item.code)) {
            return false;
          }
        }
        return !btnList.some((obj) => obj.code === item.code);
      });
      const customBtnList = customConfigList.filter((item) => !btnList.some((obj) => obj.code === item.code));
      const btOptions = [];
      if (systemBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "";
        }
        btOptions.push({ value: "", label: "系统按钮" });
      }
      if (customBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "custom";
        }
        btOptions.push({ value: "custom", label: "自定义按钮" });
      }
      const refSystemConfigOptions = computed(() => {
        return systemBtnList.map((item) => {
          const nameConfig = item.name;
          return {
            label: import_xe_utils80.default.toValueString(import_xe_utils80.default.isFunction(nameConfig) ? nameConfig({ name: item.code || "" }) : nameConfig),
            value: item.code
          };
        });
      });
      const refBtnTypeOptions = ref(btOptions);
      VxeUI.modal.open({
        title: "添加按钮",
        width: 600,
        height: 400,
        showFooter: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: "保存",
        onConfirm() {
          if (activeBtnItem.type === "custom") {
            btnList.push(activeBtnItem);
          } else {
            btnList.push(activeBtnItem);
          }
          formData.actionButtonList = [...btnList];
        },
        slots: {
          default() {
            return h(form_default, {
              vertical: true,
              titleBold: true
            }, {
              default() {
                return [
                  h(form_item_default, {
                    title: "按钮类型",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.type,
                        options: refBtnTypeOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.type = val;
                        }
                      });
                    }
                  }),
                  h(form_item_default, {
                    title: "选择系统按钮",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.code,
                        options: refSystemConfigOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.code = val;
                        }
                      });
                    }
                  })
                  // h(VxeFormItemComponent, {
                  //   title: '按钮位置',
                  //   span: 24
                  // }, {
                  //   default () {
                  //     return h(VxeSelectComponent, {
                  //       modelValue: activeBtnItem.classify,
                  //       options: refBtnClassifyOptions.value,
                  //       'onUpdate:modelValue' (val) {
                  //         activeBtnItem.classify = val
                  //       }
                  //     })
                  //   }
                  // })
                ];
              }
            });
          }
        }
      });
    };
    const renderDefaultCellActionButton = () => {
      return h(form_item_default, {
        title: "功能按钮"
      }, {
        extra() {
          return h(button_default, {
            mode: "text",
            status: "primary",
            icon: getIcon().FORM_DESIGN_PROPS_ADD,
            content: "新增",
            onClick() {
              openActiveBtnPopup();
            }
          });
        },
        default() {
          const { formData } = listDesignReactData;
          const btnList = formData.actionButtonList;
          return btnList && btnList.length ? h("div", {
            class: "vxe-list-design--field-configs-wrapper"
          }, btnList.map((btnItem) => {
            let btnIcon = "";
            let btnName = "";
            if (btnItem.type === "custom") {
              btnIcon = btnItem.icon;
              btnName = btnItem.name;
            } else {
              const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
              if (btnConfig) {
                const nameConfig = btnConfig.name;
                btnIcon = btnConfig.icon || "";
                btnName = import_xe_utils80.default.toValueString(import_xe_utils80.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
              }
            }
            return h("div", {
              class: "vxe-list-design--field-configs-item"
            }, [
              btnIcon ? h("div", {
                class: "vxe-list-design--field-configs-item-icon"
              }, [
                h("i", {
                  class: btnIcon
                })
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-list-design--field-configs-item-title"
              }, `${btnName || ""}`),
              h("div", {
                class: "vxe-list-design--field-configs-item-btn"
              }, [
                h(button_default, {
                  icon: getIcon().LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE,
                  mode: "text",
                  status: "error",
                  onClick() {
                    formData.actionButtonList = btnList.filter((item) => item !== btnItem);
                  }
                })
              ])
            ]);
          })) : h("div", {
            class: "vxe-list-design--field-configs-empty-data"
          }, [
            h("span", {}, "无操作按钮")
          ]);
        }
      });
    };
    return () => {
      const { showPc, showMobile } = listDesignProps;
      const { formData } = listDesignReactData;
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: "视图配置"
            }, {
              default() {
                return h("div", {
                  class: "vxe-form-design--widget-form-item-render-view"
                }, renderViewList.value.map((item) => {
                  return h("div", {
                    key: item.value,
                    class: "vxe-form-design--widget-form-item-render-view-item"
                  }, [
                    h(switch_default, {
                      modelValue: formData.listView.enabled,
                      disabled: disableView.value,
                      "onUpdate:modelValue"(val) {
                        formData.listView.enabled = val;
                      }
                    }),
                    h(text_default, {
                      content: item.label,
                      icon: "vxe-icon-table"
                    })
                  ]);
                }));
              }
            }),
            h(form_item_default, {
              title: "默认视图"
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    showPc ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_PC,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.pcDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.pcDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode(),
                    showMobile ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.mobileDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.mobileDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode()
                  ])
                ];
              }
            }),
            // h(VxeFormItemComponent, {
            //   title: '查询配置'
            // }, {
            //   default () {
            //     const { formData } = listDesignReactData
            //     return [
            //       h('div', {
            //         class: 'vxe-list-design--widget-form-item-prop-list'
            //       }, [
            //         h('span', {}, '折叠字段'),
            //         h(VxeRadioGroupComponent, {
            //           modelValue: formData.autoFoldFilter,
            //           options: refFoldOpts.value,
            //           'onUpdate:modelValue' (val) {
            //             formData.autoFoldFilter = val
            //           }
            //         })
            //       ])
            //     ]
            //   }
            // }),
            h(form_item_default, {
              title: "列配置"
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return [
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, "显示序号"),
                    h(group_default2, {
                      modelValue: formData2.showSeq,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showSeq = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, "表尾汇总"),
                    h(group_default2, {
                      modelValue: formData2.showSummary,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showSummary = val;
                      }
                    })
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: "批量操作"
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return h(group_default2, {
                  modelValue: formData2.showCheckbox,
                  options: refCheckboxOpts.value,
                  "onUpdate:modelValue"(val) {
                    formData2.showCheckbox = val;
                  }
                });
              }
            }),
            systemConfigList.length || customConfigList.length ? renderDefaultCellActionButton() : createCommentVNode()
          ];
        }
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/src/layout-setting.js
var layout_setting_default2 = defineComponent({
  name: "ListDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const activeTab = ref(1);
    return () => {
      return h("div", {
        class: "vxe-list-design--setting"
      }, [
        h("div", {
          class: "vxe-list-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-list-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.fieldSettingTab"),
                  icon: getIcon().LIST_DESIGN_FIELD_SETTING,
                  name: 1
                }, {
                  default() {
                    return h(DefaultFieldSettingFormComponent);
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.listSettingTab"),
                  icon: getIcon().LIST_DESIGN_LIST_SETTING,
                  name: 2
                }, {
                  default() {
                    return h(DefaultParameterSettingFormComponent);
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var list_design_default = defineComponent({
  name: "VxeListDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().listDesign.size
    },
    height: {
      type: [String, Number],
      default: () => getConfig().listDesign.height
    },
    config: Object,
    showPc: {
      type: Boolean,
      default: () => getConfig().listDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().listDesign.showMobile
    },
    actionCodes: Array,
    formRender: Object
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils81.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      formData: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeListDesign = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const parseWidgetColumn = (widget) => {
      return {
        title: widget.title,
        field: widget.field,
        visible: !widget.hidden,
        width: "",
        cellRender: {
          name: widget.name,
          props: widget.options
        }
      };
    };
    const parseFormDesignColumns = (config2) => {
      const tableColumns = [];
      if (config2) {
        const { widgetData } = config2;
        if (widgetData) {
          widgetData.forEach((item) => {
            const { name } = item;
            if (name) {
              if (name === "row") {
                item.children.forEach((childItem) => {
                  if (childItem.name) {
                    tableColumns.push(parseWidgetColumn(childItem));
                  }
                });
              } else if (name === "subTable") {
              } else {
                tableColumns.push(parseWidgetColumn(item));
              }
            }
          });
        }
      }
      return tableColumns;
    };
    const configToSearchItems = (searchItems) => {
      if (searchItems) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils81.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const loadConfig = (config2) => {
      const { formConfig, searchItems, listColumns } = config2;
      if (formConfig) {
        loadFormConfig(formConfig);
      }
      if (searchItems) {
        setSearchItems(searchItems);
      }
      if (listColumns) {
        reactData.listTableColumns = parseColumnConfigs(listColumns);
      }
      return nextTick();
    };
    const parseColumnConfigs = (listColumns) => {
      return configToListColumns(listColumns);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getSearchItems = () => {
      return reactData.searchFormItems;
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      return nextTick();
    };
    const getListColumns = () => {
      return reactData.listTableColumns;
    };
    const setListColumns = (listColumns) => {
      reactData.listTableColumns = parseColumnConfigs(listColumns);
      return nextTick();
    };
    const createSettingForm = () => {
      const { actionCodes, formRender } = props;
      let conf = getDefaultSettingFormData2();
      if (actionCodes && actionCodes.length) {
        if (!conf.actionButtonList || !conf.actionButtonList.length) {
          const defActionBtnList = [];
          actionCodes.forEach((item) => {
            if (import_xe_utils81.default.isObject(item) && item.default) {
              const sysItem = systemConfigList.find((obj) => obj.code === item.code);
              if (sysItem) {
                defActionBtnList.push(createListDesignActionButton({
                  type: sysItem.type,
                  code: sysItem.code
                }));
              }
            }
          });
          conf.actionButtonList = defActionBtnList;
        }
      }
      if (formRender && formRender.name) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createListDesignSettingFormConfig : null;
        const params = { name: formRender.name };
        conf = (createFormConfig ? createFormConfig(params) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const clearConfig = () => {
      loadConfig({
        searchItems: [],
        listColumns: []
      });
      initSettingForm();
      return nextTick();
    };
    const listDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $listDesign: $xeListDesign }, params));
      },
      loadFormDesignConfig(config2) {
        const { listTableColumns } = reactData;
        const oldMaps = {};
        import_xe_utils81.default.eachTree(listTableColumns, (item) => {
          oldMaps[item.field] = item;
        }, { children: "children" });
        const columns = parseFormDesignColumns(config2);
        import_xe_utils81.default.eachTree(columns, (item) => {
          const oldItem = oldMaps[item.field];
          if (oldItem) {
            if (oldItem.width) {
              item.width = oldItem.width;
            }
            item.visible = oldItem.visible;
          }
        }, { children: "children" });
        reactData.listTableColumns = columns;
        return nextTick();
      },
      reloadFormDesignConfig(config2) {
        reactData.listTableColumns = parseFormDesignColumns(config2);
        return nextTick();
      },
      getSearchItems,
      setSearchItems,
      getListColumns,
      setListColumns,
      getConfig() {
        return {
          formConfig: reactData.formData,
          searchItems: getSearchItems(),
          listColumns: getListColumns()
        };
      },
      loadConfig,
      reloadConfig(config2) {
        clearConfig();
        return loadConfig(config2);
      },
      clearConfig
    };
    const listDesignPrivateMethods = {};
    Object.assign($xeListDesign, listDesignMethods, listDesignPrivateMethods);
    const renderVN = () => {
      const { height } = props;
      const headerSlot = slots.header;
      return h("div", {
        ref: refElem,
        class: "vxe-list-design",
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-design--header"
        }, headerSlot ? headerSlot({}) : []),
        h("div", {
          class: "vxe-list-design--body"
        }, [
          h(layout_preview_default2),
          h(layout_setting_default2)
        ])
      ]);
    };
    $xeListDesign.renderVN = renderVN;
    provide("$xeListDesign", $xeListDesign);
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    if (props.config) {
      loadConfig(props.config);
    }
    return $xeListDesign;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/render/index.js
renderer.mixin({
  // ActionButtonUpdate: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-edit',
  //       status: 'primary'
  //     }
  //   }
  // },
  // ActionButtonDelete: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-delete',
  //       status: 'error'
  //     }
  //   }
  // }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/index.js
var VxeListDesign = Object.assign({}, list_design_default, {
  install(app) {
    app.component(list_design_default.name, list_design_default);
  }
});
var listDesign = {};
dynamicApp.component(list_design_default.name, list_design_default);
VxeUI.component(list_design_default);
VxeUI.listDesign = listDesign;
var ListDesign = VxeListDesign;
var list_design_default2 = VxeListDesign;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-design/src/list-view.js
var import_xe_utils82 = __toESM(require_xe_utils());
var list_view_default = defineComponent({
  name: "VxeListView",
  props: {
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().listView.height
    },
    loading: Boolean,
    formData: Object,
    actionButtons: Array,
    gridOptions: Object,
    gridEvents: Object,
    viewRender: Object
  },
  emits: [
    "cell-action",
    "update:formData",
    "update:actionButtons"
  ],
  setup(props, context) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const { emit, slots } = context;
    const xID = import_xe_utils82.default.uniqueId();
    const refElem = ref();
    const refGrid = ref();
    const reactData = reactive({
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: [],
      tableColumns: []
    });
    const computeGridOptions = computed(() => {
      const { gridOptions } = props;
      const { tableColumns, searchFormData, searchFormItems } = reactData;
      const gridOpts = gridOptions || {};
      const columnOpts = Object.assign({
        minWidth: 120
      }, gridOpts.columnConfig);
      let proxyOpts;
      if (gridOpts.proxyConfig) {
        proxyOpts = Object.assign({ autoLoad: false }, gridOpts.proxyConfig);
      }
      return Object.assign({}, gridOpts, {
        columns: tableColumns,
        columnConfig: columnOpts,
        formConfig: {
          data: searchFormData,
          items: searchFormItems
        },
        proxyConfig: proxyOpts
      });
    });
    const computeGridEvents = computed(() => {
      const { gridEvents } = props;
      const ons = {};
      import_xe_utils82.default.each(gridEvents, (fn, key) => {
        ons[import_xe_utils82.default.camelCase(`on-${key}`)] = fn;
      });
      return ons;
    });
    const refMaps = {
      refElem,
      refGrid
    };
    const computeMaps = {};
    const $xeListView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const configToSearchItems = (searchItems) => {
      if (searchItems && searchItems.length) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        items.push({
          field: "active",
          title: "",
          folding: false,
          collapseNode: searchItems.some((item) => item.folding),
          itemRender: {
            name: "VxeButtonGroup",
            options: [
              { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
              { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
            ]
          }
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils82.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const clearConfig = () => {
      emit("update:formData", {});
      reactData.searchFormData = {};
      reactData.searchFormItems = [];
      reactData.listTableColumns = [];
      reactData.tableColumns = [];
      return nextTick();
    };
    const loadConfig = (config2) => {
      if (config2) {
        const { formConfig, searchItems, listColumns } = config2;
        setSearchItems(searchItems || []);
        loadListColumns(listColumns || [], formConfig || {});
      }
      return nextTick();
    };
    const parseForm = (searchItems) => {
      return configToSearchItems(searchItems || []);
    };
    const parseTableColumn = (listColumns, formConfig) => {
      const formOpts = Object.assign({}, formConfig);
      const { showSeq, actionButtonList } = formOpts;
      const columns = [];
      const cellActionSlot = slots.cellAction;
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          width: 70
        });
      }
      configToListColumns(listColumns || []).forEach((conf) => {
        columns.push(conf);
      });
      if (actionButtonList && actionButtonList.length) {
        const actionColumn = {
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto"
        };
        const btnOptions = [];
        actionButtonList.forEach((btnItem) => {
          if (btnItem.type === "custom") {
            return {
              content: btnItem.name,
              name: btnItem.code,
              icon: btnItem.icon
            };
          }
          const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
          let btnName = btnItem.name;
          let btnIcon = btnItem.icon;
          let btnStatus = btnItem.status;
          let btnPermissionCode = btnItem.permissionCode;
          let btnClassify = btnItem.classify;
          if (btnConfig) {
            const nameConfig = btnConfig.name;
            btnIcon = btnConfig.icon || "";
            btnStatus = btnConfig.status || "";
            btnPermissionCode = btnConfig.permissionCode || "";
            btnClassify = btnConfig.classify || "";
            btnName = import_xe_utils82.default.toValueString(import_xe_utils82.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
          }
          if (!btnClassify || btnClassify === "cellButton") {
            btnOptions.push({
              content: btnName,
              name: btnItem.code,
              icon: btnIcon,
              status: btnStatus,
              permissionCode: btnPermissionCode
            });
          }
        });
        if (cellActionSlot) {
          actionColumn.slots = {
            default(params) {
              return cellActionSlot(Object.assign(Object.assign({}, params), { buttons: btnOptions }));
            }
          };
        } else {
          actionColumn.cellRender = {
            name: "VxeButtonGroup",
            props: {
              mode: "text"
            },
            options: btnOptions,
            events: {
              click(params, btnParams) {
                const { option } = btnParams;
                dispatchEvent2("cell-action", Object.assign(Object.assign({}, params), { button: option }), btnParams.$event);
              }
            }
          };
        }
        columns.push(actionColumn);
      }
      return { columns, actionButtons: actionButtonList };
    };
    const parseConfig = (config2) => {
      const { formConfig, searchItems, listColumns } = config2 || {};
      const { columns, actionButtons } = parseTableColumn(listColumns || [], formConfig);
      const { data, items } = parseForm(searchItems || []);
      return {
        formData: data,
        formItems: items,
        tableColumns: columns,
        actionButtons
      };
    };
    const getQueryFilter = () => {
      const { searchFormData, searchFormItems } = reactData;
      const items = [];
      const rest = {
        items,
        type: "and"
      };
      const $grid = refGrid.value;
      if (!$grid) {
        return rest;
      }
      searchFormItems.forEach((item) => {
        const { field } = item;
        const itemValue = searchFormData[field];
        if (itemValue) {
          const condition = [];
          condition.push({
            field,
            value: itemValue,
            match: "",
            type: import_xe_utils82.default.isArray(itemValue) ? "array" : ""
          });
          items.push({
            condition,
            type: "and"
          });
        }
      });
      return rest;
    };
    const commitProxy = (code, ...args) => {
      const $grid = refGrid.value;
      if ($grid) {
        return $grid.commitProxy(code, ...args);
      }
      return Promise.resolve();
    };
    const loadListColumns = (listColumns, formConfig) => {
      const listTableColumns = listColumns || [];
      const { columns, actionButtons } = parseTableColumn(listTableColumns, formConfig);
      reactData.listTableColumns = listTableColumns;
      reactData.tableColumns = columns;
      emit("update:actionButtons", actionButtons);
      nextTick(() => {
        const gridOptions = computeGridOptions.value;
        if (gridOptions.proxyConfig) {
          commitProxy("reload");
        }
      });
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      emit("update:formData", data);
      return nextTick();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $listView: $xeListView }, params));
    };
    const listViewMethods = {
      dispatchEvent: dispatchEvent2,
      clearConfig,
      loadConfig,
      parseConfig,
      getQueryFilter,
      commitProxy
    };
    const listViewPrivateMethods = {};
    Object.assign($xeListView, listViewMethods, listViewPrivateMethods);
    const renderVN = () => {
      const { height, loading: loading2 } = props;
      const gridSlot = slots.grid;
      const gridOptions = computeGridOptions.value;
      const gridEvents = computeGridEvents.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list-view", {
          "is--loading": loading2
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-view--body"
        }, [
          gridSlot ? h("div", {
            class: "vxe-list-view--grid-wrapper"
          }, getSlotVNs(gridSlot({ $listView: $xeListView }))) : VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign({}, gridOptions, gridEvents, {
            ref: refGrid
          }), Object.assign({}, slots, {
            default: void 0
          })) : createCommentVNode()
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeListView.renderVN = renderVN;
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeListView", $xeListView);
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    return $xeListView;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list-view/index.js
var VxeListView = Object.assign(list_view_default, {
  install: function(app) {
    app.component(list_view_default.name, list_view_default);
  }
});
dynamicApp.component(list_view_default.name, list_view_default);
VxeUI.component(list_view_default);
var ListView = VxeListView;
var list_view_default2 = VxeListView;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list/src/list.js
var import_xe_utils83 = __toESM(require_xe_utils());
var list_default = defineComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => getConfig().list.size || getConfig().size },
    autoResize: { type: Boolean, default: () => getConfig().list.autoResize },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils83.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      scrollYLoad: false,
      bodyHeight: 0,
      rowHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const refElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const internalData = {
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let listMethods = {};
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig().list.scrollY, props.scrollY);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const style = {};
      if (height) {
        style.height = `${isNaN(height) ? height : `${height}px`}`;
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = `${isNaN(maxHeight) ? maxHeight : `${maxHeight}px`}`;
      }
      return style;
    });
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, fullData } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad } = reactData;
      const { fullData, scrollYStore } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? import_xe_utils83.default.toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
        reactData.rowHeight = rowHeight;
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick();
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (import_xe_utils83.default.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (import_xe_utils83.default.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el = refElem.value;
      if (el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      listMethods.dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    listMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $list: $xeList }, params));
      },
      /**
       * 加载数据
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const { scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const fullData = datas || [];
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 1,
          visibleSize: 0
        });
        internalData.fullData = fullData;
        reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
        handleData();
        return computeScrollLoad().then(() => {
          refreshScroll();
        });
      },
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return listMethods.loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      listMethods.loadData(props.data || []);
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        recalculate();
        nextTick(() => setTimeout(() => recalculate()));
      }
    });
    onActivated(() => {
      recalculate().then(() => refreshScroll());
    });
    let resizeObserver;
    nextTick(() => {
      globalEvents.on($xeList, "resize", () => {
        recalculate();
      });
      if (props.autoResize) {
        const el = refElem.value;
        resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el);
      }
      listMethods.loadData(props.data || []);
    });
    onUnmounted(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, "resize");
    });
    const renderVN = () => {
      const { className, loading: loading2 } = props;
      const { bodyHeight, topSpaceHeight, items } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list", className ? import_xe_utils83.default.isFunction(className) ? className({ $list: $xeList }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
            }
          }, defaultSlot ? defaultSlot({ items, $list: $xeList }) : [])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/list/index.js
var VxeList = Object.assign(list_default, {
  install(app) {
    app.component(list_default.name, list_default);
  }
});
dynamicApp.component(list_default.name, list_default);
VxeUI.component(list_default);
var List = VxeList;
var list_default2 = VxeList;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/menu/src/menu.js
var import_xe_utils84 = __toESM(require_xe_utils());
var menu_default = defineComponent({
  name: "VxeMenu",
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    collapsed: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    }
  },
  emits: [
    "update:modelValue",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils84.default.uniqueId();
    const $xeLayoutAside = inject("$xeLayoutAside", null);
    const refElem = ref();
    const refWrapperElem = ref();
    const reactData = reactive({
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = computed(() => {
      const { collapsed } = props;
      if (import_xe_utils84.default.isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return $xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeMaps = {};
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = (item) => {
      return `${item.title || item.name}`;
    };
    const updateItemHeight = () => {
      const wrapperElem = refWrapperElem.value;
      const childEls = wrapperElem ? wrapperElem.children : [];
      if (childEls.length) {
        reactData.itemHeight = childEls[0].offsetHeight;
      }
    };
    const getExpandChildSize = (item) => {
      let size = 0;
      if (item.isExpand) {
        item.childList.forEach((child) => {
          size += getExpandChildSize(child) + 1;
        });
      }
      return size;
    };
    const updateStyle = () => {
      import_xe_utils84.default.eachTree(reactData.menuList, (item) => {
        if (item.hasChild && item.isExpand) {
          item.childHeight = getExpandChildSize(item) * reactData.itemHeight;
        } else {
          item.childHeight = 0;
        }
      }, { children: "childList" });
    };
    const updateActiveMenu = (isDefExpand) => {
      const { activeName } = reactData;
      import_xe_utils84.default.eachTree(reactData.menuList, (item, index, items, path, parent, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach((obj) => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, { children: "childList" });
    };
    const updateMenuConfig = () => {
      const { expandAll } = props;
      reactData.menuList = import_xe_utils84.default.mapTree(props.options, (item, index, items, path, parent) => {
        const objItem = Object.assign(Object.assign({}, item), { parentKey: parent ? parent.name || path.slice(0, path.length - 1).join(",") : "", level: path.length, itemKey: item.name || path.join(","), isExactActive: false, isActive: false, isExpand: import_xe_utils84.default.isBoolean(item.expanded) ? item.expanded : !!expandAll, hasChild: item.children && item.children.length > 0, childHeight: 0 });
        return objItem;
      }, { children: "children", mapChildren: "childList" });
    };
    const handleClickIconCollapse = (evnt, item) => {
      const { hasChild, isExpand } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        item.isExpand = !isExpand;
        updateItemHeight();
        updateStyle();
      }
    };
    const handleClickMenu = (evnt, item) => {
      const { routerLink, hasChild } = item;
      if (routerLink) {
        reactData.activeName = item.itemKey;
        emit("update:modelValue", item.itemKey);
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item);
        }
      }
      emit("click", createEvent(evnt, { $menu: $xeMenu, menu: item }));
    };
    const renderMenuTitle = (item) => {
      const { icon, isExpand, hasChild } = item;
      const title = getMenuTitle(item);
      return [
        h("span", {
          class: "vxe-menu--item-link-icon"
        }, icon ? [
          h("i", {
            class: icon
          })
        ] : []),
        h("span", {
          class: "vxe-menu--item-link-title",
          title
        }, title),
        hasChild ? h("span", {
          class: "vxe-menu--item-link-collapse",
          onClick(evnt) {
            handleClickIconCollapse(evnt, item);
          }
        }, [
          h("i", {
            class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
          })
        ]) : createCommentVNode()
      ];
    };
    const renderChildren = (item) => {
      const { itemKey, level, hasChild, isActive, isExactActive, isExpand, routerLink, childList } = item;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return createCommentVNode();
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive,
          "is--expand": !isCollapsed && isExpand
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, {
          default: () => renderMenuTitle(item)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, renderMenuTitle(item)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group",
          style: {
            // height: `${childHeight}px`
          }
        }, childList.map((child) => renderChildren(child))) : createCommentVNode()
      ]);
    };
    const renderVN = () => {
      const { loading: loading2 } = props;
      const { menuList } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-menu", {
          "is--collapsed": isCollapsed,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          ref: refWrapperElem,
          class: "vxe-menu--item-list"
        }, menuList.map((child) => renderChildren(child))),
        /**
         * 加载中
         */
        h(loading_default2, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeMenu.renderVN = renderVN;
    const optFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    watch(() => props.options, () => {
      optFlag.value++;
    });
    watch(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    watch(() => props.modelValue, (val) => {
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    onMounted(() => {
      nextTick(updateItemHeight);
    });
    updateMenuConfig();
    updateActiveMenu(true);
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/menu/index.js
var VxeMenu = Object.assign({}, menu_default, {
  install(app) {
    app.component(menu_default.name, menu_default);
  }
});
dynamicApp.component(menu_default.name, menu_default);
VxeUI.component(menu_default);
var Menu = VxeMenu;
var menu_default2 = VxeMenu;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/modal/index.js
var import_xe_utils85 = __toESM(require_xe_utils());
function openModal(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveModals.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const modalOpts = Object.assign(options, {
        key: import_xe_utils85.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter((item) => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return import_xe_utils85.default.find(allActiveModals, ($modal) => $modal.props.id === id);
}
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach(($modal) => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (import_xe_utils85.default.isObject(content)) {
    opts = content;
  } else {
    opts = { content: import_xe_utils85.default.toValueString(content), title };
  }
  return openModal(Object.assign(Object.assign(Object.assign({}, defOpts), options), opts));
}
function openAlert(content, title, options) {
  return handleOpen({
    type: "alert",
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: "confirm",
    status: "question",
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: "message",
    mask: false,
    lockView: false,
    showHeader: false
  }, content, "", options);
}
function openNotification(content, title, options) {
  return handleOpen({
    type: "notification",
    mask: false,
    lockView: false,
    showHeader: true,
    draggable: false,
    position: "top-right",
    width: 320
  }, content, title, options);
}
var ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage,
  notification: openNotification
};
var VxeModal = Object.assign(modal_default, {
  install: function(app) {
    app.component(modal_default.name, modal_default);
  }
});
dynamicApp.component(modal_default.name, modal_default);
VxeUI.component(modal_default);
VxeUI.modal = ModalController;
var Modal = VxeModal;
var modal_default2 = VxeModal;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/number-input/index.js
var VxeNumberInput = Object.assign({}, number_input_default, {
  install(app) {
    app.component(number_input_default.name, number_input_default);
  }
});
dynamicApp.component(number_input_default.name, number_input_default);
VxeUI.component(number_input_default);
var NumberInput = VxeNumberInput;
var number_input_default2 = VxeNumberInput;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/select/src/util.js
var import_xe_utils87 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/select/src/option-info.js
var import_xe_utils86 = __toESM(require_xe_utils());
var OptionInfo = class {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: import_xe_utils86.default.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/select/src/util.js
function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      option.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el, option, optGroup) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const parentElem = el.parentNode;
  const parentOption = optGroup ? optGroup.option : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils87.default.arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const matchObj = import_xe_utils87.default.findTree(staticOptions, (item) => item.id === option.id, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/select/src/optgroup.js
var optgroup_default = defineComponent({
  name: "VxeOptgroup",
  props: {
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const option = createOption($xeSelect, props);
    const xeOption = { option };
    option.options = [];
    provide("xeoptgroup", xeOption);
    watchOption(props, option);
    onMounted(() => {
      assembleOption($xeSelect, elem.value, option);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, option);
    });
    return () => {
      return h("div", {
        ref: elem
      }, slots.default ? slots.default() : []);
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/optgroup/index.js
var VxeOptgroup = Object.assign(optgroup_default, {
  install: function(app) {
    app.component(optgroup_default.name, optgroup_default);
  }
});
dynamicApp.component(optgroup_default.name, optgroup_default);
VxeUI.component(optgroup_default);
var Optgroup = VxeOptgroup;
var optgroup_default2 = VxeOptgroup;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/select/src/option.js
var option_default = defineComponent({
  name: "VxeOption",
  props: {
    value: null,
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const optGroup = inject("xeoptgroup", null);
    const option = createOption($xeSelect, props);
    option.slots = slots;
    watchOption(props, option);
    onMounted(() => {
      assembleOption($xeSelect, elem.value, option, optGroup);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, option);
    });
    return () => {
      return h("div", {
        ref: elem
      });
    };
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/option/index.js
var VxeOption = Object.assign(option_default, {
  install: function(app) {
    app.component(option_default.name, option_default);
  }
});
dynamicApp.component(option_default.name, option_default);
VxeUI.component(option_default);
var Option = VxeOption;
var option_default2 = VxeOption;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/pager/src/pager.js
var import_xe_utils88 = __toESM(require_xe_utils());
var pager_default = defineComponent({
  name: "VxePager",
  props: {
    size: { type: String, default: () => getConfig().pager.size || getConfig().size },
    // 自定义布局
    layouts: { type: Array, default: () => getConfig().pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"] },
    // 当前页
    currentPage: { type: Number, default: 1 },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: { type: Number, default: () => getConfig().pager.pageSize || 10 },
    // 总条数
    total: { type: Number, default: 0 },
    // 显示页码按钮的数量
    pagerCount: { type: Number, default: () => getConfig().pager.pagerCount || 7 },
    // 每页大小选项列表
    pageSizes: { type: Array, default: () => getConfig().pager.pageSizes || [10, 15, 20, 50, 100] },
    // 列对其方式
    align: { type: String, default: () => getConfig().pager.align },
    // 带边框
    border: { type: Boolean, default: () => getConfig().pager.border },
    // 带背景颜色
    background: { type: Boolean, default: () => getConfig().pager.background },
    // 配套的样式
    perfect: { type: Boolean, default: () => getConfig().pager.perfect },
    // 当只有一页时隐藏
    autoHidden: { type: Boolean, default: () => getConfig().pager.autoHidden },
    transfer: { type: Boolean, default: () => getConfig().pager.transfer },
    className: [String, Function],
    pageSizePlacement: { type: String, default: () => getConfig().pager.pageSizePlacement },
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils88.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeGrid = inject("$xeGrid", null);
    const reactData = reactive({
      inpCurrPage: props.currentPage
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xePager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    let pagerMethods = {};
    let pagerPrivateMethods = {};
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const computePageCount = computed(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const jumpPageEvent = (evnt, currentPage) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const changeCurrentPage = (currentPage, evnt) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const triggerJumpEvent = (params) => {
      const { $event } = params;
      const inputElem = $event.target;
      const inpValue = import_xe_utils88.default.toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = import_xe_utils88.default.toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      changeCurrentPage(current, $event);
    };
    const computeNumList = computed(() => {
      const { pagerCount } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = computed(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = computed(() => {
      return props.pageSizes.map((item) => {
        if (import_xe_utils88.default.isNumber(item)) {
          return {
            value: item,
            label: `${getI18n("vxe.pager.pagesize", [item])}`
          };
        }
        return Object.assign({ value: "", label: "" }, item);
      });
    });
    const handleHomePage = (evnt) => {
      const { currentPage } = props;
      if (currentPage > 1) {
        changeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = (evnt) => {
      const numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = (evnt) => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = (params) => {
      const { value } = params;
      const pageSize = import_xe_utils88.default.toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit("update:currentPage", pageCount);
      }
      emit("update:pageSize", pageSize);
      pagerMethods.dispatchEvent("page-change", { type: "size", pageSize, currentPage }, params.$event);
    };
    const jumpKeydownEvent = (params) => {
      const { $event } = params;
      if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ENTER)) {
        triggerJumpEvent(params);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        $event.preventDefault();
        handleNextPage($event);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        $event.preventDefault();
        handlePrevPage($event);
      }
    };
    const renderHomePage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.homePageTitle"),
        onClick: handleHomePage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconHomePage || getIcon().PAGER_HOME]
        })
      ]);
    };
    const renderPrevPage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevPageTitle"),
        onClick: handlePrevPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconPrevPage || getIcon().PAGER_PREV_PAGE]
        })
      ]);
    };
    const renderPrevJump = (tagName) => {
      return h(tagName || "button", {
        class: ["vxe-pager--jump-prev", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevJumpTitle"),
        onClick: handlePrevJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpPrev || getIcon().PAGER_JUMP_PREV]
        })
      ]);
    };
    const renderNextJump = (tagName) => {
      const pageCount = computePageCount.value;
      return h(tagName || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextJumpTitle"),
        onClick: handleNextJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpNext || getIcon().PAGER_JUMP_NEXT]
        })
      ]);
    };
    const renderNextPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextPageTitle"),
        onClick: handleNextPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconNextPage || getIcon().PAGER_NEXT_PAGE]
        })
      ]);
    };
    const renderEndPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.endPageTitle"),
        onClick: handleEndPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconEndPage || getIcon().PAGER_END]
        })
      ]);
    };
    const renderNumber = (showJump) => {
      const { currentPage, pagerCount } = props;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push(h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, 1)
        }, 1), renderPrevJump("span"));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          nums.push(h("button", {
            key: number,
            class: ["vxe-pager--num-btn", {
              "is--active": currentPage === number
            }],
            type: "button",
            onClick: (evnt) => jumpPageEvent(evnt, number)
          }, number));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump("button"), h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      return h("span", {
        class: "vxe-pager--btn-wrapper"
      }, nums);
    };
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    const renderSizes = () => {
      const sizeList = computeSizeList.value;
      return h(select_default, {
        class: "vxe-pager--sizes",
        modelValue: props.pageSize,
        placement: props.pageSizePlacement,
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    const renderJump = (isFull) => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--jump"
      }, [
        isFull ? h("span", {
          class: "vxe-pager--goto-text"
        }, getI18n("vxe.pager.goto")) : null,
        h(input_default, {
          class: "vxe-pager--goto",
          modelValue: reactData.inpCurrPage,
          placeholder: getI18n("vxe.pager.gotoTitle"),
          align: "center",
          type: "integer",
          max: pageCount,
          min: 1,
          controls: false,
          onKeydown: jumpKeydownEvent,
          onBlur: triggerJumpEvent,
          "onUpdate:modelValue"(val) {
            reactData.inpCurrPage = val;
          }
        }),
        isFull ? h("span", {
          class: "vxe-pager--classifier-text"
        }, getI18n("vxe.pager.pageClassifier")) : null
      ]);
    };
    const renderFullJump = () => {
      return renderJump(true);
    };
    const renderPageCount = () => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--count"
      }, [
        h("span", {
          class: "vxe-pager--separator"
        }),
        h("span", pageCount)
      ]);
    };
    const renderTotal = () => {
      return h("span", {
        class: "vxe-pager--total"
      }, getI18n("vxe.pager.total", [props.total]));
    };
    pagerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $pager: $xePager }, params));
      },
      homePage() {
        handleHomePage();
        return nextTick();
      },
      endPage() {
        handleEndPage();
        return nextTick();
      },
      prevPage() {
        handlePrevPage();
        return nextTick();
      },
      nextPage() {
        handleNextPage();
        return nextTick();
      },
      prevJump() {
        handlePrevJump();
        return nextTick();
      },
      nextJump() {
        handleNextJump();
        return nextTick();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xePager, pagerMethods, pagerPrivateMethods);
    watch(() => props.currentPage, (value) => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const { align, layouts, className } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push(h("span", {
          class: "vxe-pager--left-wrapper"
        }, slots.left({ $grid: $xeGrid })));
      }
      layouts.forEach((name) => {
        let renderFn;
        switch (name) {
          case "Home":
            renderFn = renderHomePage;
            break;
          case "PrevJump":
            renderFn = renderPrevJump;
            break;
          case "PrevPage":
            renderFn = renderPrevPage;
            break;
          case "Number":
            renderFn = renderNumber;
            break;
          case "JumpNumber":
            renderFn = renderJumpNumber;
            break;
          case "NextPage":
            renderFn = renderNextPage;
            break;
          case "NextJump":
            renderFn = renderNextJump;
            break;
          case "End":
            renderFn = renderEndPage;
            break;
          case "Sizes":
            renderFn = renderSizes;
            break;
          case "FullJump":
            renderFn = renderFullJump;
            break;
          case "Jump":
            renderFn = renderJump;
            break;
          case "PageCount":
            renderFn = renderPageCount;
            break;
          case "Total":
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          if (true) {
            errLog("vxe.error.notProp", [`layouts -> ${name}`]);
          }
        }
      });
      if (slots.right) {
        childNodes.push(h("span", {
          class: "vxe-pager--right-wrapper"
        }, slots.right({ $grid: $xeGrid })));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-pager", className ? import_xe_utils88.default.isFunction(className) ? className({ $pager: $xePager }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          "is--border": props.border,
          "is--background": props.background,
          "is--perfect": props.perfect,
          "is--hidden": props.autoHidden && pageCount === 1,
          "is--loading": props.loading
        }]
      }, [
        h("div", {
          class: "vxe-pager--wrapper"
        }, childNodes)
      ]);
    };
    $xePager.renderVN = renderVN;
    return $xePager;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/pager/index.js
var VxePager = Object.assign(pager_default, {
  install: function(app) {
    app.component(pager_default.name, pager_default);
  }
});
dynamicApp.component(pager_default.name, pager_default);
VxeUI.component(pager_default);
var Pager = VxePager;
var pager_default2 = VxePager;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/password-input/src/password-input.js
var import_xe_utils89 = __toESM(require_xe_utils());
var password_input_default = defineComponent({
  name: "VxePasswordInput",
  props: {
    modelValue: String,
    name: String,
    clearable: { type: Boolean, default: () => getConfig().passwordInput.clearable },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    className: String,
    size: { type: String, default: () => getConfig().passwordInput.size || getConfig().size },
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "click",
    "focus",
    "blur",
    "clear",
    "toggle-visible",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils89.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInpReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInputType = computed(() => {
      const { showPwd } = reactData;
      if (showPwd) {
        return "text";
      }
      return "password";
    });
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      reactData.inputValue = value;
      passwordInputMethods.dispatchEvent("input", { value }, evnt);
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      passwordInputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils89.default.toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = (evnt) => {
      triggerEvent(evnt);
      const { inputValue } = reactData;
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, inputValue);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      passwordInputMethods.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    const passwordToggleEvent = (evnt) => {
      const { readonly, disabled } = props;
      const { showPwd } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      passwordInputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      emitModel("", evnt);
      passwordInputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const clickPrefixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "password-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["password-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "password-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "password-input--prefix-icon"
        }, prefixSlot ? getSlotVNs(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { disabled, suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || suffixSlot || suffixIcon ? h("div", {
        class: ["password-input--suffix", {
          "is--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils89.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "password-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "password-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    const renderExtraSuffixIcon = () => {
      return renderPasswordIcon();
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $passwordInput: $xePasswordInput }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const { className, name, disabled, readonly, autocomplete, autoComplete, maxLength } = props;
      const { inputValue, isActivated } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["password-input", className, {
          [`size--${vSize}`]: vSize,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--readonly": readonly,
          "is--disabled": disabled,
          "is--active": isActivated,
          "show--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils89.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "password-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "password-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inpReadonly,
            disabled,
            autocomplete: autocomplete || autoComplete,
            maxlength: maxLength,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode()
      ]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/password-input/index.js
var VxePasswordInput = Object.assign({}, password_input_default, {
  install(app) {
    app.component(password_input_default.name, password_input_default);
  }
});
dynamicApp.component(password_input_default.name, password_input_default);
VxeUI.component(password_input_default);
var PasswordInput = VxePasswordInput;
var password_input_default2 = VxePasswordInput;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/print/src/page-break.js
var import_xe_utils91 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/print/src/util.js
var import_xe_utils90 = __toESM(require_xe_utils());
var printFrame;
var defaultHtmlStyle = 'body{margin:0;padding:0;color:#000000;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createPrintFrame() {
  const frame = document.createElement("iframe");
  frame.className = "vxe-table--print-frame";
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write("");
      } catch (e) {
      }
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], { type: `text/${type};charset=utf-8;` });
}
var printMargin = 80;
function createHtmlPage(opts, printHtml2) {
  const { customStyle } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.title}</title>`,
    opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length ? '<style media="print">@page {size: auto;margin: 0mm;}</style>' : "",
    `<style>.vxe-print-slots{display: none;}.vxe-print-page-break.align--center{text-align:center;}.vxe-print-page-break.align--left{text-align:left;}.vxe-print-page-break.align--right{text-align:right;}.vxe-print-page-break--header-title{font-size:1.8em;text-align:center;line-height:${printMargin}px;}.vxe-print-page-break{page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow: hidden;}.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;width:${printMargin}px;height:100%;}.vxe-print-page-break--header,.vxe-print-page-break--footer{flex-shrink:0;height:${printMargin}px;width:100%;}.vxe-print-page-break--content{flex-grow: 1;overflow: hidden;}.vxe-print-page-break--footer-page-number{line-height:${printMargin}px;text-align:center;}</style>`,
    "<style>.vxe-table{white-space:pre;}</style>",
    `<style>${defaultHtmlStyle}</style>`,
    customStyle ? `<style>${customStyle}</style>` : "",
    "</head>",
    "<body>",
    `${printHtml2}`,
    "</body>",
    "</html>"
  ].join("");
}
function handlePrint(opts, printHtml2 = "") {
  const { beforeMethod } = opts;
  if (beforeMethod) {
    printHtml2 = beforeMethod({ content: printHtml2, html: printHtml2, options: opts }) || "";
  }
  printHtml2 = createHtmlPage(opts, printHtml2);
  const blob = getExportBlobByString(printHtml2, "html");
  return new Promise((resolve) => {
    if (import_xe_utils90.default.browse().msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      printFrame.contentDocument.write(printHtml2);
      printFrame.contentDocument.execCommand("print");
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = (evnt) => {
          if (evnt.target.src) {
            evnt.target.contentWindow.onafterprint = afterPrintEvent;
            evnt.target.contentWindow.print();
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const { title, showPageNumber, align, headerAlign, footerAlign, showAllPageTitle } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [
      `<div class="${["vxe-print-page-break", align ? `align--${align}` : ""].join(" ")}">`,
      `<div class="${["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""].join(" ")}">`,
      headerHtml ? `${import_xe_utils90.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : title && (showAllPageTitle || !index) ? `<div class="vxe-print-page-break--header-title">${title || ""}</div>` : "",
      "</div>",
      '<div class="vxe-print-page-break--body">',
      `<div class="vxe-print-page-break--left">${import_xe_utils90.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}</div>`,
      `<div class="vxe-print-page-break--content">${import_xe_utils90.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}</div>`,
      `<div class="vxe-print-page-break--right">${import_xe_utils90.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}</div>`,
      "</div>",
      `<div class="${["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""].join(" ")}">`,
      footerHtml ? `${import_xe_utils90.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : "",
      "</div>",
      "</div>"
    ].join("");
  }).join("");
}
var printHtml = (options) => {
  const opts = Object.assign({ _pageBreaks: false, customLayout: true }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml2 = opts.html || opts.content;
  return handlePrint(opts, printHtml2);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(import_xe_utils90.default.arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter((item) => item.id !== pageBreakConfig.id);
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/print/src/page-break.js
var page_break_default = defineComponent({
  name: "VxePrintPageBreak",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils91.default.uniqueId();
    const $xePrint = inject("$xePrint", null);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = reactive({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => [];
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    $xePrintPageBreak.renderVN = renderVN;
    onMounted(() => {
      if ($xePrint && refElem.value) {
        assemblePageBreak($xePrint, refElem.value, pageBreakConfig);
      }
    });
    onUnmounted(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/print-page-break/index.js
var VxePrintPageBreak = Object.assign({}, page_break_default, {
  install(app) {
    app.component(page_break_default.name, page_break_default);
  }
});
dynamicApp.component(page_break_default.name, page_break_default);
VxeUI.component(page_break_default);
var PrintPageBreak = VxePrintPageBreak;
var print_page_break_default = VxePrintPageBreak;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/print/src/print.js
var import_xe_utils92 = __toESM(require_xe_utils());
var print_default = defineComponent({
  name: "VxePrint",
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils92.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const printMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $print: $xePrint }, params));
      },
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: (elem ? elem.outerHTML : "") || props.html || props.content || ""
        }));
      }
    };
    Object.assign($xePrint, printMethods);
    const renderPageConfigLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index + 1;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerHtml ? `${import_xe_utils92.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : [
            title && (showAllPageTitle || !index) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, `${import_xe_utils92.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--content"
            }, `${import_xe_utils92.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--right"
            }, `${import_xe_utils92.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}`)
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerHtml ? `${import_xe_utils92.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderPageStaticLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const { staticPageBreaks } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index) => {
        const itemSlots = item.slots || {};
        const currentPage = index + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerSlot ? getSlotVNs(headerSlot(params)) : [
            title && (showAllPageTitle || !index) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, leftSlot ? getSlotVNs(leftSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--content"
            }, defaultSlot ? getSlotVNs(defaultSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--right"
            }, rightSlot ? getSlotVNs(rightSlot(params)) : [])
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerSlot ? getSlotVNs(footerSlot(params)) : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { customLayout } = props;
      const { staticPageBreaks } = reactData;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-print"]
      }, customLayout ? defaultSlot ? getSlotVNs(defaultSlot({})) : [] : [
        h("div", {
          key: "slot",
          class: "vxe-print-slots"
        }, defaultSlot ? getSlotVNs(defaultSlot({})) : [])
      ].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    provide("$xePrint", $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/print/index.js
var VxePrint = Object.assign({}, print_default, {
  install(app) {
    app.component(print_default.name, print_default);
  }
});
dynamicApp.component(print_default.name, print_default);
VxeUI.component(print_default);
VxeUI.print = printHtml;
var Print = VxePrint;
var print_default2 = VxePrint;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/pulldown/src/pulldown.js
var import_xe_utils93 = __toESM(require_xe_utils());
var pulldown_default = defineComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    size: { type: String, default: () => getConfig().size },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "click",
    "option-click",
    "hide-panel"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const xID = import_xe_utils93.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      panelStyle: null,
      panelPlacement: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    const refElem = ref();
    const refPulldowContent = ref();
    const refPulldowPnanel = ref();
    const computeTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (import_xe_utils93.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex, visiblePanel } = reactData;
        const transfer = computeTransfer.value;
        if (visiblePanel) {
          const targetElem = refPulldowContent.value;
          const panelElem = refPulldowPnanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
            let panelPlacement = "bottom";
            if (transfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === "top") {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              } else if (!placement) {
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = "top";
                  top = boundingTop - panelHeight;
                }
                if (top < marginSize) {
                  panelPlacement = "bottom";
                  top = boundingTop + targetHeight;
                }
              }
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === "top") {
                panelPlacement = "top";
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = "top";
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return nextTick();
      });
    };
    let hidePanelTimeout;
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise((resolve) => {
        if (!props.disabled) {
          clearTimeout(hidePanelTimeout);
          reactData.isActivated = true;
          reactData.animatVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const hidePanel = () => {
      reactData.visiblePanel = false;
      emit("update:modelValue", false);
      return new Promise((resolve) => {
        if (reactData.animatVisible) {
          hidePanelTimeout = window.setTimeout(() => {
            reactData.animatVisible = false;
            nextTick(() => {
              resolve();
            });
          }, 350);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option) => {
      if (!option.disabled) {
        hidePanel();
        dispatchEvent2("option-click", { option }, evnt);
      }
    };
    const clickTargetEvent = (evnt) => {
      const { trigger } = props;
      if (trigger === "click") {
        if (reactData.visiblePanel) {
          hidePanel();
        } else {
          showPanel();
        }
      }
      dispatchEvent2("click", { $pulldown: $xePulldown }, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            dispatchEvent2("hide-panel", {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const el = refElem.value;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          dispatchEvent2("hide-panel", {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = (evnt) => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        dispatchEvent2("hide-panel", {}, evnt);
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pulldown: $xePulldown }, params));
    };
    pulldownMethods = {
      dispatchEvent: dispatchEvent2,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xePulldown, pulldownMethods);
    watch(() => props.modelValue, (value) => {
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    nextTick(() => {
      globalEvents.on($xePulldown, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xePulldown, "mousewheel");
      globalEvents.off($xePulldown, "mousedown");
      globalEvents.off($xePulldown, "blur");
    });
    const renderDefaultPanel = (options) => {
      const optionSlot = slots.option;
      return h("div", {
        class: "vxe-pulldown--panel-list"
      }, options ? options.map((item) => {
        return h("div", {
          class: "vxe-pulldown--panel-item",
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({ $pulldown: $xePulldown, option: item }) : `${item.label || ""}`);
      }) : []);
    };
    const renderVN = () => {
      const { className, options, popupClassName, showPopupShadow, destroyOnClose, disabled } = props;
      const { initialized, isActivated, animatVisible, visiblePanel, panelStyle, panelPlacement } = reactData;
      const transfer = computeTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return h("div", {
        ref: refElem,
        class: ["vxe-pulldown", className ? import_xe_utils93.default.isFunction(className) ? className({ $pulldown: $xePulldown }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          ref: refPulldowContent,
          class: "vxe-pulldown--content",
          onClick: clickTargetEvent
        }, defaultSlot ? defaultSlot({ $pulldown: $xePulldown }) : []),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !initialized : true
        }, [
          h("div", {
            ref: refPulldowPnanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", popupClassName ? import_xe_utils93.default.isFunction(popupClassName) ? popupClassName({ $pulldown: $xePulldown }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--shadow": showPopupShadow,
              "is--transfer": transfer,
              "animat--leave": animatVisible,
              "animat--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, [
            h("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, !initialized || destroyOnClose && !visiblePanel && !animatVisible ? [] : [
              headerSlot ? h("div", {
                class: "vxe-pulldown--panel-header"
              }, headerSlot({ $pulldown: $xePulldown })) : createCommentVNode(),
              h("div", {
                class: "vxe-pulldown--panel-body"
              }, dropdownSlot ? dropdownSlot({ $pulldown: $xePulldown }) : [
                renderDefaultPanel(options)
              ]),
              footerSlot ? h("div", {
                class: "vxe-pulldown--panel-footer"
              }, footerSlot({ $pulldown: $xePulldown })) : createCommentVNode()
            ])
          ])
        ])
      ]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/pulldown/index.js
var VxePulldown = Object.assign(pulldown_default, {
  install: function(app) {
    app.component(pulldown_default.name, pulldown_default);
  }
});
dynamicApp.component(pulldown_default.name, pulldown_default);
VxeUI.component(pulldown_default);
var Pulldown = VxePulldown;
var pulldown_default2 = VxePulldown;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/radio/index.js
var VxeRadio = Object.assign(radio_default, {
  install: function(app) {
    app.component(radio_default.name, radio_default);
  }
});
dynamicApp.component(radio_default.name, radio_default);
VxeUI.component(radio_default);
var Radio = VxeRadio;
var radio_default2 = VxeRadio;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/radio-button/index.js
var VxeRadioButton = Object.assign(button_default3, {
  install: function(app) {
    app.component(button_default3.name, button_default3);
  }
});
dynamicApp.component(button_default3.name, button_default3);
VxeUI.component(button_default3);
var RadioButton = VxeRadioButton;
var radio_button_default = VxeRadioButton;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/radio-group/index.js
var VxeRadioGroup = Object.assign(group_default2, {
  install: function(app) {
    app.component(group_default2.name, group_default2);
  }
});
dynamicApp.component(group_default2.name, group_default2);
VxeUI.component(group_default2);
var RadioGroup = VxeRadioGroup;
var radio_group_default = VxeRadioGroup;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/row/index.js
var VxeRow = Object.assign({}, row_default, {
  install(app) {
    app.component(row_default.name, row_default);
  }
});
dynamicApp.component(row_default.name, row_default);
VxeUI.component(row_default);
var Row = VxeRow;
var row_default2 = VxeRow;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/select/index.js
var VxeSelect = Object.assign(select_default, {
  install: function(app) {
    app.component(select_default.name, select_default);
  }
});
dynamicApp.component(select_default.name, select_default);
VxeUI.component(select_default);
var Select = VxeSelect;
var select_default2 = VxeSelect;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/switch/index.js
var VxeSwitch = Object.assign(switch_default, {
  install: function(app) {
    app.component(switch_default.name, switch_default);
  }
});
dynamicApp.component(switch_default.name, switch_default);
VxeUI.component(switch_default);
var Switch = VxeSwitch;
var switch_default2 = VxeSwitch;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tab-pane/index.js
var VxeTabPane = Object.assign({}, tab_pane_default, {
  install(app) {
    app.component(tab_pane_default.name, tab_pane_default);
  }
});
dynamicApp.component(tab_pane_default.name, tab_pane_default);
VxeUI.component(tab_pane_default);
var TabPane = VxeTabPane;
var tab_pane_default2 = VxeTabPane;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tabs/index.js
var VxeTabs = Object.assign({}, tabs_default, {
  install(app) {
    app.component(tabs_default.name, tabs_default);
  }
});
dynamicApp.component(tabs_default.name, tabs_default);
VxeUI.component(tabs_default);
var Tabs = VxeTabs;
var tabs_default2 = VxeTabs;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tag/src/tag.js
var import_xe_utils94 = __toESM(require_xe_utils());
var tag_default = defineComponent({
  name: "VxeTag",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    size: { type: String, default: () => getConfig().tag.size || getConfig().size }
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils94.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-tag--icon"
        }, iconSlot ? getSlotVNs(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("span", {
          class: "vxe-tag--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils94.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { status, title } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        title,
        class: ["vxe-tag", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status
        }]
      }, renderContent());
    };
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tag/index.js
var VxeTag = Object.assign({}, tag_default, {
  install(app) {
    app.component(tag_default.name, tag_default);
  }
});
dynamicApp.component(tag_default.name, tag_default);
VxeUI.component(tag_default);
var Tag = VxeTag;
var tag_default2 = VxeTag;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/text/index.js
var VxeText = Object.assign({}, text_default, {
  install(app) {
    app.component(text_default.name, text_default);
  }
});
dynamicApp.component(text_default.name, text_default);
VxeUI.component(text_default);
var Text = VxeText;
var text_default2 = VxeText;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/textarea/index.js
var VxeTextarea = Object.assign(textarea_default, {
  install: function(app) {
    app.component(textarea_default.name, textarea_default);
  }
});
dynamicApp.component(textarea_default.name, textarea_default);
VxeUI.component(textarea_default);
var Textarea = VxeTextarea;
var textarea_default2 = VxeTextarea;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tip/index.js
var VxeTip = Object.assign({}, tip_default, {
  install(app) {
    app.component(tip_default.name, tip_default);
    app.component("VxeTipsComponent", tip_default);
  }
});
dynamicApp.component(tip_default.name, tip_default);
VxeUI.component(tip_default);
var Tips = VxeTip;
var Tip = VxeTip;
var tip_default2 = VxeTip;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tree/index.js
var VxeTree = Object.assign({}, tree_default, {
  install(app) {
    app.component(tree_default.name, tree_default);
  }
});
dynamicApp.component(tree_default.name, tree_default);
VxeUI.component(tree_default);
var Tree = VxeTree;
var tree_default2 = VxeTree;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tree-select/index.js
var VxeTreeSelect = Object.assign({}, tree_select_default, {
  install(app) {
    app.component(tree_select_default.name, tree_select_default);
  }
});
dynamicApp.component(tree_select_default.name, tree_select_default);
VxeUI.component(tree_select_default);
var TreeSelect = VxeTreeSelect;
var tree_select_default2 = VxeTreeSelect;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/upload/index.js
var VxeUpload = Object.assign({}, upload_default, {
  install(app) {
    app.component(upload_default.name, upload_default);
  }
});
dynamicApp.component(upload_default.name, upload_default);
VxeUI.component(upload_default);
VxeUI.saveFile = saveLocalFile;
VxeUI.readFile = readLocalFile;
var Upload = VxeUpload;
var upload_default2 = VxeUpload;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/components.js
var components = [
  alert_default2,
  anchor_default2,
  anchor_link_default2,
  breadcrumb_default2,
  breadcrumb_item_default2,
  button_default2,
  button_group_default2,
  calendar_default2,
  card_default2,
  carousel_default2,
  carousel_item_default2,
  checkbox_default2,
  checkbox_group_default,
  col_default2,
  collapse_default2,
  collapse_pane_default2,
  date_picker_default2,
  drawer_default2,
  form_default2,
  form_design_default2,
  form_gather_default2,
  form_item_default2,
  form_view_default2,
  icon_default2,
  icon_picker_default2,
  image_default2,
  image_group_default,
  image_preview_default,
  input_default2,
  layout_aside_default2,
  layout_body_default2,
  layout_container_default2,
  layout_footer_default2,
  layout_header_default2,
  link_default2,
  list_design_default2,
  list_view_default2,
  list_default2,
  loading_default2,
  menu_default2,
  modal_default2,
  number_input_default2,
  optgroup_default2,
  option_default2,
  pager_default2,
  password_input_default2,
  print_page_break_default,
  print_default2,
  pulldown_default2,
  radio_default2,
  radio_button_default,
  radio_group_default,
  row_default2,
  select_default2,
  switch_default2,
  tab_pane_default2,
  tabs_default2,
  tag_default2,
  text_default2,
  textarea_default2,
  tip_default2,
  tooltip_default2,
  tree_default2,
  tree_select_default2,
  upload_default2
];
function install(app, options) {
  setConfig(options);
  components.forEach((component2) => app.use(component2));
}
var defaultLanguage = "zh-CN";
setI18n(defaultLanguage, zh_CN_default);
setLanguage(defaultLanguage);
setTheme("light");
var loading = LoadingController;
var modal = ModalController;
var drawer = DrawerController;
var print = printHtml;
var saveFile = saveLocalFile;
var readFile = readLocalFile;

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/index.esm.js
var index_esm_default = components_exports;
export {
  Alert,
  Anchor,
  AnchorLink,
  Breadcrumb,
  BreadcrumbItem,
  Button,
  ButtonGroup,
  Calendar,
  Card,
  Carousel,
  CarouselItem,
  Checkbox,
  CheckboxGroup,
  Col,
  Collapse,
  CollapsePane,
  DatePicker,
  Drawer,
  DrawerController,
  Form,
  FormDesign,
  FormGather,
  FormItem,
  FormView,
  GLOBAL_EVENT_KEYS,
  Icon,
  IconPicker,
  Image,
  ImageGroup,
  ImagePreview,
  Input,
  LayoutAside,
  LayoutBody,
  LayoutContainer,
  LayoutFooter,
  LayoutHeader,
  Link,
  List,
  ListDesign,
  ListView,
  Loading,
  LoadingController,
  Menu,
  Modal,
  ModalController,
  NumberInput,
  Optgroup,
  Option,
  Pager,
  PasswordInput,
  Print,
  PrintPageBreak,
  Pulldown,
  Radio,
  RadioButton,
  RadioGroup,
  Row,
  Select,
  Switch,
  TabPane,
  Tabs,
  Tag,
  Text,
  Textarea,
  Tip,
  Tips,
  Tooltip,
  Tree,
  TreeSelect,
  Upload,
  VxeAlert,
  VxeAnchor,
  VxeAnchorLink,
  VxeBreadcrumb,
  VxeBreadcrumbItem,
  VxeButton,
  VxeButtonGroup,
  VxeCalendar,
  VxeCard,
  VxeCarousel,
  VxeCarouselItem,
  VxeCheckbox,
  VxeCheckboxGroup,
  VxeCol,
  VxeCollapse,
  VxeCollapsePane,
  VxeDatePicker,
  VxeDrawer,
  VxeForm,
  VxeFormDesign,
  VxeFormGather,
  VxeFormItem,
  VxeFormView,
  VxeIcon,
  VxeIconPicker,
  VxeImage,
  VxeImageGroup,
  VxeImagePreview,
  VxeInput,
  VxeLayoutAside,
  VxeLayoutBody,
  VxeLayoutContainer,
  VxeLayoutFooter,
  VxeLayoutHeader,
  VxeLink,
  VxeList,
  VxeListDesign,
  VxeListView,
  VxeLoading,
  VxeMenu,
  VxeModal,
  VxeNumberInput,
  VxeOptgroup,
  VxeOption,
  VxePager,
  VxePasswordInput,
  VxePrint,
  VxePrintPageBreak,
  VxePulldown,
  VxeRadio,
  VxeRadioButton,
  VxeRadioGroup,
  VxeRow,
  VxeSelect,
  VxeSwitch,
  VxeTabPane,
  VxeTabs,
  VxeTag,
  VxeText,
  VxeTextarea,
  VxeTip,
  VxeTooltip,
  VxeTree,
  VxeTreeSelect,
  VxeUI,
  VxeUpload,
  clipboard,
  commands,
  component,
  config,
  coreVersion,
  createEvent,
  index_esm_default as default,
  drawer,
  formats,
  getComponent,
  getConfig,
  getI18n,
  getIcon,
  getLanguage,
  getTheme,
  globalEvents,
  globalResize,
  globalStore,
  handleCheckInfo,
  hasLanguage,
  hooks,
  install,
  interceptor,
  loading,
  log,
  menus,
  modal,
  permission,
  print,
  readFile,
  renderer,
  saveFile,
  setConfig,
  setI18n,
  setIcon,
  setLanguage,
  setTheme,
  setup,
  use,
  useFns,
  usePermission,
  useSize,
  validators,
  version
};
//# sourceMappingURL=vxe-pc-ui.js.map
