import {
  errLog,
  getSlotVNs,
  warnLog
} from "./chunk-UFZLQBRE.js";
import {
  VxeUI,
  require_xe_utils
} from "./chunk-BNXASOE3.js";
import {
  computed,
  createCommentVNode,
  defineComponent,
  h,
  inject,
  nextTick,
  reactive,
  ref
} from "./chunk-4BEKJ24D.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/.pnpm/vxe-table@4.7.67/node_modules/vxe-table/es/toolbar/src/toolbar.js
var import_xe_utils = __toESM(require_xe_utils());
var { getConfig, getIcon, getI18n, renderer, commands, createEvent, useFns } = VxeUI;
var toolbar_default = defineComponent({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: { type: Array, default: () => getConfig().toolbar.buttons },
    tools: { type: Array, default: () => getConfig().toolbar.tools },
    perfect: { type: Boolean, default: () => getConfig().toolbar.perfect },
    size: { type: String, default: () => getConfig().toolbar.size || getConfig().size },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils.default.uniqueId();
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const { computeSize } = useFns.useSize(props);
    const reactData = reactive({
      isRefresh: false,
      columns: []
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeToolbar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const $xeGrid = inject("$xeGrid", null);
    const refTable = ref();
    const connectFlag = ref(0);
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, getConfig().toolbar.refresh, props.refresh);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, getConfig().toolbar.import, props.import);
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, getConfig().toolbar.export, props.export);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, getConfig().toolbar.print, props.print);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig().toolbar.zoom, props.zoom);
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, getConfig().toolbar.custom, props.custom);
    });
    const computeTableCustomOpts = computed(() => {
      const $table = refTable.value;
      if (connectFlag.value || $table) {
        if ($table) {
          const { computeCustomOpts: computeCustomOpts2 } = $table.getComputeMaps();
          return computeCustomOpts2.value;
        }
      }
      return { trigger: "" };
    });
    const computeTrigger = computed(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      const $table = refTable.value;
      if ($table) {
        return true;
      }
      errLog("vxe.error.barUnableLink");
    };
    const handleClickSettingEvent = ({ $event }) => {
      const $table = refTable.value;
      if ($table) {
        if ($table.triggerCustomEvent) {
          $table.triggerCustomEvent($event);
        } else {
          errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
        }
      }
    };
    const handleMouseenterSettingEvent = ({ $event }) => {
      const $table = refTable.value;
      if ($table) {
        $table.customOpenEvent($event);
      } else {
        errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
      }
    };
    const handleMouseleaveSettingEvent = ({ $event }) => {
      const $table = refTable.value;
      if ($table) {
        const { customStore } = $table.reactData;
        customStore.activeBtn = false;
        setTimeout(() => {
          if (!customStore.activeBtn && !customStore.activeWrapper) {
            $table.customCloseEvent($event);
          }
        }, 350);
      }
    };
    const refreshEvent = ({ $event }) => {
      const { isRefresh } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch((e) => e).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e) {
            reactData.isRefresh = false;
          }
        } else if ($xeGrid) {
          reactData.isRefresh = true;
          $xeGrid.triggerToolbarCommitEvent({ code: refreshOpts.code || "reload" }, $event).catch((e) => e).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = ({ $event }) => {
      if ($xeGrid) {
        $xeGrid.triggerZoomEvent($event);
      }
    };
    const btnEvent = (evnt, item) => {
      const $table = refTable.value;
      const { code } = item;
      if (code) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = commands.get(code);
          const params = { code, button: item, $table, $grid: $xeGrid, $event: evnt };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code]);
              }
            }
          }
          $xeToolbar.dispatchEvent("button-click", params, evnt);
        }
      }
    };
    const tolEvent = (evnt, item) => {
      const $table = refTable.value;
      const { code } = item;
      if (code) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = commands.get(code);
          const params = { code, tool: item, $table, $grid: $xeGrid, $event: evnt };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code]);
              }
            }
          }
          $xeToolbar.dispatchEvent("tool-click", params, evnt);
        }
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        const $table = refTable.value;
        if ($table) {
          $table.openImport();
        }
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        const $table = refTable.value;
        if ($table) {
          $table.openExport();
        }
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        const $table = refTable.value;
        if ($table) {
          $table.openPrint();
        }
      }
    };
    const renderDropdowns = (item, isBtn) => {
      const { dropdowns } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index) => {
          if (child.visible === false) {
            return createCommentVNode();
          }
          return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
            key: index,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            mode: child.mode,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            onClick: ({ $event }) => isBtn ? btnEvent($event, child) : tolEvent($event, child)
          }) : createCommentVNode();
        });
      }
      return downVNs;
    };
    const renderBtns = () => {
      const { buttons } = props;
      const $table = refTable.value;
      const buttonsSlot = slots.buttons;
      if (buttonsSlot) {
        return getSlotVNs(buttonsSlot({ $grid: $xeGrid, $table }));
      }
      const btnVNs = [];
      if (buttons) {
        buttons.forEach((item) => {
          const { dropdowns, buttonRender } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = { $grid: $xeGrid, $table, button: item };
              btnVNs.push(h("span", {
                class: ["vxe-button--item", toolbarButtonClassName ? import_xe_utils.default.isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : ""]
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  permissionCode: item.permissionCode,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({ $event }) => btnEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, true)
                } : {}));
              }
            }
          }
        });
      }
      return btnVNs;
    };
    const renderRightTools = () => {
      const { tools } = props;
      const $table = refTable.value;
      const toolsSlot = slots.tools;
      if (toolsSlot) {
        return getSlotVNs(toolsSlot({ $grid: $xeGrid, $table }));
      }
      const btnVNs = [];
      if (tools) {
        tools.forEach((item, tIndex) => {
          const { dropdowns, toolRender } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? renderer.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = { $grid: $xeGrid, $table, tool: item };
              btnVNs.push(h("span", {
                key: rdName,
                class: ["vxe-tool--item", toolbarToolClassName ? import_xe_utils.default.isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : ""]
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  key: tIndex,
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({ $event }) => tolEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, false)
                } : {}));
              }
            }
          }
        });
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "import",
        circle: true,
        icon: importOpts.icon || getIcon().TOOLBAR_TOOLS_IMPORT,
        title: getI18n("vxe.toolbar.import"),
        onClick: importEvent
      }) : createCommentVNode();
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "export",
        circle: true,
        icon: exportOpts.icon || getIcon().TOOLBAR_TOOLS_EXPORT,
        title: getI18n("vxe.toolbar.export"),
        onClick: exportEvent
      }) : createCommentVNode();
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "print",
        circle: true,
        icon: printOpts.icon || getIcon().TOOLBAR_TOOLS_PRINT,
        title: getI18n("vxe.toolbar.print"),
        onClick: printEvent
      }) : createCommentVNode();
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "refresh",
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || getIcon().TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || getIcon().TOOLBAR_TOOLS_REFRESH,
        title: getI18n("vxe.toolbar.refresh"),
        onClick: refreshEvent
      }) : createCommentVNode();
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xeGrid && VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "zoom",
        circle: true,
        icon: $xeGrid.isMaximized() ? zoomOpts.iconOut || getIcon().TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || getIcon().TOOLBAR_TOOLS_FULLSCREEN,
        title: getI18n(`vxe.toolbar.zoom${$xeGrid.isMaximized() ? "Out" : "In"}`),
        onClick: zoomEvent
      }) : createCommentVNode();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === "manual") {
      } else if (btnTrigger === "hover") {
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, Object.assign({ key: "custom", circle: true, icon: customOpts.icon || getIcon().TOOLBAR_TOOLS_CUSTOM, title: getI18n("vxe.toolbar.custom"), className: "vxe-toolbar-custom-target" }, customBtnOns)) : createCommentVNode();
    };
    toolbarMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $toolbar: $xeToolbar }, params));
      },
      syncUpdate(params) {
        const { collectColumn } = params;
        refTable.value = params.$table;
        reactData.columns = collectColumn;
        connectFlag.value++;
      }
    };
    Object.assign($xeToolbar, toolbarMethods);
    nextTick(() => {
      const { refresh } = props;
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xeGrid && !queryMethod) {
        warnLog("vxe.error.notFunc", ["queryMethod"]);
      }
      const customOpts = computeCustomOpts.value;
      if (true) {
        if (customOpts.isFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.isFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.showFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.showFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.immediate) {
          warnLog("vxe.error.delProp", ["toolbar.custom.immediate", "table.custom-config.immediate"]);
        }
        if (customOpts.trigger) {
          warnLog("vxe.error.delProp", ["toolbar.custom.trigger", "table.custom-config.trigger"]);
        }
      }
    });
    const renderVN = () => {
      const { perfect, loading, refresh, zoom, custom, className } = props;
      const vSize = computeSize.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-toolbar", className ? import_xe_utils.default.isFunction(className) ? className({ $toolbar: $xeToolbar }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--perfect": perfect,
          "is--loading": loading
        }]
      }, [
        h("div", {
          class: "vxe-buttons--wrapper"
        }, renderBtns()),
        h("div", {
          class: "vxe-tools--wrapper"
        }, renderRightTools()),
        h("div", {
          class: "vxe-tools--operate"
        }, [
          props.import ? renderToolImport() : createCommentVNode(),
          props.export ? renderToolExport() : createCommentVNode(),
          props.print ? renderToolPrint() : createCommentVNode(),
          refresh ? renderToolRefresh() : createCommentVNode(),
          zoom && $xeGrid ? renderToolZoom() : createCommentVNode(),
          custom ? renderToolCustom() : createCommentVNode()
        ])
      ]);
    };
    $xeToolbar.renderVN = renderVN;
    if (true) {
      nextTick(() => {
        if (props.refresh || props.import || props.export || props.print || props.zoom) {
          if (!VxeUIButtonComponent) {
            errLog("vxe.error.reqComp", ["vxe-button"]);
          }
        }
      });
    }
    return $xeToolbar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.7.67/node_modules/vxe-table/es/toolbar/index.js
var VxeToolbar = Object.assign({}, toolbar_default, {
  install(app) {
    app.component(toolbar_default.name, toolbar_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(toolbar_default.name, toolbar_default);
}
VxeUI.component(toolbar_default);
var Toolbar = VxeToolbar;
var toolbar_default2 = VxeToolbar;

export {
  VxeToolbar,
  Toolbar,
  toolbar_default2 as toolbar_default
};
//# sourceMappingURL=chunk-ZH7PILL3.js.map
