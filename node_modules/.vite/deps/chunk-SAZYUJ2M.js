import {
  getSlotVNs
} from "./chunk-QTR2GV55.js";
import {
  dynamicApp,
  getLastZIndex,
  nextZIndex
} from "./chunk-CEEPHHD6.js";
import {
  VxeUI,
  createEvent,
  getConfig,
  require_xe_utils,
  useSize
} from "./chunk-BNXASOE3.js";
import {
  defineComponent,
  h,
  nextTick,
  onBeforeUnmount,
  onMounted,
  reactive,
  ref,
  watch
} from "./chunk-4BEKJ24D.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tooltip/src/tooltip.js
var import_xe_utils2 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/ui/src/dom.js
var import_xe_utils = __toESM(require_xe_utils());
var browse = import_xe_utils.default.browse();
var reClsMap = {};
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function hasClass(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), "");
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function toCssUnit(val) {
  if (/^\d+$/.test(`${val}`)) {
    return `${val}px`;
  }
  return `${val || ""}`;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded = "scrollIntoViewIfNeeded";
var scrollIntoView = "scrollIntoView";
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tooltip/src/tooltip.js
var tooltip_default = defineComponent({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: { type: String, default: () => getConfig().tooltip.size || getConfig().size },
    trigger: { type: String, default: () => getConfig().tooltip.trigger || "hover" },
    theme: { type: String, default: () => getConfig().tooltip.theme || "dark" },
    content: { type: [String, Number], default: null },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: { type: Boolean, default: true },
    enterable: Boolean,
    enterDelay: { type: Number, default: () => getConfig().tooltip.enterDelay },
    leaveDelay: { type: Number, default: () => getConfig().tooltip.leaveDelay }
  },
  emits: [
    "update:modelValue"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils2.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: "",
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeTooltip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const { tipTarget, tipStore } = reactData;
      if (tipTarget) {
        const { scrollTop, scrollLeft, visibleWidth } = getDomNode();
        const { top, left } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = "bottom";
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = (value) => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit("update:modelValue", value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        tooltipMethods.open();
      }
    };
    const targetMouseenterEvent = () => {
      tooltipMethods.open();
    };
    const targetMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const { tipStore } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = "top";
      tipStore.style = { width: "auto", left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };
      tipStore.arrowStyle = { left: "50%" };
      return tooltipMethods.updatePlacement();
    };
    const showDelayTip = import_xe_utils2.default.debounce(() => {
      if (reactData.tipActive) {
        showTip();
      }
    }, props.enterDelay, { leading: false, trailing: true });
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $tooltip: $xeTooltip }, params));
      },
      open(target, content) {
        return tooltipMethods.toVisible(target || reactData.target, content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        });
        updateValue(false);
        return nextTick();
      },
      toVisible(target, content) {
        if (target) {
          const { trigger, enterDelay } = props;
          reactData.tipActive = true;
          reactData.tipTarget = target;
          if (content) {
            reactData.tipContent = content;
          }
          if (enterDelay && trigger === "hover") {
            showDelayTip();
          } else {
            return showTip();
          }
        }
        return nextTick();
      },
      updatePlacement() {
        return nextTick().then(() => {
          const { tipTarget } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return nextTick().then(updateTipStyle);
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(actived) {
        reactData.tipActive = !!actived;
      }
    };
    Object.assign($xeTooltip, tooltipMethods);
    watch(() => props.content, () => {
      reactData.tipContent = props.content;
    });
    watch(() => props.modelValue, () => {
      if (!reactData.isUpdate) {
        if (props.modelValue) {
          tooltipMethods.open();
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    onMounted(() => {
      nextTick(() => {
        const { trigger, content, modelValue } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            import_xe_utils2.default.arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const { target } = reactData;
            if (target) {
              if (trigger === "hover") {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === "click") {
                target.onclick = clickEvent;
              }
            }
            if (modelValue) {
              tooltipMethods.open();
            }
          }
        }
      });
    });
    onBeforeUnmount(() => {
      const { trigger } = props;
      const { target } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        if (trigger === "hover") {
          target.onmouseenter = null;
          target.onmouseleave = null;
        } else if (trigger === "click") {
          target.onclick = null;
        }
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    const renderContent = () => {
      const { useHTML } = props;
      const { tipContent } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return h("div", {
          key: 1,
          class: "vxe-table--tooltip-content"
        }, getSlotVNs(contentSlot({})));
      }
      if (useHTML) {
        return h("div", {
          key: 2,
          class: "vxe-table--tooltip-content",
          innerHTML: tipContent
        });
      }
      return h("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, `${tipContent}`);
    };
    const renderVN = () => {
      const { popupClassName, theme, isArrow, enterable } = props;
      const { tipActive, visible, tipStore } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--tooltip-wrapper", `theme--${theme}`, popupClassName ? import_xe_utils2.default.isFunction(popupClassName) ? popupClassName({ $tooltip: $xeTooltip }) : popupClassName : "", {
        [`size--${vSize}`]: vSize,
        [`placement--${tipStore.placement}`]: tipStore.placement,
        "is--enterable": enterable,
        "is--visible": visible,
        "is--arrow": isArrow,
        "is--active": tipActive
      }], style: tipStore.style }, ons), [
        renderContent(),
        h("div", {
          class: "vxe-table--tooltip-arrow",
          style: tipStore.arrowStyle
        }),
        ...defaultSlot ? getSlotVNs(defaultSlot({})) : []
      ]);
    };
    $xeTooltip.renderVN = renderVN;
    return $xeTooltip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-pc-ui@4.1.2/node_modules/vxe-pc-ui/es/tooltip/index.js
var VxeTooltip = Object.assign({}, tooltip_default, {
  install(app) {
    app.component(tooltip_default.name, tooltip_default);
  }
});
dynamicApp.component(tooltip_default.name, tooltip_default);
VxeUI.component(tooltip_default);
var Tooltip = VxeTooltip;
var tooltip_default2 = VxeTooltip;

export {
  browse,
  hasClass,
  removeClass,
  addClass,
  toCssUnit,
  getDomNode,
  getEventTargetNode,
  getOffsetPos,
  getAbsolutePos,
  scrollToView,
  tooltip_default,
  VxeTooltip,
  Tooltip,
  tooltip_default2
};
//# sourceMappingURL=chunk-SAZYUJ2M.js.map
